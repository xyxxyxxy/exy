// This file is auto-generated by @hey-api/openapi-ts

export type QueryResult_BaseItemDto = {
    Items?: Array<BaseItemDto>;
    TotalRecordCount?: number;
};

export type BaseItemDto = {
    Name?: string;
    OriginalTitle?: string;
    ServerId?: string;
    Id?: string;
    Etag?: string;
    PlaylistItemId?: string;
    DateCreated?: (string) | null;
    ExtraType?: string;
    AirsBeforeSeasonNumber?: (number) | null;
    AirsAfterSeasonNumber?: (number) | null;
    AirsBeforeEpisodeNumber?: (number) | null;
    DisplaySpecialsWithSeasons?: (boolean) | null;
    CanDelete?: (boolean) | null;
    CanDownload?: (boolean) | null;
    HasSubtitles?: (boolean) | null;
    SupportsResume?: (boolean) | null;
    PreferredMetadataLanguage?: string;
    PreferredMetadataCountryCode?: string;
    SupportsSync?: (boolean) | null;
    Container?: string;
    SortName?: string;
    ForcedSortName?: string;
    Video3DFormat?: 'HalfSideBySide' | 'FullSideBySide' | 'FullTopAndBottom' | 'HalfTopAndBottom' | 'MVC';
    PremiereDate?: (string) | null;
    ExternalUrls?: Array<ExternalUrl>;
    MediaSources?: Array<MediaSourceInfo>;
    CriticRating?: (number) | null;
    GameSystemId?: (number) | null;
    GameSystem?: string;
    ProductionLocations?: Array<(string)>;
    Path?: string;
    OfficialRating?: string;
    CustomRating?: string;
    ChannelId?: string;
    ChannelName?: string;
    Overview?: string;
    Taglines?: Array<(string)>;
    Genres?: Array<(string)>;
    CommunityRating?: (number) | null;
    RunTimeTicks?: (number) | null;
    PlayAccess?: 'Full' | 'None';
    AspectRatio?: string;
    ProductionYear?: (number) | null;
    Number?: string;
    ChannelNumber?: string;
    IndexNumber?: (number) | null;
    IndexNumberEnd?: (number) | null;
    ParentIndexNumber?: (number) | null;
    RemoteTrailers?: Array<MediaUrl>;
    ProviderIds?: {
        [key: string]: (string);
    };
    IsFolder?: (boolean) | null;
    ParentId?: string;
    Type?: string;
    People?: Array<BaseItemPerson>;
    Studios?: Array<NameLongIdPair>;
    GenreItems?: Array<NameLongIdPair>;
    ParentLogoItemId?: string;
    ParentBackdropItemId?: string;
    ParentBackdropImageTags?: Array<(string)>;
    LocalTrailerCount?: (number) | null;
    UserData?: UserItemDataDto;
    RecursiveItemCount?: (number) | null;
    ChildCount?: (number) | null;
    SeriesName?: string;
    SeriesId?: string;
    SeasonId?: string;
    SpecialFeatureCount?: (number) | null;
    DisplayPreferencesId?: string;
    Status?: string;
    AirTime?: string;
    AirDays?: Array<('Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday')>;
    Tags?: Array<(string)>;
    PrimaryImageAspectRatio?: (number) | null;
    Artists?: Array<(string)>;
    ArtistItems?: Array<NameIdPair>;
    Album?: string;
    CollectionType?: string;
    DisplayOrder?: string;
    AlbumId?: string;
    AlbumPrimaryImageTag?: string;
    SeriesPrimaryImageTag?: string;
    AlbumArtist?: string;
    AlbumArtists?: Array<NameIdPair>;
    SeasonName?: string;
    MediaStreams?: Array<MediaStream>;
    PartCount?: (number) | null;
    ImageTags?: {
        [key: string]: (string);
    };
    BackdropImageTags?: Array<(string)>;
    ParentLogoImageTag?: string;
    ParentArtItemId?: string;
    ParentArtImageTag?: string;
    SeriesThumbImageTag?: string;
    SeriesStudio?: string;
    ParentThumbItemId?: string;
    ParentThumbImageTag?: string;
    ParentPrimaryImageItemId?: string;
    ParentPrimaryImageTag?: string;
    Chapters?: Array<ChapterInfo>;
    LocationType?: 'FileSystem' | 'Virtual';
    MediaType?: string;
    EndDate?: (string) | null;
    LockedFields?: Array<('Cast' | 'Genres' | 'ProductionLocations' | 'Studios' | 'Tags' | 'Name' | 'Overview' | 'Runtime' | 'OfficialRating')>;
    LockData?: (boolean) | null;
    Width?: (number) | null;
    Height?: (number) | null;
    CameraMake?: string;
    CameraModel?: string;
    Software?: string;
    ExposureTime?: (number) | null;
    FocalLength?: (number) | null;
    ImageOrientation?: 'TopLeft' | 'TopRight' | 'BottomRight' | 'BottomLeft' | 'LeftTop' | 'RightTop' | 'RightBottom' | 'LeftBottom';
    Aperture?: (number) | null;
    ShutterSpeed?: (number) | null;
    Latitude?: (number) | null;
    Longitude?: (number) | null;
    Altitude?: (number) | null;
    IsoSpeedRating?: (number) | null;
    SeriesTimerId?: string;
    ChannelPrimaryImageTag?: string;
    StartDate?: (string) | null;
    CompletionPercentage?: (number) | null;
    IsRepeat?: (boolean) | null;
    IsNew?: (boolean) | null;
    EpisodeTitle?: string;
    IsMovie?: (boolean) | null;
    IsSports?: (boolean) | null;
    IsSeries?: (boolean) | null;
    IsLive?: (boolean) | null;
    IsNews?: (boolean) | null;
    IsKids?: (boolean) | null;
    IsPremiere?: (boolean) | null;
    TimerId?: string;
    CurrentProgram?: BaseItemDto;
    MovieCount?: (number) | null;
    SeriesCount?: (number) | null;
    AlbumCount?: (number) | null;
    SongCount?: (number) | null;
    MusicVideoCount?: (number) | null;
};

export type Video3DFormat = 'HalfSideBySide' | 'FullSideBySide' | 'FullTopAndBottom' | 'HalfTopAndBottom' | 'MVC';

export type PlayAccess = 'Full' | 'None';

export type LocationType = 'FileSystem' | 'Virtual';

export type ImageOrientation = 'TopLeft' | 'TopRight' | 'BottomRight' | 'BottomLeft' | 'LeftTop' | 'RightTop' | 'RightBottom' | 'LeftBottom';

export type ExternalUrl = {
    Name?: string;
    Url?: string;
};

export type MediaSourceInfo = {
    Protocol?: 'File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp' | 'Mms';
    Id?: string;
    Path?: string;
    EncoderPath?: string;
    EncoderProtocol?: 'File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp' | 'Mms';
    Type?: 'Default' | 'Grouping' | 'Placeholder';
    Container?: string;
    Size?: (number) | null;
    Name?: string;
    IsRemote?: boolean;
    RunTimeTicks?: (number) | null;
    SupportsTranscoding?: boolean;
    SupportsDirectStream?: boolean;
    SupportsDirectPlay?: boolean;
    IsInfiniteStream?: boolean;
    RequiresOpening?: boolean;
    OpenToken?: string;
    RequiresClosing?: boolean;
    LiveStreamId?: string;
    BufferMs?: (number) | null;
    RequiresLooping?: boolean;
    SupportsProbing?: boolean;
    Video3DFormat?: 'HalfSideBySide' | 'FullSideBySide' | 'FullTopAndBottom' | 'HalfTopAndBottom' | 'MVC';
    MediaStreams?: Array<MediaStream>;
    Formats?: Array<(string)>;
    Bitrate?: (number) | null;
    Timestamp?: 'None' | 'Zero' | 'Valid';
    RequiredHttpHeaders?: {
        [key: string]: (string);
    };
    TranscodingUrl?: string;
    TranscodingSubProtocol?: string;
    TranscodingContainer?: string;
    AnalyzeDurationMs?: (number) | null;
    ReadAtNativeFramerate?: boolean;
    DefaultAudioStreamIndex?: (number) | null;
    DefaultSubtitleStreamIndex?: (number) | null;
};

export type Protocol = 'File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp' | 'Mms';

export type EncoderProtocol = 'File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp' | 'Mms';

export type Type = 'Default' | 'Grouping' | 'Placeholder';

export type Timestamp = 'None' | 'Zero' | 'Valid';

export type MediaStream = {
    Codec?: string;
    CodecTag?: string;
    Language?: string;
    ColorTransfer?: string;
    ColorPrimaries?: string;
    ColorSpace?: string;
    Comment?: string;
    TimeBase?: string;
    CodecTimeBase?: string;
    Title?: string;
    Extradata?: string;
    VideoRange?: string;
    DisplayTitle?: string;
    DisplayLanguage?: string;
    NalLengthSize?: string;
    IsInterlaced?: boolean;
    IsAVC?: (boolean) | null;
    ChannelLayout?: string;
    BitRate?: (number) | null;
    BitDepth?: (number) | null;
    RefFrames?: (number) | null;
    PacketLength?: (number) | null;
    Channels?: (number) | null;
    SampleRate?: (number) | null;
    IsDefault?: boolean;
    IsForced?: boolean;
    Height?: (number) | null;
    Width?: (number) | null;
    AverageFrameRate?: (number) | null;
    RealFrameRate?: (number) | null;
    Profile?: string;
    Type?: 'Audio' | 'Video' | 'Subtitle' | 'EmbeddedImage';
    AspectRatio?: string;
    Index?: number;
    Score?: (number) | null;
    IsExternal?: boolean;
    DeliveryMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    DeliveryUrl?: string;
    IsExternalUrl?: (boolean) | null;
    IsTextSubtitleStream?: boolean;
    SupportsExternalStream?: boolean;
    Path?: string;
    PixelFormat?: string;
    Level?: (number) | null;
    IsAnamorphic?: (boolean) | null;
};

export type Type2 = 'Audio' | 'Video' | 'Subtitle' | 'EmbeddedImage';

export type DeliveryMethod = 'Encode' | 'Embed' | 'External' | 'Hls';

export type MediaUrl = {
    Url?: string;
    Name?: string;
};

export type BaseItemPerson = {
    Name?: string;
    Id?: string;
    Role?: string;
    Type?: 'Actor' | 'Director' | 'Writer' | 'Producer' | 'GuestStar' | 'Composer' | 'Conductor' | 'Lyricist';
    PrimaryImageTag?: string;
};

export type Type3 = 'Actor' | 'Director' | 'Writer' | 'Producer' | 'GuestStar' | 'Composer' | 'Conductor' | 'Lyricist';

export type NameLongIdPair = {
    Name?: string;
    Id?: number;
};

export type UserItemDataDto = {
    Rating?: (number) | null;
    PlayedPercentage?: (number) | null;
    UnplayedItemCount?: (number) | null;
    PlaybackPositionTicks?: number;
    PlayCount?: number;
    IsFavorite?: boolean;
    Likes?: (boolean) | null;
    LastPlayedDate?: (string) | null;
    Played?: boolean;
    Key?: string;
    ItemId?: string;
};

export type NameIdPair = {
    Name?: string;
    Id?: string;
};

export type ChapterInfo = {
    StartPositionTicks?: number;
    Name?: string;
    ImageTag?: string;
};

export type QueryResult_UserLibrary_TagItem = {
    Items?: Array<UserLibrary_TagItem>;
    TotalRecordCount?: number;
};

export type UserLibrary_TagItem = {
    Name?: string;
};

export type Collections_CollectionCreationResult = {
    Id?: string;
};

export type QueryResult_Devices_DeviceInfo = {
    Items?: Array<Devices_DeviceInfo>;
    TotalRecordCount?: number;
};

export type Devices_DeviceInfo = {
    Name?: string;
    Id?: string;
    LastUserName?: string;
    AppName?: string;
    AppVersion?: string;
    LastUserId?: string;
    DateLastActivity?: string;
    IconUrl?: string;
};

export type QueryResult_UserLibrary_OfficialRatingItem = {
    Items?: Array<UserLibrary_OfficialRatingItem>;
    TotalRecordCount?: number;
};

export type UserLibrary_OfficialRatingItem = {
    Name?: string;
};

export type Updates_PackageInfo = {
    id?: string;
    name?: string;
    shortDescription?: string;
    overview?: string;
    isPremium?: boolean;
    adult?: boolean;
    richDescUrl?: string;
    thumbImage?: string;
    previewImage?: string;
    type?: string;
    targetFilename?: string;
    owner?: string;
    category?: string;
    tileColor?: string;
    featureId?: string;
    regInfo?: string;
    price?: number;
    targetSystem?: 'Server' | 'MBTheater' | 'MBClassic';
    guid?: string;
    totalRatings?: (number) | null;
    avgRating?: number;
    isRegistered?: boolean;
    expDate?: string;
    versions?: Array<Updates_PackageVersionInfo>;
    enableInAppStore?: boolean;
    installs?: number;
};

export type targetSystem = 'Server' | 'MBTheater' | 'MBClassic';

export type Updates_PackageVersionInfo = {
    name?: string;
    guid?: string;
    versionStr?: string;
    classification?: 'Release' | 'Beta' | 'Dev';
    description?: string;
    requiredVersionStr?: string;
    sourceUrl?: string;
    checksum?: string;
    targetFilename?: string;
    infoUrl?: string;
    runtimes?: string;
};

export type classification = 'Release' | 'Beta' | 'Dev';

export type Playlists_PlaylistCreationResult = {
    Id?: string;
};

export type Plugins_PluginInfo = {
    Name?: string;
    Version?: string;
    ConfigurationFileName?: string;
    Description?: string;
    Id?: string;
    ImageTag?: string;
};

export type Tasks_TaskInfo = {
    Name?: string;
    State?: 'Idle' | 'Cancelling' | 'Running';
    CurrentProgressPercentage?: (number) | null;
    Id?: string;
    LastExecutionResult?: Tasks_TaskResult;
    Triggers?: Array<Tasks_TaskTriggerInfo>;
    Description?: string;
    Category?: string;
    IsHidden?: boolean;
    Key?: string;
};

export type State = 'Idle' | 'Cancelling' | 'Running';

export type Tasks_TaskResult = {
    StartTimeUtc?: string;
    EndTimeUtc?: string;
    Status?: 'Completed' | 'Failed' | 'Cancelled' | 'Aborted';
    Name?: string;
    Key?: string;
    Id?: string;
    ErrorMessage?: string;
    LongErrorMessage?: string;
};

export type Status = 'Completed' | 'Failed' | 'Cancelled' | 'Aborted';

export type Tasks_TaskTriggerInfo = {
    Type?: string;
    TimeOfDayTicks?: (number) | null;
    IntervalTicks?: (number) | null;
    SystemEvent?: 'WakeFromSleep' | 'DisplayConfigurationChange';
    DayOfWeek?: 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday';
    MaxRuntimeTicks?: (number) | null;
};

export type SystemEvent = 'WakeFromSleep' | 'DisplayConfigurationChange';

export type DayOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday';

export type Session_SessionInfo = {
    PlayState?: PlayerStateInfo;
    AdditionalUsers?: Array<SessionUserInfo>;
    Capabilities?: ClientCapabilities;
    RemoteEndPoint?: string;
    PlayableMediaTypes?: Array<(string)>;
    PlaylistItemId?: string;
    Id?: string;
    ServerId?: string;
    UserId?: string;
    UserName?: string;
    UserPrimaryImageTag?: string;
    Client?: string;
    LastActivityDate?: string;
    DeviceName?: string;
    DeviceType?: string;
    NowPlayingItem?: BaseItemDto;
    DeviceId?: string;
    ApplicationVersion?: string;
    AppIconUrl?: string;
    SupportedCommands?: Array<(string)>;
    TranscodingInfo?: TranscodingInfo;
    SupportsRemoteControl?: boolean;
};

export type PlayerStateInfo = {
    PositionTicks?: (number) | null;
    CanSeek?: boolean;
    IsPaused?: boolean;
    IsMuted?: boolean;
    VolumeLevel?: (number) | null;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    MediaSourceId?: string;
    PlayMethod?: 'Transcode' | 'DirectStream' | 'DirectPlay';
    RepeatMode?: 'RepeatNone' | 'RepeatAll' | 'RepeatOne';
};

export type PlayMethod = 'Transcode' | 'DirectStream' | 'DirectPlay';

export type RepeatMode = 'RepeatNone' | 'RepeatAll' | 'RepeatOne';

export type SessionUserInfo = {
    UserId?: string;
    UserName?: string;
    UserInternalId?: number;
};

export type ClientCapabilities = {
    PlayableMediaTypes?: Array<(string)>;
    SupportedCommands?: Array<(string)>;
    SupportsMediaControl?: boolean;
    PushToken?: string;
    PushTokenType?: string;
    SupportsPersistentIdentifier?: boolean;
    SupportsSync?: boolean;
    DeviceProfile?: Dlna_DeviceProfile;
    IconUrl?: string;
    AppId?: string;
};

export type Dlna_DeviceProfile = {
    Name?: string;
    Id?: string;
    Identification?: Dlna_DeviceIdentification;
    FriendlyName?: string;
    Manufacturer?: string;
    ManufacturerUrl?: string;
    ModelName?: string;
    ModelDescription?: string;
    ModelNumber?: string;
    ModelUrl?: string;
    SerialNumber?: string;
    EnableAlbumArtInDidl?: boolean;
    EnableSingleAlbumArtLimit?: boolean;
    EnableSingleSubtitleLimit?: boolean;
    SupportedMediaTypes?: string;
    UserId?: string;
    AlbumArtPn?: string;
    MaxAlbumArtWidth?: number;
    MaxAlbumArtHeight?: number;
    MaxIconWidth?: (number) | null;
    MaxIconHeight?: (number) | null;
    MaxStreamingBitrate?: (number) | null;
    MaxStaticBitrate?: (number) | null;
    MusicStreamingTranscodingBitrate?: (number) | null;
    MaxStaticMusicBitrate?: (number) | null;
    SonyAggregationFlags?: string;
    ProtocolInfo?: string;
    TimelineOffsetSeconds?: number;
    RequiresPlainVideoItems?: boolean;
    RequiresPlainFolders?: boolean;
    EnableMSMediaReceiverRegistrar?: boolean;
    IgnoreTranscodeByteRangeRequests?: boolean;
    XmlRootAttributes?: Array<Dlna_XmlAttribute>;
    DirectPlayProfiles?: Array<Dlna_DirectPlayProfile>;
    TranscodingProfiles?: Array<Dlna_TranscodingProfile>;
    ContainerProfiles?: Array<Dlna_ContainerProfile>;
    CodecProfiles?: Array<Dlna_CodecProfile>;
    ResponseProfiles?: Array<Dlna_ResponseProfile>;
    SubtitleProfiles?: Array<Dlna_SubtitleProfile>;
};

export type Dlna_DeviceIdentification = {
    FriendlyName?: string;
    ModelNumber?: string;
    SerialNumber?: string;
    ModelName?: string;
    ModelDescription?: string;
    DeviceDescription?: string;
    ModelUrl?: string;
    Manufacturer?: string;
    ManufacturerUrl?: string;
    Headers?: Array<Dlna_HttpHeaderInfo>;
};

export type Dlna_HttpHeaderInfo = {
    Name?: string;
    Value?: string;
    Match?: 'Equals' | 'Regex' | 'Substring';
};

export type Match = 'Equals' | 'Regex' | 'Substring';

export type Dlna_XmlAttribute = {
    Name?: string;
    Value?: string;
};

export type Dlna_DirectPlayProfile = {
    Container?: string;
    AudioCodec?: string;
    VideoCodec?: string;
    Type?: 'Audio' | 'Video' | 'Photo';
};

export type Type4 = 'Audio' | 'Video' | 'Photo';

export type Dlna_TranscodingProfile = {
    Container?: string;
    Type?: 'Audio' | 'Video' | 'Photo';
    VideoCodec?: string;
    AudioCodec?: string;
    Protocol?: string;
    EstimateContentLength?: boolean;
    EnableMpegtsM2TsMode?: boolean;
    TranscodeSeekInfo?: 'Auto' | 'Bytes';
    CopyTimestamps?: boolean;
    Context?: 'Streaming' | 'Static';
    MaxAudioChannels?: string;
    MinSegments?: number;
    SegmentLength?: number;
    BreakOnNonKeyFrames?: boolean;
    ManifestSubtitles?: string;
};

export type TranscodeSeekInfo = 'Auto' | 'Bytes';

export type Context = 'Streaming' | 'Static';

export type Dlna_ContainerProfile = {
    Type?: 'Audio' | 'Video' | 'Photo';
    Conditions?: Array<Dlna_ProfileCondition>;
    Container?: string;
};

export type Dlna_ProfileCondition = {
    Condition?: 'Equals' | 'NotEquals' | 'LessThanEqual' | 'GreaterThanEqual' | 'EqualsAny';
    Property?: 'AudioChannels' | 'AudioBitrate' | 'AudioProfile' | 'Width' | 'Height' | 'Has64BitOffsets' | 'PacketLength' | 'VideoBitDepth' | 'VideoBitrate' | 'VideoFramerate' | 'VideoLevel' | 'VideoProfile' | 'VideoTimestamp' | 'IsAnamorphic' | 'RefFrames' | 'NumAudioStreams' | 'NumVideoStreams' | 'IsSecondaryAudio' | 'VideoCodecTag' | 'IsAvc' | 'IsInterlaced' | 'AudioSampleRate' | 'AudioBitDepth';
    Value?: string;
    IsRequired?: boolean;
};

export type Condition = 'Equals' | 'NotEquals' | 'LessThanEqual' | 'GreaterThanEqual' | 'EqualsAny';

export type Property = 'AudioChannels' | 'AudioBitrate' | 'AudioProfile' | 'Width' | 'Height' | 'Has64BitOffsets' | 'PacketLength' | 'VideoBitDepth' | 'VideoBitrate' | 'VideoFramerate' | 'VideoLevel' | 'VideoProfile' | 'VideoTimestamp' | 'IsAnamorphic' | 'RefFrames' | 'NumAudioStreams' | 'NumVideoStreams' | 'IsSecondaryAudio' | 'VideoCodecTag' | 'IsAvc' | 'IsInterlaced' | 'AudioSampleRate' | 'AudioBitDepth';

export type Dlna_CodecProfile = {
    Type?: 'Video' | 'VideoAudio' | 'Audio';
    Conditions?: Array<Dlna_ProfileCondition>;
    ApplyConditions?: Array<Dlna_ProfileCondition>;
    Codec?: string;
    Container?: string;
};

export type Type5 = 'Video' | 'VideoAudio' | 'Audio';

export type Dlna_ResponseProfile = {
    Container?: string;
    AudioCodec?: string;
    VideoCodec?: string;
    Type?: 'Audio' | 'Video' | 'Photo';
    OrgPn?: string;
    MimeType?: string;
    Conditions?: Array<Dlna_ProfileCondition>;
};

export type Dlna_SubtitleProfile = {
    Format?: string;
    Method?: 'Encode' | 'Embed' | 'External' | 'Hls';
    DidlMode?: string;
    Language?: string;
    Container?: string;
};

export type Method = 'Encode' | 'Embed' | 'External' | 'Hls';

export type TranscodingInfo = {
    AudioCodec?: string;
    VideoCodec?: string;
    Container?: string;
    IsVideoDirect?: boolean;
    IsAudioDirect?: boolean;
    Bitrate?: (number) | null;
    Framerate?: (number) | null;
    CompletionPercentage?: (number) | null;
    TranscodingPositionTicks?: (number) | null;
    TranscodingStartPositionTicks?: (number) | null;
    Width?: (number) | null;
    Height?: (number) | null;
    AudioChannels?: (number) | null;
    TranscodeReasons?: Array<('ContainerNotSupported' | 'VideoCodecNotSupported' | 'AudioCodecNotSupported' | 'ContainerBitrateExceedsLimit' | 'AudioBitrateNotSupported' | 'AudioChannelsNotSupported' | 'VideoResolutionNotSupported' | 'UnknownVideoStreamInfo' | 'UnknownAudioStreamInfo' | 'AudioProfileNotSupported' | 'AudioSampleRateNotSupported' | 'AnamorphicVideoNotSupported' | 'InterlacedVideoNotSupported' | 'SecondaryAudioNotSupported' | 'RefFramesNotSupported' | 'VideoBitDepthNotSupported' | 'VideoBitrateNotSupported' | 'VideoFramerateNotSupported' | 'VideoLevelNotSupported' | 'VideoProfileNotSupported' | 'AudioBitDepthNotSupported' | 'SubtitleCodecNotSupported' | 'DirectPlayError')>;
    CurrentCpuUsage?: (number) | null;
    AverageCpuUsage?: (number) | null;
    CpuHistory?: Array<Tuple_Double_Double>;
    CurrentThrottle?: (number) | null;
    VideoDecoder?: string;
    VideoDecoderIsHardware?: boolean;
    VideoDecoderMediaType?: string;
    VideoDecoderHwAccel?: string;
    VideoEncoder?: string;
    VideoEncoderIsHardware?: boolean;
    VideoEncoderMediaType?: string;
    VideoEncoderHwAccel?: string;
};

export type Tuple_Double_Double = {
    Item1?: number;
    Item2?: number;
};

export type UserDto = {
    Name?: string;
    ServerId?: string;
    ServerName?: string;
    ConnectUserName?: string;
    ConnectLinkType?: 'LinkedUser' | 'Guest';
    Id?: string;
    PrimaryImageTag?: string;
    HasPassword?: boolean;
    HasConfiguredPassword?: boolean;
    HasConfiguredEasyPassword?: boolean;
    EnableAutoLogin?: (boolean) | null;
    LastLoginDate?: (string) | null;
    LastActivityDate?: (string) | null;
    Configuration?: Configuration_UserConfiguration;
    Policy?: Users_UserPolicy;
    PrimaryImageAspectRatio?: (number) | null;
};

export type ConnectLinkType = 'LinkedUser' | 'Guest';

export type Configuration_UserConfiguration = {
    AudioLanguagePreference?: string;
    PlayDefaultAudioTrack?: boolean;
    SubtitleLanguagePreference?: string;
    DisplayMissingEpisodes?: boolean;
    GroupedFolders?: Array<(string)>;
    SubtitleMode?: 'Default' | 'Always' | 'OnlyForced' | 'None' | 'Smart';
    DisplayCollectionsView?: boolean;
    EnableLocalPassword?: boolean;
    OrderedViews?: Array<(string)>;
    LatestItemsExcludes?: Array<(string)>;
    MyMediaExcludes?: Array<(string)>;
    HidePlayedInLatest?: boolean;
    RememberAudioSelections?: boolean;
    RememberSubtitleSelections?: boolean;
    EnableNextEpisodeAutoPlay?: boolean;
};

export type SubtitleMode = 'Default' | 'Always' | 'OnlyForced' | 'None' | 'Smart';

export type Users_UserPolicy = {
    IsAdministrator?: boolean;
    IsHidden?: boolean;
    IsHiddenRemotely?: boolean;
    IsDisabled?: boolean;
    MaxParentalRating?: (number) | null;
    BlockedTags?: Array<(string)>;
    EnableUserPreferenceAccess?: boolean;
    AccessSchedules?: Array<Configuration_AccessSchedule>;
    BlockUnratedItems?: Array<('Movie' | 'Trailer' | 'Series' | 'Music' | 'Game' | 'Book' | 'LiveTvChannel' | 'LiveTvProgram' | 'ChannelContent' | 'Other')>;
    EnableRemoteControlOfOtherUsers?: boolean;
    EnableSharedDeviceControl?: boolean;
    EnableRemoteAccess?: boolean;
    EnableLiveTvManagement?: boolean;
    EnableLiveTvAccess?: boolean;
    EnableMediaPlayback?: boolean;
    EnableAudioPlaybackTranscoding?: boolean;
    EnableVideoPlaybackTranscoding?: boolean;
    EnablePlaybackRemuxing?: boolean;
    EnableContentDeletion?: boolean;
    EnableContentDeletionFromFolders?: Array<(string)>;
    EnableContentDownloading?: boolean;
    EnableSubtitleDownloading?: boolean;
    EnableSubtitleManagement?: boolean;
    EnableSyncTranscoding?: boolean;
    EnableMediaConversion?: boolean;
    EnabledDevices?: Array<(string)>;
    EnableAllDevices?: boolean;
    EnabledChannels?: Array<(string)>;
    EnableAllChannels?: boolean;
    EnabledFolders?: Array<(string)>;
    EnableAllFolders?: boolean;
    InvalidLoginAttemptCount?: number;
    EnablePublicSharing?: boolean;
    BlockedMediaFolders?: Array<(string)>;
    BlockedChannels?: Array<(string)>;
    RemoteClientBitrateLimit?: number;
    AuthenticationProviderId?: string;
    ExcludedSubFolders?: Array<(string)>;
    DisablePremiumFeatures?: boolean;
};

export type Configuration_AccessSchedule = {
    DayOfWeek?: 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday' | 'Everyday' | 'Weekday' | 'Weekend';
    StartHour?: number;
    EndHour?: number;
};

export type DayOfWeek2 = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday' | 'Everyday' | 'Weekday' | 'Weekend';

export type NameValuePair = {
    Name?: string;
    Value?: string;
};

export type Branding_BrandingOptions = {
    LoginDisclaimer?: string;
    CustomCss?: string;
};

export type Connect_ConnectAuthenticationExchangeResult = {
    LocalUserId?: string;
    AccessToken?: string;
};

export type Devices_DeviceOptions = {
    CustomName?: string;
};

export type Devices_ContentUploadHistory = {
    DeviceId?: string;
    FilesUploaded?: Array<Devices_LocalFileInfo>;
};

export type Devices_LocalFileInfo = {
    Name?: string;
    Id?: string;
    Album?: string;
    MimeType?: string;
};

export type DisplayPreferences = {
    Id?: string;
    ViewType?: string;
    SortBy?: string;
    IndexBy?: string;
    RememberIndexing?: boolean;
    PrimaryImageHeight?: number;
    PrimaryImageWidth?: number;
    CustomPrefs?: {
        [key: string]: (string);
    };
    ScrollDirection?: 'Horizontal' | 'Vertical';
    ShowBackdrop?: boolean;
    RememberSorting?: boolean;
    SortOrder?: 'Ascending' | 'Descending';
    ShowSidebar?: boolean;
    Client?: string;
};

export type ScrollDirection = 'Horizontal' | 'Vertical';

export type SortOrder = 'Ascending' | 'Descending';

export type Dlna_DeviceProfileInfo = {
    Id?: string;
    Name?: string;
    Type?: 'System' | 'User';
};

export type Type6 = 'System' | 'User';

export type ValidatePath = {
    ValidateWriteable?: boolean;
    IsFile?: (boolean) | null;
};

export type DefaultDirectoryBrowserInfo = {
    Path?: string;
};

export type IO_FileSystemEntryInfo = {
    Name?: string;
    Path?: string;
    Type?: 'File' | 'Directory' | 'NetworkComputer' | 'NetworkShare';
};

export type Type7 = 'File' | 'Directory' | 'NetworkComputer' | 'NetworkShare';

export type GameSystemSummary = {
    Name?: string;
    DisplayName?: string;
    GameCount?: number;
    GameFileExtensions?: Array<(string)>;
    ClientInstalledGameCount?: number;
};

export type ImageByNameInfo = {
    Name?: string;
    Theme?: string;
    Context?: string;
    FileLength?: number;
    Format?: string;
};

export type QueryFilters = {
    Genres?: Array<NameLongIdPair>;
    Studios?: Array<NameLongIdPair>;
    Tags?: Array<(string)>;
};

export type QueryFiltersLegacy = {
    Genres?: Array<(string)>;
    Tags?: Array<(string)>;
    OfficialRatings?: Array<(string)>;
    Years?: Array<(number)>;
};

export type ItemCounts = {
    MovieCount?: number;
    SeriesCount?: number;
    EpisodeCount?: number;
    GameCount?: number;
    ArtistCount?: number;
    ProgramCount?: number;
    GameSystemCount?: number;
    TrailerCount?: number;
    SongCount?: number;
    AlbumCount?: number;
    MusicVideoCount?: number;
    BoxSetCount?: number;
    BookCount?: number;
    ItemCount?: number;
};

export type Library_LibraryOptionsResult = {
    MetadataSavers?: Array<Library_LibraryOptionInfo>;
    MetadataReaders?: Array<Library_LibraryOptionInfo>;
    SubtitleFetchers?: Array<Library_LibraryOptionInfo>;
    TypeOptions?: Array<Library_LibraryTypeOptions>;
};

export type Library_LibraryOptionInfo = {
    Name?: string;
    DefaultEnabled?: boolean;
};

export type Library_LibraryTypeOptions = {
    Type?: string;
    MetadataFetchers?: Array<Library_LibraryOptionInfo>;
    ImageFetchers?: Array<Library_LibraryOptionInfo>;
    SupportedImageTypes?: Array<('Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail')>;
    DefaultImageOptions?: Array<Configuration_ImageOption>;
};

export type Configuration_ImageOption = {
    Type?: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    Limit?: number;
    MinWidth?: number;
};

export type Type8 = 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';

export type Library_MediaFolder = {
    Name?: string;
    Id?: string;
    SubFolders?: Array<Library_SubFolder>;
};

export type Library_SubFolder = {
    Name?: string;
    Id?: string;
    Path?: string;
};

export type VirtualFolderInfo = {
    Name?: string;
    Locations?: Array<(string)>;
    CollectionType?: string;
    LibraryOptions?: Configuration_LibraryOptions;
    ItemId?: string;
    PrimaryImageItemId?: string;
    RefreshProgress?: (number) | null;
    RefreshStatus?: string;
};

export type Configuration_LibraryOptions = {
    EnableArchiveMediaFiles?: boolean;
    EnablePhotos?: boolean;
    EnableRealtimeMonitor?: boolean;
    EnableChapterImageExtraction?: boolean;
    ExtractChapterImagesDuringLibraryScan?: boolean;
    DownloadImagesInAdvance?: boolean;
    PathInfos?: Array<Configuration_MediaPathInfo>;
    SaveLocalMetadata?: boolean;
    SaveLocalThumbnailSets?: boolean;
    ImportMissingEpisodes?: boolean;
    EnableAutomaticSeriesGrouping?: boolean;
    EnableEmbeddedTitles?: boolean;
    EnableAudioResume?: boolean;
    AutomaticRefreshIntervalDays?: number;
    PreferredMetadataLanguage?: string;
    ContentType?: string;
    MetadataCountryCode?: string;
    SeasonZeroDisplayName?: string;
    MetadataSavers?: Array<(string)>;
    DisabledLocalMetadataReaders?: Array<(string)>;
    LocalMetadataReaderOrder?: Array<(string)>;
    DisabledSubtitleFetchers?: Array<(string)>;
    SubtitleFetcherOrder?: Array<(string)>;
    SkipSubtitlesIfEmbeddedSubtitlesPresent?: boolean;
    SkipSubtitlesIfAudioTrackMatches?: boolean;
    SubtitleDownloadLanguages?: Array<(string)>;
    RequirePerfectSubtitleMatch?: boolean;
    SaveSubtitlesWithMedia?: boolean;
    ForcedSubtitlesOnly?: boolean;
    TypeOptions?: Array<Configuration_TypeOptions>;
    CollapseSingleItemFolders?: boolean;
    MinResumePct?: number;
    MaxResumePct?: number;
    MinResumeDurationSeconds?: number;
    ThumbnailImagesIntervalSeconds?: number;
};

export type Configuration_MediaPathInfo = {
    Path?: string;
    NetworkPath?: string;
};

export type Configuration_TypeOptions = {
    Type?: string;
    MetadataFetchers?: Array<(string)>;
    MetadataFetcherOrder?: Array<(string)>;
    ImageFetchers?: Array<(string)>;
    ImageFetcherOrder?: Array<(string)>;
    ImageOptions?: Array<Configuration_ImageOption>;
};

export type Library_AddVirtualFolder = {
    Name?: string;
    CollectionType?: string;
    RefreshLibrary?: boolean;
    Paths?: Array<(string)>;
    LibraryOptions?: Configuration_LibraryOptions;
};

export type MediaInfo_LiveStreamRequest = {
    OpenToken?: string;
    UserId?: string;
    PlaySessionId?: string;
    MaxStreamingBitrate?: (number) | null;
    StartTimeTicks?: (number) | null;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    MaxAudioChannels?: (number) | null;
    ItemId?: number;
    DeviceProfile?: Dlna_DeviceProfile;
    EnableDirectPlay?: boolean;
    EnableDirectStream?: boolean;
    EnableTranscoding?: boolean;
    AllowVideoStreamCopy?: boolean;
    AllowAudioStreamCopy?: boolean;
    DirectPlayProtocols?: Array<('File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp' | 'Mms')>;
};

export type MediaInfo_LiveStreamResponse = {
    MediaSource?: MediaSourceInfo;
};

export type LiveTv_SetChannelMapping = {
    TunerChannelId?: string;
    ProviderChannelId?: string;
};

export type LiveTv_ListingsProviderInfo = {
    Name?: string;
    SetupUrl?: string;
    Id?: string;
    Type?: string;
    Username?: string;
    Password?: string;
    ListingsId?: string;
    ZipCode?: string;
    Country?: string;
    Path?: string;
    EnabledTuners?: Array<(string)>;
    EnableAllTuners?: boolean;
    NewsCategories?: Array<(string)>;
    SportsCategories?: Array<(string)>;
    KidsCategories?: Array<(string)>;
    MovieCategories?: Array<(string)>;
    ChannelMappings?: Array<NameValuePair>;
    MoviePrefix?: string;
    PreferredLanguage?: string;
    UserAgent?: string;
};

export type LiveTv_TunerHostInfo = {
    Id?: string;
    Url?: string;
    Type?: string;
    DeviceId?: string;
    FriendlyName?: string;
    ImportFavoritesOnly?: boolean;
    AllowHWTranscoding?: boolean;
    Source?: string;
    TunerCount?: number;
    UserAgent?: string;
};

export type LiveTv_LiveTvInfo = {
    Services?: Array<LiveTv_LiveTvServiceInfo>;
    IsEnabled?: boolean;
    EnabledUsers?: Array<(string)>;
};

export type LiveTv_LiveTvServiceInfo = {
    Name?: string;
    HomePageUrl?: string;
    Status?: 'Ok' | 'Unavailable';
    StatusMessage?: string;
    Version?: string;
    HasUpdateAvailable?: boolean;
    IsVisible?: boolean;
    Tuners?: Array<(string)>;
};

export type Status2 = 'Ok' | 'Unavailable';

export type LiveTv_GetPrograms = {
    IsAiring?: (boolean) | null;
    EnableTotalRecordCount?: boolean;
    SeriesTimerId?: string;
    LibrarySeriesId?: string;
};

export type QueryResult_LiveTv_TimerInfoDto = {
    Items?: Array<LiveTv_TimerInfoDto>;
    TotalRecordCount?: number;
};

export type LiveTv_TimerInfoDto = {
    Status?: 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';
    SeriesTimerId?: string;
    ExternalSeriesTimerId?: string;
    RunTimeTicks?: (number) | null;
    ProgramInfo?: BaseItemDto;
    Id?: string;
    Type?: string;
    ServerId?: string;
    ExternalId?: string;
    ChannelId?: string;
    ExternalChannelId?: string;
    ChannelName?: string;
    ChannelPrimaryImageTag?: string;
    ProgramId?: string;
    ExternalProgramId?: string;
    Name?: string;
    Overview?: string;
    StartDate?: string;
    EndDate?: string;
    ServiceName?: string;
    Priority?: number;
    PrePaddingSeconds?: number;
    PostPaddingSeconds?: number;
    IsPrePaddingRequired?: boolean;
    ParentBackdropItemId?: string;
    ParentBackdropImageTags?: Array<(string)>;
    IsPostPaddingRequired?: boolean;
    KeepUntil?: 'UntilDeleted' | 'UntilSpaceNeeded' | 'UntilWatched' | 'UntilDate';
};

export type Status3 = 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';

export type KeepUntil = 'UntilDeleted' | 'UntilSpaceNeeded' | 'UntilWatched' | 'UntilDate';

export type QueryResult_LiveTv_SeriesTimerInfoDto = {
    Items?: Array<LiveTv_SeriesTimerInfoDto>;
    TotalRecordCount?: number;
};

export type LiveTv_SeriesTimerInfoDto = {
    RecordAnyTime?: boolean;
    SkipEpisodesInLibrary?: boolean;
    RecordAnyChannel?: boolean;
    KeepUpTo?: number;
    RecordNewOnly?: boolean;
    Days?: Array<('Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday')>;
    DayPattern?: 'Daily' | 'Weekdays' | 'Weekends';
    ImageTags?: {
        [key: string]: (string);
    };
    ParentThumbItemId?: string;
    ParentThumbImageTag?: string;
    ParentPrimaryImageItemId?: string;
    ParentPrimaryImageTag?: string;
    Id?: string;
    Type?: string;
    ServerId?: string;
    ExternalId?: string;
    ChannelId?: string;
    ExternalChannelId?: string;
    ChannelName?: string;
    ChannelPrimaryImageTag?: string;
    ProgramId?: string;
    ExternalProgramId?: string;
    Name?: string;
    Overview?: string;
    StartDate?: string;
    EndDate?: string;
    ServiceName?: string;
    Priority?: number;
    PrePaddingSeconds?: number;
    PostPaddingSeconds?: number;
    IsPrePaddingRequired?: boolean;
    ParentBackdropItemId?: string;
    ParentBackdropImageTags?: Array<(string)>;
    IsPostPaddingRequired?: boolean;
    KeepUntil?: 'UntilDeleted' | 'UntilSpaceNeeded' | 'UntilWatched' | 'UntilDate';
};

export type DayPattern = 'Daily' | 'Weekdays' | 'Weekends';

export type LiveTv_GuideInfo = {
    StartDate?: string;
    EndDate?: string;
};

export type ParentalRating = {
    Name?: string;
    Value?: number;
};

export type Globalization_LocalizatonOption = {
    Name?: string;
    Value?: string;
};

export type Globalization_CountryInfo = {
    Name?: string;
    DisplayName?: string;
    TwoLetterISORegionName?: string;
    ThreeLetterISORegionName?: string;
};

export type Globalization_CultureDto = {
    Name?: string;
    DisplayName?: string;
    TwoLetterISOLanguageName?: string;
    ThreeLetterISOLanguageName?: string;
    ThreeLetterISOLanguageNames?: Array<(string)>;
};

export type RecommendationDto = {
    Items?: Array<BaseItemDto>;
    RecommendationType?: 'SimilarToRecentlyPlayed' | 'SimilarToLikedItem' | 'HasDirectorFromRecentlyPlayed' | 'HasActorFromRecentlyPlayed' | 'HasLikedDirector' | 'HasLikedActor';
    BaselineItemName?: string;
    CategoryId?: number;
};

export type RecommendationType = 'SimilarToRecentlyPlayed' | 'SimilarToLikedItem' | 'HasDirectorFromRecentlyPlayed' | 'HasActorFromRecentlyPlayed' | 'HasLikedDirector' | 'HasLikedActor';

export type QueryResult_News_NewsItem = {
    Items?: Array<News_NewsItem>;
    TotalRecordCount?: number;
};

export type News_NewsItem = {
    Title?: string;
    Link?: string;
    Description?: string;
    DescriptionHtml?: string;
    Guid?: string;
    Date?: string;
};

export type Notifications_NotificationTypeInfo = {
    Type?: string;
    Name?: string;
    Enabled?: boolean;
    Category?: string;
    IsBasedOnUserEvent?: boolean;
};

export type Emby_Notifications_Api_NotificationResult = {
    Notifications?: Array<Emby_Notifications_Api_Notification>;
    TotalRecordCount?: number;
};

export type Emby_Notifications_Api_Notification = {
    Id?: string;
    UserId?: string;
    Date?: string;
    IsRead?: boolean;
    Name?: string;
    Description?: string;
    Url?: string;
    Level?: 'Normal' | 'Warning' | 'Error';
};

export type Level = 'Normal' | 'Warning' | 'Error';

export type EmbyReports_Api_Model_ReportResult = {
    Rows?: Array<EmbyReports_Api_Model_ReportRow>;
    Headers?: Array<EmbyReports_Api_Model_ReportHeader>;
    Groups?: Array<EmbyReports_Api_Model_ReportGroup>;
    TotalRecordCount?: number;
    IsGrouped?: boolean;
};

export type EmbyReports_Api_Model_ReportRow = {
    Id?: string;
    HasImageTagsBackdrop?: boolean;
    HasImageTagsPrimary?: boolean;
    HasImageTagsLogo?: boolean;
    HasLocalTrailer?: boolean;
    HasLockData?: boolean;
    HasEmbeddedImage?: boolean;
    HasSubtitles?: boolean;
    HasSpecials?: boolean;
    Columns?: Array<EmbyReports_Api_Model_ReportItem>;
    RowType?: 'MusicArtist' | 'MusicAlbum' | 'Book' | 'BoxSet' | 'Episode' | 'Game' | 'Video' | 'Movie' | 'MusicVideo' | 'Trailer' | 'Season' | 'Series' | 'Audio' | 'BaseItem' | 'Artist';
    UserId?: string;
};

export type RowType = 'MusicArtist' | 'MusicAlbum' | 'Book' | 'BoxSet' | 'Episode' | 'Game' | 'Video' | 'Movie' | 'MusicVideo' | 'Trailer' | 'Season' | 'Series' | 'Audio' | 'BaseItem' | 'Artist';

export type EmbyReports_Api_Model_ReportItem = {
    Id?: string;
    Name?: string;
    Image?: string;
    CustomTag?: string;
};

export type EmbyReports_Api_Model_ReportHeader = {
    HeaderFieldType?: 'String' | 'Boolean' | 'Date' | 'Time' | 'DateTime' | 'Int' | 'Image' | 'Object' | 'Minutes';
    Name?: string;
    FieldName?: 'None' | 'Path' | 'Name' | 'PremiereDate' | 'DateAdded' | 'ReleaseDate' | 'Runtime' | 'PlayCount' | 'Season' | 'SeasonNumber' | 'Series' | 'Network' | 'Year' | 'ParentalRating' | 'CommunityRating' | 'Trailers' | 'Specials' | 'GameSystem' | 'AlbumArtist' | 'Album' | 'Disc' | 'Track' | 'Audio' | 'EmbeddedImage' | 'Video' | 'Resolution' | 'Subtitles' | 'Genres' | 'Countries' | 'Status' | 'Tracks' | 'EpisodeSeries' | 'EpisodeSeason' | 'EpisodeNumber' | 'AudioAlbumArtist' | 'MusicArtist' | 'AudioAlbum' | 'Locked' | 'ImagePrimary' | 'ImageBackdrop' | 'ImageLogo' | 'Actor' | 'Studios' | 'Composer' | 'Director' | 'GuestStar' | 'Producer' | 'Writer' | 'Artist' | 'Years' | 'ParentalRatings' | 'CommunityRatings' | 'Overview' | 'ShortOverview' | 'Type' | 'Date' | 'UserPrimaryImage' | 'Severity' | 'Item' | 'User' | 'UserId';
    SortField?: string;
    Type?: string;
    ItemViewType?: 'None' | 'Detail' | 'Edit' | 'List' | 'ItemByNameDetails' | 'StatusImage' | 'EmbeddedImage' | 'SubtitleImage' | 'TrailersImage' | 'SpecialsImage' | 'LockDataImage' | 'TagsPrimaryImage' | 'TagsBackdropImage' | 'TagsLogoImage' | 'UserPrimaryImage';
    Visible?: boolean;
    DisplayType?: 'None' | 'Screen' | 'Export' | 'ScreenExport';
    ShowHeaderLabel?: boolean;
    CanGroup?: boolean;
};

export type HeaderFieldType = 'String' | 'Boolean' | 'Date' | 'Time' | 'DateTime' | 'Int' | 'Image' | 'Object' | 'Minutes';

export type FieldName = 'None' | 'Path' | 'Name' | 'PremiereDate' | 'DateAdded' | 'ReleaseDate' | 'Runtime' | 'PlayCount' | 'Season' | 'SeasonNumber' | 'Series' | 'Network' | 'Year' | 'ParentalRating' | 'CommunityRating' | 'Trailers' | 'Specials' | 'GameSystem' | 'AlbumArtist' | 'Album' | 'Disc' | 'Track' | 'Audio' | 'EmbeddedImage' | 'Video' | 'Resolution' | 'Subtitles' | 'Genres' | 'Countries' | 'Status' | 'Tracks' | 'EpisodeSeries' | 'EpisodeSeason' | 'EpisodeNumber' | 'AudioAlbumArtist' | 'MusicArtist' | 'AudioAlbum' | 'Locked' | 'ImagePrimary' | 'ImageBackdrop' | 'ImageLogo' | 'Actor' | 'Studios' | 'Composer' | 'Director' | 'GuestStar' | 'Producer' | 'Writer' | 'Artist' | 'Years' | 'ParentalRatings' | 'CommunityRatings' | 'Overview' | 'ShortOverview' | 'Type' | 'Date' | 'UserPrimaryImage' | 'Severity' | 'Item' | 'User' | 'UserId';

export type ItemViewType = 'None' | 'Detail' | 'Edit' | 'List' | 'ItemByNameDetails' | 'StatusImage' | 'EmbeddedImage' | 'SubtitleImage' | 'TrailersImage' | 'SpecialsImage' | 'LockDataImage' | 'TagsPrimaryImage' | 'TagsBackdropImage' | 'TagsLogoImage' | 'UserPrimaryImage';

export type DisplayType = 'None' | 'Screen' | 'Export' | 'ScreenExport';

export type EmbyReports_Api_Model_ReportGroup = {
    Name?: string;
    Rows?: Array<EmbyReports_Api_Model_ReportRow>;
};

export type Search_SearchHintResult = {
    SearchHints?: Array<Search_SearchHint>;
    TotalRecordCount?: number;
};

export type Search_SearchHint = {
    ItemId?: number;
    Id?: number;
    Name?: string;
    MatchedTerm?: string;
    IndexNumber?: (number) | null;
    ProductionYear?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PrimaryImageTag?: string;
    ThumbImageTag?: string;
    ThumbImageItemId?: string;
    BackdropImageTag?: string;
    BackdropImageItemId?: string;
    Type?: string;
    IsFolder?: (boolean) | null;
    RunTimeTicks?: (number) | null;
    MediaType?: string;
    StartDate?: (string) | null;
    EndDate?: (string) | null;
    Series?: string;
    Status?: string;
    Album?: string;
    AlbumId?: number;
    AlbumArtist?: string;
    Artists?: Array<(string)>;
    SongCount?: (number) | null;
    EpisodeCount?: (number) | null;
    ChannelName?: string;
    PrimaryImageAspectRatio?: (number) | null;
};

export type PlaybackStartInfo = {
    CanSeek?: boolean;
    Item?: BaseItemDto;
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    ItemId?: string;
    SessionId?: string;
    MediaSourceId?: string;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    IsPaused?: boolean;
    IsMuted?: boolean;
    PositionTicks?: (number) | null;
    RunTimeTicks?: (number) | null;
    PlaybackStartTimeTicks?: (number) | null;
    VolumeLevel?: (number) | null;
    Brightness?: (number) | null;
    AspectRatio?: string;
    PlayMethod?: 'Transcode' | 'DirectStream' | 'DirectPlay';
    LiveStreamId?: string;
    PlaySessionId?: string;
    RepeatMode?: 'RepeatNone' | 'RepeatAll' | 'RepeatOne';
};

export type QueueItem = {
    Id?: number;
    PlaylistItemId?: string;
};

export type Sync_SyncTarget = {
    Name?: string;
    Id?: string;
};

export type QueryResult_Sync_SyncJob = {
    Items?: Array<Sync_SyncJob>;
    TotalRecordCount?: number;
};

export type Sync_SyncJob = {
    Id?: number;
    TargetId?: string;
    TargetName?: string;
    Quality?: string;
    Bitrate?: (number) | null;
    Profile?: string;
    Category?: 'Latest' | 'NextUp' | 'Resume';
    ParentId?: number;
    Progress?: number;
    Name?: string;
    Status?: 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Completed' | 'CompletedWithError' | 'Failed';
    UserId?: number;
    UnwatchedOnly?: boolean;
    SyncNewContent?: boolean;
    ItemLimit?: (number) | null;
    RequestedItemIds?: Array<(number)>;
    DateCreated?: string;
    DateLastModified?: string;
    ItemCount?: number;
    ParentName?: string;
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
};

export type Category = 'Latest' | 'NextUp' | 'Resume';

export type Status4 = 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Completed' | 'CompletedWithError' | 'Failed';

export type QueryResult_Sync_Model_SyncJobItem = {
    Items?: Array<Sync_Model_SyncJobItem>;
    TotalRecordCount?: number;
};

export type Sync_Model_SyncJobItem = {
    Id?: number;
    JobId?: number;
    ItemId?: number;
    ItemName?: string;
    MediaSourceId?: string;
    MediaSource?: MediaSourceInfo;
    TargetId?: string;
    OutputPath?: string;
    Status?: 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Synced' | 'Failed';
    Progress?: (number) | null;
    DateCreated?: string;
    PrimaryImageItemId?: number;
    PrimaryImageTag?: string;
    TemporaryPath?: string;
    AdditionalFiles?: Array<Sync_Model_ItemFileInfo>;
    ItemDateModifiedTicks?: number;
};

export type Status5 = 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Synced' | 'Failed';

export type Sync_Model_ItemFileInfo = {
    Type?: 'Media' | 'Image' | 'Subtitles';
    Name?: string;
    Path?: string;
    ImageType?: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    Index?: number;
};

export type Type9 = 'Media' | 'Image' | 'Subtitles';

export type ImageType = 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';

export type Sync_Model_SyncJobRequest = {
    TargetId?: string;
    ItemIds?: Array<(string)>;
    Category?: 'Latest' | 'NextUp' | 'Resume';
    ParentId?: string;
    Quality?: string;
    Profile?: string;
    Name?: string;
    UserId?: string;
    UnwatchedOnly?: boolean;
    SyncNewContent?: boolean;
    ItemLimit?: (number) | null;
    Bitrate?: (number) | null;
};

export type Sync_Model_SyncJobCreationResult = {
    Job?: Sync_SyncJob;
    JobItems?: Array<Sync_Model_SyncJobItem>;
};

export type Sync_Model_SyncDialogOptions = {
    Targets?: Array<Sync_SyncTarget>;
    Options?: Array<('Name' | 'Quality' | 'UnwatchedOnly' | 'SyncNewContent' | 'ItemLimit' | 'Profile')>;
    QualityOptions?: Array<Sync_Model_SyncQualityOption>;
    ProfileOptions?: Array<Sync_Model_SyncProfileOption>;
};

export type Sync_Model_SyncQualityOption = {
    Name?: string;
    Description?: string;
    Id?: string;
    IsDefault?: boolean;
    IsOriginalQuality?: boolean;
};

export type Sync_Model_SyncProfileOption = {
    Name?: string;
    Description?: string;
    Id?: string;
    IsDefault?: boolean;
    EnableQualityOptions?: boolean;
};

export type Users_UserAction = {
    Id?: string;
    ServerId?: string;
    UserId?: string;
    ItemId?: string;
    Type?: 'PlayedItem';
    Date?: string;
    PositionTicks?: (number) | null;
};

export type Type10 = 'PlayedItem';

export type Sync_Model_SyncDataRequest = {
    LocalItemIds?: Array<(string)>;
    TargetId?: string;
};

export type Sync_Model_SyncDataResponse = {
    ItemIdsToRemove?: Array<(string)>;
};

export type Configuration_ServerConfiguration = {
    EnableUPnP?: boolean;
    PublicPort?: number;
    PublicHttpsPort?: number;
    HttpServerPortNumber?: number;
    HttpsPortNumber?: number;
    EnableHttps?: boolean;
    SubtitlePermissionsUpgraded?: boolean;
    CertificatePath?: string;
    CertificatePassword?: string;
    IsPortAuthorized?: boolean;
    AutoRunWebApp?: boolean;
    EnableRemoteAccess?: boolean;
    LogAllQueryTimes?: boolean;
    EnableCaseSensitiveItemIds?: boolean;
    MetadataPath?: string;
    MetadataNetworkPath?: string;
    PreferredMetadataLanguage?: string;
    MetadataCountryCode?: string;
    SortReplaceCharacters?: Array<(string)>;
    SortRemoveCharacters?: Array<(string)>;
    SortRemoveWords?: Array<(string)>;
    LibraryMonitorDelay?: number;
    EnableDashboardResponseCaching?: boolean;
    DashboardSourcePath?: string;
    ImageSavingConvention?: 'Legacy' | 'Compatible';
    EnableAutomaticRestart?: boolean;
    SkipDeserializationForBasicTypes?: boolean;
    ServerName?: string;
    WanDdns?: string;
    UICulture?: string;
    SaveMetadataHidden?: boolean;
    RemoteClientBitrateLimit?: number;
    SchemaVersion?: number;
    DisplaySpecialsWithinSeasons?: boolean;
    LocalNetworkSubnets?: Array<(string)>;
    LocalNetworkAddresses?: Array<(string)>;
    EnableExternalContentInSuggestions?: boolean;
    RequireHttps?: boolean;
    IsBehindProxy?: boolean;
    RemoteIPFilter?: Array<(string)>;
    IsRemoteIPFilterBlacklist?: boolean;
    ImageExtractionTimeoutMs?: number;
    PathSubstitutions?: Array<Configuration_PathSubstitution>;
    UninstalledPlugins?: Array<(string)>;
    CollapseVideoFolders?: boolean;
    EnableOriginalTrackTitles?: boolean;
    EnableDebugLevelLogging?: boolean;
    EnableAutoUpdate?: boolean;
    LogFileRetentionDays?: number;
    RunAtStartup?: boolean;
    IsStartupWizardCompleted?: boolean;
    CachePath?: string;
};

export type ImageSavingConvention = 'Legacy' | 'Compatible';

export type Configuration_PathSubstitution = {
    From?: string;
    To?: string;
};

export type WakeOnLanInfo = {
    MacAddress?: string;
    BroadcastAddress?: string;
    Port?: number;
};

export type LogFile = {
    DateCreated?: string;
    DateModified?: string;
    Size?: number;
    Name?: string;
};

export type SystemInfo = {
    SystemUpdateLevel?: 'Release' | 'Beta' | 'Dev';
    OperatingSystemDisplayName?: string;
    PackageName?: string;
    HasPendingRestart?: boolean;
    IsShuttingDown?: boolean;
    SupportsLibraryMonitor?: boolean;
    WebSocketPortNumber?: number;
    CompletedInstallations?: Array<Updates_InstallationInfo>;
    CanSelfRestart?: boolean;
    CanSelfUpdate?: boolean;
    CanLaunchWebBrowser?: boolean;
    ProgramDataPath?: string;
    ItemsByNamePath?: string;
    CachePath?: string;
    LogPath?: string;
    InternalMetadataPath?: string;
    TranscodingTempPath?: string;
    HttpServerPortNumber?: number;
    SupportsHttps?: boolean;
    HttpsPortNumber?: number;
    HasUpdateAvailable?: boolean;
    SupportsAutoRunAtStartup?: boolean;
    HardwareAccelerationRequiresPremiere?: boolean;
    LocalAddress?: string;
    WanAddress?: string;
    ServerName?: string;
    Version?: string;
    OperatingSystem?: string;
    Id?: string;
};

export type SystemUpdateLevel = 'Release' | 'Beta' | 'Dev';

export type Updates_InstallationInfo = {
    Id?: string;
    Name?: string;
    AssemblyGuid?: string;
    Version?: string;
    UpdateClass?: 'Release' | 'Beta' | 'Dev';
    PercentComplete?: (number) | null;
};

export type UpdateClass = 'Release' | 'Beta' | 'Dev';

export type Net_EndPointInfo = {
    IsLocal?: boolean;
    IsInNetwork?: boolean;
};

export type AuthenticateUserByName = {
    Username?: string;
    Password?: string;
    Pw?: string;
};

export type Authentication_AuthenticationResult = {
    User?: UserDto;
    SessionInfo?: Session_SessionInfo;
    AccessToken?: string;
    ServerId?: string;
};

export type CreateUserByName = {
    Name?: string;
};

export type ForgotPassword = {
    EnteredUsername?: string;
};

export type Users_ForgotPasswordResult = {
    Action?: 'ContactAdmin' | 'PinCode' | 'InNetworkRequired';
    PinFile?: string;
    PinExpirationDate?: (string) | null;
};

export type Action = 'ContactAdmin' | 'PinCode' | 'InNetworkRequired';

export type playback_reporting_Api_CustomQuery = {
    CustomQueryString?: string;
    ReplaceUserId?: boolean;
};

export type WebDashboard_Api_ConfigurationPageInfo = {
    Name?: string;
    EnableInMainMenu?: boolean;
    MenuSection?: string;
    MenuIcon?: string;
    DisplayName?: string;
    ConfigurationPageType?: 'PluginConfiguration' | 'None';
    PluginId?: string;
};

export type ConfigurationPageType = 'PluginConfiguration' | 'None';

export type MediaEncoding_Codecs_VideoCodecs_VideoCodecBase = {
    CodecKind?: 'Audio' | 'Video' | 'SubTitles';
    MediaTypeName?: string;
    VideoMediaType?: 'Unknown' | 'copy' | 'flv1' | 'h263' | 'h263p' | 'h264' | 'hevc' | 'mjpeg' | 'mpeg1video' | 'mpeg2video' | 'mpeg4' | 'msvideo1' | 'theora' | 'vc1image' | 'vc1' | 'vp8' | 'vp9' | 'wmv1' | 'wmv2' | 'wmv3' | '_012v' | '_4xm' | '_8bps' | 'a64_multi' | 'a64_multi5' | 'aasc' | 'aic' | 'alias_pix' | 'amv' | 'anm' | 'ansi' | 'apng' | 'asv1' | 'asv2' | 'aura' | 'aura2' | 'av1' | 'avrn' | 'avrp' | 'avs' | 'avui' | 'ayuv' | 'bethsoftvid' | 'bfi' | 'binkvideo' | 'bintext' | 'bitpacked' | 'bmp' | 'bmv_video' | 'brender_pix' | 'c93' | 'cavs' | 'cdgraphics' | 'cdxl' | 'cfhd' | 'cinepak' | 'clearvideo' | 'cljr' | 'cllc' | 'cmv' | 'cpia' | 'cscd' | 'cyuv' | 'daala' | 'dds' | 'dfa' | 'dirac' | 'dnxhd' | 'dpx' | 'dsicinvideo' | 'dvvideo' | 'dxa' | 'dxtory' | 'dxv' | 'escape124' | 'escape130' | 'exr' | 'ffv1' | 'ffvhuff' | 'fic' | 'fits' | 'flashsv' | 'flashsv2' | 'flic' | 'fmvc' | 'fraps' | 'frwu' | 'g2m' | 'gdv' | 'gif' | 'h261' | 'h263i' | 'hap' | 'hnm4video' | 'hq_hqa' | 'hqx' | 'huffyuv' | 'idcin' | 'idf' | 'iff_ilbm' | 'indeo2' | 'indeo3' | 'indeo4' | 'indeo5' | 'interplayvideo' | 'jpeg2000' | 'jpegls' | 'jv' | 'kgv1' | 'kmvc' | 'lagarith' | 'ljpeg' | 'loco' | 'm101' | 'mad' | 'magicyuv' | 'mdec' | 'mimic' | 'mjpegb' | 'mmvideo' | 'motionpixels' | 'msa1' | 'mscc' | 'msmpeg4v1' | 'msmpeg4v2' | 'msmpeg4v3' | 'msrle' | 'mss1' | 'mss2' | 'mszh' | 'mts2' | 'mvc1' | 'mvc2' | 'mxpeg' | 'nuv' | 'paf_video' | 'pam' | 'pbm' | 'pcx' | 'pgm' | 'pgmyuv' | 'pictor' | 'pixlet' | 'png' | 'ppm' | 'prores' | 'psd' | 'ptx' | 'qdraw' | 'qpeg' | 'qtrle' | 'r10k' | 'r210' | 'rawvideo' | 'rl2' | 'roq' | 'rpza' | 'rscc' | 'rv10' | 'rv20' | 'rv30' | 'rv40' | 'sanm' | 'scpr' | 'screenpresso' | 'sgi' | 'sgirle' | 'sheervideo' | 'smackvideo' | 'smc' | 'smvjpeg' | 'snow' | 'sp5x' | 'speedhq' | 'srgc' | 'sunrast' | 'svg' | 'svq1' | 'svq3' | 'targa' | 'targa_y216' | 'tdsc' | 'tgq' | 'tgv' | 'thp' | 'tiertexseqvideo' | 'tiff' | 'tmv' | 'tqi' | 'truemotion1' | 'truemotion2' | 'truemotion2rt' | 'tscc' | 'tscc2' | 'txd' | 'ulti' | 'utvideo' | 'v210' | 'v210x' | 'v308' | 'v408' | 'v410' | 'vb' | 'vble' | 'vcr1' | 'vixl' | 'vmdvideo' | 'vmnc' | 'vp3' | 'vp5' | 'vp6' | 'vp6a' | 'vp6f' | 'vp7' | 'webp' | 'wmv3image' | 'wnv1' | 'wrapped_avframe' | 'ws_vqa' | 'xan_wc3' | 'xan_wc4' | 'xbin' | 'xbm' | 'xface' | 'xpm' | 'xwd' | 'y41p' | 'ylc' | 'yop' | 'yuv4' | 'zerocodec' | 'zlib' | 'zmbv';
    MinWidth?: (number) | null;
    MaxWidth?: (number) | null;
    MinHeight?: (number) | null;
    MaxHeight?: (number) | null;
    WidthAlignment?: (number) | null;
    HeightAlignment?: (number) | null;
    MinFrameRate?: (number) | null;
    MaxFrameRate?: (number) | null;
    SupportedColorFormats?: Array<('Unknown' | 'yuv420p' | 'yuyv422' | 'rgb24' | 'bgr24' | 'yuv422p' | 'yuv444p' | 'yuv410p' | 'yuv411p' | 'gray' | 'monow' | 'monob' | 'pal8' | 'yuvj420p' | 'yuvj422p' | 'yuvj444p' | 'uyvy422' | 'uyyvyy411' | 'bgr8' | 'bgr4' | 'bgr4_byte' | 'rgb8' | 'rgb4' | 'rgb4_byte' | 'nv12' | 'nv21' | 'argb' | 'rgba' | 'abgr' | 'bgra' | 'gray16' | 'yuv440p' | 'yuvj440p' | 'yuva420p' | 'rgb48' | 'rgb565' | 'rgb555' | 'bgr565' | 'bgr555' | 'vaapi_moco' | 'vaapi_idct' | 'vaapi_vld' | 'yuv420p16' | 'yuv422p16' | 'yuv444p16' | 'dxva2_vld' | 'rgb444' | 'bgr444' | 'ya8' | 'bgr48' | 'yuv420p9' | 'yuv420p10' | 'yuv422p10' | 'yuv444p9' | 'yuv444p10' | 'yuv422p9' | 'gbrp' | 'gbrp9' | 'gbrp10' | 'gbrp16' | 'yuva422p' | 'yuva444p' | 'yuva420p9' | 'yuva422p9' | 'yuva444p9' | 'yuva420p10' | 'yuva422p10' | 'yuva444p10' | 'yuva420p16' | 'yuva422p16' | 'yuva444p16' | 'vdpau' | 'xyz12' | 'nv16' | 'nv20' | 'rgba64' | 'bgra64' | 'yvyu422' | 'ya16' | 'gbrap' | 'gbrap16' | 'qsv' | 'mmal' | 'd3d11va_vld' | 'cuda' | '_0rgb' | 'rgb0' | '_0bgr' | 'bgr0' | 'yuv420p12' | 'yuv420p14' | 'yuv422p12' | 'yuv422p14' | 'yuv444p12' | 'yuv444p14' | 'gbrp12' | 'gbrp14' | 'yuvj411p' | 'bayer_bggr8' | 'bayer_rggb8' | 'bayer_gbrg8' | 'bayer_grbg8' | 'bayer_bggr16' | 'bayer_rggb16' | 'bayer_gbrg16' | 'bayer_grbg16' | 'xvmc' | 'yuv440p10' | 'yuv440p12' | 'ayuv64' | 'videotoolbox_vld' | 'p010' | 'gbrap12' | 'gbrap10' | 'mediacodec' | 'gray12' | 'gray10' | 'p016' | 'd3d11' | 'gray9' | 'gbrpf32' | 'gbrapf32' | 'drm_prime' | 'opencl')>;
    SupportedColorFormatStrings?: Array<(string)>;
    ProfileAndLevelInformation?: Array<MediaEncoding_Codecs_Common_Types_ProfileLevelInformation>;
    Id?: string;
    Direction?: 'Encoder' | 'Decoder';
    Name?: string;
    Description?: string;
    FrameworkCodec?: string;
    IsHardwareCodec?: boolean;
    SecondaryFramework?: 'Unknown' | 'None' | 'AmdAmf' | 'MediaCodec' | 'NvEncDec' | 'OpenMax' | 'QuickSync' | 'VaApi' | 'V4L2' | 'DxVa' | 'D3d11va' | 'VideoToolbox';
    SecondaryFrameworkCodec?: string;
    MaxInstanceCount?: (number) | null;
    MinBitRate?: MediaEncoding_Codecs_Common_Types_BitRate;
    MaxBitRate?: MediaEncoding_Codecs_Common_Types_BitRate;
    IsEnabledByDefault?: boolean;
    DefaultPriority?: number;
};

export type CodecKind = 'Audio' | 'Video' | 'SubTitles';

export type VideoMediaType = 'Unknown' | 'copy' | 'flv1' | 'h263' | 'h263p' | 'h264' | 'hevc' | 'mjpeg' | 'mpeg1video' | 'mpeg2video' | 'mpeg4' | 'msvideo1' | 'theora' | 'vc1image' | 'vc1' | 'vp8' | 'vp9' | 'wmv1' | 'wmv2' | 'wmv3' | '_012v' | '_4xm' | '_8bps' | 'a64_multi' | 'a64_multi5' | 'aasc' | 'aic' | 'alias_pix' | 'amv' | 'anm' | 'ansi' | 'apng' | 'asv1' | 'asv2' | 'aura' | 'aura2' | 'av1' | 'avrn' | 'avrp' | 'avs' | 'avui' | 'ayuv' | 'bethsoftvid' | 'bfi' | 'binkvideo' | 'bintext' | 'bitpacked' | 'bmp' | 'bmv_video' | 'brender_pix' | 'c93' | 'cavs' | 'cdgraphics' | 'cdxl' | 'cfhd' | 'cinepak' | 'clearvideo' | 'cljr' | 'cllc' | 'cmv' | 'cpia' | 'cscd' | 'cyuv' | 'daala' | 'dds' | 'dfa' | 'dirac' | 'dnxhd' | 'dpx' | 'dsicinvideo' | 'dvvideo' | 'dxa' | 'dxtory' | 'dxv' | 'escape124' | 'escape130' | 'exr' | 'ffv1' | 'ffvhuff' | 'fic' | 'fits' | 'flashsv' | 'flashsv2' | 'flic' | 'fmvc' | 'fraps' | 'frwu' | 'g2m' | 'gdv' | 'gif' | 'h261' | 'h263i' | 'hap' | 'hnm4video' | 'hq_hqa' | 'hqx' | 'huffyuv' | 'idcin' | 'idf' | 'iff_ilbm' | 'indeo2' | 'indeo3' | 'indeo4' | 'indeo5' | 'interplayvideo' | 'jpeg2000' | 'jpegls' | 'jv' | 'kgv1' | 'kmvc' | 'lagarith' | 'ljpeg' | 'loco' | 'm101' | 'mad' | 'magicyuv' | 'mdec' | 'mimic' | 'mjpegb' | 'mmvideo' | 'motionpixels' | 'msa1' | 'mscc' | 'msmpeg4v1' | 'msmpeg4v2' | 'msmpeg4v3' | 'msrle' | 'mss1' | 'mss2' | 'mszh' | 'mts2' | 'mvc1' | 'mvc2' | 'mxpeg' | 'nuv' | 'paf_video' | 'pam' | 'pbm' | 'pcx' | 'pgm' | 'pgmyuv' | 'pictor' | 'pixlet' | 'png' | 'ppm' | 'prores' | 'psd' | 'ptx' | 'qdraw' | 'qpeg' | 'qtrle' | 'r10k' | 'r210' | 'rawvideo' | 'rl2' | 'roq' | 'rpza' | 'rscc' | 'rv10' | 'rv20' | 'rv30' | 'rv40' | 'sanm' | 'scpr' | 'screenpresso' | 'sgi' | 'sgirle' | 'sheervideo' | 'smackvideo' | 'smc' | 'smvjpeg' | 'snow' | 'sp5x' | 'speedhq' | 'srgc' | 'sunrast' | 'svg' | 'svq1' | 'svq3' | 'targa' | 'targa_y216' | 'tdsc' | 'tgq' | 'tgv' | 'thp' | 'tiertexseqvideo' | 'tiff' | 'tmv' | 'tqi' | 'truemotion1' | 'truemotion2' | 'truemotion2rt' | 'tscc' | 'tscc2' | 'txd' | 'ulti' | 'utvideo' | 'v210' | 'v210x' | 'v308' | 'v408' | 'v410' | 'vb' | 'vble' | 'vcr1' | 'vixl' | 'vmdvideo' | 'vmnc' | 'vp3' | 'vp5' | 'vp6' | 'vp6a' | 'vp6f' | 'vp7' | 'webp' | 'wmv3image' | 'wnv1' | 'wrapped_avframe' | 'ws_vqa' | 'xan_wc3' | 'xan_wc4' | 'xbin' | 'xbm' | 'xface' | 'xpm' | 'xwd' | 'y41p' | 'ylc' | 'yop' | 'yuv4' | 'zerocodec' | 'zlib' | 'zmbv';

export type Direction = 'Encoder' | 'Decoder';

export type SecondaryFramework = 'Unknown' | 'None' | 'AmdAmf' | 'MediaCodec' | 'NvEncDec' | 'OpenMax' | 'QuickSync' | 'VaApi' | 'V4L2' | 'DxVa' | 'D3d11va' | 'VideoToolbox';

export type MediaEncoding_Codecs_Common_Types_ProfileLevelInformation = {
    Profile?: MediaEncoding_Codecs_Common_Types_ProfileInformation;
    Level?: MediaEncoding_Codecs_Common_Types_LevelInformation;
};

export type MediaEncoding_Codecs_Common_Types_ProfileInformation = {
    ShortName?: string;
    Description?: string;
    Details?: string;
    Id?: string;
};

export type MediaEncoding_Codecs_Common_Types_LevelInformation = {
    ShortName?: string;
    Description?: string;
    Ordinal?: (number) | null;
    MaxBitRate?: MediaEncoding_Codecs_Common_Types_BitRate;
    MaxBitRateDisplay?: string;
    Id?: string;
    ResolutionRates?: Array<MediaEncoding_Codecs_Common_Types_ResolutionWithRate>;
    ResolutionRateStrings?: Array<(string)>;
    ResolutionRatesDisplay?: string;
};

export type MediaEncoding_Codecs_Common_Types_BitRate = {
    bps?: number;
    kbps?: number;
    Mbps?: number;
};

export type MediaEncoding_Codecs_Common_Types_ResolutionWithRate = {
    Width?: number;
    Height?: number;
    FrameRate?: number;
    Resolution?: MediaEncoding_Codecs_Common_Types_Resolution;
};

export type MediaEncoding_Codecs_Common_Types_Resolution = {
    Width?: number;
    Height?: number;
};

export type Configuration_CodecConfiguration = {
    IsEnabled?: boolean;
    Priority?: number;
    CodecId?: string;
};

export type ExternalIdInfo = {
    Name?: string;
    Key?: string;
    UrlFormatString?: string;
};

export type Providers_RemoteSearchQuery_Providers_TrailerInfo = {
    SearchInfo?: Providers_TrailerInfo;
    ItemId?: number;
    SearchProviderName?: string;
    IncludeDisabledProviders?: boolean;
};

export type Providers_TrailerInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type RemoteSearchResult = {
    Name?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    ProductionYear?: (number) | null;
    IndexNumber?: (number) | null;
    IndexNumberEnd?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    ImageUrl?: string;
    SearchProviderName?: string;
    GameSystem?: string;
    Overview?: string;
    AlbumArtist?: RemoteSearchResult;
    Artists?: Array<RemoteSearchResult>;
};

export type Providers_RemoteSearchQuery_Providers_BookInfo = {
    SearchInfo?: Providers_BookInfo;
    ItemId?: number;
    SearchProviderName?: string;
    IncludeDisabledProviders?: boolean;
};

export type Providers_BookInfo = {
    SeriesName?: string;
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type Providers_RemoteSearchQuery_Providers_MovieInfo = {
    SearchInfo?: Providers_MovieInfo;
    ItemId?: number;
    SearchProviderName?: string;
    IncludeDisabledProviders?: boolean;
};

export type Providers_MovieInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type Providers_RemoteSearchQuery_Providers_SeriesInfo = {
    SearchInfo?: Providers_SeriesInfo;
    ItemId?: number;
    SearchProviderName?: string;
    IncludeDisabledProviders?: boolean;
};

export type Providers_SeriesInfo = {
    EpisodeAirDate?: (string) | null;
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type Providers_RemoteSearchQuery_Providers_GameInfo = {
    SearchInfo?: Providers_GameInfo;
    ItemId?: number;
    SearchProviderName?: string;
    IncludeDisabledProviders?: boolean;
};

export type Providers_GameInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type Providers_RemoteSearchQuery_Providers_BoxSetInfo = {
    SearchInfo?: Providers_BoxSetInfo;
    ItemId?: number;
    SearchProviderName?: string;
    IncludeDisabledProviders?: boolean;
};

export type Providers_BoxSetInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type Providers_RemoteSearchQuery_Providers_MusicVideoInfo = {
    SearchInfo?: Providers_MusicVideoInfo;
    ItemId?: number;
    SearchProviderName?: string;
    IncludeDisabledProviders?: boolean;
};

export type Providers_MusicVideoInfo = {
    Artists?: Array<(string)>;
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type Providers_RemoteSearchQuery_Providers_PersonLookupInfo = {
    SearchInfo?: Providers_PersonLookupInfo;
    ItemId?: number;
    SearchProviderName?: string;
    IncludeDisabledProviders?: boolean;
};

export type Providers_PersonLookupInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type Providers_RemoteSearchQuery_Providers_AlbumInfo = {
    SearchInfo?: Providers_AlbumInfo;
    ItemId?: number;
    SearchProviderName?: string;
    IncludeDisabledProviders?: boolean;
};

export type Providers_AlbumInfo = {
    AlbumArtists?: Array<(string)>;
    SongInfos?: Array<Providers_SongInfo>;
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type Providers_SongInfo = {
    AlbumArtists?: Array<(string)>;
    Album?: string;
    Artists?: Array<(string)>;
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type Providers_RemoteSearchQuery_Providers_ArtistInfo = {
    SearchInfo?: Providers_ArtistInfo;
    ItemId?: number;
    SearchProviderName?: string;
    IncludeDisabledProviders?: boolean;
};

export type Providers_ArtistInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    ProviderIds?: {
        [key: string]: (string);
    };
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
};

export type MetadataEditorInfo = {
    ParentalRatingOptions?: Array<ParentalRating>;
    Countries?: Array<Globalization_CountryInfo>;
    Cultures?: Array<Globalization_CultureDto>;
    ExternalIdInfos?: Array<ExternalIdInfo>;
};

export type Library_DeleteInfo = {
    Paths?: Array<(string)>;
};

export type AllThemeMediaResult = {
    ThemeVideosResult?: ThemeMediaResult;
    ThemeSongsResult?: ThemeMediaResult;
    SoundtrackSongsResult?: ThemeMediaResult;
};

export type ThemeMediaResult = {
    OwnerId?: number;
    Items?: Array<BaseItemDto>;
    TotalRecordCount?: number;
};

export type ImageInfo = {
    ImageType?: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    ImageIndex?: (number) | null;
    Path?: string;
    Height?: (number) | null;
    Width?: (number) | null;
    Size?: number;
};

export type RemoteImageResult = {
    Images?: Array<RemoteImageInfo>;
    TotalRecordCount?: number;
    Providers?: Array<(string)>;
};

export type RemoteImageInfo = {
    ProviderName?: string;
    Url?: string;
    ThumbnailUrl?: string;
    Height?: (number) | null;
    Width?: (number) | null;
    CommunityRating?: (number) | null;
    VoteCount?: (number) | null;
    Language?: string;
    Type?: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    RatingType?: 'Score' | 'Likes';
};

export type RatingType = 'Score' | 'Likes';

export type RokuMetadata_Api_ThumbnailSetInfo = {
    AspectRatio?: (number) | null;
    Thumbnails?: Array<RokuMetadata_Api_ThumbnailInfo>;
};

export type RokuMetadata_Api_ThumbnailInfo = {
    PositionTicks?: number;
    ImageTag?: string;
};

export type MediaInfo_PlaybackInfoResponse = {
    MediaSources?: Array<MediaSourceInfo>;
    PlaySessionId?: string;
    ErrorCode?: 'NotAllowed' | 'NoCompatibleStream' | 'RateLimitExceeded';
};

export type ErrorCode = 'NotAllowed' | 'NoCompatibleStream' | 'RateLimitExceeded';

export type MediaInfo_PlaybackInfoRequest = {
    Id?: string;
    UserId?: string;
    MaxStreamingBitrate?: (number) | null;
    StartTimeTicks?: (number) | null;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    MaxAudioChannels?: (number) | null;
    MediaSourceId?: string;
    LiveStreamId?: string;
    DeviceProfile?: Dlna_DeviceProfile;
    EnableDirectPlay?: boolean;
    EnableDirectStream?: boolean;
    EnableTranscoding?: boolean;
    AllowVideoStreamCopy?: boolean;
    AllowAudioStreamCopy?: boolean;
    IsPlayback?: boolean;
    AutoOpenLiveStream?: boolean;
    DirectPlayProtocols?: Array<('File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp' | 'Mms')>;
};

export type Library_PostUpdatedMedia = {
    Updates?: Array<Library_MediaUpdateInfo>;
};

export type Library_MediaUpdateInfo = {
    Path?: string;
    UpdateType?: string;
};

export type Library_UpdateLibraryOptions = {
    Id?: string;
    LibraryOptions?: Configuration_LibraryOptions;
};

export type Library_RenameVirtualFolder = {
    Name?: string;
    NewName?: string;
    RefreshLibrary?: boolean;
};

export type Library_AddMediaPath = {
    Name?: string;
    Path?: string;
    PathInfo?: Configuration_MediaPathInfo;
    RefreshLibrary?: boolean;
};

export type LiveTv_ListingProviderTypeInfo = {
    Name?: string;
    Id?: string;
    SetupUrl?: string;
};

export type Emby_Notifications_Api_NotificationsSummary = {
    UnreadCount?: number;
    MaxUnreadNotificationLevel?: 'Normal' | 'Warning' | 'Error';
};

export type MaxUnreadNotificationLevel = 'Normal' | 'Warning' | 'Error';

export type PlayRequest = {
    ControllingUserId?: string;
    SubtitleStreamIndex?: (number) | null;
    AudioStreamIndex?: (number) | null;
    MediaSourceId?: string;
    StartIndex?: (number) | null;
};

export type GeneralCommand = {
    Name?: string;
    ControllingUserId?: string;
    Arguments?: {
        [key: string]: (string);
    };
};

export type PlaybackProgressInfo = {
    CanSeek?: boolean;
    Item?: BaseItemDto;
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    ItemId?: string;
    SessionId?: string;
    MediaSourceId?: string;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    IsPaused?: boolean;
    IsMuted?: boolean;
    PositionTicks?: (number) | null;
    RunTimeTicks?: (number) | null;
    PlaybackStartTimeTicks?: (number) | null;
    VolumeLevel?: (number) | null;
    Brightness?: (number) | null;
    AspectRatio?: string;
    PlayMethod?: 'Transcode' | 'DirectStream' | 'DirectPlay';
    LiveStreamId?: string;
    PlaySessionId?: string;
    RepeatMode?: 'RepeatNone' | 'RepeatAll' | 'RepeatOne';
};

export type PlaybackStopInfo = {
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    Item?: BaseItemDto;
    ItemId?: string;
    SessionId?: string;
    MediaSourceId?: string;
    PositionTicks?: (number) | null;
    LiveStreamId?: string;
    PlaySessionId?: string;
    Failed?: boolean;
    NextMediaType?: string;
};

export type Sync_Model_SyncedItemProgress = {
    Progress?: (number) | null;
    Status?: 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Synced' | 'Failed';
};

export type Sync_Model_SyncedItem = {
    ServerId?: string;
    SyncJobId?: number;
    SyncJobName?: string;
    SyncJobDateCreated?: string;
    SyncJobItemId?: number;
    OriginalFileName?: string;
    Item?: BaseItemDto;
    UserId?: string;
    AdditionalFiles?: Array<Sync_Model_ItemFileInfo>;
};

export type QueryResult_ActivityLogEntry = {
    Items?: Array<ActivityLogEntry>;
    TotalRecordCount?: number;
};

export type ActivityLogEntry = {
    Id?: number;
    Name?: string;
    Overview?: string;
    ShortOverview?: string;
    Type?: string;
    ItemId?: string;
    Date?: string;
    UserId?: string;
    UserPrimaryImageTag?: string;
    Severity?: 'Info' | 'Debug' | 'Warn' | 'Error' | 'Fatal';
};

export type Severity = 'Info' | 'Debug' | 'Warn' | 'Error' | 'Fatal';

export type PublicSystemInfo = {
    LocalAddress?: string;
    WanAddress?: string;
    ServerName?: string;
    Version?: string;
    OperatingSystem?: string;
    Id?: string;
};

export type AuthenticateUser = {
    Pw?: string;
    Password?: string;
};

export type UpdateUserPassword = {
    Id?: string;
    CurrentPw?: string;
    NewPw?: string;
    ResetPassword?: boolean;
};

export type UpdateUserEasyPassword = {
    Id?: string;
    NewPw?: string;
    ResetPassword?: boolean;
};

export type ForgotPasswordPin = {
    Pin?: string;
};

export type Users_PinRedeemResult = {
    Success?: boolean;
    UsersReset?: Array<(string)>;
};

export type ImageProviderInfo = {
    Name?: string;
    SupportedImages?: Array<('Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail')>;
};

export type Library_UpdateMediaPath = {
    Name?: string;
    PathInfo?: Configuration_MediaPathInfo;
};

export type PlaystateRequest = {
    Command?: 'Stop' | 'Pause' | 'Unpause' | 'NextTrack' | 'PreviousTrack' | 'Seek' | 'Rewind' | 'FastForward' | 'PlayPause';
    SeekPositionTicks?: (number) | null;
    ControllingUserId?: string;
};

export type Command = 'Stop' | 'Pause' | 'Unpause' | 'NextTrack' | 'PreviousTrack' | 'Seek' | 'Rewind' | 'FastForward' | 'PlayPause';

export type Connect_UserLinkResult = {
    IsPending?: boolean;
    IsNewUserInvitation?: boolean;
    GuestDisplayName?: string;
};

export type RemoteSubtitleInfo = {
    ThreeLetterISOLanguageName?: string;
    Id?: string;
    ProviderName?: string;
    Name?: string;
    Format?: string;
    Author?: string;
    Comment?: string;
    DateCreated?: (string) | null;
    CommunityRating?: (number) | null;
    DownloadCount?: (number) | null;
    IsHashMatch?: (boolean) | null;
    IsForced?: (boolean) | null;
};

export type GetArtistsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsResponse = (QueryResult_BaseItemDto);

export type GetArtistsByNameData = {
    /**
     * The artist name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetArtistsByNameResponse = (BaseItemDto);

export type GetArtistsAlbumartistsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsAlbumartistsResponse = (QueryResult_BaseItemDto);

export type GetAudiocodecsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetAudiocodecsResponse = (QueryResult_UserLibrary_TagItem);

export type GetContainersData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetContainersResponse = (QueryResult_UserLibrary_TagItem);

export type GetSubtitlecodecsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetSubtitlecodecsResponse = (QueryResult_UserLibrary_TagItem);

export type GetTagsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetTagsResponse = (QueryResult_UserLibrary_TagItem);

export type GetVideocodecsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetVideocodecsResponse = (QueryResult_UserLibrary_TagItem);

export type GetYearsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetYearsResponse = (QueryResult_UserLibrary_TagItem);

export type GetArtistsPrefixesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsPrefixesResponse = (Array<NameValuePair>);

export type GetItemsPrefixesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsPrefixesResponse = (Array<NameValuePair>);

export type GetChannelsData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId?: string;
};

export type GetChannelsResponse = (QueryResult_BaseItemDto);

export type GetChannelsByIdItemsResponse = (unknown);

export type GetChannelsItemsLatestResponse = (unknown);

export type PostCollectionsData = {
    /**
     * Item Ids to add to the collection
     */
    ids?: string;
    /**
     * Whether or not to lock the new collection.
     */
    isLocked?: boolean;
    /**
     * The name of the new collection.
     */
    name?: string;
    /**
     * Optional - create the collection within a specific folder
     */
    parentId?: string;
};

export type PostCollectionsResponse = (Collections_CollectionCreationResult);

export type PostCollectionsByIdItemsData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
};

export type PostCollectionsByIdItemsResponse = (unknown);

export type DeleteCollectionsByIdItemsData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
};

export type DeleteCollectionsByIdItemsResponse = (unknown);

export type GetDevicesResponse = (QueryResult_Devices_DeviceInfo);

export type DeleteDevicesData = {
    /**
     * Device Id
     */
    id: string;
};

export type DeleteDevicesResponse = (unknown);

export type PostDevicesOptionsData = {
    /**
     * DeviceOptions:
     */
    requestBody: Devices_DeviceOptions;
};

export type PostDevicesOptionsResponse = (unknown);

export type GetDevicesOptionsData = {
    /**
     * Device Id
     */
    id: string;
};

export type GetDevicesOptionsResponse = (Devices_DeviceOptions);

export type GetDevicesInfoData = {
    /**
     * Device Id
     */
    id: string;
};

export type GetDevicesInfoResponse = (Devices_DeviceInfo);

export type GetDevicesCamerauploadsData = {
    /**
     * Device Id
     */
    deviceId: string;
};

export type GetDevicesCamerauploadsResponse = (Devices_ContentUploadHistory);

export type PostDevicesCamerauploadsData = {
    /**
     * Album
     */
    album: string;
    /**
     * Device Id
     */
    deviceId: string;
    /**
     * Id
     */
    id: string;
    /**
     * Name
     */
    name: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostDevicesCamerauploadsResponse = (unknown);

export type GetGamegenresData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetGamegenresResponse = (QueryResult_BaseItemDto);

export type GetGamegenresByNameData = {
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetGamegenresByNameResponse = (BaseItemDto);

export type GetGenresData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetGenresResponse = (QueryResult_BaseItemDto);

export type GetGenresByNameData = {
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetGenresByNameResponse = (BaseItemDto);

export type GetItemsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridItemsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetUsersByUseridItemsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridItemsResumeData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetUsersByUseridItemsResumeResponse = (QueryResult_BaseItemDto);

export type DeleteItemsData = {
    /**
     * Ids
     */
    ids: string;
};

export type DeleteItemsResponse = (unknown);

export type GetItemsCountsData = {
    /**
     * Optional. Get counts of favorite items
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional. Get counts from a specific user's library.
     */
    userId?: string;
};

export type GetItemsCountsResponse = (ItemCounts);

export type DeleteItemsByIdData = {
    /**
     * Item Id
     */
    id: string;
};

export type DeleteItemsByIdResponse = (unknown);

export type GetLibrariesAvailableoptionsResponse = (Library_LibraryOptionsResult);

export type GetLibrarySelectablemediafoldersResponse = (Array<Library_MediaFolder>);

export type GetLibraryMediafoldersData = {
    /**
     * Optional. Filter by folders that are marked hidden, or not.
     */
    isHidden?: (boolean) | null;
};

export type GetLibraryMediafoldersResponse = (QueryResult_BaseItemDto);

export type GetLibraryPhysicalpathsResponse = (Array<(string)>);

export type PostLibraryRefreshResponse = (unknown);

export type GetAlbumsByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetAlbumsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetArtistsByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetArtistsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetGamesByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetGamesByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdDeleteinfoData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdDeleteinfoResponse = (Library_DeleteInfo);

export type GetItemsByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdDownloadData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdDownloadResponse = (unknown);

export type GetItemsByIdFileData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdFileResponse = (unknown);

export type GetItemsByIdAncestorsData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdAncestorsResponse = (Array<BaseItemDto>);

export type GetItemsByIdCriticreviewsData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
};

export type GetItemsByIdCriticreviewsResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdThememediaData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Determines whether or not parent items should be searched for theme media.
     */
    inheritFromParent?: boolean;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdThememediaResponse = (AllThemeMediaResult);

export type GetItemsByIdThemesongsData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Determines whether or not parent items should be searched for theme media.
     */
    inheritFromParent?: boolean;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdThemesongsResponse = (ThemeMediaResult);

export type GetItemsByIdThemevideosData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Determines whether or not parent items should be searched for theme media.
     */
    inheritFromParent?: boolean;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdThemevideosResponse = (ThemeMediaResult);

export type PostLibrarySeriesAddedResponse = (unknown);

export type PostLibrarySeriesUpdatedResponse = (unknown);

export type PostLibraryMediaUpdatedData = {
    /**
     * PostUpdatedMedia
     */
    requestBody: Library_PostUpdatedMedia;
};

export type PostLibraryMediaUpdatedResponse = (unknown);

export type PostLibraryMoviesAddedResponse = (unknown);

export type PostLibraryMoviesUpdatedResponse = (unknown);

export type GetMoviesByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMoviesByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetShowsByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetShowsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetTrailersByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetTrailersByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetMusicgenresResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresByNameData = {
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMusicgenresByNameResponse = (BaseItemDto);

export type GetOfficialratingsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetOfficialratingsResponse = (QueryResult_UserLibrary_OfficialRatingItem);

export type GetOpenapiResponse = (string);

export type GetOpenapiJsonResponse = (string);

export type GetSwaggerResponse = (string);

export type GetSwaggerJsonResponse = (string);

export type GetPackagesData = {
    /**
     * Optional. Filter by package that contain adult content.
     */
    isAdult?: (boolean) | null;
    /**
     * Optional. Filter by premium status
     */
    isPremium?: (boolean) | null;
    /**
     * Optional package type filter (System/UserInstalled)
     */
    packageType?: string;
    /**
     * Optional. Filter by target system type. Allows multiple, comma delimited.
     */
    targetSystems?: string;
};

export type GetPackagesResponse = (Array<Updates_PackageInfo>);

export type GetPackagesUpdatesData = {
    /**
     * Package type filter (System/UserInstalled)
     */
    packageType: string;
};

export type GetPackagesUpdatesResponse = (Array<Updates_PackageVersionInfo>);

export type GetPackagesByNameData = {
    /**
     * The guid of the associated assembly
     */
    assemblyGuid?: string;
    /**
     * The name of the package
     */
    name: string;
};

export type GetPackagesByNameResponse = (Updates_PackageInfo);

export type PostPackagesInstalledByNameData = {
    /**
     * Guid of the associated assembly
     */
    assemblyGuid?: string;
    /**
     * Package name
     */
    name: string;
    /**
     * Optional update class (Dev, Beta, Release). Defaults to Release.
     */
    updateClass?: 'Release' | 'Beta' | 'Dev';
    /**
     * Optional version. Defaults to latest version.
     */
    version?: string;
};

export type PostPackagesInstalledByNameResponse = (unknown);

export type DeletePackagesInstallingByIdData = {
    /**
     * Installation Id
     */
    id: string;
};

export type DeletePackagesInstallingByIdResponse = (unknown);

export type GetPersonsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetPersonsResponse = (QueryResult_BaseItemDto);

export type GetPersonsByNameData = {
    /**
     * The person name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetPersonsByNameResponse = (BaseItemDto);

export type PostPlaylistsData = {
    /**
     * Item Ids to add to the playlist
     */
    ids?: string;
    /**
     * The playlist media type
     */
    mediaType?: string;
    /**
     * The name of the new playlist.
     */
    name?: string;
};

export type PostPlaylistsResponse = (Playlists_PlaylistCreationResult);

export type PostPlaylistsByIdItemsData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
    /**
     * User Id
     */
    userId?: string;
};

export type PostPlaylistsByIdItemsResponse = (unknown);

export type DeletePlaylistsByIdItemsData = {
    entryIds: string;
    id: string;
};

export type DeletePlaylistsByIdItemsResponse = (unknown);

export type GetPlaylistsByIdItemsData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId?: string;
};

export type GetPlaylistsByIdItemsResponse = (QueryResult_BaseItemDto);

export type PostPlaylistsByIdItemsByItemidMoveByNewindexData = {
    id: string;
    /**
     * ItemId
     */
    itemId: number;
    /**
     * NewIndex
     */
    newIndex: number;
};

export type PostPlaylistsByIdItemsByItemidMoveByNewindexResponse = (unknown);

export type GetPluginsResponse = (Array<Plugins_PluginInfo>);

export type DeletePluginsByIdData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type DeletePluginsByIdResponse = (unknown);

export type GetPluginsByIdThumbData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type GetPluginsByIdThumbResponse = (unknown);

export type GetPluginsByIdConfigurationData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type GetPluginsByIdConfigurationResponse = (unknown);

export type PostPluginsByIdConfigurationData = {
    /**
     * Plugin Id
     */
    id: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostPluginsByIdConfigurationResponse = (unknown);

export type GetScheduledtasksData = {
    /**
     * Optional filter tasks that are enabled, or not.
     */
    isEnabled?: (boolean) | null;
    /**
     * Optional filter tasks that are hidden, or not.
     */
    isHidden?: (boolean) | null;
};

export type GetScheduledtasksResponse = (Array<Tasks_TaskInfo>);

export type GetScheduledtasksByIdData = {
    id: string;
};

export type GetScheduledtasksByIdResponse = (Tasks_TaskInfo);

export type PostScheduledtasksRunningByIdData = {
    id: string;
};

export type PostScheduledtasksRunningByIdResponse = (unknown);

export type DeleteScheduledtasksRunningByIdData = {
    id: string;
};

export type DeleteScheduledtasksRunningByIdResponse = (unknown);

export type PostScheduledtasksByIdTriggersData = {
    id: string;
    /**
     * List`1:
     */
    requestBody: Array<Tasks_TaskTriggerInfo>;
};

export type PostScheduledtasksByIdTriggersResponse = (unknown);

export type GetSessionsData = {
    /**
     * Optional. Filter by sessions that a given user is allowed to remote control.
     */
    controllableByUserId?: string;
    /**
     * Optional. Filter by device id.
     */
    deviceId?: string;
};

export type GetSessionsResponse = (Array<Session_SessionInfo>);

export type GetAuthProvidersResponse = (Array<NameIdPair>);

export type PostAuthKeysData = {
    /**
     * App
     */
    app: string;
};

export type PostAuthKeysResponse = (unknown);

export type GetAuthKeysResponse = (unknown);

export type PostSessionsLogoutResponse = (unknown);

export type PostSessionsCapabilitiesData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
     */
    playableMediaTypes?: string;
    /**
     * A list of supported remote control commands, comma delimited
     */
    supportedCommands?: string;
    /**
     * Determines whether media can be played remotely.
     */
    supportsMediaControl?: boolean;
    /**
     * Determines whether the device supports a unique identifier.
     */
    supportsPersistentIdentifier?: boolean;
    /**
     * Determines whether sync is supported.
     */
    supportsSync?: boolean;
};

export type PostSessionsCapabilitiesResponse = (unknown);

export type DeleteAuthKeysByKeyData = {
    /**
     * Auth Key
     */
    key: string;
};

export type DeleteAuthKeysByKeyResponse = (unknown);

export type PostSessionsByIdViewingData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * The Id of the item.
     */
    itemId: string;
    /**
     * The name of the item.
     */
    itemName: string;
    /**
     * The type of item to browse to.
     */
    itemType: string;
};

export type PostSessionsByIdViewingResponse = (unknown);

export type PostSessionsByIdMessageData = {
    /**
     * The message header.
     */
    header: string;
    /**
     * Session Id
     */
    id: string;
    /**
     * The message text.
     */
    text: string;
    /**
     * The message timeout. If omitted the user will have to confirm viewing the message.
     */
    timeoutMs?: (number) | null;
};

export type PostSessionsByIdMessageResponse = (unknown);

export type PostSessionsByIdPlayingData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * The ids of the items to play, comma delimited
     */
    itemIds: Array<(number)>;
    /**
     * The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
     */
    playCommand: 'PlayNow' | 'PlayNext' | 'PlayLast' | 'PlayInstantMix' | 'PlayShuffle';
    /**
     * PlayRequest:
     */
    requestBody: PlayRequest;
    /**
     * The starting position of the first item.
     */
    startPositionTicks?: (number) | null;
};

export type PostSessionsByIdPlayingResponse = (unknown);

export type PostSessionsByIdCommandData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * GeneralCommand:
     */
    requestBody: GeneralCommand;
};

export type PostSessionsByIdCommandResponse = (unknown);

export type PostSessionsCapabilitiesFullData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * ClientCapabilities:
     */
    requestBody: ClientCapabilities;
};

export type PostSessionsCapabilitiesFullResponse = (unknown);

export type PostSessionsByIdPlayingByCommandData = {
    command: 'Stop' | 'Pause' | 'Unpause' | 'NextTrack' | 'PreviousTrack' | 'Seek' | 'Rewind' | 'FastForward' | 'PlayPause';
    /**
     * Session Id
     */
    id: string;
    /**
     * PlaystateRequest:
     */
    requestBody: PlaystateRequest;
};

export type PostSessionsByIdPlayingByCommandResponse = (unknown);

export type PostSessionsByIdSystemByCommandData = {
    /**
     * The command to send.
     */
    command: string;
    /**
     * Session Id
     */
    id: string;
};

export type PostSessionsByIdSystemByCommandResponse = (unknown);

export type PostSessionsByIdCommandByCommandData = {
    /**
     * The command to send.
     */
    command: string;
    /**
     * Session Id
     */
    id: string;
};

export type PostSessionsByIdCommandByCommandResponse = (unknown);

export type PostSessionsByIdUsersByUseridData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * UserId Id
     */
    userId: string;
};

export type PostSessionsByIdUsersByUseridResponse = (unknown);

export type DeleteSessionsByIdUsersByUseridData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * UserId Id
     */
    userId: string;
};

export type DeleteSessionsByIdUsersByUseridResponse = (unknown);

export type GetStudiosData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetStudiosResponse = (QueryResult_BaseItemDto);

export type GetStudiosByNameData = {
    /**
     * The studio name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetStudiosByNameResponse = (BaseItemDto);

export type GetTrailersData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetTrailersResponse = (QueryResult_BaseItemDto);

export type GetUsersData = {
    /**
     * Optional filter by IsDisabled=true or false
     */
    isDisabled?: (boolean) | null;
    /**
     * Optional filter by IsHidden=true or false
     */
    isHidden?: (boolean) | null;
};

export type GetUsersResponse = (Array<UserDto>);

export type GetUsersPublicResponse = (Array<UserDto>);

export type GetUsersByIdData = {
    id: string;
};

export type GetUsersByIdResponse = (UserDto);

export type DeleteUsersByIdData = {
    id: string;
};

export type DeleteUsersByIdResponse = (unknown);

export type PostUsersByIdData = {
    id: string;
    /**
     * UserDto:
     */
    requestBody: UserDto;
};

export type PostUsersByIdResponse = (unknown);

export type PostUsersAuthenticatebynameData = {
    /**
     * AuthenticateUserByName
     */
    requestBody: AuthenticateUserByName;
    /**
     * The authorization header can be either named 'Authorization' or 'X-Emby-Authorization'.
     * It must be of the following schema:
     * Emby UserId="(guid)", Client="(string)", Device="(string)", DeviceId="(string)", Version="string", Token="(string)"
     * Please consult the documentation for further details.
     */
    xEmbyAuthorization: string;
};

export type PostUsersAuthenticatebynameResponse = (Authentication_AuthenticationResult);

export type PostUsersNewData = {
    /**
     * CreateUserByName
     */
    requestBody: CreateUserByName;
};

export type PostUsersNewResponse = (UserDto);

export type PostUsersForgotpasswordData = {
    /**
     * ForgotPassword
     */
    requestBody: ForgotPassword;
};

export type PostUsersForgotpasswordResponse = (Users_ForgotPasswordResult);

export type PostUsersByIdAuthenticateData = {
    id: string;
    /**
     * AuthenticateUser
     */
    requestBody: AuthenticateUser;
};

export type PostUsersByIdAuthenticateResponse = (Authentication_AuthenticationResult);

export type PostUsersByIdPasswordData = {
    id: string;
    /**
     * UpdateUserPassword
     */
    requestBody: UpdateUserPassword;
};

export type PostUsersByIdPasswordResponse = (unknown);

export type PostUsersByIdEasypasswordData = {
    id: string;
    /**
     * UpdateUserEasyPassword
     */
    requestBody: UpdateUserEasyPassword;
};

export type PostUsersByIdEasypasswordResponse = (unknown);

export type PostUsersForgotpasswordPinData = {
    /**
     * ForgotPasswordPin
     */
    requestBody: ForgotPasswordPin;
};

export type PostUsersForgotpasswordPinResponse = (Users_PinRedeemResult);

export type PostUsersByIdConfigurationData = {
    id: string;
    /**
     * UserConfiguration:
     */
    requestBody: Configuration_UserConfiguration;
};

export type PostUsersByIdConfigurationResponse = (unknown);

export type PostUsersByIdPolicyData = {
    id: string;
    /**
     * UserPolicy:
     */
    requestBody: Users_UserPolicy;
};

export type PostUsersByIdPolicyResponse = (unknown);

export type GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth: (number) | null;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse = (unknown);

export type HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth: (number) | null;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse = (unknown);

export type GetItemsByIdImagesData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdImagesResponse = (Array<ImageInfo>);

export type GetArtistsByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetArtistsByNameImagesByTypeResponse = (unknown);

export type HeadArtistsByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadArtistsByNameImagesByTypeResponse = (unknown);

export type GetGamegenresByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetGamegenresByNameImagesByTypeResponse = (unknown);

export type HeadGamegenresByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadGamegenresByNameImagesByTypeResponse = (unknown);

export type GetGenresByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetGenresByNameImagesByTypeResponse = (unknown);

export type HeadGenresByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadGenresByNameImagesByTypeResponse = (unknown);

export type GetItemsByIdImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetItemsByIdImagesByTypeResponse = (unknown);

export type HeadItemsByIdImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadItemsByIdImagesByTypeResponse = (unknown);

export type PostItemsByIdImagesByTypeData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type PostItemsByIdImagesByTypeResponse = (unknown);

export type DeleteItemsByIdImagesByTypeData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type DeleteItemsByIdImagesByTypeResponse = (unknown);

export type GetMusicgenresByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetMusicgenresByNameImagesByTypeResponse = (unknown);

export type HeadMusicgenresByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadMusicgenresByNameImagesByTypeResponse = (unknown);

export type GetPersonsByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetPersonsByNameImagesByTypeResponse = (unknown);

export type HeadPersonsByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadPersonsByNameImagesByTypeResponse = (unknown);

export type GetStudiosByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetStudiosByNameImagesByTypeResponse = (unknown);

export type HeadStudiosByNameImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadStudiosByNameImagesByTypeResponse = (unknown);

export type GetUsersByIdImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetUsersByIdImagesByTypeResponse = (unknown);

export type HeadUsersByIdImagesByTypeData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadUsersByIdImagesByTypeResponse = (unknown);

export type PostUsersByIdImagesByTypeData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type PostUsersByIdImagesByTypeResponse = (unknown);

export type DeleteUsersByIdImagesByTypeData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type DeleteUsersByIdImagesByTypeResponse = (unknown);

export type GetArtistsByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetArtistsByNameImagesByTypeByIndexResponse = (unknown);

export type HeadArtistsByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadArtistsByNameImagesByTypeByIndexResponse = (unknown);

export type GetGamegenresByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetGamegenresByNameImagesByTypeByIndexResponse = (unknown);

export type HeadGamegenresByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadGamegenresByNameImagesByTypeByIndexResponse = (unknown);

export type GetGenresByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetGenresByNameImagesByTypeByIndexResponse = (unknown);

export type HeadGenresByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadGenresByNameImagesByTypeByIndexResponse = (unknown);

export type GetItemsByIdImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetItemsByIdImagesByTypeByIndexResponse = (unknown);

export type HeadItemsByIdImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadItemsByIdImagesByTypeByIndexResponse = (unknown);

export type PostItemsByIdImagesByTypeByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type PostItemsByIdImagesByTypeByIndexResponse = (unknown);

export type DeleteItemsByIdImagesByTypeByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type DeleteItemsByIdImagesByTypeByIndexResponse = (unknown);

export type GetMusicgenresByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetMusicgenresByNameImagesByTypeByIndexResponse = (unknown);

export type HeadMusicgenresByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadMusicgenresByNameImagesByTypeByIndexResponse = (unknown);

export type GetPersonsByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetPersonsByNameImagesByTypeByIndexResponse = (unknown);

export type HeadPersonsByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadPersonsByNameImagesByTypeByIndexResponse = (unknown);

export type GetStudiosByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetStudiosByNameImagesByTypeByIndexResponse = (unknown);

export type HeadStudiosByNameImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadStudiosByNameImagesByTypeByIndexResponse = (unknown);

export type GetUsersByIdImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type GetUsersByIdImagesByTypeByIndexResponse = (unknown);

export type HeadUsersByIdImagesByTypeByIndexData = {
    /**
     * Optional. Add a played indicator
     */
    addPlayedIndicator?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: (number) | null;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * The maximum image height to return.
     */
    maxHeight?: (number) | null;
    /**
     * The maximum image width to return.
     */
    maxWidth?: (number) | null;
    /**
     * Optional percent to render for the percent played overlay
     */
    percentPlayed?: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: (number) | null;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
    /**
     * Optional unplayed count overlay to render
     */
    unplayedCount?: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: (number) | null;
};

export type HeadUsersByIdImagesByTypeByIndexResponse = (unknown);

export type PostUsersByIdImagesByTypeByIndexData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type PostUsersByIdImagesByTypeByIndexResponse = (unknown);

export type DeleteUsersByIdImagesByTypeByIndexData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type DeleteUsersByIdImagesByTypeByIndexResponse = (unknown);

export type PostItemsByIdImagesByTypeByIndexIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * The new image index
     */
    newIndex: number;
    /**
     * Image Type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type PostItemsByIdImagesByTypeByIndexIndexResponse = (unknown);

export type GetArtistsInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * The artist Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetArtistsInstantmixResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * The genre Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMusicgenresInstantmixResponse = (QueryResult_BaseItemDto);

export type GetAlbumsByIdInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetAlbumsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresByNameInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMusicgenresByNameInstantmixResponse = (QueryResult_BaseItemDto);

export type GetPlaylistsByIdInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetPlaylistsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type GetSongsByIdInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetSongsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type GetBrandingConfigurationResponse = (Branding_BrandingOptions);

export type GetBrandingCssResponse = (unknown);

export type GetBrandingCssCssResponse = (unknown);

export type GetConnectPendingResponse = (unknown);

export type GetConnectExchangeData = {
    /**
     * ConnectUserId
     */
    connectUserId: string;
};

export type GetConnectExchangeResponse = (Connect_ConnectAuthenticationExchangeResult);

export type PostUsersByIdConnectLinkData = {
    /**
     * Connect username
     */
    connectUsername: string;
    /**
     * User Id
     */
    id: string;
};

export type PostUsersByIdConnectLinkResponse = (Connect_UserLinkResult);

export type DeleteUsersByIdConnectLinkData = {
    /**
     * User Id
     */
    id: string;
};

export type DeleteUsersByIdConnectLinkResponse = (unknown);

export type GetDisplaypreferencesByIdData = {
    /**
     * Client
     */
    client: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetDisplaypreferencesByIdResponse = (DisplayPreferences);

export type PostDisplaypreferencesByDisplaypreferencesidData = {
    /**
     * DisplayPreferences Id
     */
    displayPreferencesId: string;
    /**
     * DisplayPreferences:
     */
    requestBody: DisplayPreferences;
    /**
     * User Id
     */
    userId: string;
};

export type PostDisplaypreferencesByDisplaypreferencesidResponse = (unknown);

export type GetDlnaProfileinfosResponse = (Array<Dlna_DeviceProfileInfo>);

export type PostDlnaProfilesData = {
    /**
     * DeviceProfile:
     */
    requestBody: Dlna_DeviceProfile;
};

export type PostDlnaProfilesResponse = (unknown);

export type GetDlnaProfilesByIdData = {
    /**
     * Profile Id
     */
    id: string;
};

export type GetDlnaProfilesByIdResponse = (Dlna_DeviceProfile);

export type DeleteDlnaProfilesByIdData = {
    /**
     * Profile Id
     */
    id: string;
};

export type DeleteDlnaProfilesByIdResponse = (unknown);

export type PostDlnaProfilesByIdData = {
    id: string;
    /**
     * DeviceProfile:
     */
    requestBody: Dlna_DeviceProfile;
};

export type PostDlnaProfilesByIdResponse = (unknown);

export type GetDlnaProfilesDefaultResponse = (Dlna_DeviceProfile);

export type PostEnvironmentValidatepathData = {
    path: string;
    /**
     * ValidatePath
     */
    requestBody: ValidatePath;
};

export type PostEnvironmentValidatepathResponse = (unknown);

export type GetEnvironmentDefaultdirectorybrowserResponse = (DefaultDirectoryBrowserInfo);

export type GetEnvironmentDirectorycontentsData = {
    /**
     * An optional filter to include or exclude folders from the results. true/false
     */
    includeDirectories?: boolean;
    /**
     * An optional filter to include or exclude files from the results. true/false
     */
    includeFiles?: boolean;
    path: string;
};

export type GetEnvironmentDirectorycontentsResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentNetworksharesData = {
    path: string;
};

export type GetEnvironmentNetworksharesResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentDrivesResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentNetworkdevicesResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentParentpathData = {
    path: string;
};

export type GetEnvironmentParentpathResponse = (string);

export type GetGamesSystemsummariesData = {
    /**
     * Optional. Filter by user id
     */
    userId?: string;
};

export type GetGamesSystemsummariesResponse = (Array<GameSystemSummary>);

export type GetImagesMediainfoResponse = (Array<ImageByNameInfo>);

export type GetImagesRatingsResponse = (Array<ImageByNameInfo>);

export type GetImagesGeneralResponse = (Array<ImageByNameInfo>);

export type GetImagesGeneralByNameByTypeData = {
    /**
     * The name of the image
     */
    name: string;
    /**
     * Image Type (primary, backdrop, logo, etc).
     */
    type: string;
};

export type GetImagesGeneralByNameByTypeResponse = (unknown);

export type GetImagesRatingsByThemeByNameData = {
    /**
     * The name of the image
     */
    name: string;
    /**
     * The theme to get the image from
     */
    theme: string;
};

export type GetImagesRatingsByThemeByNameResponse = (unknown);

export type GetImagesMediainfoByThemeByNameData = {
    /**
     * The name of the image
     */
    name: string;
    /**
     * The theme to get the image from
     */
    theme: string;
};

export type GetImagesMediainfoByThemeByNameResponse = (unknown);

export type GetImagesRemoteData = {
    /**
     * The image url
     */
    imageUrl: string;
};

export type GetImagesRemoteResponse = (unknown);

export type GetItemsByIdRemoteimagesData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional.
     */
    includeAllLanguages?: boolean;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The image provider to use
     */
    providerName?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * The image type
     */
    type?: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type GetItemsByIdRemoteimagesResponse = (RemoteImageResult);

export type GetItemsByIdRemoteimagesProvidersData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdRemoteimagesProvidersResponse = (Array<ImageProviderInfo>);

export type PostItemsByIdRemoteimagesDownloadData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The image url
     */
    imageUrl?: string;
    /**
     * The image provider
     */
    providerName?: string;
    /**
     * The image type
     */
    type: 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail';
};

export type PostItemsByIdRemoteimagesDownloadResponse = (unknown);

export type GetItemsFilters2Data = {
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * User Id
     */
    userId?: string;
};

export type GetItemsFilters2Response = (QueryFilters);

export type GetItemsFiltersData = {
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * User Id
     */
    userId?: string;
};

export type GetItemsFiltersResponse = (QueryFiltersLegacy);

export type PostItemsByItemidData = {
    /**
     * The id of the item
     */
    itemId: string;
    /**
     * BaseItemDto:
     */
    requestBody: BaseItemDto;
};

export type PostItemsByItemidResponse = (unknown);

export type GetItemsByItemidMetadataeditorData = {
    /**
     * The id of the item
     */
    itemId: string;
};

export type GetItemsByItemidMetadataeditorResponse = (MetadataEditorInfo);

export type GetItemsFileResponse = (unknown);

export type GetVideosByIdByContainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdByContainerResponse = (unknown);

export type HeadVideosByIdByContainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdByContainerResponse = (unknown);

export type GetVideosByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdStreamResponse = (unknown);

export type HeadVideosByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdStreamResponse = (unknown);

export type GetLibraryVirtualfoldersResponse = (Array<VirtualFolderInfo>);

export type PostLibraryVirtualfoldersData = {
    /**
     * AddVirtualFolder
     */
    requestBody: Library_AddVirtualFolder;
};

export type PostLibraryVirtualfoldersResponse = (unknown);

export type DeleteLibraryVirtualfoldersResponse = (unknown);

export type PostLibraryVirtualfoldersLibraryoptionsData = {
    /**
     * UpdateLibraryOptions
     */
    requestBody: Library_UpdateLibraryOptions;
};

export type PostLibraryVirtualfoldersLibraryoptionsResponse = (unknown);

export type PostLibraryVirtualfoldersNameData = {
    /**
     * RenameVirtualFolder
     */
    requestBody: Library_RenameVirtualFolder;
};

export type PostLibraryVirtualfoldersNameResponse = (unknown);

export type PostLibraryVirtualfoldersPathsData = {
    /**
     * AddMediaPath
     */
    requestBody: Library_AddMediaPath;
};

export type PostLibraryVirtualfoldersPathsResponse = (unknown);

export type DeleteLibraryVirtualfoldersPathsResponse = (unknown);

export type PostLibraryVirtualfoldersPathsUpdateData = {
    /**
     * UpdateMediaPath
     */
    requestBody: Library_UpdateMediaPath;
};

export type PostLibraryVirtualfoldersPathsUpdateResponse = (unknown);

export type PostLivestreamsOpenData = {
    /**
     * LiveStreamRequest:
     */
    requestBody: MediaInfo_LiveStreamRequest;
};

export type PostLivestreamsOpenResponse = (MediaInfo_LiveStreamResponse);

export type PostLivestreamsCloseData = {
    /**
     * LiveStreamId
     */
    liveStreamId: string;
};

export type PostLivestreamsCloseResponse = (unknown);

export type PostLivestreamsMediainfoData = {
    /**
     * LiveStreamId
     */
    liveStreamId: string;
};

export type PostLivestreamsMediainfoResponse = (unknown);

export type GetPlaybackBitratetestData = {
    /**
     * Size
     */
    size: number;
};

export type GetPlaybackBitratetestResponse = (unknown);

export type GetItemsByIdPlaybackinfoData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetItemsByIdPlaybackinfoResponse = (MediaInfo_PlaybackInfoResponse);

export type PostItemsByIdPlaybackinfoData = {
    id: string;
    /**
     * PlaybackInfoRequest:
     */
    requestBody: MediaInfo_PlaybackInfoRequest;
};

export type PostItemsByIdPlaybackinfoResponse = (MediaInfo_PlaybackInfoResponse);

export type OptionsLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type OptionsLivetvChannelmappingsResponse = (unknown);

export type GetLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type GetLivetvChannelmappingsResponse = (unknown);

export type HeadLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type HeadLivetvChannelmappingsResponse = (unknown);

export type PostLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
    /**
     * SetChannelMapping
     */
    requestBody: LiveTv_SetChannelMapping;
};

export type PostLivetvChannelmappingsResponse = (unknown);

export type PutLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
    /**
     * SetChannelMapping
     */
    requestBody: LiveTv_SetChannelMapping;
};

export type PutLivetvChannelmappingsResponse = (unknown);

export type DeleteLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type DeleteLivetvChannelmappingsResponse = (unknown);

export type TraceLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type TraceLivetvChannelmappingsResponse = (unknown);

export type PatchLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type PatchLivetvChannelmappingsResponse = (unknown);

export type OptionsLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type OptionsLivetvChannelmappingoptionsResponse = (unknown);

export type GetLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type GetLivetvChannelmappingoptionsResponse = (unknown);

export type HeadLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type HeadLivetvChannelmappingoptionsResponse = (unknown);

export type PostLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type PostLivetvChannelmappingoptionsResponse = (unknown);

export type PutLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type PutLivetvChannelmappingoptionsResponse = (unknown);

export type DeleteLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type DeleteLivetvChannelmappingoptionsResponse = (unknown);

export type TraceLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type TraceLivetvChannelmappingoptionsResponse = (unknown);

export type PatchLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type PatchLivetvChannelmappingoptionsResponse = (unknown);

export type PostLivetvListingprovidersData = {
    /**
     * ListingsProviderInfo:
     */
    requestBody: LiveTv_ListingsProviderInfo;
};

export type PostLivetvListingprovidersResponse = (LiveTv_ListingsProviderInfo);

export type DeleteLivetvListingprovidersData = {
    /**
     * Provider id
     */
    id?: string;
};

export type DeleteLivetvListingprovidersResponse = (unknown);

export type GetLivetvListingprovidersResponse = (Array<LiveTv_ListingsProviderInfo>);

export type GetLivetvTunerhostsResponse = (Array<LiveTv_TunerHostInfo>);

export type PostLivetvTunerhostsData = {
    /**
     * TunerHostInfo:
     */
    requestBody: LiveTv_TunerHostInfo;
};

export type PostLivetvTunerhostsResponse = (LiveTv_TunerHostInfo);

export type DeleteLivetvTunerhostsData = {
    /**
     * Tuner host id
     */
    id?: string;
};

export type DeleteLivetvTunerhostsResponse = (unknown);

export type GetLivetvInfoResponse = (LiveTv_LiveTvInfo);

export type GetLivetvChannelsData = {
    /**
     * Optional. Adds current program info to each channel
     */
    addCurrentProgram?: boolean;
    /**
     * Incorporate favorite and like status into channel sorting.
     */
    enableFavoriteSorting?: boolean;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Filter by channels that are disliked, or not.
     */
    isDisliked?: (boolean) | null;
    /**
     * Filter by channels that are favorites, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Filter by channels that are liked, or not.
     */
    isLiked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional filter by channel type.
     */
    type?: 'TV' | 'Radio';
    /**
     * Optional filter by user and attach user data.
     */
    userId?: string;
};

export type GetLivetvChannelsResponse = (QueryResult_BaseItemDto);

export type GetLivetvProgramsData = {
    /**
     * The channels to return guide information for.
     */
    channelIds?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * The genres to return guide information for.
     */
    genreIds?: string;
    /**
     * Optional. Filter by programs that have completed airing, or not.
     */
    hasAired?: (boolean) | null;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional filter by user id.
     */
    userId?: string;
};

export type GetLivetvProgramsResponse = (QueryResult_BaseItemDto);

export type PostLivetvProgramsData = {
    /**
     * The channels to return guide information for.
     */
    channelIds?: string;
    /**
     * The genres to return guide information for.
     */
    genreIds?: string;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * GetPrograms
     */
    requestBody: LiveTv_GetPrograms;
    /**
     * Optional filter by user id.
     */
    userId?: string;
};

export type PostLivetvProgramsResponse = (QueryResult_BaseItemDto);

export type GetLivetvRecordingsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by channel id.
     */
    channelId?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter by recordings that are in progress, or not.
     */
    isInProgress?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional filter by recordings belonging to a series timer
     */
    seriesTimerId?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional filter by recording status.
     */
    status?: 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvRecordingsResponse = (unknown);

export type GetLivetvTimersData = {
    /**
     * Optional filter by channel id.
     */
    channelId?: string;
    /**
     * Optional filter by timers belonging to a series timer
     */
    seriesTimerId?: string;
};

export type GetLivetvTimersResponse = (QueryResult_LiveTv_TimerInfoDto);

export type PostLivetvTimersData = {
    /**
     * TimerInfoDto:
     */
    requestBody: LiveTv_TimerInfoDto;
};

export type PostLivetvTimersResponse = (unknown);

export type GetLivetvSeriestimersData = {
    /**
     * Optional. Sort by SortName or Priority
     */
    sortBy?: string;
    /**
     * Optional. Sort in Ascending or Descending order
     */
    sortOrder?: 'Ascending' | 'Descending';
};

export type GetLivetvSeriestimersResponse = (QueryResult_LiveTv_SeriesTimerInfoDto);

export type PostLivetvSeriestimersData = {
    /**
     * SeriesTimerInfoDto:
     */
    requestBody: LiveTv_SeriesTimerInfoDto;
};

export type PostLivetvSeriestimersResponse = (unknown);

export type GetLivetvGuideinfoResponse = (LiveTv_GuideInfo);

export type GetLivetvTunerhostsTypesResponse = (Array<NameIdPair>);

export type GetLivetvRecordingsFoldersData = {
    /**
     * Optional filter by user and attach user data.
     */
    userId?: string;
};

export type GetLivetvRecordingsFoldersResponse = (Array<BaseItemDto>);

export type GetLivetvTunersDiscvoverResponse = (Array<LiveTv_TunerHostInfo>);

export type GetLivetvListingprovidersDefaultResponse = (LiveTv_ListingsProviderInfo);

export type GetLivetvListingprovidersLineupsData = {
    /**
     * Country
     */
    country?: string;
    /**
     * Provider id
     */
    id?: string;
    /**
     * Location
     */
    location?: string;
    /**
     * Provider Type
     */
    type?: string;
};

export type GetLivetvListingprovidersLineupsResponse = (Array<NameIdPair>);

export type GetLivetvChannelsByIdData = {
    /**
     * Channel Id
     */
    id: string;
    /**
     * Optional attach user data.
     */
    userId?: string;
};

export type GetLivetvChannelsByIdResponse = (BaseItemDto);

export type GetLivetvProgramsRecommendedData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * The genres to return guide information for.
     */
    genreIds?: string;
    /**
     * Optional. Filter by programs that have completed airing, or not.
     */
    hasAired?: (boolean) | null;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. Filter by programs that are currently airing, or not.
     */
    isAiring?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional filter by user id.
     */
    userId?: string;
};

export type GetLivetvProgramsRecommendedResponse = (QueryResult_BaseItemDto);

export type GetLivetvRecordingsSeriesData = {
    /**
     * Optional filter by channel id.
     */
    channelId?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional filter by recording group.
     */
    groupId?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional filter by recordings that are in progress, or not.
     */
    isInProgress?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional filter by recordings belonging to a series timer
     */
    seriesTimerId?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional filter by recording status.
     */
    status?: 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';
    /**
     * Optional filter by user and attach user data.
     */
    userId?: string;
};

export type GetLivetvRecordingsSeriesResponse = (QueryResult_BaseItemDto);

export type GetLivetvRecordingsByIdData = {
    /**
     * Recording Id
     */
    id: string;
    /**
     * Optional attach user data.
     */
    userId?: string;
};

export type GetLivetvRecordingsByIdResponse = (BaseItemDto);

export type DeleteLivetvRecordingsByIdData = {
    /**
     * Recording Id
     */
    id: string;
};

export type DeleteLivetvRecordingsByIdResponse = (unknown);

export type GetLivetvTimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type GetLivetvTimersByIdResponse = (LiveTv_TimerInfoDto);

export type DeleteLivetvTimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type DeleteLivetvTimersByIdResponse = (unknown);

export type PostLivetvTimersByIdData = {
    id: string;
    /**
     * TimerInfoDto:
     */
    requestBody: LiveTv_TimerInfoDto;
};

export type PostLivetvTimersByIdResponse = (unknown);

export type GetLivetvSeriestimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type GetLivetvSeriestimersByIdResponse = (LiveTv_TimerInfoDto);

export type DeleteLivetvSeriestimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type DeleteLivetvSeriestimersByIdResponse = (unknown);

export type PostLivetvSeriestimersByIdData = {
    id: string;
    /**
     * SeriesTimerInfoDto:
     */
    requestBody: LiveTv_SeriesTimerInfoDto;
};

export type PostLivetvSeriestimersByIdResponse = (unknown);

export type GetLivetvTimersDefaultsData = {
    /**
     * Optional, to attach default values based on a program.
     */
    programId?: string;
};

export type GetLivetvTimersDefaultsResponse = (LiveTv_SeriesTimerInfoDto);

export type GetLivetvRecordingsGroupsData = {
    /**
     * Optional filter by user and attach user data.
     */
    userId?: string;
};

export type GetLivetvRecordingsGroupsResponse = (QueryResult_BaseItemDto);

export type GetLivetvListingprovidersAvailableResponse = (Array<LiveTv_ListingProviderTypeInfo>);

export type GetLivetvLiverecordingsByIdStreamData = {
    id: string;
};

export type GetLivetvLiverecordingsByIdStreamResponse = (unknown);

export type GetLivetvLivestreamfilesByIdByContainerData = {
    container: string;
    id: string;
};

export type GetLivetvLivestreamfilesByIdByContainerResponse = (unknown);

export type GetLivetvListingprovidersSchedulesdirectCountriesResponse = (unknown);

export type GetLivetvRecordingsGroupsByIdData = {
    /**
     * Recording group Id
     */
    id: string;
};

export type GetLivetvRecordingsGroupsByIdResponse = (BaseItemDto);

export type PostLivetvTunersByIdResetData = {
    /**
     * Tuner Id
     */
    id: string;
};

export type PostLivetvTunersByIdResetResponse = (unknown);

export type GetLocalizationParentalratingsResponse = (Array<ParentalRating>);

export type GetLocalizationOptionsResponse = (Array<Globalization_LocalizatonOption>);

export type GetLocalizationCountriesResponse = (Array<Globalization_CountryInfo>);

export type GetLocalizationCulturesResponse = (Array<Globalization_CultureDto>);

export type GetMoviesRecommendationsData = {
    /**
     * The max number of categories to return
     */
    categoryLimit?: number;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * The max number of items to return per category
     */
    itemLimit?: number;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMoviesRecommendationsResponse = (Array<RecommendationDto>);

export type GetNewsProductData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
};

export type GetNewsProductResponse = (QueryResult_News_NewsItem);

export type GetNotificationsTypesResponse = (Array<Notifications_NotificationTypeInfo>);

export type GetNotificationsServicesResponse = (Array<NameIdPair>);

export type PostNotificationsAdminData = {
    /**
     * The notification's description
     */
    description: string;
    /**
     * The notification's image url
     */
    imageUrl?: string;
    /**
     * The notification level
     */
    level?: 'Normal' | 'Warning' | 'Error';
    /**
     * The notification's name
     */
    name: string;
    /**
     * The notification's info url
     */
    url?: string;
};

export type PostNotificationsAdminResponse = (unknown);

export type GetNotificationsByUseridData = {
    /**
     * An optional filter by IsRead
     */
    isRead?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetNotificationsByUseridResponse = (Emby_Notifications_Api_NotificationResult);

export type GetNotificationsByUseridSummaryData = {
    /**
     * User Id
     */
    userId: string;
};

export type GetNotificationsByUseridSummaryResponse = (Emby_Notifications_Api_NotificationsSummary);

export type PostNotificationsByUseridReadData = {
    /**
     * A list of notification ids, comma delimited
     */
    ids: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostNotificationsByUseridReadResponse = (unknown);

export type PostNotificationsByUseridUnreadData = {
    /**
     * A list of notification ids, comma delimited
     */
    ids: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostNotificationsByUseridUnreadResponse = (unknown);

export type GetReportsActivitiesData = {
    /**
     * The report display type. Values (None, Screen, Export, ScreenExport)
     */
    displayType: string;
    /**
     * Optional. If specified, results will include grouped records.
     */
    groupBy?: string;
    /**
     * Optional. If specified, results will include all records.
     */
    hasQueryLimit?: boolean;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The columns to show.
     */
    reportColumns?: string;
    /**
     * The report view. Values (ReportData, ReportActivities)
     */
    reportView: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
};

export type GetReportsActivitiesResponse = (EmbyReports_Api_Model_ReportResult);

export type GetReportsHeadersData = {
    /**
     * The report display type. Values (None, Screen, Export, ScreenExport)
     */
    displayType: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The columns to show.
     */
    reportColumns?: string;
    /**
     * The report view. Values (ReportData, ReportActivities)
     */
    reportView: string;
};

export type GetReportsHeadersResponse = (Array<EmbyReports_Api_Model_ReportHeader>);

export type GetReportsItemsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    collapseBoxSetItems?: (boolean) | null;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * The report display type. Values (None, Screen, Export, ScreenExport)
     */
    displayType: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Optional. If specified, results will include grouped records.
     */
    groupBy?: string;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional. If specified, results will include all records.
     */
    hasQueryLimit?: boolean;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional. The columns to show.
     */
    reportColumns?: string;
    /**
     * The report view. Values (ReportData, ReportActivities)
     */
    reportView: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetReportsItemsResponse = (EmbyReports_Api_Model_ReportResult);

export type GetReportsItemsDownloadData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    collapseBoxSetItems?: (boolean) | null;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * The report display type. Values (None, Screen, Export, ScreenExport)
     */
    displayType: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    excludeLocationTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Optional. If specified, results will include grouped records.
     */
    groupBy?: string;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional. If specified, results will include all records.
     */
    hasQueryLimit?: boolean;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     */
    locationTypes?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Optional. The columns to show.
     */
    reportColumns?: string;
    /**
     * The report view. Values (ReportData, ReportActivities)
     */
    reportView: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetReportsItemsDownloadResponse = (unknown);

export type GetSearchHintsData = {
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    includeArtists?: boolean;
    includeGenres?: boolean;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    includeMedia?: boolean;
    includePeople?: boolean;
    includeStudios?: boolean;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    mediaTypes?: string;
    /**
     * The search term to filter on
     */
    searchTerm: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Supply a user id to search within a user's library or omit to search all.
     */
    userId?: string;
};

export type GetSearchHintsResponse = (Search_SearchHintResult);

export type PostSessionsPlayingData = {
    /**
     * PlaybackStartInfo:
     */
    requestBody: PlaybackStartInfo;
};

export type PostSessionsPlayingResponse = (unknown);

export type PostSessionsPlayingProgressData = {
    /**
     * PlaybackProgressInfo:
     */
    requestBody: PlaybackProgressInfo;
};

export type PostSessionsPlayingProgressResponse = (unknown);

export type PostSessionsPlayingPingData = {
    playSessionId?: string;
};

export type PostSessionsPlayingPingResponse = (unknown);

export type PostSessionsPlayingStoppedData = {
    /**
     * PlaybackStopInfo:
     */
    requestBody: PlaybackStopInfo;
};

export type PostSessionsPlayingStoppedResponse = (unknown);

export type PostUsersByUseridPlayeditemsByIdData = {
    /**
     * The date the item was played (if any). Format = yyyyMMddHHmmss
     */
    datePlayed?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridPlayeditemsByIdResponse = (UserItemDataDto);

export type DeleteUsersByUseridPlayeditemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridPlayeditemsByIdResponse = (UserItemDataDto);

export type PostUsersByUseridPlayingitemsByIdData = {
    audioStreamIndex?: (number) | null;
    /**
     * Indicates if the client can seek
     */
    canSeek?: boolean;
    /**
     * Item Id
     */
    id: string;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    playMethod?: 'Transcode' | 'DirectStream' | 'DirectPlay';
    playSessionId?: string;
    subtitleStreamIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridPlayingitemsByIdResponse = (unknown);

export type DeleteUsersByUseridPlayingitemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    /**
     * The next media type that will play
     */
    nextMediaType: string;
    playSessionId?: string;
    /**
     * Optional. The position, in ticks, where playback stopped. 1 tick = 10000 ms
     */
    positionTicks?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridPlayingitemsByIdResponse = (unknown);

export type PostUsersByUseridPlayingitemsByIdProgressData = {
    audioStreamIndex?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Indicates if the player is muted.
     */
    isMuted?: boolean;
    /**
     * Indicates if the player is paused.
     */
    isPaused?: boolean;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    playMethod?: 'Transcode' | 'DirectStream' | 'DirectPlay';
    playSessionId?: string;
    /**
     * Optional. The current position, in ticks. 1 tick = 10000 ms
     */
    positionTicks?: (number) | null;
    repeatMode?: 'RepeatNone' | 'RepeatAll' | 'RepeatOne';
    subtitleStreamIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
    /**
     * Scale of 0-100
     */
    volumeLevel?: (number) | null;
};

export type PostUsersByUseridPlayingitemsByIdProgressResponse = (unknown);

export type GetShowsUpcomingData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetShowsUpcomingResponse = (QueryResult_BaseItemDto);

export type GetShowsNextupData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional. Filter by series id
     */
    seriesId?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetShowsNextupResponse = (QueryResult_BaseItemDto);

export type GetShowsByIdSeasonsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * The series id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetShowsByIdSeasonsResponse = (QueryResult_BaseItemDto);

export type GetShowsByIdEpisodesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * The series id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional filter by items that are missing episodes or not.
     */
    isMissing?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional filter by season number.
     */
    season?: (number) | null;
    /**
     * Optional. Filter by season id
     */
    seasonId?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: 'Ascending' | 'Descending';
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetShowsByIdEpisodesResponse = (QueryResult_BaseItemDto);

export type GetSyncTargetsData = {
    /**
     * UserId
     */
    userId: string;
};

export type GetSyncTargetsResponse = (Array<Sync_SyncTarget>);

export type GetSyncJobsResponse = (QueryResult_Sync_SyncJob);

export type PostSyncJobsData = {
    /**
     * SyncJobRequest:
     */
    requestBody: Sync_Model_SyncJobRequest;
};

export type PostSyncJobsResponse = (Sync_Model_SyncJobCreationResult);

export type GetSyncJobitemsResponse = (QueryResult_Sync_Model_SyncJobItem);

export type GetSyncOptionsData = {
    /**
     * Category
     */
    category?: 'Latest' | 'NextUp' | 'Resume';
    /**
     * ItemIds
     */
    itemIds?: string;
    /**
     * ParentId
     */
    parentId?: string;
    /**
     * TargetId
     */
    targetId?: string;
    /**
     * UserId
     */
    userId: string;
};

export type GetSyncOptionsResponse = (Sync_Model_SyncDialogOptions);

export type PostSyncOfflineactionsData = {
    /**
     * List`1:
     */
    requestBody: Array<Users_UserAction>;
};

export type PostSyncOfflineactionsResponse = (unknown);

export type PostSyncDataData = {
    /**
     * SyncDataRequest:
     */
    requestBody: Sync_Model_SyncDataRequest;
};

export type PostSyncDataResponse = (Sync_Model_SyncDataResponse);

export type PostSyncByItemidStatusData = {
    itemId: string;
    /**
     * SyncedItemProgress:
     */
    requestBody: Sync_Model_SyncedItemProgress;
};

export type PostSyncByItemidStatusResponse = (unknown);

export type GetSyncJobsByIdData = {
    /**
     * Id
     */
    id: string;
};

export type GetSyncJobsByIdResponse = (Sync_SyncJob);

export type DeleteSyncJobsByIdData = {
    /**
     * Id
     */
    id: string;
};

export type DeleteSyncJobsByIdResponse = (unknown);

export type PostSyncJobsByIdData = {
    id: number;
    /**
     * SyncJob:
     */
    requestBody: Sync_SyncJob;
};

export type PostSyncJobsByIdResponse = (unknown);

export type PostSyncItemsCancelData = {
    /**
     * ItemIds
     */
    itemIds?: string;
};

export type PostSyncItemsCancelResponse = (unknown);

export type DeleteSyncByTargetidItemsData = {
    /**
     * TargetId
     */
    targetId: string;
};

export type DeleteSyncByTargetidItemsResponse = (unknown);

export type GetSyncItemsReadyData = {
    /**
     * TargetId
     */
    targetId: string;
};

export type GetSyncItemsReadyResponse = (Array<Sync_Model_SyncedItem>);

export type DeleteSyncJobitemsByIdData = {
    /**
     * Id
     */
    id: string;
};

export type DeleteSyncJobitemsByIdResponse = (unknown);

export type PostSyncJobitemsByIdTransferredData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdTransferredResponse = (unknown);

export type GetSyncJobitemsByIdFileData = {
    /**
     * Id
     */
    id: string;
};

export type GetSyncJobitemsByIdFileResponse = (unknown);

export type GetSyncJobitemsByIdAdditionalfilesData = {
    /**
     * Id
     */
    id: string;
    /**
     * Name
     */
    name: string;
};

export type GetSyncJobitemsByIdAdditionalfilesResponse = (unknown);

export type PostSyncJobitemsByIdEnableData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdEnableResponse = (unknown);

export type PostSyncJobitemsByIdMarkforremovalData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdMarkforremovalResponse = (unknown);

export type PostSyncJobitemsByIdUnmarkforremovalData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdUnmarkforremovalResponse = (unknown);

export type GetSystemConfigurationResponse = (Configuration_ServerConfiguration);

export type PostSystemConfigurationData = {
    /**
     * ServerConfiguration:
     */
    requestBody: Configuration_ServerConfiguration;
};

export type PostSystemConfigurationResponse = (unknown);

export type GetSystemConfigurationByKeyData = {
    /**
     * Key
     */
    key: string;
};

export type GetSystemConfigurationByKeyResponse = (unknown);

export type PostSystemConfigurationByKeyData = {
    /**
     * Key
     */
    key: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostSystemConfigurationByKeyResponse = (unknown);

export type PostSystemPingResponse = (unknown);

export type GetSystemPingResponse = (unknown);

export type GetSystemWakeonlaninfoResponse = (Array<WakeOnLanInfo>);

export type GetSystemLogsResponse = (Array<LogFile>);

export type GetSystemInfoResponse = (SystemInfo);

export type PostSystemRestartResponse = (unknown);

export type PostSystemShutdownResponse = (unknown);

export type GetSystemEndpointResponse = (Net_EndPointInfo);

export type GetSystemLogsLogData = {
    /**
     * The log file name.
     */
    name: string;
};

export type GetSystemLogsLogResponse = (unknown);

export type GetSystemInfoPublicResponse = (PublicSystemInfo);

export type GetUserUsageStatsTypeFilterListResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsUserActivityData = {
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
};

export type GetUserUsageStatsUserActivityResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsUserListResponse = ({
    [key: string]: unknown;
});

export type PostUserUsageStatsImportBackupData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostUserUsageStatsImportBackupResponse = (unknown);

export type GetUserUsageStatsLoadBackupData = {
    /**
     * File name of file to load
     */
    backupfile: string;
};

export type GetUserUsageStatsLoadBackupResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsSaveBackupResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsPlayactivityData = {
    /**
     * Data type to return (count,time)
     */
    dataType?: string;
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
    /**
     * Comma separated list of media types to filter (movies,series)
     */
    filter?: string;
};

export type GetUserUsageStatsPlayactivityResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsHourlyreportData = {
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
    /**
     * Comma separated list of media types to filter (movies,series)
     */
    filter?: string;
};

export type GetUserUsageStatsHourlyreportResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsDurationhistogramreportData = {
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
    /**
     * Comma separated list of media types to filter (movies,series)
     */
    filter?: string;
};

export type GetUserUsageStatsDurationhistogramreportResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsTvshowsreportData = {
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
};

export type GetUserUsageStatsTvshowsreportResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsMoviesreportData = {
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
};

export type GetUserUsageStatsMoviesreportResponse = ({
    [key: string]: unknown;
});

export type PostUserUsageStatsSubmitCustomQueryData = {
    /**
     * CustomQuery
     */
    requestBody: playback_reporting_Api_CustomQuery;
};

export type PostUserUsageStatsSubmitCustomQueryResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsUserplaylistData = {
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
    /**
     * Comma separated list of media types to filter (movies,series)
     */
    filter?: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUserUsageStatsUserplaylistResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsSessionListResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsResourceUsageData = {
    /**
     * Number of Hours
     */
    hours?: number;
};

export type GetUserUsageStatsResourceUsageResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsProcessListResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsByBreakdowntypeBreakdownreportData = {
    /**
     * Breakdown type
     */
    breakdownType: string;
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
};

export type GetUserUsageStatsByBreakdowntypeBreakdownreportResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsUserManageByActionByIdData = {
    /**
     * action to perform
     */
    action: string;
    /**
     * user Id to perform the action on
     */
    id: string;
};

export type GetUserUsageStatsUserManageByActionByIdResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsByUseridByDateGetitemsData = {
    /**
     * UTC DateTime, Format yyyy-MM-dd
     */
    date: string;
    /**
     * Comma separated list of media types to filter (movies,series)
     */
    filter?: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUserUsageStatsByUseridByDateGetitemsResponse = ({
    [key: string]: unknown;
});

export type PostVideosMergeversionsData = {
    /**
     * Item id list. This allows multiple, comma delimited.
     */
    ids?: string;
};

export type PostVideosMergeversionsResponse = (unknown);

export type GetVideosByIdAdditionalpartsData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetVideosByIdAdditionalpartsResponse = (QueryResult_BaseItemDto);

export type DeleteVideosByIdAlternatesourcesData = {
    /**
     * Item Id
     */
    id: string;
};

export type DeleteVideosByIdAlternatesourcesResponse = (unknown);

export type DeleteVideosActiveencodingsData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId: string;
    /**
     * The play session id
     */
    playSessionId: string;
};

export type DeleteVideosActiveencodingsResponse = (unknown);

export type GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    playlistId: string;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * SegmentContainer
     */
    segmentContainer: string;
    /**
     * SegmentId
     */
    segmentId: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type GetWebConfigurationpageResponse = (unknown);

export type GetWebConfigurationpagesResponse = (Array<WebDashboard_Api_ConfigurationPageInfo>);

export type GetAudioByIdByContainerData = {
    container: string;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
};

export type GetAudioByIdByContainerResponse = (unknown);

export type HeadAudioByIdByContainerData = {
    container: string;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
};

export type HeadAudioByIdByContainerResponse = (unknown);

export type GetAudioByIdUniversalData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
};

export type GetAudioByIdUniversalResponse = (unknown);

export type HeadAudioByIdUniversalData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
};

export type HeadAudioByIdUniversalResponse = (unknown);

export type GetAudioByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdStreamResponse = (unknown);

export type HeadAudioByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdStreamResponse = (unknown);

export type GetAudioByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdMasterM3U8Response = (unknown);

export type HeadAudioByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdMasterM3U8Response = (unknown);

export type GetAudioByIdMainM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdMainM3U8Response = (unknown);

export type GetVideosByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdMasterM3U8Response = (unknown);

export type HeadVideosByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdMasterM3U8Response = (unknown);

export type GetVideosByIdMainM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdMainM3U8Response = (unknown);

export type GetVideosByIdSubtitlesM3U8Data = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle segment format
     */
    manifestSubtitles: string;
    /**
     * The subtitle segment length
     */
    subtitleSegmentLength: number;
};

export type GetVideosByIdSubtitlesM3U8Response = (unknown);

export type GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    playlistId: string;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * SegmentContainer
     */
    segmentContainer: string;
    segmentId: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    playlistId: string;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * SegmentContainer
     */
    segmentContainer: string;
    segmentId: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    playlistId: string;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * SegmentContainer
     */
    segmentContainer: string;
    segmentId: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    playlistId: string;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * SegmentContainer
     */
    segmentContainer: string;
    segmentId: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type GetDlnaByUuidDescriptionXmlData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidDescriptionXmlResponse = (unknown);

export type GetDlnaByUuidDescriptionData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidDescriptionResponse = (unknown);

export type GetDlnaIconsByFilenameData = {
    /**
     * The icon filename
     */
    filename: string;
    /**
     * Server UuId
     */
    uuId?: string;
};

export type GetDlnaIconsByFilenameResponse = (unknown);

export type GetDlnaByUuidContentdirectoryContentdirectoryXmlData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidContentdirectoryContentdirectoryXmlResponse = (unknown);

export type GetDlnaByUuidContentdirectoryContentdirectoryData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidContentdirectoryContentdirectoryResponse = (unknown);

export type GetDlnaByUuidConnectionmanagerConnectionmanagerXmlData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidConnectionmanagerConnectionmanagerXmlResponse = (unknown);

export type GetDlnaByUuidConnectionmanagerConnectionmanagerData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidConnectionmanagerConnectionmanagerResponse = (unknown);

export type PostDlnaByUuidContentdirectoryControlData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Server UuId
     */
    uuId: string;
};

export type PostDlnaByUuidContentdirectoryControlResponse = (unknown);

export type PostDlnaByUuidConnectionmanagerControlData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Server UuId
     */
    uuId: string;
};

export type PostDlnaByUuidConnectionmanagerControlResponse = (unknown);

export type GetDlnaByUuidIconsByFilenameData = {
    /**
     * The icon filename
     */
    filename: string;
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidIconsByFilenameResponse = (unknown);

export type GetEncodingCodecinformationVideoResponse = (Array<MediaEncoding_Codecs_VideoCodecs_VideoCodecBase>);

export type GetEncodingCodecconfigurationDefaultsResponse = (Array<Configuration_CodecConfiguration>);

export type GetItemsByIdExternalidinfosData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdExternalidinfosResponse = (Array<ExternalIdInfo>);

export type PostItemsRemotesearchTrailerData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: Providers_RemoteSearchQuery_Providers_TrailerInfo;
};

export type PostItemsRemotesearchTrailerResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchBookData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: Providers_RemoteSearchQuery_Providers_BookInfo;
};

export type PostItemsRemotesearchBookResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMovieData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: Providers_RemoteSearchQuery_Providers_MovieInfo;
};

export type PostItemsRemotesearchMovieResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchSeriesData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: Providers_RemoteSearchQuery_Providers_SeriesInfo;
};

export type PostItemsRemotesearchSeriesResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchGameData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: Providers_RemoteSearchQuery_Providers_GameInfo;
};

export type PostItemsRemotesearchGameResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchBoxsetData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: Providers_RemoteSearchQuery_Providers_BoxSetInfo;
};

export type PostItemsRemotesearchBoxsetResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMusicvideoData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: Providers_RemoteSearchQuery_Providers_MusicVideoInfo;
};

export type PostItemsRemotesearchMusicvideoResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchPersonData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: Providers_RemoteSearchQuery_Providers_PersonLookupInfo;
};

export type PostItemsRemotesearchPersonResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMusicalbumData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: Providers_RemoteSearchQuery_Providers_AlbumInfo;
};

export type PostItemsRemotesearchMusicalbumResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMusicartistData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: Providers_RemoteSearchQuery_Providers_ArtistInfo;
};

export type PostItemsRemotesearchMusicartistResponse = (Array<RemoteSearchResult>);

export type GetItemsRemotesearchImageData = {
    /**
     * The image url
     */
    imageUrl: string;
    providerName: string;
};

export type GetItemsRemotesearchImageResponse = (unknown);

export type PostItemsRemotesearchApplyByIdData = {
    /**
     * The item id
     */
    id: string;
    /**
     * Whether or not to replace all images
     */
    replaceAllImages?: boolean;
    /**
     * RemoteSearchResult:
     */
    requestBody: RemoteSearchResult;
};

export type PostItemsRemotesearchApplyByIdResponse = (unknown);

export type PostItemsByIdRefreshData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Specifies the image refresh mode
     */
    imageRefreshMode?: 'Default' | 'FullRefresh';
    /**
     * Specifies the metadata refresh mode
     */
    metadataRefreshMode?: 'Default' | 'FullRefresh';
    /**
     * Indicates if the refresh should occur recursively.
     */
    recursive?: boolean;
    /**
     * Determines if images should be replaced. Only applicable if mode is FullRefresh
     */
    replaceAllImages?: boolean;
    /**
     * Determines if metadata should be replaced. Only applicable if mode is FullRefresh
     */
    replaceAllMetadata?: boolean;
};

export type PostItemsByIdRefreshResponse = (unknown);

export type GetItemsByIdThumbnailsetData = {
    /**
     * Item Id
     */
    id: string;
    width: number;
};

export type GetItemsByIdThumbnailsetResponse = (RokuMetadata_Api_ThumbnailSetInfo);

export type GetVideosByIdIndexBifData = {
    /**
     * Item Id
     */
    id: string;
    width: number;
};

export type GetVideosByIdIndexBifResponse = (unknown);

export type GetLivetvProgramsByIdData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetLivetvProgramsByIdResponse = (BaseItemDto);

export type GetUsersByUseridItemsLatestData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Whether or not to group items into a parent container.
     */
    groupItems?: boolean;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Filter by items that are folders, or not.
     */
    isFolder?: (boolean) | null;
    /**
     * Filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Limit
     */
    limit?: number;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsLatestResponse = (Array<BaseItemDto>);

export type GetUsersByUseridItemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdResponse = (BaseItemDto);

export type GetUsersByUseridItemsRootData = {
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsRootResponse = (BaseItemDto);

export type PostUsersByUseridFavoriteitemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridFavoriteitemsByIdResponse = (UserItemDataDto);

export type DeleteUsersByUseridFavoriteitemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridFavoriteitemsByIdResponse = (UserItemDataDto);

export type GetUsersByUseridItemsByIdSpecialfeaturesData = {
    /**
     * Movie Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdSpecialfeaturesResponse = (Array<BaseItemDto>);

export type GetUsersByUseridItemsByIdLocaltrailersData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdLocaltrailersResponse = (Array<BaseItemDto>);

export type GetUsersByUseridItemsByIdIntrosData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdIntrosResponse = (QueryResult_BaseItemDto);

export type DeleteUsersByUseridItemsByIdRatingData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridItemsByIdRatingResponse = (UserItemDataDto);

export type PostUsersByUseridItemsByIdRatingData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Whether the user likes the item or not. true/false
     */
    likes: boolean;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridItemsByIdRatingResponse = (UserItemDataDto);

export type GetSystemActivitylogEntriesData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The minimum date. Format = ISO
     */
    minDate?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
};

export type GetSystemActivitylogEntriesResponse = (QueryResult_ActivityLogEntry);

export type GetUsersByUseridSuggestionsData = {
    userId: string;
};

export type GetUsersByUseridSuggestionsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridViewsData = {
    /**
     * Whether or not to include external views such as channels or live tv
     */
    includeExternalContent: (boolean) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridViewsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridGroupingoptionsData = {
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridGroupingoptionsResponse = (Array<BaseItemDto>);

export type GetVideosByIdLiveM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    framerate?: (number) | null;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     */
    level?: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     */
    maxFramerate?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxRefFrames?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     */
    profile?: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: 'Encode' | 'Embed' | 'External' | 'Hls';
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdLiveM3U8Response = (unknown);

export type PostNotificationSmtpTestByUseridData = {
    /**
     * User Id
     */
    userId: string;
};

export type PostNotificationSmtpTestByUseridResponse = (unknown);

export type GetProvidersSubtitlesSubtitlesByIdData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetProvidersSubtitlesSubtitlesByIdResponse = (unknown);

export type DeleteVideosByIdSubtitlesByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
};

export type DeleteVideosByIdSubtitlesByIndexResponse = (unknown);

export type GetItemsByIdRemotesearchSubtitlesByLanguageData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * IsForced
     */
    isForced?: (boolean) | null;
    /**
     * IsPerfectMatch
     */
    isPerfectMatch?: (boolean) | null;
    /**
     * Language
     */
    language: string;
};

export type GetItemsByIdRemotesearchSubtitlesByLanguageResponse = (Array<RemoteSubtitleInfo>);

export type PostItemsByIdRemotesearchSubtitlesBySubtitleidData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * SubtitleId
     */
    subtitleId: string;
};

export type PostItemsByIdRemotesearchSubtitlesBySubtitleidResponse = (unknown);

export type GetVideosByIdByMediasourceidSubtitlesByIndexByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks?: number;
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexByFormatResponse = (unknown);

export type GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks: number;
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksByFormatResponse = (unknown);