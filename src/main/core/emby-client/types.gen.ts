// This file is auto-generated by @hey-api/openapi-ts

export type QueryResult_BaseItemDto = {
    Items?: Array<BaseItemDto>;
    TotalRecordCount?: number;
};

/**
 * This is strictly used as a data transfer object from the api layer. This holds information about a BaseItem in a format that is convenient for the client.
 *
 */
export type BaseItemDto = {
    /**
     * The name.
     */
    Name?: string;
    OriginalTitle?: string;
    /**
     * The server identifier.
     */
    ServerId?: string;
    /**
     * The id.
     */
    Id?: string;
    Guid?: string;
    /**
     * The etag.
     */
    Etag?: string;
    /**
     * The Prefix.
     */
    Prefix?: string;
    TunerName?: string;
    /**
     * The playlist item identifier.
     */
    PlaylistItemId?: string;
    /**
     * The date created.
     */
    DateCreated?: (string) | null;
    DateModified?: (string) | null;
    VideoCodec?: string;
    AudioCodec?: string;
    AverageFrameRate?: (number) | null;
    RealFrameRate?: (number) | null;
    ExtraType?: string;
    SortIndexNumber?: (number) | null;
    SortParentIndexNumber?: (number) | null;
    CanDelete?: (boolean) | null;
    CanDownload?: (boolean) | null;
    CanEditItems?: (boolean) | null;
    SupportsResume?: (boolean) | null;
    PresentationUniqueKey?: string;
    PreferredMetadataLanguage?: string;
    PreferredMetadataCountryCode?: string;
    /**
     * A value indicating whether \[supports synchronize\].
     */
    SupportsSync?: (boolean) | null;
    SyncStatus?: SyncJobItemStatus;
    CanManageAccess?: (boolean) | null;
    CanLeaveContent?: (boolean) | null;
    CanMakePublic?: (boolean) | null;
    Container?: string;
    /**
     * The name of the sort.
     */
    SortName?: string;
    ForcedSortName?: string;
    Video3DFormat?: Video3DFormat;
    /**
     * The premiere date.
     */
    PremiereDate?: (string) | null;
    /**
     * The external urls.
     */
    ExternalUrls?: Array<ExternalUrl>;
    /**
     * The media versions.
     */
    MediaSources?: Array<MediaSourceInfo>;
    /**
     * The critic rating.
     */
    CriticRating?: (number) | null;
    GameSystemId?: (number) | null;
    AsSeries?: (boolean) | null;
    /**
     * The game system.
     */
    GameSystem?: string;
    ProductionLocations?: Array<(string)>;
    /**
     * The path.
     */
    Path?: string;
    /**
     * The official rating.
     */
    OfficialRating?: string;
    /**
     * The custom rating.
     */
    CustomRating?: string;
    /**
     * The channel identifier.
     */
    ChannelId?: string;
    ChannelName?: string;
    /**
     * The overview.
     */
    Overview?: string;
    /**
     * The taglines.
     */
    Taglines?: Array<(string)>;
    /**
     * The genres.
     */
    Genres?: Array<(string)>;
    /**
     * The community rating.
     */
    CommunityRating?: (number) | null;
    /**
     * The run time ticks.
     */
    RunTimeTicks?: (number) | null;
    Size?: (number) | null;
    FileName?: string;
    Bitrate?: (number) | null;
    /**
     * The production year.
     */
    ProductionYear?: (number) | null;
    /**
     * The number.
     */
    Number?: string;
    ChannelNumber?: string;
    /**
     * The index number.
     */
    IndexNumber?: (number) | null;
    /**
     * The index number end.
     */
    IndexNumberEnd?: (number) | null;
    /**
     * The parent index number.
     */
    ParentIndexNumber?: (number) | null;
    /**
     * The trailer urls.
     */
    RemoteTrailers?: Array<MediaUrl>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * A value indicating whether this instance is folder.
     */
    IsFolder?: (boolean) | null;
    /**
     * The parent id.
     */
    ParentId?: string;
    /**
     * The type.
     */
    Type?: string;
    /**
     * The people.
     */
    People?: Array<BaseItemPerson>;
    /**
     * The studios.
     */
    Studios?: Array<NameLongIdPair>;
    GenreItems?: Array<NameLongIdPair>;
    TagItems?: Array<NameLongIdPair>;
    /**
     * If the item does not have a logo, this will hold the Id of the Parent that has one.
     */
    ParentLogoItemId?: string;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     */
    ParentBackdropItemId?: string;
    /**
     * The parent backdrop image tags.
     */
    ParentBackdropImageTags?: Array<(string)>;
    /**
     * The local trailer count.
     */
    LocalTrailerCount?: (number) | null;
    UserData?: UserItemDataDto;
    /**
     * The recursive item count.
     */
    RecursiveItemCount?: (number) | null;
    /**
     * The child count.
     */
    ChildCount?: (number) | null;
    SeasonCount?: (number) | null;
    /**
     * The name of the series.
     */
    SeriesName?: string;
    /**
     * The series id.
     */
    SeriesId?: string;
    /**
     * The season identifier.
     */
    SeasonId?: string;
    /**
     * The special feature count.
     */
    SpecialFeatureCount?: (number) | null;
    /**
     * The display preferences id.
     */
    DisplayPreferencesId?: string;
    /**
     * The status.
     */
    Status?: string;
    /**
     * The air days.
     */
    AirDays?: Array<DayOfWeek>;
    /**
     * The tags.
     */
    Tags?: Array<(string)>;
    /**
     * The primary image aspect ratio, after image enhancements.
     */
    PrimaryImageAspectRatio?: (number) | null;
    /**
     * The artists.
     */
    Artists?: Array<(string)>;
    /**
     * The artist items.
     */
    ArtistItems?: Array<NameIdPair>;
    Composers?: Array<NameIdPair>;
    /**
     * The album.
     */
    Album?: string;
    /**
     * The type of the collection.
     */
    CollectionType?: string;
    /**
     * The display order.
     */
    DisplayOrder?: string;
    /**
     * The album id.
     */
    AlbumId?: string;
    /**
     * The album image tag.
     */
    AlbumPrimaryImageTag?: string;
    /**
     * The series primary image tag.
     */
    SeriesPrimaryImageTag?: string;
    /**
     * The album artist.
     */
    AlbumArtist?: string;
    /**
     * The album artists.
     */
    AlbumArtists?: Array<NameIdPair>;
    /**
     * The name of the season.
     */
    SeasonName?: string;
    /**
     * The media streams.
     */
    MediaStreams?: Array<MediaStream>;
    /**
     * The part count.
     */
    PartCount?: (number) | null;
    /**
     * The image tags.
     */
    ImageTags?: {
        [key: string]: (string);
    };
    /**
     * The backdrop image tags.
     */
    BackdropImageTags?: Array<(string)>;
    /**
     * The parent logo image tag.
     */
    ParentLogoImageTag?: string;
    /**
     * The series studio.
     */
    SeriesStudio?: string;
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
    /**
     * The parent thumb item id.
     */
    ParentThumbItemId?: string;
    /**
     * The parent thumb image tag.
     */
    ParentThumbImageTag?: string;
    /**
     * The chapters.
     */
    Chapters?: Array<ChapterInfo>;
    LocationType?: LocationType;
    /**
     * The type of the media.
     */
    MediaType?: string;
    /**
     * The end date.
     */
    EndDate?: (string) | null;
    /**
     * The locked fields.
     */
    LockedFields?: Array<MetadataFields>;
    /**
     * A value indicating whether \[enable internet providers\].
     */
    LockData?: (boolean) | null;
    Width?: (number) | null;
    Height?: (number) | null;
    CameraMake?: string;
    CameraModel?: string;
    Software?: string;
    ExposureTime?: (number) | null;
    FocalLength?: (number) | null;
    ImageOrientation?: Drawing_ImageOrientation;
    Aperture?: (number) | null;
    ShutterSpeed?: (number) | null;
    Latitude?: (number) | null;
    Longitude?: (number) | null;
    Altitude?: (number) | null;
    IsoSpeedRating?: (number) | null;
    /**
     * The series timer identifier.
     */
    SeriesTimerId?: string;
    /**
     * The channel primary image tag.
     */
    ChannelPrimaryImageTag?: string;
    /**
     * The start date of the recording, in UTC.
     */
    StartDate?: (string) | null;
    /**
     * The completion percentage.
     */
    CompletionPercentage?: (number) | null;
    /**
     * A value indicating whether this instance is repeat.
     */
    IsRepeat?: (boolean) | null;
    IsNew?: (boolean) | null;
    /**
     * The episode title.
     */
    EpisodeTitle?: string;
    /**
     * A value indicating whether this instance is movie.
     */
    IsMovie?: (boolean) | null;
    /**
     * A value indicating whether this instance is sports.
     */
    IsSports?: (boolean) | null;
    /**
     * A value indicating whether this instance is series.
     */
    IsSeries?: (boolean) | null;
    /**
     * A value indicating whether this instance is live.
     */
    IsLive?: (boolean) | null;
    /**
     * A value indicating whether this instance is news.
     */
    IsNews?: (boolean) | null;
    /**
     * A value indicating whether this instance is kids.
     */
    IsKids?: (boolean) | null;
    /**
     * A value indicating whether this instance is premiere.
     */
    IsPremiere?: (boolean) | null;
    TimerType?: LiveTv_TimerType;
    Disabled?: (boolean) | null;
    ManagementId?: string;
    /**
     * The timer identifier.
     */
    TimerId?: string;
    CurrentProgram?: BaseItemDto;
    MovieCount?: (number) | null;
    SeriesCount?: (number) | null;
    AlbumCount?: (number) | null;
    SongCount?: (number) | null;
    MusicVideoCount?: (number) | null;
    Subviews?: Array<(string)>;
    ListingsProviderId?: string;
    ListingsChannelId?: string;
    ListingsPath?: string;
    ListingsId?: string;
    ListingsChannelName?: string;
    ListingsChannelNumber?: string;
    AffiliateCallSign?: string;
};

export type SyncJobItemStatus = 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Synced' | 'Failed';

export type Video3DFormat = 'HalfSideBySide' | 'FullSideBySide' | 'FullTopAndBottom' | 'HalfTopAndBottom' | 'MVC';

export type ExternalUrl = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The type of the item.
     */
    Url?: string;
};

export type MediaSourceInfo = {
    Chapters?: Array<ChapterInfo>;
    Protocol?: MediaProtocol;
    Id?: string;
    Path?: string;
    EncoderPath?: string;
    EncoderProtocol?: MediaProtocol;
    Type?: MediaSourceType;
    ProbePath?: string;
    ProbeProtocol?: MediaProtocol;
    Container?: string;
    Size?: (number) | null;
    Name?: string;
    SortName?: string;
    /**
     * Differentiate internet url vs local network
     */
    IsRemote?: boolean;
    HasMixedProtocols?: boolean;
    RunTimeTicks?: (number) | null;
    ContainerStartTimeTicks?: (number) | null;
    SupportsTranscoding?: boolean;
    TrancodeLiveStartIndex?: (number) | null;
    WallClockStart?: (string) | null;
    SupportsDirectStream?: boolean;
    SupportsDirectPlay?: boolean;
    IsInfiniteStream?: boolean;
    RequiresOpening?: boolean;
    OpenToken?: string;
    RequiresClosing?: boolean;
    LiveStreamId?: string;
    /**
     * @deprecated
     */
    BufferMs?: (number) | null;
    RequiresLooping?: boolean;
    /**
     * @deprecated
     */
    SupportsProbing?: boolean;
    Video3DFormat?: Video3DFormat;
    MediaStreams?: Array<MediaStream>;
    Formats?: Array<(string)>;
    Bitrate?: (number) | null;
    Timestamp?: TransportStreamTimestamp;
    RequiredHttpHeaders?: {
        [key: string]: (string);
    };
    DirectStreamUrl?: string;
    AddApiKeyToDirectStreamUrl?: boolean;
    TranscodingUrl?: string;
    TranscodingSubProtocol?: string;
    TranscodingContainer?: string;
    /**
     * @deprecated
     */
    AnalyzeDurationMs?: (number) | null;
    /**
     * @deprecated
     */
    ReadAtNativeFramerate?: boolean;
    DefaultAudioStreamIndex?: (number) | null;
    DefaultSubtitleStreamIndex?: (number) | null;
    /**
     * Used only by our Windows app. Not used by Emby Server. The id of the item that this mediasource belongs to, if there is one Also used by Emby for Kodi
     */
    ItemId?: string;
    /**
     * Used only by our Windows app. Not used by Emby Server.
     */
    ServerId?: string;
};

/**
 * Class ChapterInfo
 *
 */
export type ChapterInfo = {
    /**
     * The start position ticks.
     */
    StartPositionTicks?: number;
    /**
     * The name.
     */
    Name?: string;
    ImageTag?: string;
    MarkerType?: MarkerType;
    ChapterIndex?: number;
};

export type MarkerType = 'Chapter' | 'IntroStart' | 'IntroEnd' | 'CreditsStart';

export type MediaProtocol = 'File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp' | 'Mms';

export type MediaSourceType = 'Default' | 'Grouping' | 'Placeholder';

/**
 * MediaStream information.
 *
 *
 * MediaStream itens are typically included in a `MediaBrowser.Model.Dto.MediaSourceInfo` object.
 *
 *
 * `MediaBrowser.Model.Dto.MediaSourceInfo.MediaStreams`
 *
 */
export type MediaStream = {
    /**
     * The codec.
     *
     * Probe Field: `codec_name`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`
     * Related Enums: `T:Emby.Media.Model.Enums.VideoMediaTypes`, `Emby.Media.Model.Enums.AudioMediaTypes`, `Emby.Media.Model.Enums.SubtitleMediaTypes`.
     */
    Codec?: string;
    /**
     * The codec tag.
     *
     * Probe Field: `codec_tag`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    CodecTag?: string;
    /**
     * The language.
     *
     * Probe Field: `tags["language"]`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    Language?: string;
    /**
     * The color transfer characteristics.
     *
     * Probe Field: `color_transfer`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`
     * Related Enum: `Emby.Media.Model.Enums.ColorTransfers`.
     */
    ColorTransfer?: string;
    /**
     * The chromaticity coordinates of the source primaries.
     *
     * Probe Field: `color_primaries`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`
     * Related Enum: `Emby.Media.Model.Enums.ColorPrimaries`.
     */
    ColorPrimaries?: string;
    /**
     * The YUV colorspace type.
     *
     * Probe Field: `color_space`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`
     * Related Enum: `Emby.Media.Model.Enums.ColorSpaces`.
     */
    ColorSpace?: string;
    /**
     * The comment.
     *
     * Probe Field: `tags["comment"]`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    Comment?: string;
    /**
     * The start time of the stream.
     *
     * Probe Field: `start_time`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     * Actual type: `System.TimeSpan`.
     */
    StreamStartTimeTicks?: (number) | null;
    /**
     * The time\-base.
     *
     * Probe Field: `time_base`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     * Actual type: `Emby.Media.Model.Types.Rational`.
     */
    TimeBase?: string;
    /**
     * The title.
     *
     * Probe Field: `tags["title"]`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    Title?: string;
    /**
     * The extradata.
     *
     * Probe Field: `extradata`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     *
     * Currently, this value is only parsed for subtitle streams with codec `Emby.Media.Model.Enums.SubtitleMediaTypes.dvb_teletext`.
     */
    Extradata?: string;
    VideoRange?: string;
    /**
     * The display title.
     *
     * Custom property set by the application.
     */
    DisplayTitle?: string;
    /**
     * The display language.
     *
     * Custom property set by the application.
     */
    DisplayLanguage?: string;
    /**
     * The nal length size.
     *
     * Probe Field: `nal_length_size`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video` of type `Emby.Media.Model.Enums.VideoMediaTypes.h264`.
     * Actual type: `System.Int32`.
     */
    NalLengthSize?: string;
    /**
     * A value indicating whether this instance is interlaced.
     *
     * Probe Field: `field_order` \!\= `progressive`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     */
    IsInterlaced?: boolean;
    /**
     * @deprecated
     */
    IsAVC?: (boolean) | null;
    /**
     * The channel layout.
     *
     * Probe Field: `channel_layout`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Audio`
     * Related Enum: `MediaBrowser.Model.Entities.MediaStream.ChannelLayout`.
     */
    ChannelLayout?: string;
    /**
     * The bit rate.
     *
     * Probe Field: `bit_rate`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`.
     *
     * THIS VALUE IS PROCESSED BY CUSTOM LOGIC AND DOES NOT NECESSARILY MATCH FFPROBE RESULTS\!
     */
    BitRate?: (number) | null;
    /**
     * The bit depth.
     *
     * Probe Field: `bits_per_sample` or `bits_per_raw_sample`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`.
     */
    BitDepth?: (number) | null;
    /**
     * The reference frames.
     *
     * Probe Field: `refs`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     */
    RefFrames?: (number) | null;
    Rotation?: (number) | null;
    /**
     * The audio channel count.
     *
     * Probe Field: `channels`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Audio`.
     */
    Channels?: (number) | null;
    /**
     * The sample rate.
     *
     * Probe Field: `sample_rate`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Audio`
     * Related Enum: `Emby.Media.Model.Enums.SampleRates`.
     */
    SampleRate?: (number) | null;
    /**
     * A value indicating whether this instance is default.
     *
     * Probe Field: `disposition["default"]`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    IsDefault?: boolean;
    /**
     * A value indicating whether this instance is forced.
     *
     * Probe Field: `disposition["forced"]`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    IsForced?: boolean;
    IsHearingImpaired?: boolean;
    /**
     * The height.
     *
     * Probe Field: `height`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     */
    Height?: (number) | null;
    /**
     * The width.
     *
     * Probe Field: `width`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     */
    Width?: (number) | null;
    /**
     * The average frame rate..
     *
     * Probe Field: `avg_frame_rate`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     * Actual type: `Emby.Media.Model.Types.Rational`.
     */
    AverageFrameRate?: (number) | null;
    /**
     * The real frame rate..
     *
     * Probe Field: `r_frame_rate`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     * Actual type: `Emby.Media.Model.Types.Rational`.
     */
    RealFrameRate?: (number) | null;
    /**
     * The profile.
     *
     * Probe Field: `profile`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`
     * Related Enums: `Emby.Media.Model.Enums.AacProfiles`, `Emby.Media.Model.Enums.AvcProfiles`, `Emby.Media.Model.Enums.H263Profiles`, `Emby.Media.Model.Enums.HevcProfiles`, `Emby.Media.Model.Enums.Mpeg2Profiles`,`Emby.Media.Model.Enums.Vc1Profiles`, `Emby.Media.Model.Enums.Mpeg4Profiles`, `Emby.Media.Model.Enums.Vp8Profiles`, `Emby.Media.Model.Enums.Vp9Profiles`.
     */
    Profile?: string;
    Type?: MediaStreamType;
    /**
     * The aspect ratio.
     *
     * Probe Field: `display_aspect_ratio`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     * Actual type: `Emby.Media.Model.Types.Rational`.
     */
    AspectRatio?: string;
    /**
     * The index of the stream inside its container.
     *
     * Probe Field: `index`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    Index?: number;
    /**
     * A value indicating whether this instance is external.
     *
     * Custom property set by the application.
     */
    IsExternal?: boolean;
    DeliveryMethod?: SubtitleDeliveryMethod;
    /**
     * The delivery URL.
     *
     * Custom property set by the application.
     */
    DeliveryUrl?: string;
    /**
     * A value indicating whether this instance is external URL.
     *
     * Custom property set by the application.
     */
    IsExternalUrl?: (boolean) | null;
    IsTextSubtitleStream?: boolean;
    /**
     * A value indicating whether \[supports external stream\].
     */
    SupportsExternalStream?: boolean;
    /**
     * The filename.
     */
    Path?: string;
    Protocol?: MediaProtocol;
    /**
     * The pixel format.
     *
     * Probe Field: `pix_fmt`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     * Actual type: `MediaBrowser.Model.Entities.MediaStream.PixelFormat`.
     */
    PixelFormat?: string;
    /**
     * The codec level.
     *
     * Probe Field: `level`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`
     * Related Enums: `Emby.Media.Model.Enums.AvcLevels`, `Emby.Media.Model.Enums.H263Levels`, `Emby.Media.Model.Enums.HevcLevels`, `Emby.Media.Model.Enums.Mpeg2Levels`,`Emby.Media.Model.Enums.Vc1Levels`, `Emby.Media.Model.Enums.Mpeg4Levels`, `Emby.Media.Model.Enums.Vp8Levels`, `Emby.Media.Model.Enums.Vp9Levels`.
     */
    Level?: (number) | null;
    /**
     * A value indicating whether this instance is anamorphic.
     */
    IsAnamorphic?: (boolean) | null;
    ExtendedVideoType?: ExtendedVideoTypes;
    ExtendedVideoSubType?: ExtendedVideoSubTypes;
    /**
     * The extended video sub\-type description.
     */
    ExtendedVideoSubTypeDescription?: string;
    /**
     * Used only by our Windows app. Not used by Emby Server.
     */
    ItemId?: string;
    /**
     * Used only by our Windows app. Not used by Emby Server.
     */
    ServerId?: string;
    /**
     * The size of the attachment.
     */
    AttachmentSize?: (number) | null;
    /**
     * The type of the MIME.
     */
    MimeType?: string;
    SubtitleLocationType?: SubtitleLocationType;
};

/**
 * Enum MediaStreamType
 *
 */
export type MediaStreamType = 'Unknown' | 'Audio' | 'Video' | 'Subtitle' | 'EmbeddedImage' | 'Attachment' | 'Data';

export type SubtitleDeliveryMethod = 'Encode' | 'Embed' | 'External' | 'Hls' | 'VideoSideData';

export type ExtendedVideoTypes = 'None' | 'Hdr10' | 'Hdr10Plus' | 'HyperLogGamma' | 'DolbyVision';

export type ExtendedVideoSubTypes = 'None' | 'Hdr10' | 'HyperLogGamma' | 'Hdr10Plus0' | 'DoviProfile02' | 'DoviProfile10' | 'DoviProfile22' | 'DoviProfile30' | 'DoviProfile42' | 'DoviProfile50' | 'DoviProfile61' | 'DoviProfile76' | 'DoviProfile81' | 'DoviProfile82' | 'DoviProfile83' | 'DoviProfile84' | 'DoviProfile85' | 'DoviProfile92';

export type SubtitleLocationType = 'InternalStream' | 'VideoSideData';

export type TransportStreamTimestamp = 'None' | 'Zero' | 'Valid';

export type MediaUrl = {
    Url?: string;
    Name?: string;
};

export type ProviderIdDictionary = {
    [key: string]: (string);
};

/**
 * This is used by the api to get information about a Person within a BaseItem
 *
 */
export type BaseItemPerson = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The identifier.
     */
    Id?: string;
    /**
     * The role.
     */
    Role?: string;
    Type?: PersonType;
    /**
     * The primary image tag.
     */
    PrimaryImageTag?: string;
};

export type PersonType = 'Actor' | 'Director' | 'Writer' | 'Producer' | 'GuestStar' | 'Composer' | 'Conductor' | 'Lyricist';

export type NameLongIdPair = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The identifier.
     */
    Id?: number;
};

/**
 * Class UserItemDataDto
 *
 */
export type UserItemDataDto = {
    /**
     * The rating.
     */
    Rating?: (number) | null;
    /**
     * The played percentage.
     */
    PlayedPercentage?: (number) | null;
    /**
     * The unplayed item count.
     */
    UnplayedItemCount?: (number) | null;
    /**
     * The playback position ticks.
     */
    PlaybackPositionTicks?: number;
    /**
     * The play count.
     */
    PlayCount?: (number) | null;
    /**
     * A value indicating whether this instance is favorite.
     */
    IsFavorite?: boolean;
    /**
     * The last played date.
     */
    LastPlayedDate?: (string) | null;
    /**
     * A value indicating whether this `MediaBrowser.Model.Dto.UserItemDataDto` is played.
     */
    Played?: boolean;
    /**
     * The key.
     */
    Key?: string;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * Used only by our Windows app. Not used by Emby Server.
     */
    ServerId?: string;
};

export type DayOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday';

export type NameIdPair = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The identifier.
     */
    Id?: string;
};

/**
 * Enum LocationType
 *
 */
export type LocationType = 'FileSystem' | 'Virtual';

/**
 * Enum MetadataFields
 *
 */
export type MetadataFields = 'Cast' | 'Genres' | 'ProductionLocations' | 'Studios' | 'Tags' | 'Name' | 'Overview' | 'Runtime' | 'OfficialRating' | 'Collections' | 'ChannelNumber' | 'SortName' | 'OriginalTitle' | 'SortIndexNumber' | 'SortParentIndexNumber' | 'CommunityRating' | 'CriticRating' | 'Tagline' | 'Composers' | 'Artists' | 'AlbumArtists';

export type Drawing_ImageOrientation = 'TopLeft' | 'TopRight' | 'BottomRight' | 'BottomLeft' | 'LeftTop' | 'RightTop' | 'RightBottom' | 'LeftBottom';

export type LiveTv_TimerType = 'Program' | 'DateTime' | 'Keyword';

export type QueryResult_UserLibrary_TagItem = {
    Items?: Array<UserLibrary_TagItem>;
    TotalRecordCount?: number;
};

export type UserLibrary_TagItem = {
    Name?: string;
    Id?: string;
};

export type Collections_CollectionCreationResult = {
    Id?: string;
    Name?: string;
};

export type QueryResult_Devices_DeviceInfo = {
    Items?: Array<Devices_DeviceInfo>;
    TotalRecordCount?: number;
};

export type Devices_DeviceInfo = {
    Name?: string;
    /**
     * The identifier.
     */
    Id?: string;
    InternalId?: number;
    ReportedDeviceId?: string;
    /**
     * The last name of the user.
     */
    LastUserName?: string;
    /**
     * The name of the application.
     */
    AppName?: string;
    /**
     * The application version.
     */
    AppVersion?: string;
    /**
     * The last user identifier.
     */
    LastUserId?: string;
    DateLastActivity?: string;
    IconUrl?: string;
    IpAddress?: string;
};

export type FeatureInfo = {
    Name?: string;
    Id?: string;
    FeatureType?: FeatureType;
};

export type FeatureType = 'System' | 'User';

export type QueryResult_UserLibrary_OfficialRatingItem = {
    Items?: Array<UserLibrary_OfficialRatingItem>;
    TotalRecordCount?: number;
};

export type UserLibrary_OfficialRatingItem = {
    Name?: string;
};

/**
 * Class PackageInfo
 *
 */
export type PackageInfo = {
    /**
     * The internal id of this package.
     */
    id?: string;
    /**
     * The name.
     */
    name?: string;
    /**
     * The short description.
     */
    shortDescription?: string;
    /**
     * The overview.
     */
    overview?: string;
    /**
     * A value indicating whether this instance is premium.
     */
    isPremium?: boolean;
    /**
     * A value indicating whether this instance is adult only content.
     */
    adult?: boolean;
    /**
     * The rich desc URL.
     */
    richDescUrl?: string;
    /**
     * The thumb image.
     */
    thumbImage?: string;
    /**
     * The preview image.
     */
    previewImage?: string;
    /**
     * The type.
     */
    type?: string;
    /**
     * The target filename.
     */
    targetFilename?: string;
    /**
     * The owner.
     */
    owner?: string;
    /**
     * The category.
     */
    category?: string;
    /**
     * The catalog tile color.
     */
    tileColor?: string;
    /**
     * The feature id of this package (if premium).
     */
    featureId?: string;
    /**
     * The price for this package (if premium).
     */
    price?: (number) | null;
    targetSystem?: PackageTargetSystem;
    /**
     * The guid of the assembly associated with this package (if a plug\-in). This is used to identify the proper item for automatic updates.
     */
    guid?: string;
    /**
     * Whether or not this package is registered.
     */
    isRegistered?: boolean;
    /**
     * The expiration date for this package.
     */
    expDate?: string;
    /**
     * The versions.
     */
    versions?: Array<PackageVersionInfo>;
    /**
     * A value indicating whether \[enable in application store\].
     */
    enableInAppStore?: boolean;
    /**
     * The installs.
     */
    installs?: number;
};

/**
 * Enum PackageType
 *
 */
export type PackageTargetSystem = 'Server' | 'MBTheater' | 'MBClassic' | 'Other';

/**
 * Class PackageVersionInfo
 *
 */
export type PackageVersionInfo = {
    /**
     * The name.
     */
    name?: string;
    /**
     * The guid.
     */
    guid?: string;
    /**
     * The version STR.
     */
    versionStr?: string;
    classification?: PackageVersionClass;
    /**
     * The description.
     */
    description?: string;
    /**
     * The required version STR.
     */
    requiredVersionStr?: string;
    /**
     * The source URL.
     */
    sourceUrl?: string;
    /**
     * The source URL.
     */
    checksum?: string;
    /**
     * The target filename.
     */
    targetFilename?: string;
    infoUrl?: string;
    runtimes?: string;
    timestamp?: (string) | null;
};

/**
 * Enum PackageVersionClass
 *
 */
export type PackageVersionClass = 'Release' | 'Beta' | 'Dev';

export type Playlists_PlaylistCreationResult = {
    Id?: string;
    Name?: string;
    ItemAddedCount?: number;
};

/**
 * This is a serializable stub class that is used by the api to provide information about installed plugins.
 *
 */
export type Plugins_PluginInfo = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The version.
     */
    Version?: string;
    /**
     * The name of the configuration file.
     */
    ConfigurationFileName?: string;
    /**
     * The description.
     */
    Description?: string;
    /**
     * The unique id.
     */
    Id?: string;
    /**
     * The image URL.
     */
    ImageTag?: string;
};

/**
 * Class TaskInfo
 *
 */
export type TaskInfo = {
    /**
     * The name.
     */
    Name?: string;
    State?: TaskState;
    /**
     * The progress.
     */
    CurrentProgressPercentage?: (number) | null;
    /**
     * The id.
     */
    Id?: string;
    LastExecutionResult?: TaskResult;
    /**
     * The triggers.
     */
    Triggers?: Array<TaskTriggerInfo>;
    /**
     * The description.
     */
    Description?: string;
    /**
     * The category.
     */
    Category?: string;
    /**
     * A value indicating whether this instance is hidden.
     */
    IsHidden?: boolean;
    /**
     * The key.
     */
    Key?: string;
};

/**
 * Enum TaskState
 *
 */
export type TaskState = 'Idle' | 'Cancelling' | 'Running';

/**
 * Class TaskExecutionInfo
 *
 */
export type TaskResult = {
    /**
     * The start time UTC.
     */
    StartTimeUtc?: string;
    /**
     * The end time UTC.
     */
    EndTimeUtc?: string;
    Status?: TaskCompletionStatus;
    /**
     * The name.
     */
    Name?: string;
    /**
     * The key.
     */
    Key?: string;
    /**
     * The id.
     */
    Id?: string;
    /**
     * The error message.
     */
    ErrorMessage?: string;
    /**
     * The long error message.
     */
    LongErrorMessage?: string;
};

/**
 * Enum TaskCompletionStatus
 *
 */
export type TaskCompletionStatus = 'Completed' | 'Failed' | 'Cancelled' | 'Aborted';

/**
 * Class TaskTriggerInfo
 *
 */
export type TaskTriggerInfo = {
    /**
     * The type.
     */
    Type?: string;
    /**
     * The time of day.
     */
    TimeOfDayTicks?: (number) | null;
    /**
     * The interval.
     */
    IntervalTicks?: (number) | null;
    SystemEvent?: SystemEvent;
    DayOfWeek?: DayOfWeek;
    /**
     * The maximum runtime ticks.
     */
    MaxRuntimeTicks?: (number) | null;
};

/**
 * Enum SystemEvent
 *
 */
export type SystemEvent = 'WakeFromSleep' | 'DisplayConfigurationChange' | 'NetworkChange';

/**
 * Class SessionInfo
 *
 */
export type Session_SessionInfo = {
    PlayState?: PlayerStateInfo;
    AdditionalUsers?: Array<SessionUserInfo>;
    /**
     * The remote end point.
     */
    RemoteEndPoint?: string;
    Protocol?: string;
    /**
     * The playable media types.
     */
    PlayableMediaTypes?: Array<(string)>;
    PlaylistItemId?: string;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    /**
     * The id.
     */
    Id?: string;
    ServerId?: string;
    /**
     * The user id.
     */
    UserId?: string;
    PartyId?: string;
    /**
     * The username.
     */
    UserName?: string;
    UserPrimaryImageTag?: string;
    /**
     * The type of the client.
     */
    Client?: string;
    /**
     * The last activity date.
     */
    LastActivityDate?: string;
    /**
     * The name of the device.
     */
    DeviceName?: string;
    DeviceType?: string;
    NowPlayingItem?: BaseItemDto;
    InternalDeviceId?: number;
    /**
     * The device id.
     */
    DeviceId?: string;
    /**
     * The application version.
     */
    ApplicationVersion?: string;
    /**
     * The application icon URL.
     */
    AppIconUrl?: string;
    /**
     * The supported commands.
     */
    SupportedCommands?: Array<(string)>;
    TranscodingInfo?: TranscodingInfo;
    SupportsRemoteControl?: boolean;
};

export type PlayerStateInfo = {
    /**
     * The now playing position ticks.
     */
    PositionTicks?: (number) | null;
    /**
     * A value indicating whether this instance can seek.
     */
    CanSeek?: boolean;
    /**
     * A value indicating whether this instance is paused.
     */
    IsPaused?: boolean;
    /**
     * A value indicating whether this instance is muted.
     */
    IsMuted?: boolean;
    /**
     * The volume level.
     */
    VolumeLevel?: (number) | null;
    /**
     * The index of the now playing audio stream.
     */
    AudioStreamIndex?: (number) | null;
    /**
     * The index of the now playing subtitle stream.
     */
    SubtitleStreamIndex?: (number) | null;
    /**
     * The now playing media version identifier.
     */
    MediaSourceId?: string;
    MediaSource?: MediaSourceInfo;
    PlayMethod?: PlayMethod;
    RepeatMode?: RepeatMode;
    SleepTimerMode?: SleepTimerMode;
    SleepTimerEndTime?: (string) | null;
    SubtitleOffset?: number;
    Shuffle?: boolean;
    PlaybackRate?: number;
};

export type PlayMethod = 'Transcode' | 'DirectStream' | 'DirectPlay';

export type RepeatMode = 'RepeatNone' | 'RepeatAll' | 'RepeatOne';

export type SleepTimerMode = 'None' | 'AfterItem' | 'AtTime';

/**
 * Class SessionUserInfo.
 *
 */
export type SessionUserInfo = {
    /**
     * The user identifier.
     */
    UserId?: string;
    /**
     * The name of the user.
     */
    UserName?: string;
    UserInternalId?: number;
};

export type TranscodingInfo = {
    AudioCodec?: string;
    VideoCodec?: string;
    SubProtocol?: string;
    Container?: string;
    IsVideoDirect?: boolean;
    IsAudioDirect?: boolean;
    Bitrate?: (number) | null;
    AudioBitrate?: (number) | null;
    VideoBitrate?: (number) | null;
    Framerate?: (number) | null;
    CompletionPercentage?: (number) | null;
    TranscodingPositionTicks?: (number) | null;
    TranscodingStartPositionTicks?: (number) | null;
    Width?: (number) | null;
    Height?: (number) | null;
    AudioChannels?: (number) | null;
    TranscodeReasons?: Array<TranscodeReason>;
    /**
     * Deprecated, please use ProcessStatistics instead
     * @deprecated
     */
    CurrentCpuUsage?: (number) | null;
    /**
     * Deprecated, please use ProcessStatistics instead
     * @deprecated
     */
    AverageCpuUsage?: (number) | null;
    /**
     * Deprecated, please use ProcessStatistics instead
     * @deprecated
     */
    CpuHistory?: Array<Tuple_Double_Double>;
    ProcessStatistics?: ProcessRun_Metrics_ProcessStatistics;
    CurrentThrottle?: (number) | null;
    VideoDecoder?: string;
    VideoDecoderIsHardware?: boolean;
    VideoDecoderMediaType?: string;
    VideoDecoderHwAccel?: string;
    VideoEncoder?: string;
    VideoEncoderIsHardware?: boolean;
    VideoEncoderMediaType?: string;
    VideoEncoderHwAccel?: string;
    VideoPipelineInfo?: Array<Transcoding_VpStepInfo>;
    SubtitlePipelineInfos?: Array<Array<Transcoding_VpStepInfo>>;
};

export type TranscodeReason = 'ContainerNotSupported' | 'VideoCodecNotSupported' | 'AudioCodecNotSupported' | 'ContainerBitrateExceedsLimit' | 'AudioBitrateNotSupported' | 'AudioChannelsNotSupported' | 'VideoResolutionNotSupported' | 'UnknownVideoStreamInfo' | 'UnknownAudioStreamInfo' | 'AudioProfileNotSupported' | 'AudioSampleRateNotSupported' | 'AnamorphicVideoNotSupported' | 'InterlacedVideoNotSupported' | 'SecondaryAudioNotSupported' | 'RefFramesNotSupported' | 'VideoBitDepthNotSupported' | 'VideoBitrateNotSupported' | 'VideoFramerateNotSupported' | 'VideoLevelNotSupported' | 'VideoProfileNotSupported' | 'AudioBitDepthNotSupported' | 'SubtitleCodecNotSupported' | 'DirectPlayError' | 'VideoRangeNotSupported' | 'SubtitleContentOptionsEnabled' | 'ExternalAudioNotSupported' | 'AudioDelayNotSupported';

export type Tuple_Double_Double = {
    Item1?: number;
    Item2?: number;
};

export type ProcessRun_Metrics_ProcessStatistics = {
    /**
     * The current cpu.
     */
    CurrentCpu?: number;
    /**
     * The average cpu.
     */
    AverageCpu?: number;
    /**
     * The currently allocated virtual memory.
     */
    CurrentVirtualMemory?: number;
    /**
     * The currently allocated working set.
     */
    CurrentWorkingSet?: number;
    /**
     * The metrics.
     */
    Metrics?: Array<ProcessRun_Metrics_ProcessMetricPoint>;
};

export type ProcessRun_Metrics_ProcessMetricPoint = {
    /**
     * The time.
     */
    Time?: string;
    /**
     * The cpu percent.
     */
    CpuPercent?: number;
    /**
     * The virtual memory.
     */
    VirtualMemory?: number;
    /**
     * The working set.
     */
    WorkingSet?: number;
};

export type Transcoding_VpStepInfo = {
    StepType?: Transcoding_VpStepTypes;
    StepTypeName?: string;
    HardwareContextName?: string;
    IsHardwareContext?: boolean;
    Name?: string;
    Short?: string;
    FfmpegName?: string;
    FfmpegDescription?: string;
    FfmpegOptions?: string;
    Param?: string;
    ParamShort?: string;
};

/**
 * Video Processing Step Type enum.
 *
 */
export type Transcoding_VpStepTypes = 'Decoder' | 'Encoder' | 'Scaling' | 'Deinterlace' | 'SubtitleOverlay' | 'ToneMapping' | 'ColorConversion' | 'SplitCaptions' | 'TextSub2Video' | 'GraphicSub2Video' | 'GraphicSub2Text' | 'BurnInTextSubs' | 'BurnInGraphicSubs' | 'ScaleSubs' | 'TextMod' | 'Censor' | 'ShowSpeaker' | 'StripStyles' | 'ConnectTo' | 'Rotate';

/**
 * Enum ImageType
 *
 */
export type ImageType = 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail' | 'LogoLight' | 'LogoLightColor';

export type NameValuePair = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The value.
     */
    Value?: string;
};

export type MBBackup_Api_RestoreOptions = {
    RestoreServerId?: boolean;
    UseFiles?: string;
};

export type MBBackup_Api_DataRestoreOptions = {
    Users?: Array<MBBackup_Api_UserRestoreInfo>;
};

export type MBBackup_Api_UserRestoreInfo = {
    SourceUserId?: string;
    TargetUserId?: string;
};

export type MBBackup_Api_AllBackupsInfo = {
    FullBackupInfo?: MBBackup_BackupInfo;
    LightBackups?: Array<MBBackup_BackupInfo>;
};

export type MBBackup_BackupInfo = {
    ServerVersion?: string;
    PluginVersion?: string;
    Name?: string;
    CanRestore?: boolean;
    IsFullBackup?: boolean;
    DateCreated?: string;
    Users?: Array<NameIdPair>;
};

export type Branding_BrandingOptions = {
    /**
     * The login disclaimer.
     */
    LoginDisclaimer?: string;
    /**
     * The custom CSS.
     */
    CustomCss?: string;
};

export type Connect_ConnectAuthenticationExchangeResult = {
    LocalUserId?: string;
    AccessToken?: string;
};

export type Devices_DeviceOptions = {
    CustomName?: string;
};

export type Devices_ContentUploadHistory = {
    DeviceId?: string;
    FilesUploaded?: Array<Devices_LocalFileInfo>;
};

export type Devices_LocalFileInfo = {
    Name?: string;
    Id?: string;
    Album?: string;
    MimeType?: string;
    DateCreated?: (string) | null;
};

export type DisplayPreferences = {
    Id?: string;
    SortBy?: string;
    CustomPrefs?: {
        [key: string]: (string);
    };
    SortOrder?: SortOrder;
    Client?: string;
};

/**
 * Enum SortOrder
 *
 */
export type SortOrder = 'Ascending' | 'Descending';

export type Dlna_Profiles_DlnaProfile = {
    Type?: Dlna_Profiles_DeviceProfileType;
    Path?: string;
    UserId?: string;
    AlbumArtPn?: string;
    MaxAlbumArtWidth?: number;
    MaxAlbumArtHeight?: number;
    MaxIconWidth?: (number) | null;
    MaxIconHeight?: (number) | null;
    FriendlyName?: string;
    Manufacturer?: string;
    ManufacturerUrl?: string;
    ModelName?: string;
    ModelDescription?: string;
    ModelNumber?: string;
    ModelUrl?: string;
    SerialNumber?: string;
    EnableAlbumArtInDidl?: boolean;
    EnableSingleAlbumArtLimit?: boolean;
    EnableSingleSubtitleLimit?: boolean;
    ProtocolInfo?: string;
    TimelineOffsetSeconds?: number;
    RequiresPlainVideoItems?: boolean;
    RequiresPlainFolders?: boolean;
    IgnoreTranscodeByteRangeRequests?: boolean;
    SupportsSamsungBookmark?: boolean;
    Identification?: Dlna_Profiles_DeviceIdentification;
    ProtocolInfoDetection?: Dlna_Profiles_ProtocolInfoDetection;
    /**
     * The name.
     */
    Name?: string;
    Id?: string;
    SupportedMediaTypes?: string;
    MaxStreamingBitrate?: (number) | null;
    MusicStreamingTranscodingBitrate?: (number) | null;
    MaxStaticMusicBitrate?: (number) | null;
    DeclaredFeatures?: Array<(string)>;
    /**
     * The direct play profiles.
     */
    DirectPlayProfiles?: Array<DirectPlayProfile>;
    /**
     * The transcoding profiles.
     */
    TranscodingProfiles?: Array<TranscodingProfile>;
    ContainerProfiles?: Array<ContainerProfile>;
    CodecProfiles?: Array<CodecProfile>;
    ResponseProfiles?: Array<ResponseProfile>;
    SubtitleProfiles?: Array<SubtitleProfile>;
};

export type Dlna_Profiles_DeviceProfileType = 'System' | 'User';

export type Dlna_Profiles_DeviceIdentification = {
    FriendlyName?: string;
    ModelNumber?: string;
    SerialNumber?: string;
    ModelName?: string;
    ModelDescription?: string;
    DeviceDescription?: string;
    ModelUrl?: string;
    Manufacturer?: string;
    ManufacturerUrl?: string;
    Headers?: Array<Dlna_Profiles_HttpHeaderInfo>;
};

export type Dlna_Profiles_HttpHeaderInfo = {
    Name?: string;
    Value?: string;
    Match?: Dlna_Profiles_HeaderMatchType;
};

export type Dlna_Profiles_HeaderMatchType = 'Equals' | 'Regex' | 'Substring';

export type Dlna_Profiles_ProtocolInfoDetection = {
    EnabledForVideo?: boolean;
    EnabledForAudio?: boolean;
    EnabledForPhotos?: boolean;
};

export type DirectPlayProfile = {
    Container?: string;
    AudioCodec?: string;
    VideoCodec?: string;
    Type?: DlnaProfileType;
};

export type DlnaProfileType = 'Audio' | 'Video' | 'Photo';

export type TranscodingProfile = {
    Container?: string;
    Type?: DlnaProfileType;
    VideoCodec?: string;
    AudioCodec?: string;
    Protocol?: string;
    EstimateContentLength?: boolean;
    EnableMpegtsM2TsMode?: boolean;
    TranscodeSeekInfo?: TranscodeSeekInfo;
    CopyTimestamps?: boolean;
    Context?: EncodingContext;
    MaxAudioChannels?: string;
    MinSegments?: number;
    SegmentLength?: number;
    BreakOnNonKeyFrames?: boolean;
    AllowInterlacedVideoStreamCopy?: boolean;
    ManifestSubtitles?: string;
    MaxManifestSubtitles?: number;
    MaxWidth?: number;
    MaxHeight?: number;
    FillEmptySubtitleSegments?: boolean;
};

export type TranscodeSeekInfo = 'Auto' | 'Bytes';

export type EncodingContext = 'Streaming' | 'Static';

export type ContainerProfile = {
    Type?: DlnaProfileType;
    Conditions?: Array<ProfileCondition>;
    Container?: string;
};

export type ProfileCondition = {
    Condition?: ProfileConditionType;
    Property?: ProfileConditionValue;
    Value?: string;
    IsRequired?: boolean;
};

export type ProfileConditionType = 'Equals' | 'NotEquals' | 'LessThanEqual' | 'GreaterThanEqual' | 'EqualsAny';

export type ProfileConditionValue = 'AudioChannels' | 'AudioBitrate' | 'AudioProfile' | 'Width' | 'Height' | 'Has64BitOffsets' | 'PacketLength' | 'VideoBitDepth' | 'VideoBitrate' | 'VideoFramerate' | 'VideoLevel' | 'VideoProfile' | 'VideoTimestamp' | 'IsAnamorphic' | 'RefFrames' | 'NumAudioStreams' | 'NumVideoStreams' | 'IsSecondaryAudio' | 'VideoCodecTag' | 'IsAvc' | 'IsInterlaced' | 'AudioSampleRate' | 'AudioBitDepth' | 'VideoRange' | 'VideoRotation' | 'IsExternalAudio';

export type CodecProfile = {
    Type?: CodecType;
    Conditions?: Array<ProfileCondition>;
    ApplyConditions?: Array<ProfileCondition>;
    Codec?: string;
    Container?: string;
};

export type CodecType = 'Video' | 'VideoAudio' | 'Audio';

export type ResponseProfile = {
    Container?: string;
    AudioCodec?: string;
    VideoCodec?: string;
    Type?: DlnaProfileType;
    OrgPn?: string;
    MimeType?: string;
    Conditions?: Array<ProfileCondition>;
};

export type SubtitleProfile = {
    Format?: string;
    Method?: SubtitleDeliveryMethod;
    DidlMode?: string;
    Language?: string;
    Container?: string;
    Protocol?: string;
};

export type Configuration_ToneMapping_ToneMapOptionsVisibility = {
    ShowAdvanced?: boolean;
    IsSoftwareToneMappingAvailable?: boolean;
    IsAnyHardwareToneMappingAvailable?: boolean;
    ShowNvidiaOptions?: boolean;
    ShowQuickSyncOptions?: boolean;
    ShowVaapiOptions?: boolean;
    IsOpenClAvailable?: boolean;
    IsOpenClSuperTAvailable?: boolean;
    IsVaapiNativeAvailable?: boolean;
    IsQuickSyncNativeAvailable?: boolean;
    OperatingSystem?: OperatingSystem;
};

export type OperatingSystem = 'Windows' | 'Linux' | 'OSX' | 'BSD' | 'Android';

export type EditObjectContainer = {
    Object?: {
        [key: string]: unknown;
    };
    DefaultObject?: {
        [key: string]: unknown;
    };
    TypeName?: string;
    EditorRoot?: Editors_EditorRoot;
};

export type Editors_EditorRoot = {
    PropertyConditions?: Array<Conditions_PropertyCondition>;
    PostbackActions?: Array<Actions_PostbackAction>;
    TitleButton?: Editors_EditorButtonItem;
    EditorItems?: Array<Editors_EditorBase>;
    EditorType?: Common_EditorTypes;
    Name?: string;
    Id?: string;
    AllowEmpty?: boolean;
    IsReadOnly?: boolean;
    IsAdvanced?: boolean;
    DisplayName?: string;
    Description?: string;
    FeatureRequiresPremiere?: boolean;
    ParentId?: string;
};

export type Conditions_PropertyCondition = {
    AffectedPropertyId?: string;
    ConditionType?: Conditions_PropertyConditionType;
    /**
     * The target property name or path.
     */
    TargetPropertyId?: string;
    SimpleCondition?: Attributes_SimpleCondition;
    ValueCondition?: Attributes_ValueCondition;
    /**
     * The value.
     */
    Value?: {
        [key: string]: unknown;
    };
};

export type Conditions_PropertyConditionType = 'Visible' | 'Enabled';

/**
 * Conditions on the source value.
 *
 */
export type Attributes_SimpleCondition = 'IsTrue' | 'IsFalse' | 'IsNull' | 'IsNotNullOrEmpty';

/**
 * Conditions for comparing with a target value.
 *
 */
export type Attributes_ValueCondition = 'IsEqual' | 'IsNotEqual' | 'IsGreater' | 'IsGreaterOrEqual' | 'IsLess' | 'IsLessOrEqual';

export type Actions_PostbackAction = {
    TargetEditorId?: string;
    PostbackCommandId?: string;
    CommandParameterPropertyId?: string;
};

export type Editors_EditorButtonItem = {
    EditorType?: Common_EditorTypes;
    Name?: string;
    Id?: string;
    AllowEmpty?: boolean;
    IsReadOnly?: boolean;
    IsAdvanced?: boolean;
    DisplayName?: string;
    Description?: string;
    FeatureRequiresPremiere?: boolean;
    ParentId?: string;
};

export type Common_EditorTypes = 'Group' | 'Text' | 'Numeric' | 'Boolean' | 'SelectSingle' | 'SelectMultiple' | 'Date' | 'FilePath' | 'FolderPath' | 'StatusItem' | 'ProgressItem' | 'ButtonItem' | 'ButtonGroup' | 'CaptionItem' | 'LabelItem' | 'ItemList' | 'RadioGroup' | 'DxDataGrid' | 'DxPivotGrid' | 'SpacerItem';

export type Editors_EditorBase = {
    EditorType?: Common_EditorTypes;
    Name?: string;
    Id?: string;
    AllowEmpty?: boolean;
    IsReadOnly?: boolean;
    IsAdvanced?: boolean;
    DisplayName?: string;
    Description?: string;
    FeatureRequiresPremiere?: boolean;
    ParentId?: string;
};

export type MediaEncoding_CodecParameterContext = 'Playback' | 'Conversion';

export type ValidatePath = {
    ValidateWriteable?: boolean;
    IsFile?: (boolean) | null;
    Username?: string;
    Password?: string;
};

export type DefaultDirectoryBrowserInfo = {
    Path?: string;
};

/**
 * Class FileSystemEntryInfo
 *
 */
export type IO_FileSystemEntryInfo = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The path.
     */
    Path?: string;
    Type?: IO_FileSystemEntryType;
};

/**
 * Enum FileSystemEntryType
 *
 */
export type IO_FileSystemEntryType = 'File' | 'Directory' | 'NetworkComputer' | 'NetworkShare';

export type GetDirectoryContents = {
    Username?: string;
    Password?: string;
};

export type UserLibrary_UpdateUserItemAccess = {
    ItemIds?: Array<(string)>;
    UserIds?: Array<(string)>;
    ItemAccess?: UserItemShareLevel;
};

export type UserItemShareLevel = 'None' | 'Read' | 'Write' | 'Manage' | 'ManageDelete';

/**
 * Class LibrarySummary
 *
 */
export type ItemCounts = {
    /**
     * The movie count.
     */
    MovieCount?: number;
    /**
     * The series count.
     */
    SeriesCount?: number;
    /**
     * The episode count.
     */
    EpisodeCount?: number;
    /**
     * The game count.
     */
    GameCount?: number;
    ArtistCount?: number;
    ProgramCount?: number;
    /**
     * The game system count.
     */
    GameSystemCount?: number;
    /**
     * The trailer count.
     */
    TrailerCount?: number;
    /**
     * The song count.
     */
    SongCount?: number;
    /**
     * The album count.
     */
    AlbumCount?: number;
    /**
     * The music video count.
     */
    MusicVideoCount?: number;
    /**
     * The box set count.
     */
    BoxSetCount?: number;
    /**
     * The book count.
     */
    BookCount?: number;
    ItemCount?: number;
};

export type Persistence_IntroDebugInfo = {
    Id?: number;
    Path?: string;
    Start?: number;
    End?: number;
};

export type LibraryOptionsResult = {
    MetadataSavers?: Array<LibraryOptionInfo>;
    MetadataReaders?: Array<LibraryOptionInfo>;
    SubtitleFetchers?: Array<LibraryOptionInfo>;
    LyricsFetchers?: Array<LibraryOptionInfo>;
    TypeOptions?: Array<LibraryTypeOptions>;
    DefaultLibraryOptions?: LibraryOptions;
};

export type LibraryOptionInfo = {
    Name?: string;
    SetupUrl?: string;
    DefaultEnabled?: boolean;
    Features?: Array<MetadataFeatures>;
};

export type MetadataFeatures = 'Collections' | 'Adult' | 'RequiredSetup';

export type LibraryTypeOptions = {
    Type?: string;
    MetadataFetchers?: Array<LibraryOptionInfo>;
    ImageFetchers?: Array<LibraryOptionInfo>;
    SupportedImageTypes?: Array<ImageType>;
    DefaultImageOptions?: Array<ImageOption>;
};

export type ImageOption = {
    Type?: ImageType;
    /**
     * The limit.
     */
    Limit?: number;
    /**
     * The minimum width.
     */
    MinWidth?: number;
};

export type LibraryOptions = {
    EnableArchiveMediaFiles?: boolean;
    EnablePhotos?: boolean;
    EnableRealtimeMonitor?: boolean;
    EnableMarkerDetection?: boolean;
    EnableMarkerDetectionDuringLibraryScan?: boolean;
    IntroDetectionFingerprintLength?: number;
    EnableChapterImageExtraction?: boolean;
    ExtractChapterImagesDuringLibraryScan?: boolean;
    DownloadImagesInAdvance?: boolean;
    CacheImages?: boolean;
    ExcludeFromSearch?: boolean;
    EnablePlexIgnore?: boolean;
    PathInfos?: Array<MediaPathInfo>;
    IgnoreHiddenFiles?: boolean;
    IgnoreFileExtensions?: Array<(string)>;
    SaveLocalMetadata?: boolean;
    SaveMetadataHidden?: boolean;
    SaveLocalThumbnailSets?: boolean;
    ImportPlaylists?: boolean;
    EnableAutomaticSeriesGrouping?: boolean;
    ShareEmbeddedMusicAlbumImages?: boolean;
    EnableEmbeddedTitles?: boolean;
    EnableAudioResume?: boolean;
    AutoGenerateChapters?: boolean;
    MergeTopLevelFolders?: boolean;
    AutoGenerateChapterIntervalMinutes?: number;
    AutomaticRefreshIntervalDays?: number;
    PlaceholderMetadataRefreshIntervalDays?: number;
    /**
     * The preferred metadata language.
     */
    PreferredMetadataLanguage?: string;
    PreferredImageLanguage?: string;
    ContentType?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataSavers?: Array<(string)>;
    DisabledLocalMetadataReaders?: Array<(string)>;
    LocalMetadataReaderOrder?: Array<(string)>;
    DisabledLyricsFetchers?: Array<(string)>;
    SaveLyricsWithMedia?: boolean;
    LyricsDownloadMaxAgeDays?: number;
    LyricsFetcherOrder?: Array<(string)>;
    LyricsDownloadLanguages?: Array<(string)>;
    DisabledSubtitleFetchers?: Array<(string)>;
    SubtitleFetcherOrder?: Array<(string)>;
    SkipSubtitlesIfEmbeddedSubtitlesPresent?: boolean;
    SkipSubtitlesIfAudioTrackMatches?: boolean;
    SubtitleDownloadLanguages?: Array<(string)>;
    SubtitleDownloadMaxAgeDays?: number;
    RequirePerfectSubtitleMatch?: boolean;
    SaveSubtitlesWithMedia?: boolean;
    ForcedSubtitlesOnly?: boolean;
    HearingImpairedSubtitlesOnly?: boolean;
    TypeOptions?: Array<TypeOptions>;
    CollapseSingleItemFolders?: boolean;
    EnableAdultMetadata?: boolean;
    ImportCollections?: boolean;
    EnableMultiVersionByFiles?: boolean;
    EnableMultiVersionByMetadata?: boolean;
    EnableMultiPartItems?: boolean;
    MinCollectionItems?: number;
    MusicFolderStructure?: string;
    /**
     * The minimum percentage of an item that must be played in order for playstate to be updated.
     */
    MinResumePct?: number;
    /**
     * The maximum percentage of an item that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
     */
    MaxResumePct?: number;
    /**
     * The minimum duration that an item must have in order to be eligible for playstate updates..
     */
    MinResumeDurationSeconds?: number;
    ThumbnailImagesIntervalSeconds?: number;
    SampleIgnoreSize?: number;
};

export type MediaPathInfo = {
    Path?: string;
    NetworkPath?: string;
    Username?: string;
    Password?: string;
};

export type TypeOptions = {
    Type?: string;
    MetadataFetchers?: Array<(string)>;
    MetadataFetcherOrder?: Array<(string)>;
    ImageFetchers?: Array<(string)>;
    ImageFetcherOrder?: Array<(string)>;
    ImageOptions?: Array<ImageOption>;
};

export type Library_MediaFolder = {
    Name?: string;
    Id?: string;
    Guid?: string;
    SubFolders?: Array<Library_SubFolder>;
    IsUserAccessConfigurable?: boolean;
};

export type Library_SubFolder = {
    Name?: string;
    Id?: string;
    Path?: string;
    IsUserAccessConfigurable?: boolean;
};

export type Library_AddVirtualFolder = {
    Name?: string;
    CollectionType?: string;
    RefreshLibrary?: boolean;
    Paths?: Array<(string)>;
    LibraryOptions?: LibraryOptions;
};

export type LiveStreamRequest = {
    OpenToken?: string;
    UserId?: string;
    PlaySessionId?: string;
    MaxStreamingBitrate?: (number) | null;
    StartTimeTicks?: (number) | null;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    MaxAudioChannels?: (number) | null;
    ItemId?: number;
    DeviceProfile?: DeviceProfile;
    EnableDirectPlay?: boolean;
    EnableDirectStream?: boolean;
    EnableTranscoding?: boolean;
    AllowVideoStreamCopy?: boolean;
    AllowInterlacedVideoStreamCopy?: boolean;
    AllowAudioStreamCopy?: boolean;
};

export type DeviceProfile = {
    /**
     * The name.
     */
    Name?: string;
    Id?: string;
    SupportedMediaTypes?: string;
    MaxStreamingBitrate?: (number) | null;
    MusicStreamingTranscodingBitrate?: (number) | null;
    MaxStaticMusicBitrate?: (number) | null;
    DeclaredFeatures?: Array<(string)>;
    /**
     * The direct play profiles.
     */
    DirectPlayProfiles?: Array<DirectPlayProfile>;
    /**
     * The transcoding profiles.
     */
    TranscodingProfiles?: Array<TranscodingProfile>;
    ContainerProfiles?: Array<ContainerProfile>;
    CodecProfiles?: Array<CodecProfile>;
    ResponseProfiles?: Array<ResponseProfile>;
    SubtitleProfiles?: Array<SubtitleProfile>;
};

export type LiveStreamResponse = {
    MediaSource?: MediaSourceInfo;
};

export type Api_SetChannelMapping = {
    TunerChannelId?: string;
    ProviderChannelId?: string;
};

export type LiveTv_ListingsProviderInfo = {
    Name?: string;
    SetupUrl?: string;
    Id?: string;
    Type?: string;
    Username?: string;
    Password?: string;
    ListingsId?: string;
    ZipCode?: string;
    Country?: string;
    Path?: string;
    EnabledTuners?: Array<(string)>;
    EnableAllTuners?: boolean;
    NewsCategories?: Array<(string)>;
    SportsCategories?: Array<(string)>;
    KidsCategories?: Array<(string)>;
    MovieCategories?: Array<(string)>;
    ChannelMappings?: Array<NameValuePair>;
    TvgShiftTicks?: number;
    MoviePrefix?: string;
    PreferredLanguage?: string;
    UserAgent?: string;
    DataVersion?: string;
};

export type LiveTv_TunerHostInfo = {
    Id?: string;
    Url?: string;
    Type?: string;
    DeviceId?: string;
    FriendlyName?: string;
    SetupUrl?: string;
    ImportFavoritesOnly?: boolean;
    PreferEpgChannelImages?: boolean;
    PreferEpgChannelNumbers?: boolean;
    AllowHWTranscoding?: boolean;
    AllowMappingByNumber?: boolean;
    ImportGuideData?: boolean;
    Source?: string;
    TunerCount?: number;
    UserAgent?: string;
    Referrer?: string;
    ProviderOptions?: string;
    DataVersion?: number;
};

export type LiveTv_LiveTvInfo = {
    /**
     * A value indicating whether this instance is enabled.
     */
    IsEnabled?: boolean;
    /**
     * The enabled users.
     */
    EnabledUsers?: Array<(string)>;
};

/**
 * Enum ChannelType
 *
 */
export type LiveTv_ChannelType = 'TV' | 'Radio';

export type QueryResult_Api_EpgRow = {
    Items?: Array<Api_EpgRow>;
    TotalRecordCount?: number;
};

export type Api_EpgRow = {
    Channel?: BaseItemDto;
    Programs?: Array<BaseItemDto>;
};

export type Api_BaseItemsRequest = {
    IsSpecialEpisode?: (boolean) | null;
    Is4K?: (boolean) | null;
    MinDateCreated?: (string) | null;
    MaxDateCreated?: (string) | null;
    EnableTotalRecordCount?: boolean;
    MatchAnyWord?: boolean;
    IsDuplicate?: (boolean) | null;
    Name?: string;
    RecordingKeyword?: string;
    RecordingKeywordType?: LiveTv_KeywordType;
    RandomSeed?: number;
    GenreIds?: string;
    CollectionIds?: string;
    TagIds?: string;
    ExcludeTagIds?: string;
    ItemPersonTypes?: Array<PersonType>;
    ExcludeArtistIds?: string;
    AlbumArtistIds?: string;
    ComposerArtistIds?: string;
    ContributingArtistIds?: string;
    AlbumIds?: string;
    OuterIds?: string;
    ListItemIds?: string;
    AudioLanguages?: string;
    SubtitleLanguages?: string;
    CanEditItems?: (boolean) | null;
    GroupItemsInto?: Library_ItemLinkType;
    IsStandaloneSpecial?: (boolean) | null;
    MinWidth?: (number) | null;
    MinHeight?: (number) | null;
    MaxWidth?: (number) | null;
    MaxHeight?: (number) | null;
    GroupProgramsBySeries?: boolean;
    AirDays?: Array<DayOfWeek>;
    IsAiring?: (boolean) | null;
    HasAired?: (boolean) | null;
    CollectionTypes?: string;
    ExcludeSources?: Array<(string)>;
};

export type LiveTv_KeywordType = 'Name' | 'EpisodeTitle' | 'Overview' | 'Actor' | 'Director';

export type Library_ItemLinkType = 'Artists' | 'AlbumArtists' | 'Genres' | 'Studios' | 'Tags' | 'Composers' | 'Collections' | 'Albums' | 'CollectionFolders' | 'LiveTVSeries' | 'GameSystems';

export type LiveTv_RecordingStatus = 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';

export type QueryResult_LiveTv_TimerInfoDto = {
    Items?: Array<LiveTv_TimerInfoDto>;
    TotalRecordCount?: number;
};

export type LiveTv_TimerInfoDto = {
    Status?: LiveTv_RecordingStatus;
    /**
     * The series timer identifier.
     */
    SeriesTimerId?: string;
    /**
     * The run time ticks.
     */
    RunTimeTicks?: (number) | null;
    ProgramInfo?: BaseItemDto;
    TimerType?: LiveTv_TimerType;
    /**
     * Id of the recording.
     */
    Id?: string;
    Type?: string;
    /**
     * The server identifier.
     */
    ServerId?: string;
    /**
     * ChannelId of the recording.
     */
    ChannelId?: string;
    /**
     * ChannelName of the recording.
     */
    ChannelName?: string;
    ChannelNumber?: string;
    ChannelPrimaryImageTag?: string;
    /**
     * The program identifier.
     */
    ProgramId?: string;
    /**
     * Name of the recording.
     */
    Name?: string;
    /**
     * Description of the recording.
     */
    Overview?: string;
    ParentFolderId?: string;
    /**
     * The start date of the recording, in UTC.
     */
    StartDate?: string;
    /**
     * The end date of the recording, in UTC.
     */
    EndDate?: string;
    /**
     * The priority.
     */
    Priority?: number;
    /**
     * The pre padding seconds.
     */
    PrePaddingSeconds?: number;
    /**
     * The post padding seconds.
     */
    PostPaddingSeconds?: number;
    /**
     * A value indicating whether this instance is pre padding required.
     */
    IsPrePaddingRequired?: boolean;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     */
    ParentBackdropItemId?: string;
    /**
     * The parent backdrop image tags.
     */
    ParentBackdropImageTags?: Array<(string)>;
    /**
     * A value indicating whether this instance is post padding required.
     */
    IsPostPaddingRequired?: boolean;
    KeepUntil?: LiveTv_KeepUntil;
};

export type LiveTv_KeepUntil = 'UntilDeleted' | 'UntilSpaceNeeded' | 'UntilWatched' | 'UntilDate';

export type QueryResult_LiveTv_SeriesTimerInfoDto = {
    Items?: Array<LiveTv_SeriesTimerInfoDto>;
    TotalRecordCount?: number;
};

/**
 * Class SeriesTimerInfoDto.
 *
 */
export type LiveTv_SeriesTimerInfoDto = {
    /**
     * A value indicating whether \[record any time\].
     */
    RecordAnyTime?: boolean;
    SkipEpisodesInLibrary?: boolean;
    MatchExistingItemsWithAnyLibrary?: boolean;
    /**
     * A value indicating whether \[record any channel\].
     */
    RecordAnyChannel?: boolean;
    KeepUpTo?: number;
    MaxRecordingSeconds?: number;
    /**
     * A value indicating whether \[record new only\].
     */
    RecordNewOnly?: boolean;
    ChannelIds?: Array<(string)>;
    /**
     * The days.
     */
    Days?: Array<DayOfWeek>;
    /**
     * The image tags.
     */
    ImageTags?: {
        [key: string]: (string);
    };
    /**
     * The parent thumb item id.
     */
    ParentThumbItemId?: string;
    /**
     * The parent thumb image tag.
     */
    ParentThumbImageTag?: string;
    /**
     * The parent primary image item identifier.
     */
    ParentPrimaryImageItemId?: string;
    /**
     * The parent primary image tag.
     */
    ParentPrimaryImageTag?: string;
    SeriesId?: string;
    Keywords?: Array<LiveTv_KeywordInfo>;
    TimerType?: LiveTv_TimerType;
    /**
     * Id of the recording.
     */
    Id?: string;
    Type?: string;
    /**
     * The server identifier.
     */
    ServerId?: string;
    /**
     * ChannelId of the recording.
     */
    ChannelId?: string;
    /**
     * ChannelName of the recording.
     */
    ChannelName?: string;
    ChannelNumber?: string;
    ChannelPrimaryImageTag?: string;
    /**
     * The program identifier.
     */
    ProgramId?: string;
    /**
     * Name of the recording.
     */
    Name?: string;
    /**
     * Description of the recording.
     */
    Overview?: string;
    ParentFolderId?: string;
    /**
     * The start date of the recording, in UTC.
     */
    StartDate?: string;
    /**
     * The end date of the recording, in UTC.
     */
    EndDate?: string;
    /**
     * The priority.
     */
    Priority?: number;
    /**
     * The pre padding seconds.
     */
    PrePaddingSeconds?: number;
    /**
     * The post padding seconds.
     */
    PostPaddingSeconds?: number;
    /**
     * A value indicating whether this instance is pre padding required.
     */
    IsPrePaddingRequired?: boolean;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     */
    ParentBackdropItemId?: string;
    /**
     * The parent backdrop image tags.
     */
    ParentBackdropImageTags?: Array<(string)>;
    /**
     * A value indicating whether this instance is post padding required.
     */
    IsPostPaddingRequired?: boolean;
    KeepUntil?: LiveTv_KeepUntil;
};

export type LiveTv_KeywordInfo = {
    KeywordType?: LiveTv_KeywordType;
    Keyword?: string;
};

export type LiveTv_SeriesTimerInfo = {
    /**
     * Id of the recording.
     */
    Id?: string;
    /**
     * ChannelId of the recording.
     */
    ChannelId?: string;
    ChannelIds?: Array<(string)>;
    ParentFolderId?: number;
    /**
     * The program identifier.
     */
    ProgramId?: string;
    /**
     * Name of the recording.
     */
    Name?: string;
    ServiceName?: string;
    /**
     * Description of the recording.
     */
    Overview?: string;
    /**
     * The start date of the recording, in UTC.
     */
    StartDate?: string;
    /**
     * The end date of the recording, in UTC.
     */
    EndDate?: string;
    /**
     * A value indicating whether \[record any time\].
     */
    RecordAnyTime?: boolean;
    KeepUpTo?: number;
    KeepUntil?: LiveTv_KeepUntil;
    SkipEpisodesInLibrary?: boolean;
    MatchExistingItemsWithAnyLibrary?: boolean;
    /**
     * A value indicating whether \[record new only\].
     */
    RecordNewOnly?: boolean;
    /**
     * The days.
     */
    Days?: Array<DayOfWeek>;
    /**
     * The priority.
     */
    Priority?: number;
    /**
     * The pre padding seconds.
     */
    PrePaddingSeconds?: number;
    /**
     * The post padding seconds.
     */
    PostPaddingSeconds?: number;
    /**
     * A value indicating whether this instance is pre padding required.
     */
    IsPrePaddingRequired?: boolean;
    /**
     * A value indicating whether this instance is post padding required.
     */
    IsPostPaddingRequired?: boolean;
    /**
     * The series identifier.
     */
    SeriesId?: string;
    ProviderIds?: ProviderIdDictionary;
    MaxRecordingSeconds?: number;
    Keywords?: Array<LiveTv_KeywordInfo>;
    TimerType?: LiveTv_TimerType;
};

export type LiveTv_GuideInfo = {
    /**
     * The start date.
     */
    StartDate?: string;
    /**
     * The end date.
     */
    EndDate?: string;
};

export type Api_AvailableRecordingOptions = {
    RecordingFolders?: Array<Api_NameIdDescriptionPair>;
    MovieRecordingFolders?: Array<Api_NameIdDescriptionPair>;
    SeriesRecordingFolders?: Array<Api_NameIdDescriptionPair>;
};

export type Api_NameIdDescriptionPair = {
    ShortOverview?: string;
    /**
     * The name.
     */
    Name?: string;
    /**
     * The identifier.
     */
    Id?: string;
};

/**
 * Class ParentalRating
 *
 */
export type ParentalRating = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The value.
     */
    Value?: number;
};

export type Globalization_LocalizatonOption = {
    Name?: string;
    Value?: string;
};

/**
 * Class CountryInfo
 *
 */
export type Globalization_CountryInfo = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The display name.
     */
    DisplayName?: string;
    /**
     * The English name.
     */
    EnglishName?: string;
    /**
     * The name of the two letter ISO region.
     */
    TwoLetterISORegionName?: string;
    /**
     * The name of the three letter ISO region.
     */
    ThreeLetterISORegionName?: string;
};

/**
 * Class CultureDto
 *
 */
export type Globalization_CultureDto = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The display name.
     */
    DisplayName?: string;
    /**
     * The name of the two letter ISO language.
     */
    TwoLetterISOLanguageName?: string;
    /**
     * The name of the three letter ISO language.
     */
    ThreeLetterISOLanguageName?: string;
    ThreeLetterISOLanguageNames?: Array<(string)>;
    TwoLetterISOLanguageNames?: Array<(string)>;
};

export type RecommendationDto = {
    Items?: Array<BaseItemDto>;
    RecommendationType?: RecommendationType;
    BaselineItemName?: string;
    CategoryId?: number;
};

export type RecommendationType = 'SimilarToRecentlyPlayed' | 'SimilarToLikedItem' | 'HasDirectorFromRecentlyPlayed' | 'HasActorFromRecentlyPlayed' | 'HasLikedDirector' | 'HasLikedActor';

export type NotificationCategoryInfo = {
    Name?: string;
    Id?: string;
    Events?: Array<NotificationTypeInfo>;
};

export type NotificationTypeInfo = {
    Name?: string;
    Id?: string;
    CategoryName?: string;
    CategoryId?: string;
};

export type Api_AddAdminNotification = {
    DisplayDateTime?: boolean;
};

/**
 * Class PlaybackStartInfo.
 *
 */
export type PlaybackStartInfo = {
    /**
     * A value indicating whether this instance can seek.
     */
    CanSeek?: boolean;
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    /**
     * The session id.
     */
    SessionId?: string;
    /**
     * The index of the audio stream.
     */
    AudioStreamIndex?: (number) | null;
    /**
     * The index of the subtitle stream.
     */
    SubtitleStreamIndex?: (number) | null;
    /**
     * A value indicating whether this instance is paused.
     */
    IsPaused?: boolean;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    /**
     * A value indicating whether this instance is muted.
     */
    IsMuted?: boolean;
    RunTimeTicks?: (number) | null;
    PlaybackStartTimeTicks?: (number) | null;
    /**
     * The volume level.
     */
    VolumeLevel?: (number) | null;
    Brightness?: (number) | null;
    AspectRatio?: string;
    EventName?: ProgressEvent;
    PlayMethod?: PlayMethod;
    RepeatMode?: RepeatMode;
    SleepTimerMode?: SleepTimerMode;
    SleepTimerEndTime?: (string) | null;
    Shuffle?: boolean;
    SubtitleOffset?: number;
    PlaybackRate?: number;
    PlaylistItemIds?: Array<(string)>;
    /**
     * The play session identifier.
     */
    PlaySessionId?: string;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * The live stream identifier.
     */
    LiveStreamId?: string;
    /**
     * The media version identifier.
     */
    MediaSourceId?: string;
    Item?: BaseItemDto;
    /**
     * The position ticks.
     */
    PositionTicks?: (number) | null;
};

export type QueueItem = {
    Id?: number;
    PlaylistItemId?: string;
};

export type ProgressEvent = 'TimeUpdate' | 'Pause' | 'Unpause' | 'VolumeChange' | 'RepeatModeChange' | 'AudioTrackChange' | 'SubtitleTrackChange' | 'PlaylistItemMove' | 'PlaylistItemRemove' | 'PlaylistItemAdd' | 'QualityChange' | 'StateChange' | 'SubtitleOffsetChange' | 'PlaybackRateChange' | 'ShuffleChange' | 'SleepTimerChange';

export type SyncTarget = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The identifier.
     */
    Id?: string;
};

export type QueryResult_SyncJob = {
    Items?: Array<SyncJob>;
    TotalRecordCount?: number;
};

export type SyncJob = {
    /**
     * The identifier.
     */
    Id?: number;
    /**
     * The device identifier.
     */
    TargetId?: string;
    InternalTargetId?: number;
    /**
     * The name of the target.
     */
    TargetName?: string;
    /**
     * The quality.
     */
    Quality?: string;
    /**
     * The bitrate.
     */
    Bitrate?: (number) | null;
    Container?: string;
    VideoCodec?: string;
    AudioCodec?: string;
    /**
     * The profile.
     */
    Profile?: string;
    Category?: SyncCategory;
    /**
     * The parent identifier.
     */
    ParentId?: number;
    /**
     * The current progress.
     */
    Progress?: number;
    /**
     * The name.
     */
    Name?: string;
    Status?: SyncJobStatus;
    /**
     * The user identifier.
     */
    UserId?: number;
    /**
     * A value indicating whether \[unwatched only\].
     */
    UnwatchedOnly?: boolean;
    /**
     * A value indicating whether \[synchronize new content\].
     */
    SyncNewContent?: boolean;
    /**
     * The item limit.
     */
    ItemLimit?: (number) | null;
    /**
     * The requested item ids.
     */
    RequestedItemIds?: Array<(number)>;
    ItemId?: number;
    /**
     * The date created.
     */
    DateCreated?: string;
    /**
     * The date last modified.
     */
    DateLastModified?: string;
    /**
     * The item count.
     */
    ItemCount?: number;
    ParentName?: string;
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
};

export type SyncCategory = 'Latest' | 'NextUp' | 'Resume';

export type SyncJobStatus = 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Completed' | 'CompletedWithError' | 'Failed';

export type QueryResult_SyncJobItem = {
    Items?: Array<SyncJobItem>;
    TotalRecordCount?: number;
};

export type SyncJobItem = {
    Id?: number;
    JobId?: number;
    ItemId?: number;
    ItemName?: string;
    MediaSourceId?: string;
    MediaSource?: MediaSourceInfo;
    TargetId?: string;
    InternalTargetId?: number;
    OutputPath?: string;
    Status?: SyncJobItemStatus;
    Progress?: (number) | null;
    DateCreated?: string;
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
    TemporaryPath?: string;
    AdditionalFiles?: Array<ItemFileInfo>;
};

export type ItemFileInfo = {
    Type?: ItemFileType;
    Name?: string;
    Path?: string;
    ImageType?: ImageType;
    Index?: number;
};

export type ItemFileType = 'Media' | 'Image' | 'Subtitles';

export type SyncJobRequest = {
    TargetId?: string;
    ItemIds?: Array<(string)>;
    Category?: SyncCategory;
    ParentId?: string;
    Quality?: string;
    Profile?: string;
    Container?: string;
    VideoCodec?: string;
    AudioCodec?: string;
    Name?: string;
    UserId?: string;
    UnwatchedOnly?: boolean;
    SyncNewContent?: boolean;
    ItemLimit?: (number) | null;
    Bitrate?: (number) | null;
    Downloaded?: boolean;
};

export type SyncJobCreationResult = {
    Job?: SyncJob;
    JobItems?: Array<SyncJobItem>;
};

export type SyncDialogOptions = {
    Targets?: Array<SyncTarget>;
    Options?: Array<SyncJobOption>;
    QualityOptions?: Array<SyncQualityOption>;
    ProfileOptions?: Array<SyncProfileOption>;
};

export type SyncJobOption = 'Name' | 'Quality' | 'UnwatchedOnly' | 'SyncNewContent' | 'ItemLimit' | 'Profile';

export type SyncQualityOption = {
    Name?: string;
    Description?: string;
    Id?: string;
    IsDefault?: boolean;
    IsOriginalQuality?: boolean;
};

export type SyncProfileOption = {
    Name?: string;
    Description?: string;
    Id?: string;
    IsDefault?: boolean;
    EnableQualityOptions?: boolean;
};

export type UserAction = {
    Id?: string;
    ServerId?: string;
    UserId?: string;
    ItemId?: string;
    Type?: UserActionType;
    Date?: string;
    PositionTicks?: (number) | null;
    Played?: (boolean) | null;
    IsFavorite?: (boolean) | null;
};

export type UserActionType = 'PlayedItem' | 'MarkPlayed' | 'MarkFavorite';

export type SyncDataRequest = {
    LocalItemIds?: Array<(string)>;
    InternalTargetIds?: Array<(number)>;
};

export type SyncDataResponse = {
    ItemIdsToRemove?: Array<(string)>;
};

/**
 * Represents the server configuration.
 *
 */
export type ServerConfiguration = {
    /**
     * A value indicating whether \[enable u pn p\].
     */
    EnableUPnP?: boolean;
    /**
     * The public mapped port.
     */
    PublicPort?: number;
    /**
     * The public HTTPS port.
     */
    PublicHttpsPort?: number;
    /**
     * The HTTP server port number.
     */
    HttpServerPortNumber?: number;
    /**
     * The HTTPS server port number.
     */
    HttpsPortNumber?: number;
    /**
     * A value indicating whether \[use HTTPS\].
     */
    EnableHttps?: boolean;
    /**
     * The value pointing to the file system where the ssl certiifcate is located..
     */
    CertificatePath?: string;
    CertificatePassword?: string;
    /**
     * A value indicating whether this instance is port authorized.
     */
    IsPortAuthorized?: boolean;
    AutoRunWebApp?: boolean;
    EnableRemoteAccess?: boolean;
    LogAllQueryTimes?: boolean;
    DisableOutgoingIPv6?: boolean;
    /**
     * A value indicating whether \[enable case sensitive item ids\].
     */
    EnableCaseSensitiveItemIds?: boolean;
    /**
     * The metadata path.
     */
    MetadataPath?: string;
    MetadataNetworkPath?: string;
    /**
     * The preferred metadata language.
     */
    PreferredMetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    /**
     * Words to be removed from strings to create a sort name
     */
    SortRemoveWords?: Array<(string)>;
    /**
     * The delay in seconds that we will wait after a file system change to try and discover what has been added\/removed Some delay is necessary with some items because their creation is not atomic.  It involves the creation of several different directories and files.
     */
    LibraryMonitorDelaySeconds?: number;
    /**
     * A value indicating whether \[enable dashboard response caching\]. Allows potential contributors without visual studio to modify production dashboard code and test changes.
     */
    EnableDashboardResponseCaching?: boolean;
    /**
     * Allows the dashboard to be served from a custom path.
     */
    DashboardSourcePath?: string;
    ImageSavingConvention?: ImageSavingConvention;
    EnableAutomaticRestart?: boolean;
    ServerName?: string;
    PreferredDetectedRemoteAddressFamily?: Net_Sockets_AddressFamily;
    WanDdns?: string;
    UICulture?: string;
    RemoteClientBitrateLimit?: number;
    LocalNetworkSubnets?: Array<(string)>;
    LocalNetworkAddresses?: Array<(string)>;
    EnableExternalContentInSuggestions?: boolean;
    RequireHttps?: boolean;
    IsBehindProxy?: boolean;
    RemoteIPFilter?: Array<(string)>;
    IsRemoteIPFilterBlacklist?: boolean;
    ImageExtractionTimeoutMs?: number;
    PathSubstitutions?: Array<PathSubstitution>;
    UninstalledPlugins?: Array<(string)>;
    CollapseVideoFolders?: boolean;
    EnableOriginalTrackTitles?: boolean;
    VacuumDatabaseOnStartup?: boolean;
    SimultaneousStreamLimit?: number;
    DatabaseCacheSizeMB?: number;
    EnableSqLiteMmio?: boolean;
    PlaylistsUpgradedToM3U?: boolean;
    ImageExtractorUpgraded1?: boolean;
    EnablePeopleLetterSubFolders?: boolean;
    OptimizeDatabaseOnShutdown?: boolean;
    DatabaseAnalysisLimit?: number;
    MaxLibraryDbConnections?: number;
    MaxAuthDbConnections?: number;
    MaxOtherDbConnections?: number;
    DisableAsyncIO?: boolean;
    MigratedToUserItemShares8?: boolean;
    MigratedLibraryOptionsToDb?: boolean;
    AllowLegacyLocalNetworkPassword?: boolean;
    EnableSavedMetadataForPeople?: boolean;
    TvChannelsRefreshed?: boolean;
    ProxyHeaderMode?: ProxyHeaderMode;
    IsInMaintenanceMode?: boolean;
    MaintenanceModeMessage?: string;
    /**
     * A value indicating whether \[enable debug level logging\].
     */
    EnableDebugLevelLogging?: boolean;
    RevertDebugLogging?: string;
    /**
     * Enable automatically and silently updating of the application
     */
    EnableAutoUpdate?: boolean;
    /**
     * The number of days we should retain log files
     */
    LogFileRetentionDays?: number;
    /**
     * A value indicating whether \[run at startup\].
     */
    RunAtStartup?: boolean;
    /**
     * A value indicating whether this instance is first run.
     */
    IsStartupWizardCompleted?: boolean;
    /**
     * The cache path.
     */
    CachePath?: string;
};

export type ImageSavingConvention = 'Legacy' | 'Compatible';

export type Net_Sockets_AddressFamily = 'Unspecified' | 'Unix' | 'InterNetwork' | 'ImpLink' | 'Pup' | 'Chaos' | 'NS' | 'Ipx' | 'Iso' | 'Osi' | 'Ecma' | 'DataKit' | 'Ccitt' | 'Sna' | 'DecNet' | 'DataLink' | 'Lat' | 'HyperChannel' | 'AppleTalk' | 'NetBios' | 'VoiceView' | 'FireFox' | 'Banyan' | 'Atm' | 'InterNetworkV6' | 'Cluster' | 'Ieee12844' | 'Irda' | 'NetworkDesigners' | 'Max' | 'Packet' | 'ControllerAreaNetwork' | 'Unknown';

export type PathSubstitution = {
    From?: string;
    To?: string;
};

export type ProxyHeaderMode = 'None' | 'LanAddressesOnly' | 'RemoteAddressesOnly' | 'AllAddresses';

export type WakeOnLanInfo = {
    MacAddress?: string;
    BroadcastAddress?: string;
    Port?: number;
};

/**
 * Class SystemInfo
 *
 */
export type SystemInfo = {
    SystemUpdateLevel?: PackageVersionClass;
    /**
     * The display name of the operating system.
     */
    OperatingSystemDisplayName?: string;
    PackageName?: string;
    /**
     * A value indicating whether this instance has pending restart.
     */
    HasPendingRestart?: boolean;
    IsShuttingDown?: boolean;
    HasImageEnhancers?: boolean;
    /**
     * The operating sytem.
     */
    OperatingSystem?: string;
    /**
     * A value indicating whether \[supports library monitor\].
     */
    SupportsLibraryMonitor?: boolean;
    SupportsLocalPortConfiguration?: boolean;
    SupportsWakeServer?: boolean;
    /**
     * The web socket port number.
     */
    WebSocketPortNumber?: number;
    /**
     * The completed installations.
     */
    CompletedInstallations?: Array<InstallationInfo>;
    /**
     * A value indicating whether this instance can self restart.
     */
    CanSelfRestart?: boolean;
    /**
     * A value indicating whether this instance can self update.
     */
    CanSelfUpdate?: boolean;
    CanLaunchWebBrowser?: boolean;
    /**
     * The program data path.
     */
    ProgramDataPath?: string;
    /**
     * The items by name path.
     */
    ItemsByNamePath?: string;
    /**
     * The cache path.
     */
    CachePath?: string;
    /**
     * The log path.
     */
    LogPath?: string;
    /**
     * The internal metadata path.
     */
    InternalMetadataPath?: string;
    /**
     * The transcoding temporary path.
     */
    TranscodingTempPath?: string;
    /**
     * The HTTP server port number.
     */
    HttpServerPortNumber?: number;
    /**
     * A value indicating whether \[enable HTTPS\].
     */
    SupportsHttps?: boolean;
    /**
     * The HTTPS server port number.
     */
    HttpsPortNumber?: number;
    /**
     * A value indicating whether this instance has update available.
     */
    HasUpdateAvailable?: boolean;
    /**
     * A value indicating whether \[supports automatic run at startup\].
     */
    SupportsAutoRunAtStartup?: boolean;
    HardwareAccelerationRequiresPremiere?: boolean;
    WakeOnLanInfo?: Array<WakeOnLanInfo>;
    IsInMaintenanceMode?: boolean;
    /**
     * The local address.
     */
    LocalAddress?: string;
    LocalAddresses?: Array<(string)>;
    /**
     * The wan address.
     */
    WanAddress?: string;
    RemoteAddresses?: Array<(string)>;
    /**
     * The name of the server.
     */
    ServerName?: string;
    /**
     * The version.
     */
    Version?: string;
    /**
     * The id.
     */
    Id?: string;
};

/**
 * Class InstallationInfo
 *
 */
export type InstallationInfo = {
    /**
     * The id.
     */
    Id?: string;
    /**
     * The name.
     */
    Name?: string;
    /**
     * The assembly guid.
     */
    AssemblyGuid?: string;
    /**
     * The version.
     */
    Version?: string;
    UpdateClass?: PackageVersionClass;
    /**
     * The percent complete.
     */
    PercentComplete?: (number) | null;
};

export type Net_EndPointInfo = {
    IsLocal?: boolean;
    IsInNetwork?: boolean;
};

export type UIViewInfo = {
    ViewId?: string;
    PageId?: string;
    Caption?: string;
    SubCaption?: string;
    PluginId?: string;
    ViewType?: Enums_UIViewType;
    ShowDialogFullScreen?: boolean;
    IsInSequence?: boolean;
    RedirectViewUrl?: string;
    EditObjectContainer?: GenericEdit_IEditObjectContainer;
    Commands?: Array<UICommand>;
    TabPageInfos?: Array<UITabPageInfo>;
    IsPageChangeInfo?: boolean;
};

export type Enums_UIViewType = 'RegularPage' | 'Dialog' | 'Wizard';

export type GenericEdit_IEditObjectContainer = {
    Object?: {
        [key: string]: unknown;
    };
    DefaultObject?: {
        [key: string]: unknown;
    };
    TypeName?: string;
};

export type UICommand = {
    CommandType?: Enums_UICommandType;
    CommandId?: string;
    IsVisible?: boolean;
    IsEnabled?: boolean;
    Caption?: string;
    SetFocus?: boolean;
    ConfirmationPrompt?: string;
};

export type Enums_UICommandType = 'Custom' | 'WizardCancel' | 'WizardBack' | 'WizardNext' | 'WizardFinish' | 'DialogCancel' | 'DialogOk' | 'PageSave' | 'PageBack' | 'WizardButton1' | 'WizardButton2' | 'WizardButton3';

export type UITabPageInfo = {
    PageId?: string;
    DisplayName?: string;
    PluginId?: string;
    Href?: string;
    NavKey?: string;
    Index?: number;
};

export type RunUICommand = {
    PageId?: string;
    CommandId?: string;
    Data?: string;
    ItemId?: string;
    ClientLocale?: string;
};

/**
 * Class UserDto
 *
 */
export type UserDto = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The server identifier.
     */
    ServerId?: string;
    /**
     * The name of the server. This is not used by the server and is for client\-side usage only.
     */
    ServerName?: string;
    Prefix?: string;
    /**
     * The name of the connect user.
     */
    ConnectUserName?: string;
    DateCreated?: (string) | null;
    ConnectLinkType?: Connect_UserLinkType;
    /**
     * The id.
     */
    Id?: string;
    /**
     * The primary image tag.
     */
    PrimaryImageTag?: string;
    /**
     * A value indicating whether this instance has password.
     */
    HasPassword?: boolean;
    /**
     * A value indicating whether this instance has configured password.
     */
    HasConfiguredPassword?: boolean;
    EnableAutoLogin?: (boolean) | null;
    /**
     * The last login date.
     */
    LastLoginDate?: (string) | null;
    /**
     * The last activity date.
     */
    LastActivityDate?: (string) | null;
    Configuration?: UserConfiguration;
    Policy?: UserPolicy;
    /**
     * The primary image aspect ratio.
     */
    PrimaryImageAspectRatio?: (number) | null;
    /**
     * @deprecated
     */
    HasConfiguredEasyPassword?: boolean;
    UserItemShareLevel?: UserItemShareLevel;
};

export type Connect_UserLinkType = 'LinkedUser' | 'Guest';

/**
 * Class UserConfiguration
 *
 */
export type UserConfiguration = {
    /**
     * The audio language preference.
     */
    AudioLanguagePreference?: string;
    /**
     * A value indicating whether \[play default audio track\].
     */
    PlayDefaultAudioTrack?: boolean;
    /**
     * The subtitle language preference.
     */
    SubtitleLanguagePreference?: string;
    ProfilePin?: string;
    DisplayMissingEpisodes?: boolean;
    SubtitleMode?: SubtitlePlaybackMode;
    OrderedViews?: Array<(string)>;
    LatestItemsExcludes?: Array<(string)>;
    MyMediaExcludes?: Array<(string)>;
    HidePlayedInLatest?: boolean;
    HidePlayedInMoreLikeThis?: boolean;
    HidePlayedInSuggestions?: boolean;
    RememberAudioSelections?: boolean;
    RememberSubtitleSelections?: boolean;
    EnableNextEpisodeAutoPlay?: boolean;
    ResumeRewindSeconds?: number;
    IntroSkipMode?: SegmentSkipMode;
    /**
     * @deprecated
     */
    EnableLocalPassword?: boolean;
};

export type SubtitlePlaybackMode = 'Default' | 'Always' | 'OnlyForced' | 'None' | 'Smart' | 'HearingImpaired';

export type SegmentSkipMode = 'ShowButton' | 'AutoSkip' | 'None';

export type UserPolicy = {
    /**
     * A value indicating whether this instance is administrator.
     */
    IsAdministrator?: boolean;
    /**
     * A value indicating whether this instance is hidden.
     */
    IsHidden?: boolean;
    IsHiddenRemotely?: boolean;
    IsHiddenFromUnusedDevices?: boolean;
    /**
     * A value indicating whether this instance is disabled.
     */
    IsDisabled?: boolean;
    LockedOutDate?: number;
    /**
     * The max parental rating.
     */
    MaxParentalRating?: (number) | null;
    AllowTagOrRating?: boolean;
    BlockedTags?: Array<(string)>;
    IsTagBlockingModeInclusive?: boolean;
    IncludeTags?: Array<(string)>;
    EnableUserPreferenceAccess?: boolean;
    AccessSchedules?: Array<AccessSchedule>;
    BlockUnratedItems?: Array<UnratedItem>;
    EnableRemoteControlOfOtherUsers?: boolean;
    EnableSharedDeviceControl?: boolean;
    EnableRemoteAccess?: boolean;
    EnableLiveTvManagement?: boolean;
    EnableLiveTvAccess?: boolean;
    EnableMediaPlayback?: boolean;
    EnableAudioPlaybackTranscoding?: boolean;
    EnableVideoPlaybackTranscoding?: boolean;
    EnablePlaybackRemuxing?: boolean;
    EnableContentDeletion?: boolean;
    RestrictedFeatures?: Array<(string)>;
    EnableContentDeletionFromFolders?: Array<(string)>;
    EnableContentDownloading?: boolean;
    EnableSubtitleDownloading?: boolean;
    EnableSubtitleManagement?: boolean;
    /**
     * A value indicating whether \[enable synchronize\].
     */
    EnableSyncTranscoding?: boolean;
    EnableMediaConversion?: boolean;
    EnabledChannels?: Array<(string)>;
    EnableAllChannels?: boolean;
    EnabledFolders?: Array<(string)>;
    EnableAllFolders?: boolean;
    InvalidLoginAttemptCount?: number;
    EnablePublicSharing?: boolean;
    RemoteClientBitrateLimit?: number;
    AuthenticationProviderId?: string;
    ExcludedSubFolders?: Array<(string)>;
    SimultaneousStreamLimit?: number;
    EnabledDevices?: Array<(string)>;
    EnableAllDevices?: boolean;
    AllowCameraUpload?: boolean;
    AllowSharingPersonalItems?: boolean;
};

export type AccessSchedule = {
    DayOfWeek?: DynamicDayOfWeek;
    /**
     * The start hour.
     */
    StartHour?: number;
    /**
     * The end hour.
     */
    EndHour?: number;
};

export type DynamicDayOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday' | 'Everyday' | 'Weekday' | 'Weekend';

export type UnratedItem = 'Movie' | 'Trailer' | 'Series' | 'Music' | 'Game' | 'Book' | 'LiveTvChannel' | 'LiveTvProgram' | 'ChannelContent' | 'Other';

export type QueryResult_UserDto = {
    Items?: Array<UserDto>;
    TotalRecordCount?: number;
};

export type AuthenticateUserByName = {
    Username?: string;
    Pw?: string;
};

export type Authentication_AuthenticationResult = {
    User?: UserDto;
    SessionInfo?: Session_SessionInfo;
    /**
     * The authentication token.
     */
    AccessToken?: string;
    /**
     * The server identifier.
     */
    ServerId?: string;
};

export type CreateUserByName = {
    Name?: string;
    CopyFromUserId?: string;
    UserCopyOptions?: Array<Library_UserCopyOptions>;
};

export type Library_UserCopyOptions = 'UserPolicy' | 'UserConfiguration' | 'UserData';

export type ForgotPassword = {
    EnteredUsername?: string;
};

export type ForgotPasswordResult = {
    Action?: ForgotPasswordAction;
    /**
     * The pin file.
     */
    PinFile?: string;
    /**
     * The pin expiration date.
     */
    PinExpirationDate?: (string) | null;
};

export type ForgotPasswordAction = 'ContactAdmin' | 'PinCode';

export type Api_ConfigurationPageInfo = {
    Name?: string;
    EnableInMainMenu?: boolean;
    EnableInUserMenu?: boolean;
    FeatureId?: string;
    MenuSection?: string;
    MenuIcon?: string;
    DisplayName?: string;
    ConfigurationPageType?: Plugins_ConfigurationPageType;
    PluginId?: string;
    Href?: string;
    NavMenuId?: string;
    Plugin?: Common_Plugins_IPlugin;
    Translations?: Array<(string)>;
};

/**
 * Enum ConfigurationPageType
 *
 */
export type Plugins_ConfigurationPageType = 'PluginConfiguration' | 'None';

/**
 * Interface IPlugin
 *
 */
export type Common_Plugins_IPlugin = {
    /**
     * The name of the plugin
     */
    Name?: string;
    /**
     * The description.
     */
    Description?: string;
    /**
     * The unique id.
     */
    Id?: string;
    Version?: Version;
    /**
     * The path to the assembly file
     */
    AssemblyFilePath?: string;
    /**
     * The full path to the data folder, where the plugin can store any miscellaneous files needed
     */
    DataFolderPath?: string;
};

export type Version = {
    Major?: number;
    Minor?: number;
    Build?: number;
    Revision?: number;
    MajorRevision?: number;
    MinorRevision?: number;
};

export type VideoCodecBase = {
    CodecDeviceInfo?: Common_Interfaces_ICodecDeviceInfo;
    CodecKind?: CodecKinds;
    MediaTypeName?: string;
    VideoMediaType?: VideoMediaTypes;
    MinWidth?: (number) | null;
    MaxWidth?: (number) | null;
    MinHeight?: (number) | null;
    MaxHeight?: (number) | null;
    WidthAlignment?: (number) | null;
    HeightAlignment?: (number) | null;
    MaxBitRate?: BitRate;
    SupportedColorFormats?: Array<ColorFormats>;
    SupportedColorFormatStrings?: Array<(string)>;
    ProfileAndLevelInformation?: Array<ProfileLevelInformation>;
    Id?: string;
    Direction?: CodecDirections;
    Name?: string;
    Description?: string;
    FrameworkCodec?: string;
    IsHardwareCodec?: boolean;
    SecondaryFramework?: SecondaryFrameworks;
    SecondaryFrameworkCodec?: string;
    MaxInstanceCount?: (number) | null;
    IsEnabledByDefault?: boolean;
    DefaultPriority?: number;
};

export type Common_Interfaces_ICodecDeviceInfo = {
    Capabilities?: Common_Interfaces_ICodecDeviceCapabilities;
    Adapter?: number;
    Name?: string;
    Desription?: string;
    Driver?: string;
    DriverVersion?: Version;
    ApiVersion?: Version;
    VendorId?: number;
    DeviceId?: number;
    DeviceIdentifier?: string;
    HardwareContextFramework?: SecondaryFrameworks;
    DevPath?: string;
    DrmNode?: string;
    VendorName?: string;
    DeviceName?: string;
};

export type Common_Interfaces_ICodecDeviceCapabilities = {
    SupportsHwUpload?: boolean;
    SupportsHwDownload?: boolean;
    SupportsStandaloneDeviceInit?: boolean;
    Supports10BitProcessing?: boolean;
    SupportsNativeToneMapping?: boolean;
};

/**
 * Enum defining secondary frameworks for encoding and decoding.
 *
 *
 * While most of these are hardware acceleration frameworks, this is not a necessity             (e.g. Android MediaCodec offers software codecs as well).
 *
 */
export type SecondaryFrameworks = 'Unknown' | 'None' | 'AmdAmf' | 'MediaCodec' | 'NvEncDec' | 'OpenMax' | 'QuickSync' | 'VaApi' | 'V4L2' | 'DxVa' | 'D3d11va' | 'VideoToolbox' | 'Mmal';

/**
 * Enum defining the kind of media a codec is processing.
 *
 */
export type CodecKinds = 'Audio' | 'Video' | 'SubTitles';

/**
 * Enum listing video media types.
 *
 *
 * The enum member names are matching exactly those that are used by ffmpeg. Exception: Items that are starting with a number are prefixed with an underscore here.
 *
 */
export type VideoMediaTypes = 'Unknown' | 'copy' | 'flv1' | 'h263' | 'h263p' | 'h264' | 'hevc' | 'mjpeg' | 'mpeg1video' | 'mpeg2video' | 'mpeg4' | 'msvideo1' | 'theora' | 'vc1image' | 'vc1' | 'vp8' | 'vp9' | 'wmv1' | 'wmv2' | 'wmv3' | '_012v' | '_4xm' | '_8bps' | 'a64_multi' | 'a64_multi5' | 'aasc' | 'aic' | 'alias_pix' | 'amv' | 'anm' | 'ansi' | 'apng' | 'asv1' | 'asv2' | 'aura' | 'aura2' | 'av1' | 'avrn' | 'avrp' | 'avs' | 'avui' | 'ayuv' | 'bethsoftvid' | 'bfi' | 'binkvideo' | 'bintext' | 'bitpacked' | 'bmp' | 'bmv_video' | 'brender_pix' | 'c93' | 'cavs' | 'cdgraphics' | 'cdxl' | 'cfhd' | 'cinepak' | 'clearvideo' | 'cljr' | 'cllc' | 'cmv' | 'cpia' | 'cscd' | 'cyuv' | 'daala' | 'dds' | 'dfa' | 'dirac' | 'dnxhd' | 'dpx' | 'dsicinvideo' | 'dvvideo' | 'dxa' | 'dxtory' | 'dxv' | 'escape124' | 'escape130' | 'exr' | 'ffv1' | 'ffvhuff' | 'fic' | 'fits' | 'flashsv' | 'flashsv2' | 'flic' | 'fmvc' | 'fraps' | 'frwu' | 'g2m' | 'gdv' | 'gif' | 'h261' | 'h263i' | 'hap' | 'hnm4video' | 'hq_hqa' | 'hqx' | 'huffyuv' | 'idcin' | 'idf' | 'iff_ilbm' | 'indeo2' | 'indeo3' | 'indeo4' | 'indeo5' | 'interplayvideo' | 'jpeg2000' | 'jpegls' | 'jv' | 'kgv1' | 'kmvc' | 'lagarith' | 'ljpeg' | 'loco' | 'm101' | 'mad' | 'magicyuv' | 'mdec' | 'mimic' | 'mjpegb' | 'mmvideo' | 'motionpixels' | 'msa1' | 'mscc' | 'msmpeg4v1' | 'msmpeg4v2' | 'msmpeg4v3' | 'msrle' | 'mss1' | 'mss2' | 'mszh' | 'mts2' | 'mvc1' | 'mvc2' | 'mxpeg' | 'nuv' | 'paf_video' | 'pam' | 'pbm' | 'pcx' | 'pgm' | 'pgmyuv' | 'pictor' | 'pixlet' | 'png' | 'ppm' | 'prores' | 'psd' | 'ptx' | 'qdraw' | 'qpeg' | 'qtrle' | 'r10k' | 'r210' | 'rawvideo' | 'rl2' | 'roq' | 'rpza' | 'rscc' | 'rv10' | 'rv20' | 'rv30' | 'rv40' | 'sanm' | 'scpr' | 'screenpresso' | 'sgi' | 'sgirle' | 'sheervideo' | 'smackvideo' | 'smc' | 'smvjpeg' | 'snow' | 'sp5x' | 'speedhq' | 'srgc' | 'sunrast' | 'svg' | 'svq1' | 'svq3' | 'targa' | 'targa_y216' | 'tdsc' | 'tgq' | 'tgv' | 'thp' | 'tiertexseqvideo' | 'tiff' | 'tmv' | 'tqi' | 'truemotion1' | 'truemotion2' | 'truemotion2rt' | 'tscc' | 'tscc2' | 'txd' | 'ulti' | 'utvideo' | 'v210' | 'v210x' | 'v308' | 'v408' | 'v410' | 'vb' | 'vble' | 'vcr1' | 'vixl' | 'vmdvideo' | 'vmnc' | 'vp3' | 'vp5' | 'vp6' | 'vp6a' | 'vp6f' | 'vp7' | 'webp' | 'wmv3image' | 'wnv1' | 'wrapped_avframe' | 'ws_vqa' | 'xan_wc3' | 'xan_wc4' | 'xbin' | 'xbm' | 'xface' | 'xpm' | 'xwd' | 'y41p' | 'ylc' | 'yop' | 'yuv4' | 'zerocodec' | 'zlib' | 'zmbv';

/**
 * A type for handling bit rates.
 *
 *
 * The purpose of this type is to avoid manual calculations and conversions in code,             unified handling and conversion as well as presentation through its various To\*\*\*String methods.
 *
 *
 * `System.IComparable`
 *
 *
 * `System.IEquatable`1`
 *
 */
export type BitRate = {
    bps?: number;
    kbps?: number;
    Mbps?: number;
};

/**
 * Enum listing color formats.
 *
 *
 * The enum member names are matching those that are used by ffmpeg. (execute 'ffmpeg \-pix\_fmts' to list them) Exception: Items that are starting with a number are prefixed with an underscore here. In ffmpeg code these are prefixed with 'AV\_PIX\_FMT\_' and all\-caps.
 *
 */
export type ColorFormats = 'Unknown' | 'yuv420p' | 'yuyv422' | 'rgb24' | 'bgr24' | 'yuv422p' | 'yuv444p' | 'yuv410p' | 'yuv411p' | 'gray' | 'monow' | 'monob' | 'pal8' | 'yuvj420p' | 'yuvj422p' | 'yuvj444p' | 'uyvy422' | 'uyyvyy411' | 'bgr8' | 'bgr4' | 'bgr4_byte' | 'rgb8' | 'rgb4' | 'rgb4_byte' | 'nv12' | 'nv21' | 'argb' | 'rgba' | 'abgr' | 'bgra' | 'gray16' | 'yuv440p' | 'yuvj440p' | 'yuva420p' | 'rgb48' | 'rgb565' | 'rgb555' | 'bgr565' | 'bgr555' | 'vaapi_moco' | 'vaapi_idct' | 'vaapi_vld' | 'yuv420p16' | 'yuv422p16' | 'yuv444p16' | 'dxva2_vld' | 'rgb444' | 'bgr444' | 'ya8' | 'bgr48' | 'yuv420p9' | 'yuv420p10' | 'yuv422p10' | 'yuv444p9' | 'yuv444p10' | 'yuv422p9' | 'gbrp' | 'gbrp9' | 'gbrp10' | 'gbrp16' | 'yuva422p' | 'yuva444p' | 'yuva420p9' | 'yuva422p9' | 'yuva444p9' | 'yuva420p10' | 'yuva422p10' | 'yuva444p10' | 'yuva420p16' | 'yuva422p16' | 'yuva444p16' | 'vdpau' | 'xyz12' | 'nv16' | 'nv20' | 'rgba64' | 'bgra64' | 'yvyu422' | 'ya16' | 'gbrap' | 'gbrap16' | 'qsv' | 'mmal' | 'd3d11va_vld' | 'cuda' | '_0rgb' | 'rgb0' | '_0bgr' | 'bgr0' | 'yuv420p12' | 'yuv420p14' | 'yuv422p12' | 'yuv422p14' | 'yuv444p12' | 'yuv444p14' | 'gbrp12' | 'gbrp14' | 'yuvj411p' | 'bayer_bggr8' | 'bayer_rggb8' | 'bayer_gbrg8' | 'bayer_grbg8' | 'bayer_bggr16' | 'bayer_rggb16' | 'bayer_gbrg16' | 'bayer_grbg16' | 'xvmc' | 'yuv440p10' | 'yuv440p12' | 'ayuv64' | 'videotoolbox_vld' | 'p010' | 'gbrap12' | 'gbrap10' | 'mediacodec' | 'gray12' | 'gray10' | 'gray14' | 'p016' | 'd3d11' | 'gray9' | 'gbrpf32' | 'gbrapf32' | 'drm_prime' | 'opencl' | 'grayf32' | 'yuva422p12' | 'yuva444p12' | 'nv24' | 'nv42';

/**
 * A class combining both `Emby.Media.Model.Types.ProfileInformation` and `Emby.Media.Model.Types.LevelInformation`.
 *
 */
export type ProfileLevelInformation = {
    Profile?: ProfileInformation;
    Level?: LevelInformation;
};

/**
 * Class for unified presentation of all information associated with a specific codec profile.
 *
 */
export type ProfileInformation = {
    /**
     * The enum member name of the profile.
     */
    ShortName?: string;
    /**
     * The common name of the profile.
     */
    Description?: string;
    /**
     * Detail information about the profile.
     */
    Details?: string;
    /**
     * A unique identifier.
     */
    Id?: string;
    /**
     * The bit depths.
     */
    BitDepths?: Array<(number)>;
};

/**
 * Class for unified presentation of all information associated with a specific codec level.
 *
 */
export type LevelInformation = {
    /**
     * The enum member name of the level.
     */
    ShortName?: string;
    /**
     * The common name of the level.
     */
    Description?: string;
    /**
     * A value indicating the level's ranking relative to other levels.
     */
    Ordinal?: (number) | null;
    MaxBitRate?: BitRate;
    /**
     * A display value of the `Emby.Media.Model.Types.LevelInformation.MaxBitRate` property.
     */
    MaxBitRateDisplay?: string;
    /**
     * A unique identifier.
     */
    Id?: string;
    /**
     * Examples for the maximum supported combinations of resolution and rate for this level.
     */
    ResolutionRates?: Array<ResolutionWithRate>;
    /**
     * Examples for the maximum supported combinations of resolution and rate for this level as string values.
     */
    ResolutionRateStrings?: Array<(string)>;
    /**
     * A single string from the `Emby.Media.Model.Types.LevelInformation.ResolutionRateStrings` list.
     */
    ResolutionRatesDisplay?: string;
};

/**
 * Struct representing a combination of video resolution and frame rate.
 *
 *
 * `System.IEquatable`1`
 *
 */
export type ResolutionWithRate = {
    /**
     * The resolution width.
     */
    Width?: number;
    /**
     * The resolution height.
     */
    Height?: number;
    /**
     * The frame rate in frames\/second (fps).
     */
    FrameRate?: number;
    Resolution?: Resolution;
};

/**
 * Struct representing a video resolution specified in X and Y dimension.
 *
 *
 * `System.IComparable`
 *
 *
 * `System.IEquatable`1`
 *
 */
export type Resolution = {
    /**
     * The resolution width.
     */
    Width?: number;
    /**
     * The resolution height.
     */
    Height?: number;
};

/**
 * Enum for indicating the processing direction of a codec.
 *
 */
export type CodecDirections = 'Encoder' | 'Decoder';

export type CodecConfiguration = {
    /**
     * A value indicating whether the codec is enabled.
     */
    IsEnabled?: boolean;
    /**
     * The selection priority for the codec.
     *
     * Higher values mean higher priority.
     */
    Priority?: number;
    /**
     * The codec identifier.
     */
    CodecId?: string;
};

export type ExternalIdInfo = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The key.
     */
    Key?: string;
    Website?: string;
    /**
     * The URL format string.
     */
    UrlFormatString?: string;
    IsSupportedAsIdentifier?: boolean;
};

export type RemoteSearchQuery_TrailerInfo = {
    SearchInfo?: TrailerInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type TrailerInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchResult = {
    /**
     * The name.
     */
    Name?: string;
    OriginalTitle?: string;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    ProductionYear?: (number) | null;
    IndexNumber?: (number) | null;
    IndexNumberEnd?: (number) | null;
    ParentIndexNumber?: (number) | null;
    SortIndexNumber?: (number) | null;
    SortParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    StartDate?: (string) | null;
    EndDate?: (string) | null;
    ImageUrl?: string;
    SearchProviderName?: string;
    GameSystem?: string;
    Overview?: string;
    DisambiguationComment?: string;
    AlbumArtist?: RemoteSearchResult;
    Artists?: Array<RemoteSearchResult>;
};

export type RemoteSearchQuery_BookInfo = {
    SearchInfo?: BookInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type BookInfo = {
    SeriesName?: string;
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_MovieInfo = {
    SearchInfo?: MovieInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type MovieInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_SeriesInfo = {
    SearchInfo?: SeriesInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type SeriesInfo = {
    EpisodeAirDate?: (string) | null;
    DisplayOrder?: SeriesDisplayOrder;
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type SeriesDisplayOrder = 'Aired' | 'Dvd' | 'Absolute';

export type RemoteSearchQuery_GameInfo = {
    SearchInfo?: GameInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type GameInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_ItemLookupInfo = {
    SearchInfo?: ItemLookupInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type ItemLookupInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_MusicVideoInfo = {
    SearchInfo?: MusicVideoInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type MusicVideoInfo = {
    Artists?: Array<(string)>;
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_PersonLookupInfo = {
    SearchInfo?: PersonLookupInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type PersonLookupInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_AlbumInfo = {
    SearchInfo?: AlbumInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type AlbumInfo = {
    /**
     * The album artist.
     */
    AlbumArtists?: Array<(string)>;
    SongInfos?: Array<SongInfo>;
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type SongInfo = {
    AlbumArtists?: Array<(string)>;
    Album?: string;
    Artists?: Array<(string)>;
    Composers?: Array<(string)>;
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_ArtistInfo = {
    SearchInfo?: ArtistInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type ArtistInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type MetadataRefreshMode = 'ValidationOnly' | 'Default' | 'FullRefresh';

export type BaseRefreshRequest = {
    ReplaceThumbnailImages?: boolean;
};

export type MetadataEditorInfo = {
    ParentalRatingOptions?: Array<ParentalRating>;
    Countries?: Array<Globalization_CountryInfo>;
    Cultures?: Array<Globalization_CultureDto>;
    ExternalIdInfos?: Array<ExternalIdInfo>;
    PersonExternalIdInfos?: Array<ExternalIdInfo>;
};

export type UserLibrary_LeaveSharedItems = {
    ItemIds?: Array<(string)>;
    UserId?: string;
};

export type Library_DeleteInfo = {
    Paths?: Array<(string)>;
};

export type AllThemeMediaResult = {
    ThemeVideosResult?: ThemeMediaResult;
    ThemeSongsResult?: ThemeMediaResult;
    SoundtrackSongsResult?: ThemeMediaResult;
};

/**
 * Class ThemeMediaResult
 *
 */
export type ThemeMediaResult = {
    /**
     * The owner id.
     */
    OwnerId?: number;
    Items?: Array<BaseItemDto>;
    TotalRecordCount?: number;
};

/**
 * Class ImageInfo
 *
 */
export type ImageInfo = {
    ImageType?: ImageType;
    /**
     * The index of the image.
     */
    ImageIndex?: (number) | null;
    /**
     * The path.
     */
    Path?: string;
    Filename?: string;
    /**
     * The height.
     */
    Height?: (number) | null;
    /**
     * The width.
     */
    Width?: (number) | null;
    /**
     * The size.
     */
    Size?: number;
};

/**
 * Class RemoteImageResult.
 *
 */
export type RemoteImageResult = {
    /**
     * The images.
     */
    Images?: Array<RemoteImageInfo>;
    /**
     * The total record count.
     */
    TotalRecordCount?: number;
    /**
     * The providers.
     */
    Providers?: Array<(string)>;
};

/**
 * Class RemoteImageInfo
 *
 */
export type RemoteImageInfo = {
    /**
     * The name of the provider.
     */
    ProviderName?: string;
    /**
     * The URL.
     */
    Url?: string;
    /**
     * A url used for previewing a smaller version
     */
    ThumbnailUrl?: string;
    /**
     * The height.
     */
    Height?: (number) | null;
    /**
     * The width.
     */
    Width?: (number) | null;
    /**
     * The community rating.
     */
    CommunityRating?: (number) | null;
    /**
     * The vote count.
     */
    VoteCount?: (number) | null;
    /**
     * The language.
     */
    Language?: string;
    DisplayLanguage?: string;
    Type?: ImageType;
    RatingType?: RatingType;
};

export type RatingType = 'Score' | 'Likes';

export type RokuMetadata_Api_ThumbnailSetInfo = {
    AspectRatio?: (number) | null;
    Thumbnails?: Array<RokuMetadata_Api_ThumbnailInfo>;
};

export type RokuMetadata_Api_ThumbnailInfo = {
    PositionTicks?: number;
    ImageTag?: string;
};

export type PlaybackInfoResponse = {
    /**
     * The media sources.
     */
    MediaSources?: Array<MediaSourceInfo>;
    /**
     * The play session identifier.
     */
    PlaySessionId?: string;
    ErrorCode?: PlaybackErrorCode;
};

export type PlaybackErrorCode = 'NotAllowed' | 'NoCompatibleStream' | 'RateLimitExceeded';

export type PlaybackInfoRequest = {
    Id?: string;
    UserId?: string;
    MaxStreamingBitrate?: (number) | null;
    StartTimeTicks?: (number) | null;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    MaxAudioChannels?: (number) | null;
    MediaSourceId?: string;
    LiveStreamId?: string;
    DeviceProfile?: DeviceProfile;
    EnableDirectPlay?: boolean;
    EnableDirectStream?: boolean;
    EnableTranscoding?: boolean;
    AllowInterlacedVideoStreamCopy?: boolean;
    AllowVideoStreamCopy?: boolean;
    AllowAudioStreamCopy?: boolean;
    IsPlayback?: boolean;
    AutoOpenLiveStream?: boolean;
    CurrentPlaySessionId?: string;
};

export type Library_PostUpdatedMedia = {
    Updates?: Array<Library_MediaUpdateInfo>;
};

export type Library_MediaUpdateInfo = {
    Path?: string;
    UpdateType?: string;
};

export type QueryResult_VirtualFolderInfo = {
    Items?: Array<VirtualFolderInfo>;
    TotalRecordCount?: number;
};

/**
 * Used to hold information about a user's list of configured virtual folders
 *
 */
export type VirtualFolderInfo = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The locations.
     */
    Locations?: Array<(string)>;
    /**
     * The type of the collection.
     */
    CollectionType?: string;
    LibraryOptions?: LibraryOptions;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * ItemId came first, so that is left for compatability purposes
     */
    Id?: string;
    Guid?: string;
    /**
     * The primary image item identifier.
     */
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
    RefreshProgress?: (number) | null;
    RefreshStatus?: string;
};

export type Library_UpdateLibraryOptions = {
    Id?: string;
    LibraryOptions?: LibraryOptions;
};

export type Library_RenameVirtualFolder = {
    Id?: string;
    NewName?: string;
};

export type Library_RemoveVirtualFolder = {
    Id?: string;
    RefreshLibrary?: boolean;
};

export type Library_AddMediaPath = {
    Id?: string;
    Path?: string;
    PathInfo?: MediaPathInfo;
    RefreshLibrary?: boolean;
};

export type Api_TagItem = {
    Name?: string;
    Id?: string;
};

export type Api_ListingProviderTypeInfo = {
    Name?: string;
    Id?: string;
    SetupUrl?: string;
};

export type UserNotificationInfo = {
    NotifierKey?: string;
    SetupModuleUrl?: string;
    ServiceName?: string;
    PluginId?: string;
    FriendlyName?: string;
    Id?: string;
    Enabled?: boolean;
    /**
     * Limit events based on user ids, for admin notifications
     */
    UserIds?: Array<(string)>;
    DeviceIds?: Array<(string)>;
    LibraryIds?: Array<(string)>;
    EventIds?: Array<(string)>;
    /**
     * Notification intended for a specific user
     */
    UserId?: string;
    IsSelfNotification?: boolean;
    GroupItems?: boolean;
    /**
     * This is for webhooks since this will cause xml serialization to fail
     */
    Options?: {
        [key: string]: (string);
    };
};

export type Playlists_AddToPlaylistInfo = {
    ItemCount?: number;
    ContainsDuplicates?: boolean;
};

export type Playlists_AddToPlaylistResult = {
    Id?: string;
    ItemAddedCount?: number;
};

/**
 * Enum PlayCommand
 *
 */
export type PlayCommand = 'PlayNow' | 'PlayNext' | 'PlayLast' | 'PlayInstantMix' | 'PlayShuffle';

/**
 * Class PlayRequest
 *
 */
export type PlayRequest = {
    /**
     * The controlling user identifier.
     */
    ControllingUserId?: string;
    SubtitleStreamIndex?: (number) | null;
    AudioStreamIndex?: (number) | null;
    MediaSourceId?: string;
    StartIndex?: (number) | null;
};

export type GeneralCommand = {
    Name?: string;
    ControllingUserId?: string;
    Arguments?: {
        [key: string]: (string);
    };
};

export type ClientCapabilities = {
    PlayableMediaTypes?: Array<(string)>;
    SupportedCommands?: Array<(string)>;
    SupportsMediaControl?: boolean;
    PushToken?: string;
    PushTokenType?: string;
    SupportsSync?: boolean;
    DeviceProfile?: DeviceProfile;
    IconUrl?: string;
    AppId?: string;
};

/**
 * Class PlaybackProgressInfo.
 *
 */
export type PlaybackProgressInfo = {
    /**
     * A value indicating whether this instance can seek.
     */
    CanSeek?: boolean;
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    /**
     * The session id.
     */
    SessionId?: string;
    /**
     * The index of the audio stream.
     */
    AudioStreamIndex?: (number) | null;
    /**
     * The index of the subtitle stream.
     */
    SubtitleStreamIndex?: (number) | null;
    /**
     * A value indicating whether this instance is paused.
     */
    IsPaused?: boolean;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    /**
     * A value indicating whether this instance is muted.
     */
    IsMuted?: boolean;
    RunTimeTicks?: (number) | null;
    PlaybackStartTimeTicks?: (number) | null;
    /**
     * The volume level.
     */
    VolumeLevel?: (number) | null;
    Brightness?: (number) | null;
    AspectRatio?: string;
    EventName?: ProgressEvent;
    PlayMethod?: PlayMethod;
    RepeatMode?: RepeatMode;
    SleepTimerMode?: SleepTimerMode;
    SleepTimerEndTime?: (string) | null;
    Shuffle?: boolean;
    SubtitleOffset?: number;
    PlaybackRate?: number;
    PlaylistItemIds?: Array<(string)>;
    /**
     * The play session identifier.
     */
    PlaySessionId?: string;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * The live stream identifier.
     */
    LiveStreamId?: string;
    /**
     * The media version identifier.
     */
    MediaSourceId?: string;
    Item?: BaseItemDto;
    /**
     * The position ticks.
     */
    PositionTicks?: (number) | null;
};

/**
 * Class PlaybackStopInfo.
 *
 */
export type PlaybackStopInfo = {
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    /**
     * The session id.
     */
    SessionId?: string;
    IsAutomated?: boolean;
    /**
     * A value indicating whether this `MediaBrowser.Model.Session.PlaybackStopInfo` is failed.
     */
    Failed?: boolean;
    NextMediaType?: string;
    /**
     * The play session identifier.
     */
    PlaySessionId?: string;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * The live stream identifier.
     */
    LiveStreamId?: string;
    /**
     * The media version identifier.
     */
    MediaSourceId?: string;
    Item?: BaseItemDto;
    /**
     * The position ticks.
     */
    PositionTicks?: (number) | null;
};

export type SyncedItemProgress = {
    Progress?: (number) | null;
    Status?: SyncJobItemStatus;
};

export type SyncedItem = {
    ServerId?: string;
    SyncJobId?: number;
    SyncJobName?: string;
    SyncJobDateCreated?: string;
    SyncJobItemId?: number;
    OriginalFileName?: string;
    Item?: BaseItemDto;
    UserId?: string;
    AdditionalFiles?: Array<ItemFileInfo>;
};

export type QueryResult_LogFile = {
    Items?: Array<LogFile>;
    TotalRecordCount?: number;
};

export type LogFile = {
    /**
     * The date created.
     */
    DateCreated?: string;
    /**
     * The date modified.
     */
    DateModified?: string;
    /**
     * The size.
     */
    Size?: number;
    /**
     * The name.
     */
    Name?: string;
};

export type PublicSystemInfo = {
    /**
     * The local address.
     */
    LocalAddress?: string;
    LocalAddresses?: Array<(string)>;
    /**
     * The wan address.
     */
    WanAddress?: string;
    RemoteAddresses?: Array<(string)>;
    /**
     * The name of the server.
     */
    ServerName?: string;
    /**
     * The version.
     */
    Version?: string;
    /**
     * The id.
     */
    Id?: string;
};

export type QueryResult_ActivityLogEntry = {
    Items?: Array<ActivityLogEntry>;
    TotalRecordCount?: number;
};

export type ActivityLogEntry = {
    /**
     * The identifier.
     */
    Id?: number;
    /**
     * The name.
     */
    Name?: string;
    /**
     * The overview.
     */
    Overview?: string;
    /**
     * The short overview.
     */
    ShortOverview?: string;
    /**
     * The type.
     */
    Type?: string;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * The date.
     */
    Date?: string;
    /**
     * The user identifier.
     */
    UserId?: string;
    /**
     * The user primary image tag.
     */
    UserPrimaryImageTag?: string;
    Severity?: Logging_LogSeverity;
};

/**
 * Enum LogSeverity
 *
 */
export type Logging_LogSeverity = 'Info' | 'Debug' | 'Warn' | 'Error' | 'Fatal';

export type AuthenticateUser = {
    Pw?: string;
};

export type UpdateUserPassword = {
    Id?: string;
    NewPw?: string;
    ResetPassword?: boolean;
};

export type ForgotPasswordPin = {
    Pin?: string;
};

export type PinRedeemResult = {
    /**
     * A value indicating whether this `MediaBrowser.Model.Users.PinRedeemResult` is success.
     */
    Success?: boolean;
    /**
     * The users reset.
     */
    UsersReset?: Array<(string)>;
};

export type ContentSection = {
    Name?: string;
    Subtitle?: string;
    Id?: string;
    SectionType?: string;
    CollectionType?: string;
    ViewType?: string;
    Monitor?: Array<(string)>;
    CardSizeOffset?: number;
    ScrollDirection?: ScrollDirection;
    ParentItem?: BaseItemDto;
    TextInfo?: TextSectionInfo;
    PremiumFeature?: string;
    PremiumMessage?: string;
    RefreshInterval?: (number) | null;
};

export type ScrollDirection = 'Horizontal' | 'Vertical';

export type TextSectionInfo = {
    Text?: string;
    Name?: string;
    Id?: string;
    Level?: Notifications_NotificationLevel;
};

export type Notifications_NotificationLevel = 'Normal' | 'Warning' | 'Error';

export type UserLibrary_AddTags = {
    Tags?: Array<NameIdPair>;
};

export type UserLibrary_RemoveTags = {
    Tags?: Array<NameIdPair>;
};

/**
 * Class ImageProviderInfo.
 *
 */
export type ImageProviderInfo = {
    /**
     * The name.
     */
    Name?: string;
    SupportedImages?: Array<ImageType>;
};

export type Images_BaseDownloadRemoteImage = {
    ImageIndex?: (number) | null;
};

export type Library_UpdateMediaPath = {
    Id?: string;
    PathInfo?: MediaPathInfo;
};

export type Library_RemoveMediaPath = {
    Id?: string;
    Path?: string;
    RefreshLibrary?: boolean;
};

/**
 * Enum PlaystateCommand
 *
 */
export type PlaystateCommand = 'Stop' | 'Pause' | 'Unpause' | 'NextTrack' | 'PreviousTrack' | 'Seek' | 'Rewind' | 'FastForward' | 'PlayPause' | 'SeekRelative';

export type PlaystateRequest = {
    Command?: PlaystateCommand;
    SeekPositionTicks?: (number) | null;
    /**
     * The controlling user identifier.
     */
    ControllingUserId?: string;
};

export type QueryResult_String = {
    Items?: Array<(string)>;
    TotalRecordCount?: number;
};

export type Connect_UserLinkResult = {
    IsPending?: boolean;
    IsNewUserInvitation?: boolean;
    GuestDisplayName?: string;
};

export type RemoteSubtitleInfo = {
    /**
     * Use language instead to return the language specified by the subtitle provider
     * @deprecated
     */
    ThreeLetterISOLanguageName?: string;
    Id?: string;
    ProviderName?: string;
    Name?: string;
    Format?: string;
    Author?: string;
    Comment?: string;
    DateCreated?: (string) | null;
    CommunityRating?: (number) | null;
    DownloadCount?: (number) | null;
    IsHashMatch?: (boolean) | null;
    IsForced?: (boolean) | null;
    IsHearingImpaired?: (boolean) | null;
    Language?: string;
};

export type Subtitles_SubtitleDownloadResult = {
    NewIndex?: (number) | null;
};

export type Api_SetChannelDisabled = {
    Id?: string;
    ManagementId?: string;
    Disabled?: boolean;
};

export type QueryResult_ChannelManagementInfo = {
    Items?: Array<ChannelManagementInfo>;
    TotalRecordCount?: number;
};

export type ChannelManagementInfo = {
    Id?: string;
    Name?: string;
};

export type Api_SetChannelSortIndex = {
    Id?: string;
    ManagementId?: string;
    NewIndex?: number;
};

export type Api_OnPlaybackProgress = {
    PlaylistIndex?: number;
    PlaylistLength?: number;
    Shuffle?: boolean;
    SleepTimerMode?: SleepTimerMode;
    SleepTimerEndTime?: (string) | null;
    EventName?: ProgressEvent;
};

export type GetArtistsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsResponse = (QueryResult_BaseItemDto);

export type GetArtistsByNameData = {
    /**
     * The artist name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetArtistsByNameResponse = (BaseItemDto);

export type GetArtistsAlbumartistsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsAlbumartistsResponse = (QueryResult_BaseItemDto);

export type GetAudiocodecsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetAudiocodecsResponse = (QueryResult_UserLibrary_TagItem);

export type GetAudiolayoutsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetAudiolayoutsResponse = (QueryResult_UserLibrary_TagItem);

export type GetContainersData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetContainersResponse = (QueryResult_UserLibrary_TagItem);

export type GetExtendedvideotypesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetExtendedvideotypesResponse = (QueryResult_UserLibrary_TagItem);

export type GetItemtypesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemtypesResponse = (QueryResult_UserLibrary_TagItem);

export type GetStreamlanguagesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetStreamlanguagesResponse = (QueryResult_UserLibrary_TagItem);

export type GetSubtitlecodecsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetSubtitlecodecsResponse = (QueryResult_UserLibrary_TagItem);

export type GetTagsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetTagsResponse = (QueryResult_UserLibrary_TagItem);

export type GetVideocodecsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetVideocodecsResponse = (QueryResult_UserLibrary_TagItem);

export type GetYearsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetYearsResponse = (QueryResult_UserLibrary_TagItem);

export type GetArtistsPrefixesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsPrefixesResponse = (Array<NameValuePair>);

export type GetItemsPrefixesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsPrefixesResponse = (Array<NameValuePair>);

export type PostItemsByIdTagsAddData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * AddTags
     */
    requestBody: UserLibrary_AddTags;
};

export type PostItemsByIdTagsAddResponse = (unknown);

export type PostItemsByIdTagsDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * RemoveTags
     */
    requestBody: UserLibrary_RemoveTags;
};

export type PostItemsByIdTagsDeleteResponse = (unknown);

export type GetChannelsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetChannelsResponse = (QueryResult_BaseItemDto);

export type PostCollectionsData = {
    /**
     * Item Ids to add to the collection
     */
    ids?: string;
    /**
     * Whether or not to lock the new collection.
     */
    isLocked?: boolean;
    /**
     * The name of the new collection.
     */
    name?: string;
    /**
     * Optional - create the collection within a specific folder
     */
    parentId?: string;
};

export type PostCollectionsResponse = (Collections_CollectionCreationResult);

export type PostCollectionsByIdItemsData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
};

export type PostCollectionsByIdItemsResponse = (unknown);

export type DeleteCollectionsByIdItemsData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
};

export type DeleteCollectionsByIdItemsResponse = (unknown);

export type PostCollectionsByIdItemsDeleteData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
};

export type PostCollectionsByIdItemsDeleteResponse = (unknown);

export type GetDevicesData = {
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
};

export type GetDevicesResponse = (QueryResult_Devices_DeviceInfo);

export type DeleteDevicesData = {
    /**
     * Device Id
     */
    id: string;
};

export type DeleteDevicesResponse = (unknown);

export type PostDevicesOptionsData = {
    /**
     * Device Id
     */
    id: string;
    /**
     * DeviceOptions:
     */
    requestBody: Devices_DeviceOptions;
};

export type PostDevicesOptionsResponse = (unknown);

export type GetDevicesOptionsData = {
    /**
     * Device Id
     */
    id: string;
};

export type GetDevicesOptionsResponse = (Devices_DeviceOptions);

export type GetDevicesInfoData = {
    /**
     * Device Id
     */
    id: string;
};

export type GetDevicesInfoResponse = (Devices_DeviceInfo);

export type GetDevicesCamerauploadsResponse = (Devices_ContentUploadHistory);

export type PostDevicesCamerauploadsData = {
    /**
     * Album
     */
    album: string;
    /**
     * Id
     */
    id: string;
    /**
     * Name
     */
    name: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostDevicesCamerauploadsResponse = (unknown);

export type PostDevicesDeleteData = {
    /**
     * Device Id
     */
    id: string;
};

export type PostDevicesDeleteResponse = (unknown);

export type GetFeaturesResponse = (Array<FeatureInfo>);

export type GetGamegenresData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetGamegenresResponse = (QueryResult_BaseItemDto);

export type GetGamegenresByNameData = {
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetGamegenresByNameResponse = (BaseItemDto);

export type GetGenresData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetGenresResponse = (QueryResult_BaseItemDto);

export type GetGenresByNameData = {
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetGenresByNameResponse = (BaseItemDto);

export type GetItemsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridItemsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetUsersByUseridItemsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridItemsResumeData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetUsersByUseridItemsResumeResponse = (QueryResult_BaseItemDto);

export type DeleteItemsData = {
    /**
     * Ids
     */
    ids: string;
};

export type DeleteItemsResponse = (unknown);

export type GetItemsCountsData = {
    /**
     * Optional. Get counts of favorite items
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional. Get counts from a specific user's library.
     */
    userId?: string;
};

export type GetItemsCountsResponse = (ItemCounts);

export type GetItemsIntrosResponse = (Array<Persistence_IntroDebugInfo>);

export type PostItemsDeleteData = {
    /**
     * Ids
     */
    ids: string;
};

export type PostItemsDeleteResponse = (unknown);

export type DeleteItemsByIdData = {
    /**
     * Item Id
     */
    id: string;
};

export type DeleteItemsByIdResponse = (unknown);

export type GetLibrariesAvailableoptionsResponse = (LibraryOptionsResult);

export type GetLibrarySelectablemediafoldersResponse = (Array<Library_MediaFolder>);

export type GetLibraryMediafoldersData = {
    /**
     * Optional. Filter by folders that are marked hidden, or not.
     */
    isHidden?: (boolean) | null;
};

export type GetLibraryMediafoldersResponse = (QueryResult_BaseItemDto);

export type GetLibraryPhysicalpathsResponse = (Array<(string)>);

export type PostLibraryRefreshResponse = (unknown);

export type GetAlbumsByIdSimilarData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetAlbumsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetArtistsByIdSimilarData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetGamesByIdSimilarData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetGamesByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdDeleteinfoData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdDeleteinfoResponse = (Library_DeleteInfo);

export type GetItemsByIdSimilarData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdDownloadData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdDownloadResponse = (unknown);

export type GetItemsByIdFileData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdFileResponse = (unknown);

export type GetItemsByIdAncestorsData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdAncestorsResponse = (Array<BaseItemDto>);

export type GetItemsByIdCriticreviewsData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
};

export type GetItemsByIdCriticreviewsResponse = (QueryResult_BaseItemDto);

export type PostItemsByIdDeleteData = {
    /**
     * Item Id
     */
    id: string;
};

export type PostItemsByIdDeleteResponse = (unknown);

export type GetItemsByIdThememediaData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Determines whether or not parent items should be searched for theme media.
     */
    inheritFromParent?: boolean;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsByIdThememediaResponse = (AllThemeMediaResult);

export type GetItemsByIdThemesongsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Determines whether or not parent items should be searched for theme media.
     */
    inheritFromParent?: boolean;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsByIdThemesongsResponse = (ThemeMediaResult);

export type GetItemsByIdThemevideosData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Determines whether or not parent items should be searched for theme media.
     */
    inheritFromParent?: boolean;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsByIdThemevideosResponse = (ThemeMediaResult);

export type PostLibrarySeriesAddedResponse = (unknown);

export type PostLibrarySeriesUpdatedResponse = (unknown);

export type PostLibraryMediaUpdatedData = {
    /**
     * PostUpdatedMedia
     */
    requestBody: Library_PostUpdatedMedia;
};

export type PostLibraryMediaUpdatedResponse = (unknown);

export type PostLibraryMoviesAddedResponse = (unknown);

export type PostLibraryMoviesUpdatedResponse = (unknown);

export type GetMoviesByIdSimilarData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetMoviesByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetShowsByIdSimilarData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetShowsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetTrailersByIdSimilarData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetTrailersByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetMusicgenresResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresByNameData = {
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMusicgenresByNameResponse = (BaseItemDto);

export type GetOfficialratingsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetOfficialratingsResponse = (QueryResult_UserLibrary_OfficialRatingItem);

export type GetOpenapiResponse = (string);

export type GetOpenapiJsonResponse = (string);

export type GetSwaggerResponse = (string);

export type GetSwaggerJsonResponse = (string);

export type GetPackagesData = {
    /**
     * Optional. Filter by package that contain adult content.
     */
    isAdult?: (boolean) | null;
    /**
     * Optional. Filter by premium status
     */
    isPremium?: (boolean) | null;
    /**
     * Optional package type filter (System/UserInstalled)
     */
    packageType?: string;
    /**
     * Optional. Filter by target system type. Allows multiple, comma delimited.
     */
    targetSystems?: string;
};

export type GetPackagesResponse = (Array<PackageInfo>);

export type GetPackagesUpdatesData = {
    /**
     * Package type filter (System/UserInstalled)
     */
    packageType: string;
};

export type GetPackagesUpdatesResponse = (Array<PackageVersionInfo>);

export type GetPackagesByNameData = {
    /**
     * The guid of the associated assembly
     */
    assemblyGuid?: string;
    /**
     * The name of the package
     */
    name: string;
};

export type GetPackagesByNameResponse = (PackageInfo);

export type PostPackagesInstalledByNameData = {
    /**
     * Guid of the associated assembly
     */
    assemblyGuid?: string;
    /**
     * Package name
     */
    name: string;
    /**
     * Optional update class (Dev, Beta, Release). Defaults to Release.
     */
    updateClass?: PackageVersionClass;
    /**
     * Optional version. Defaults to latest version.
     */
    version?: string;
};

export type PostPackagesInstalledByNameResponse = (unknown);

export type DeletePackagesInstallingByIdData = {
    /**
     * Installation Id
     */
    id: string;
};

export type DeletePackagesInstallingByIdResponse = (unknown);

export type PostPackagesInstallingByIdDeleteData = {
    /**
     * Installation Id
     */
    id: string;
};

export type PostPackagesInstallingByIdDeleteResponse = (unknown);

export type GetPersonsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetPersonsResponse = (QueryResult_BaseItemDto);

export type GetPersonsByNameData = {
    /**
     * The person name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetPersonsByNameResponse = (BaseItemDto);

export type PostPlaylistsData = {
    /**
     * Item Ids to add to the playlist
     */
    ids?: string;
    /**
     * The playlist media type
     */
    mediaType?: string;
    /**
     * The name of the new playlist.
     */
    name?: string;
};

export type PostPlaylistsResponse = (Playlists_PlaylistCreationResult);

export type GetPlaylistsByIdAddtoplaylistinfoData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
    /**
     * User Id
     */
    userId?: string;
};

export type GetPlaylistsByIdAddtoplaylistinfoResponse = (Playlists_AddToPlaylistInfo);

export type PostPlaylistsByIdItemsData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
    /**
     * User Id
     */
    userId?: string;
};

export type PostPlaylistsByIdItemsResponse = (Playlists_AddToPlaylistResult);

export type DeletePlaylistsByIdItemsData = {
    entryIds: string;
    id: string;
};

export type DeletePlaylistsByIdItemsResponse = (unknown);

export type GetPlaylistsByIdItemsData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId?: string;
};

export type GetPlaylistsByIdItemsResponse = (QueryResult_BaseItemDto);

export type PostPlaylistsByIdItemsDeleteData = {
    entryIds: string;
    id: string;
};

export type PostPlaylistsByIdItemsDeleteResponse = (unknown);

export type PostPlaylistsByIdItemsByItemidMoveByNewindexData = {
    id: string;
    /**
     * ItemId
     */
    itemId: number;
    /**
     * NewIndex
     */
    newIndex: number;
};

export type PostPlaylistsByIdItemsByItemidMoveByNewindexResponse = (unknown);

export type GetPluginsResponse = (Array<Plugins_PluginInfo>);

export type DeletePluginsByIdData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type DeletePluginsByIdResponse = (unknown);

export type GetPluginsByIdThumbData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type GetPluginsByIdThumbResponse = (unknown);

export type GetPluginsByIdConfigurationData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type GetPluginsByIdConfigurationResponse = (unknown);

export type PostPluginsByIdConfigurationData = {
    /**
     * Plugin Id
     */
    id: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostPluginsByIdConfigurationResponse = (unknown);

export type PostPluginsByIdDeleteData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type PostPluginsByIdDeleteResponse = (unknown);

export type GetScheduledtasksData = {
    /**
     * Optional filter tasks that are enabled, or not.
     */
    isEnabled?: (boolean) | null;
    /**
     * Optional filter tasks that are hidden, or not.
     */
    isHidden?: (boolean) | null;
};

export type GetScheduledtasksResponse = (Array<TaskInfo>);

export type GetScheduledtasksByIdData = {
    id: string;
};

export type GetScheduledtasksByIdResponse = (TaskInfo);

export type PostScheduledtasksRunningByIdData = {
    id: string;
};

export type PostScheduledtasksRunningByIdResponse = (unknown);

export type DeleteScheduledtasksRunningByIdData = {
    id: string;
};

export type DeleteScheduledtasksRunningByIdResponse = (unknown);

export type PostScheduledtasksByIdTriggersData = {
    id: string;
    /**
     * List`1:
     */
    requestBody: Array<TaskTriggerInfo>;
};

export type PostScheduledtasksByIdTriggersResponse = (unknown);

export type PostScheduledtasksRunningByIdDeleteData = {
    id: string;
};

export type PostScheduledtasksRunningByIdDeleteResponse = (unknown);

export type GetSessionsData = {
    /**
     * Optional. Filter by sessions that a given user is allowed to remote control.
     */
    controllableByUserId?: string;
    /**
     * Optional. Filter by device id.
     */
    deviceId?: string;
    /**
     * Optional. Filter by session id.
     */
    id?: string;
};

export type GetSessionsResponse = (Array<Session_SessionInfo>);

export type GetAuthProvidersResponse = (Array<NameIdPair>);

export type PostAuthKeysData = {
    /**
     * App
     */
    app: string;
};

export type PostAuthKeysResponse = (unknown);

export type GetAuthKeysData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetAuthKeysResponse = (unknown);

export type GetSessionsPlayqueueData = {
    /**
     * Optional. Filter by device id.
     */
    deviceId?: string;
    /**
     * Optional. Filter by session id.
     */
    id?: string;
};

export type GetSessionsPlayqueueResponse = (QueryResult_BaseItemDto);

export type PostSessionsLogoutResponse = (unknown);

export type PostSessionsCapabilitiesData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
     */
    playableMediaTypes?: string;
    /**
     * A list of supported remote control commands, comma delimited
     */
    supportedCommands?: string;
    /**
     * Determines whether media can be played remotely.
     */
    supportsMediaControl?: boolean;
    /**
     * Determines whether sync is supported.
     */
    supportsSync?: boolean;
};

export type PostSessionsCapabilitiesResponse = (unknown);

export type DeleteAuthKeysByKeyData = {
    /**
     * Auth Key
     */
    key: string;
};

export type DeleteAuthKeysByKeyResponse = (unknown);

export type PostSessionsByIdViewingData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * The Id of the item.
     */
    itemId: string;
    /**
     * The name of the item.
     */
    itemName: string;
    /**
     * The type of item to browse to.
     */
    itemType: string;
};

export type PostSessionsByIdViewingResponse = (unknown);

export type PostSessionsByIdMessageData = {
    /**
     * The message header.
     */
    header: string;
    /**
     * Session Id
     */
    id: string;
    /**
     * The message text.
     */
    text: string;
    /**
     * The message timeout. If omitted the user will have to confirm viewing the message.
     */
    timeoutMs?: (number) | null;
};

export type PostSessionsByIdMessageResponse = (unknown);

export type PostSessionsByIdPlayingData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * The ids of the items to play, comma delimited
     */
    itemIds: Array<(number)>;
    /**
     * The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
     */
    playCommand: PlayCommand;
    /**
     * PlayRequest:
     */
    requestBody: PlayRequest;
    /**
     * The starting position of the first item.
     */
    startPositionTicks?: (number) | null;
};

export type PostSessionsByIdPlayingResponse = (unknown);

export type PostSessionsByIdCommandData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * GeneralCommand:
     */
    requestBody: GeneralCommand;
};

export type PostSessionsByIdCommandResponse = (unknown);

export type PostSessionsCapabilitiesFullData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * ClientCapabilities:
     */
    requestBody: ClientCapabilities;
};

export type PostSessionsCapabilitiesFullResponse = (unknown);

export type PostAuthKeysByKeyDeleteData = {
    /**
     * Auth Key
     */
    key: string;
};

export type PostAuthKeysByKeyDeleteResponse = (unknown);

export type PostSessionsByIdPlayingByCommandData = {
    command: PlaystateCommand;
    /**
     * Session Id
     */
    id: string;
    /**
     * PlaystateRequest:
     */
    requestBody: PlaystateRequest;
};

export type PostSessionsByIdPlayingByCommandResponse = (unknown);

export type PostSessionsByIdSystemByCommandData = {
    /**
     * The command to send.
     */
    command: string;
    /**
     * Session Id
     */
    id: string;
};

export type PostSessionsByIdSystemByCommandResponse = (unknown);

export type PostSessionsByIdCommandByCommandData = {
    /**
     * The command to send.
     */
    command: string;
    /**
     * Session Id
     */
    id: string;
};

export type PostSessionsByIdCommandByCommandResponse = (unknown);

export type PostSessionsByIdUsersByUseridData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * UserId Id
     */
    userId: string;
};

export type PostSessionsByIdUsersByUseridResponse = (unknown);

export type DeleteSessionsByIdUsersByUseridData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * UserId Id
     */
    userId: string;
};

export type DeleteSessionsByIdUsersByUseridResponse = (unknown);

export type PostSessionsByIdUsersByUseridDeleteData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * UserId Id
     */
    userId: string;
};

export type PostSessionsByIdUsersByUseridDeleteResponse = (unknown);

export type GetStudiosData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetStudiosResponse = (QueryResult_BaseItemDto);

export type GetStudiosByNameData = {
    /**
     * The studio name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetStudiosByNameResponse = (BaseItemDto);

export type GetTrailersData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetTrailersResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight: number;
    /**
     * The maximum image width to return.
     */
    maxWidth: number;
    percentPlayed: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag: string;
    /**
     * Image Type
     */
    type: ImageType;
    unPlayedCount: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse = (unknown);

export type HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight: number;
    /**
     * The maximum image width to return.
     */
    maxWidth: number;
    percentPlayed: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag: string;
    /**
     * Image Type
     */
    type: ImageType;
    unPlayedCount: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse = (unknown);

export type GetItemsByIdImagesData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdImagesResponse = (Array<ImageInfo>);

export type GetArtistsByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetArtistsByNameImagesByTypeResponse = (unknown);

export type HeadArtistsByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadArtistsByNameImagesByTypeResponse = (unknown);

export type GetGamegenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetGamegenresByNameImagesByTypeResponse = (unknown);

export type HeadGamegenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadGamegenresByNameImagesByTypeResponse = (unknown);

export type GetGenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetGenresByNameImagesByTypeResponse = (unknown);

export type HeadGenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadGenresByNameImagesByTypeResponse = (unknown);

export type GetItemsByIdImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetItemsByIdImagesByTypeResponse = (unknown);

export type HeadItemsByIdImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadItemsByIdImagesByTypeResponse = (unknown);

export type PostItemsByIdImagesByTypeData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: (number) | null;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostItemsByIdImagesByTypeResponse = (unknown);

export type DeleteItemsByIdImagesByTypeData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type DeleteItemsByIdImagesByTypeResponse = (unknown);

export type GetMusicgenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetMusicgenresByNameImagesByTypeResponse = (unknown);

export type HeadMusicgenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadMusicgenresByNameImagesByTypeResponse = (unknown);

export type GetPersonsByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetPersonsByNameImagesByTypeResponse = (unknown);

export type HeadPersonsByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadPersonsByNameImagesByTypeResponse = (unknown);

export type GetStudiosByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetStudiosByNameImagesByTypeResponse = (unknown);

export type HeadStudiosByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadStudiosByNameImagesByTypeResponse = (unknown);

export type GetUsersByIdImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetUsersByIdImagesByTypeResponse = (unknown);

export type HeadUsersByIdImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadUsersByIdImagesByTypeResponse = (unknown);

export type PostUsersByIdImagesByTypeData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostUsersByIdImagesByTypeResponse = (unknown);

export type DeleteUsersByIdImagesByTypeData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type DeleteUsersByIdImagesByTypeResponse = (unknown);

export type GetArtistsByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetArtistsByNameImagesByTypeByIndexResponse = (unknown);

export type HeadArtistsByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadArtistsByNameImagesByTypeByIndexResponse = (unknown);

export type GetGamegenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetGamegenresByNameImagesByTypeByIndexResponse = (unknown);

export type HeadGamegenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadGamegenresByNameImagesByTypeByIndexResponse = (unknown);

export type GetGenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetGenresByNameImagesByTypeByIndexResponse = (unknown);

export type HeadGenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadGenresByNameImagesByTypeByIndexResponse = (unknown);

export type GetItemsByIdImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetItemsByIdImagesByTypeByIndexResponse = (unknown);

export type HeadItemsByIdImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadItemsByIdImagesByTypeByIndexResponse = (unknown);

export type PostItemsByIdImagesByTypeByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: (number) | null;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostItemsByIdImagesByTypeByIndexResponse = (unknown);

export type DeleteItemsByIdImagesByTypeByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type DeleteItemsByIdImagesByTypeByIndexResponse = (unknown);

export type PostItemsByIdImagesByTypeDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostItemsByIdImagesByTypeDeleteResponse = (unknown);

export type GetMusicgenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetMusicgenresByNameImagesByTypeByIndexResponse = (unknown);

export type HeadMusicgenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadMusicgenresByNameImagesByTypeByIndexResponse = (unknown);

export type GetPersonsByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetPersonsByNameImagesByTypeByIndexResponse = (unknown);

export type HeadPersonsByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadPersonsByNameImagesByTypeByIndexResponse = (unknown);

export type GetStudiosByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetStudiosByNameImagesByTypeByIndexResponse = (unknown);

export type HeadStudiosByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadStudiosByNameImagesByTypeByIndexResponse = (unknown);

export type GetUsersByIdImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetUsersByIdImagesByTypeByIndexResponse = (unknown);

export type HeadUsersByIdImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadUsersByIdImagesByTypeByIndexResponse = (unknown);

export type PostUsersByIdImagesByTypeByIndexData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostUsersByIdImagesByTypeByIndexResponse = (unknown);

export type DeleteUsersByIdImagesByTypeByIndexData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type DeleteUsersByIdImagesByTypeByIndexResponse = (unknown);

export type PostUsersByIdImagesByTypeDeleteData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostUsersByIdImagesByTypeDeleteResponse = (unknown);

export type PostItemsByIdImagesByTypeByIndexDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostItemsByIdImagesByTypeByIndexDeleteResponse = (unknown);

export type PostItemsByIdImagesByTypeByIndexIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * The new image index
     */
    newIndex: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostItemsByIdImagesByTypeByIndexIndexResponse = (unknown);

export type PostItemsByIdImagesByTypeByIndexUrlData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The url for the new image
     */
    url: string;
};

export type PostItemsByIdImagesByTypeByIndexUrlResponse = (unknown);

export type PostUsersByIdImagesByTypeByIndexDeleteData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostUsersByIdImagesByTypeByIndexDeleteResponse = (unknown);

export type GetArtistsInstantmixData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsInstantmixResponse = (QueryResult_BaseItemDto);

export type GetAudiobooksNextupData = {
    /**
     * Optional. Filter by series id
     */
    albumId?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetAudiobooksNextupResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresInstantmixData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetMusicgenresInstantmixResponse = (QueryResult_BaseItemDto);

export type GetAlbumsByIdInstantmixData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetAlbumsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdInstantmixData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresByNameInstantmixData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    name: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetMusicgenresByNameInstantmixResponse = (QueryResult_BaseItemDto);

export type GetPlaylistsByIdInstantmixData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetPlaylistsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type GetSongsByIdInstantmixData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetSongsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type PostBackuprestoreRestoreData = {
    /**
     * RestoreOptions:
     */
    requestBody: MBBackup_Api_RestoreOptions;
};

export type PostBackuprestoreRestoreResponse = (unknown);

export type PostBackuprestoreRestoredataData = {
    /**
     * DataRestoreOptions:
     */
    requestBody: MBBackup_Api_DataRestoreOptions;
};

export type PostBackuprestoreRestoredataResponse = (unknown);

export type GetBackuprestoreBackupinfoResponse = (MBBackup_Api_AllBackupsInfo);

export type GetBrandingConfigurationResponse = (Branding_BrandingOptions);

export type GetBrandingCssResponse = (unknown);

export type GetBrandingCssCssResponse = (unknown);

export type GetConnectPendingResponse = (unknown);

export type GetConnectExchangeData = {
    /**
     * ConnectUserId
     */
    connectUserId: string;
};

export type GetConnectExchangeResponse = (Connect_ConnectAuthenticationExchangeResult);

export type PostUsersByIdConnectLinkData = {
    /**
     * Connect username
     */
    connectUsername: string;
    /**
     * User Id
     */
    id: string;
};

export type PostUsersByIdConnectLinkResponse = (Connect_UserLinkResult);

export type DeleteUsersByIdConnectLinkData = {
    /**
     * User Id
     */
    id: string;
};

export type DeleteUsersByIdConnectLinkResponse = (unknown);

export type PostUsersByIdConnectLinkDeleteData = {
    /**
     * User Id
     */
    id: string;
};

export type PostUsersByIdConnectLinkDeleteResponse = (unknown);

export type GetDisplaypreferencesByIdData = {
    /**
     * Client
     */
    client: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetDisplaypreferencesByIdResponse = (DisplayPreferences);

export type PostDisplaypreferencesByDisplaypreferencesidData = {
    /**
     * DisplayPreferences Id
     */
    displayPreferencesId: string;
    /**
     * DisplayPreferences:
     */
    requestBody: DisplayPreferences;
    /**
     * User Id
     */
    userId: string;
};

export type PostDisplaypreferencesByDisplaypreferencesidResponse = (unknown);

export type GetUsersettingsByUseridData = {
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersettingsByUseridResponse = ({
    [key: string]: (string);
});

export type PostUsersettingsByUseridData = {
    /**
     * UserSettings:
     */
    requestBody: Array<(string)>;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersettingsByUseridResponse = (unknown);

export type PostUsersettingsByUseridPartialData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersettingsByUseridPartialResponse = (unknown);

export type GetDlnaProfileinfosResponse = (Array<Dlna_Profiles_DlnaProfile>);

export type PostDlnaProfilesData = {
    /**
     * DlnaProfile:
     */
    requestBody: Dlna_Profiles_DlnaProfile;
};

export type PostDlnaProfilesResponse = (unknown);

export type GetDlnaProfilesByIdData = {
    /**
     * Profile Id
     */
    id: string;
};

export type GetDlnaProfilesByIdResponse = (Dlna_Profiles_DlnaProfile);

export type DeleteDlnaProfilesByIdData = {
    /**
     * Profile Id
     */
    id: string;
};

export type DeleteDlnaProfilesByIdResponse = (unknown);

export type PostDlnaProfilesByIdData = {
    id: string;
    /**
     * DlnaProfile:
     */
    requestBody: Dlna_Profiles_DlnaProfile;
};

export type PostDlnaProfilesByIdResponse = (unknown);

export type GetDlnaProfilesDefaultResponse = (Dlna_Profiles_DlnaProfile);

export type GetEncodingTonemapoptionsResponse = (Configuration_ToneMapping_ToneMapOptionsVisibility);

export type GetEncodingCodecinformationVideoResponse = (Array<VideoCodecBase>);

export type GetEncodingCodecconfigurationDefaultsResponse = (Array<CodecConfiguration>);

export type GetEncodingFulltonemapoptionsResponse = (EditObjectContainer);

export type PostEncodingFulltonemapoptionsData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostEncodingFulltonemapoptionsResponse = (unknown);

export type GetEncodingPublictonemapoptionsResponse = (EditObjectContainer);

export type PostEncodingPublictonemapoptionsData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostEncodingPublictonemapoptionsResponse = (unknown);

export type GetEncodingSubtitleoptionsResponse = (EditObjectContainer);

export type PostEncodingSubtitleoptionsData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostEncodingSubtitleoptionsResponse = (unknown);

export type GetEncodingFfmpegoptionsResponse = (EditObjectContainer);

export type PostEncodingFfmpegoptionsData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostEncodingFfmpegoptionsResponse = (unknown);

export type GetEncodingCodecparametersData = {
    /**
     * Codec Id
     */
    codecId: string;
    /**
     * Parameter Context
     */
    parameterContext: MediaEncoding_CodecParameterContext;
};

export type GetEncodingCodecparametersResponse = (EditObjectContainer);

export type PostEncodingCodecparametersData = {
    /**
     * Codec Id
     */
    codecId: string;
    /**
     * Parameter Context
     */
    parameterContext: MediaEncoding_CodecParameterContext;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostEncodingCodecparametersResponse = (unknown);

export type PostEnvironmentValidatepathData = {
    path: string;
    /**
     * ValidatePath
     */
    requestBody: ValidatePath;
};

export type PostEnvironmentValidatepathResponse = (unknown);

export type GetEnvironmentDefaultdirectorybrowserResponse = (DefaultDirectoryBrowserInfo);

export type GetEnvironmentDirectorycontentsData = {
    /**
     * An optional filter to include or exclude folders from the results. true/false
     */
    includeDirectories?: boolean;
    /**
     * An optional filter to include or exclude files from the results. true/false
     */
    includeFiles?: boolean;
    path: string;
};

export type GetEnvironmentDirectorycontentsResponse = (Array<IO_FileSystemEntryInfo>);

export type PostEnvironmentDirectorycontentsData = {
    /**
     * An optional filter to include or exclude folders from the results. true/false
     */
    includeDirectories?: boolean;
    /**
     * An optional filter to include or exclude files from the results. true/false
     */
    includeFiles?: boolean;
    path: string;
    /**
     * GetDirectoryContents
     */
    requestBody: GetDirectoryContents;
};

export type PostEnvironmentDirectorycontentsResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentNetworksharesData = {
    path: string;
};

export type GetEnvironmentNetworksharesResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentDrivesResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentNetworkdevicesResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentParentpathData = {
    path: string;
};

export type GetEnvironmentParentpathResponse = (string);

export type GetImagesRemoteData = {
    /**
     * The image url
     */
    imageUrl: string;
};

export type GetImagesRemoteResponse = (unknown);

export type GetItemsByIdRemoteimagesData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional.
     */
    includeAllLanguages?: boolean;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The image provider to use
     */
    providerName?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * The image type
     */
    type?: ImageType;
};

export type GetItemsByIdRemoteimagesResponse = (RemoteImageResult);

export type GetItemsByIdRemoteimagesProvidersData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdRemoteimagesProvidersResponse = (Array<ImageProviderInfo>);

export type PostItemsByIdRemoteimagesDownloadData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The image url
     */
    imageUrl?: string;
    /**
     * The image provider
     */
    providerName?: string;
    /**
     * BaseDownloadRemoteImage:
     */
    requestBody: Images_BaseDownloadRemoteImage;
    /**
     * The image type
     */
    type: ImageType;
};

export type PostItemsByIdRemoteimagesDownloadResponse = (unknown);

export type PostItemsByItemidData = {
    /**
     * The id of the item
     */
    itemId: string;
    /**
     * BaseItemDto:
     */
    requestBody: BaseItemDto;
};

export type PostItemsByItemidResponse = (unknown);

export type GetItemsByItemidMetadataeditorData = {
    /**
     * The id of the item
     */
    itemId: string;
};

export type GetItemsByItemidMetadataeditorResponse = (MetadataEditorInfo);

export type PostItemsAccessData = {
    /**
     * UpdateUserItemAccess
     */
    requestBody: UserLibrary_UpdateUserItemAccess;
};

export type PostItemsAccessResponse = (unknown);

export type PostItemsByIdMakepublicData = {
    /**
     * Item Id
     */
    id: string;
};

export type PostItemsByIdMakepublicResponse = (unknown);

export type PostItemsByIdMakeprivateData = {
    /**
     * Item Id
     */
    id: string;
};

export type PostItemsByIdMakeprivateResponse = (unknown);

export type PostItemsSharedLeaveData = {
    /**
     * LeaveSharedItems
     */
    requestBody: UserLibrary_LeaveSharedItems;
};

export type PostItemsSharedLeaveResponse = (unknown);

export type GetLivetvProgramsByIdData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetLivetvProgramsByIdResponse = (BaseItemDto);

export type GetVideosByIdAdditionalpartsData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetVideosByIdAdditionalpartsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridItemsLatestData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Whether or not to group items into a parent container.
     */
    groupItems?: boolean;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Filter by items that are folders, or not.
     */
    isFolder?: (boolean) | null;
    /**
     * Filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Limit
     */
    limit?: number;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsLatestResponse = (Array<BaseItemDto>);

export type GetUsersByUseridItemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdResponse = (BaseItemDto);

export type GetUsersByUseridItemsRootData = {
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsRootResponse = (BaseItemDto);

export type PostUsersByUseridFavoriteitemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridFavoriteitemsByIdResponse = (UserItemDataDto);

export type DeleteUsersByUseridFavoriteitemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridFavoriteitemsByIdResponse = (UserItemDataDto);

export type GetUsersByUseridItemsByIdSpecialfeaturesData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Movie Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdSpecialfeaturesResponse = (Array<BaseItemDto>);

export type GetUsersByUseridItemsByIdLocaltrailersData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdLocaltrailersResponse = (Array<BaseItemDto>);

export type GetUsersByUseridItemsByIdIntrosData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdIntrosResponse = (QueryResult_BaseItemDto);

export type PostUsersByUseridFavoriteitemsByIdDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridFavoriteitemsByIdDeleteResponse = (UserItemDataDto);

export type DeleteUsersByUseridItemsByIdRatingData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridItemsByIdRatingResponse = (UserItemDataDto);

export type PostUsersByUseridItemsByIdRatingData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Whether the user likes the item or not. true/false
     */
    likes: boolean;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridItemsByIdRatingResponse = (UserItemDataDto);

export type PostUsersByUseridItemsByIdHidefromresumeData = {
    /**
     * Whether the item should be hidden from reusme or not. true/false
     */
    hide: boolean;
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridItemsByIdHidefromresumeResponse = (UserItemDataDto);

export type PostUsersByUseridItemsByIdRatingDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridItemsByIdRatingDeleteResponse = (UserItemDataDto);

export type PostLibraryVirtualfoldersData = {
    /**
     * AddVirtualFolder
     */
    requestBody: Library_AddVirtualFolder;
};

export type PostLibraryVirtualfoldersResponse = (unknown);

export type DeleteLibraryVirtualfoldersResponse = (unknown);

export type GetLibraryVirtualfoldersQueryData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetLibraryVirtualfoldersQueryResponse = (QueryResult_VirtualFolderInfo);

export type PostLibraryVirtualfoldersLibraryoptionsData = {
    /**
     * UpdateLibraryOptions
     */
    requestBody: Library_UpdateLibraryOptions;
};

export type PostLibraryVirtualfoldersLibraryoptionsResponse = (unknown);

export type PostLibraryVirtualfoldersNameData = {
    /**
     * RenameVirtualFolder
     */
    requestBody: Library_RenameVirtualFolder;
};

export type PostLibraryVirtualfoldersNameResponse = (unknown);

export type PostLibraryVirtualfoldersDeleteData = {
    /**
     * RemoveVirtualFolder
     */
    requestBody: Library_RemoveVirtualFolder;
};

export type PostLibraryVirtualfoldersDeleteResponse = (unknown);

export type PostLibraryVirtualfoldersPathsData = {
    /**
     * AddMediaPath
     */
    requestBody: Library_AddMediaPath;
};

export type PostLibraryVirtualfoldersPathsResponse = (unknown);

export type DeleteLibraryVirtualfoldersPathsResponse = (unknown);

export type PostLibraryVirtualfoldersPathsUpdateData = {
    /**
     * UpdateMediaPath
     */
    requestBody: Library_UpdateMediaPath;
};

export type PostLibraryVirtualfoldersPathsUpdateResponse = (unknown);

export type PostLibraryVirtualfoldersPathsDeleteData = {
    /**
     * RemoveMediaPath
     */
    requestBody: Library_RemoveMediaPath;
};

export type PostLibraryVirtualfoldersPathsDeleteResponse = (unknown);

export type PostLivestreamsOpenData = {
    /**
     * LiveStreamRequest:
     */
    requestBody: LiveStreamRequest;
};

export type PostLivestreamsOpenResponse = (LiveStreamResponse);

export type PostLivestreamsCloseData = {
    /**
     * LiveStreamId
     */
    liveStreamId: string;
};

export type PostLivestreamsCloseResponse = (unknown);

export type PostLivestreamsMediainfoData = {
    /**
     * LiveStreamId
     */
    liveStreamId: string;
};

export type PostLivestreamsMediainfoResponse = (unknown);

export type GetPlaybackBitratetestData = {
    /**
     * Size
     */
    size: number;
};

export type GetPlaybackBitratetestResponse = (unknown);

export type GetItemsByIdPlaybackinfoData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetItemsByIdPlaybackinfoResponse = (PlaybackInfoResponse);

export type PostItemsByIdPlaybackinfoData = {
    id: string;
    /**
     * PlaybackInfoRequest:
     */
    requestBody: PlaybackInfoRequest;
};

export type PostItemsByIdPlaybackinfoResponse = (PlaybackInfoResponse);

export type GetLivetvChanneltagsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvChanneltagsResponse = (QueryResult_BaseItemDto);

export type GetLivetvFolderResponse = (BaseItemDto);

export type GetLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type GetLivetvChannelmappingsResponse = (unknown);

export type HeadLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type HeadLivetvChannelmappingsResponse = (unknown);

export type PostLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
    /**
     * SetChannelMapping
     */
    requestBody: Api_SetChannelMapping;
};

export type PostLivetvChannelmappingsResponse = (unknown);

export type PutLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
    /**
     * SetChannelMapping
     */
    requestBody: Api_SetChannelMapping;
};

export type PutLivetvChannelmappingsResponse = (unknown);

export type DeleteLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type DeleteLivetvChannelmappingsResponse = (unknown);

export type GetLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type GetLivetvChannelmappingoptionsResponse = (unknown);

export type HeadLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type HeadLivetvChannelmappingoptionsResponse = (unknown);

export type PostLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type PostLivetvChannelmappingoptionsResponse = (unknown);

export type PutLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type PutLivetvChannelmappingoptionsResponse = (unknown);

export type DeleteLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type DeleteLivetvChannelmappingoptionsResponse = (unknown);

export type PostLivetvListingprovidersData = {
    /**
     * ListingsProviderInfo:
     */
    requestBody: LiveTv_ListingsProviderInfo;
};

export type PostLivetvListingprovidersResponse = (LiveTv_ListingsProviderInfo);

export type DeleteLivetvListingprovidersData = {
    /**
     * Provider id
     */
    id?: string;
};

export type DeleteLivetvListingprovidersResponse = (unknown);

export type GetLivetvListingprovidersData = {
    /**
     * Channel id
     */
    channelId: string;
};

export type GetLivetvListingprovidersResponse = (Array<LiveTv_ListingsProviderInfo>);

export type GetLivetvTunerhostsResponse = (Array<LiveTv_TunerHostInfo>);

export type PostLivetvTunerhostsData = {
    /**
     * TunerHostInfo:
     */
    requestBody: LiveTv_TunerHostInfo;
};

export type PostLivetvTunerhostsResponse = (LiveTv_TunerHostInfo);

export type DeleteLivetvTunerhostsData = {
    /**
     * Tuner host id
     */
    id?: string;
};

export type DeleteLivetvTunerhostsResponse = (unknown);

export type GetLivetvInfoResponse = (LiveTv_LiveTvInfo);

export type GetLivetvEpgData = {
    /**
     * Optional. Adds current program info to each channel
     */
    addCurrentProgram?: boolean;
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * The channels to return guide information for.
     */
    channelIds?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Incorporate favorite and like status into channel sorting.
     */
    enableFavoriteSorting?: boolean;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Filter by channels that are disliked, or not.
     */
    isDisliked?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Filter by channels that are liked, or not.
     */
    isLiked?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * Optional filter by channel type.
     */
    type?: LiveTv_ChannelType;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvEpgResponse = (QueryResult_Api_EpgRow);

export type GetLivetvChannelsData = {
    /**
     * Optional. Adds current program info to each channel
     */
    addCurrentProgram?: boolean;
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Incorporate favorite and like status into channel sorting.
     */
    enableFavoriteSorting?: boolean;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Filter by channels that are disliked, or not.
     */
    isDisliked?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Filter by channels that are liked, or not.
     */
    isLiked?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * Optional filter by channel type.
     */
    type?: LiveTv_ChannelType;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvChannelsResponse = (QueryResult_BaseItemDto);

export type GetLivetvProgramsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * The channels to return guide information for.
     */
    channelIds?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvProgramsResponse = (unknown);

export type PostLivetvProgramsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * The channels to return guide information for.
     */
    channelIds?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * BaseItemsRequest:
     */
    requestBody: Api_BaseItemsRequest;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type PostLivetvProgramsResponse = (unknown);

export type GetLivetvRecordingsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by channel id.
     */
    channelId?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter by recordings that are in progress, or not.
     */
    isInProgress?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional filter by recordings belonging to a series timer
     */
    seriesTimerId?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional filter by recording status.
     */
    status?: LiveTv_RecordingStatus;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvRecordingsResponse = (unknown);

export type GetLivetvTimersData = {
    /**
     * Optional filter by channel id.
     */
    channelId?: string;
    /**
     * Optional filter by timers belonging to a series timer
     */
    seriesTimerId?: string;
};

export type GetLivetvTimersResponse = (QueryResult_LiveTv_TimerInfoDto);

export type PostLivetvTimersData = {
    /**
     * TimerInfoDto:
     */
    requestBody: LiveTv_TimerInfoDto;
};

export type PostLivetvTimersResponse = (unknown);

export type GetLivetvSeriestimersData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Sort by SortName or Priority
     */
    sortBy?: string;
    /**
     * Optional. Sort in Ascending or Descending order
     */
    sortOrder?: SortOrder;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetLivetvSeriestimersResponse = (QueryResult_LiveTv_SeriesTimerInfoDto);

export type PostLivetvSeriestimersData = {
    /**
     * SeriesTimerInfo:
     */
    requestBody: LiveTv_SeriesTimerInfo;
};

export type PostLivetvSeriestimersResponse = (LiveTv_SeriesTimerInfoDto);

export type GetLivetvGuideinfoResponse = (LiveTv_GuideInfo);

export type GetLivetvAvailablerecordingoptionsResponse = (Api_AvailableRecordingOptions);

export type GetLivetvTunerhostsTypesResponse = (Array<NameIdPair>);

export type GetLivetvManageChannelsData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
};

export type GetLivetvManageChannelsResponse = (QueryResult_BaseItemDto);

export type GetLivetvChanneltagsPrefixesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvChanneltagsPrefixesResponse = (Array<Api_TagItem>);

export type GetLivetvRecordingsFoldersData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvRecordingsFoldersResponse = (Array<BaseItemDto>);

export type GetLivetvTunersDiscvoverResponse = (Array<LiveTv_TunerHostInfo>);

export type GetLivetvTunersDiscoverResponse = (Array<LiveTv_TunerHostInfo>);

export type GetLivetvListingprovidersDefaultResponse = (LiveTv_ListingsProviderInfo);

export type PostLivetvListingprovidersDeleteData = {
    /**
     * Provider id
     */
    id?: string;
};

export type PostLivetvListingprovidersDeleteResponse = (unknown);

export type PostLivetvTunerhostsDeleteData = {
    /**
     * Tuner host id
     */
    id?: string;
};

export type PostLivetvTunerhostsDeleteResponse = (unknown);

export type GetLivetvListingprovidersLineupsData = {
    /**
     * Country
     */
    country?: string;
    /**
     * Provider id
     */
    id?: string;
    /**
     * Location
     */
    location?: string;
    /**
     * Provider Type
     */
    type?: string;
};

export type GetLivetvListingprovidersLineupsResponse = (Array<NameIdPair>);

export type GetLivetvChannelsByIdData = {
    /**
     * Channel Id
     */
    id: string;
    /**
     * Optional attach user data.
     */
    userId?: string;
};

export type GetLivetvChannelsByIdResponse = (BaseItemDto);

export type GetLivetvProgramsRecommendedData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvProgramsRecommendedResponse = (QueryResult_BaseItemDto);

export type GetLivetvRecordingsSeriesResponse = (QueryResult_BaseItemDto);

export type GetLivetvRecordingsByIdData = {
    /**
     * Recording Id
     */
    id: string;
    /**
     * Optional attach user data.
     */
    userId?: string;
};

export type GetLivetvRecordingsByIdResponse = (BaseItemDto);

export type DeleteLivetvRecordingsByIdData = {
    /**
     * Recording Id
     */
    id: string;
};

export type DeleteLivetvRecordingsByIdResponse = (unknown);

export type GetLivetvTimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type GetLivetvTimersByIdResponse = (LiveTv_TimerInfoDto);

export type DeleteLivetvTimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type DeleteLivetvTimersByIdResponse = (unknown);

export type PostLivetvTimersByIdData = {
    id: string;
    /**
     * TimerInfoDto:
     */
    requestBody: LiveTv_TimerInfoDto;
};

export type PostLivetvTimersByIdResponse = (unknown);

export type GetLivetvSeriestimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type GetLivetvSeriestimersByIdResponse = (LiveTv_TimerInfoDto);

export type DeleteLivetvSeriestimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type DeleteLivetvSeriestimersByIdResponse = (unknown);

export type PostLivetvSeriestimersByIdData = {
    id: string;
    /**
     * SeriesTimerInfo:
     */
    requestBody: LiveTv_SeriesTimerInfo;
};

export type PostLivetvSeriestimersByIdResponse = (unknown);

export type GetLivetvTimersDefaultsData = {
    /**
     * Optional, to attach default values based on a program.
     */
    programId?: string;
};

export type GetLivetvTimersDefaultsResponse = (LiveTv_SeriesTimerInfoDto);

export type GetLivetvRecordingsGroupsResponse = (QueryResult_BaseItemDto);

export type GetLivetvListingprovidersAvailableResponse = (Array<Api_ListingProviderTypeInfo>);

export type GetLivetvListingprovidersSchedulesdirectCountriesResponse = (unknown);

export type GetLivetvTunerhostsDefaultByTypeData = {
    /**
     * Type
     */
    type: string;
};

export type GetLivetvTunerhostsDefaultByTypeResponse = (LiveTv_TunerHostInfo);

export type PostLivetvRecordingsByIdDeleteData = {
    /**
     * Recording Id
     */
    id: string;
};

export type PostLivetvRecordingsByIdDeleteResponse = (unknown);

export type PostLivetvTimersByIdDeleteData = {
    /**
     * Timer Id
     */
    id: string;
};

export type PostLivetvTimersByIdDeleteResponse = (unknown);

export type PostLivetvSeriestimersByIdDeleteData = {
    /**
     * Timer Id
     */
    id: string;
};

export type PostLivetvSeriestimersByIdDeleteResponse = (unknown);

export type PostLivetvTunersByIdResetData = {
    /**
     * Tuner Id
     */
    id: string;
};

export type PostLivetvTunersByIdResetResponse = (unknown);

export type PostLivetvManageChannelsByIdDisabledData = {
    id: string;
    /**
     * SetChannelDisabled
     */
    requestBody: Api_SetChannelDisabled;
};

export type PostLivetvManageChannelsByIdDisabledResponse = (QueryResult_ChannelManagementInfo);

export type PostLivetvManageChannelsByIdSortindexData = {
    id: string;
    /**
     * SetChannelSortIndex
     */
    requestBody: Api_SetChannelSortIndex;
};

export type PostLivetvManageChannelsByIdSortindexResponse = (QueryResult_ChannelManagementInfo);

export type GetLocalizationParentalratingsResponse = (Array<ParentalRating>);

export type GetLocalizationOptionsResponse = (Array<Globalization_LocalizatonOption>);

export type GetLocalizationCountriesResponse = (Array<Globalization_CountryInfo>);

export type GetLocalizationCulturesResponse = (Array<Globalization_CultureDto>);

export type GetMoviesRecommendationsData = {
    /**
     * The max number of categories to return
     */
    categoryLimit?: number;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * The max number of items to return per category
     */
    itemLimit?: number;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMoviesRecommendationsResponse = (Array<RecommendationDto>);

export type GetNotificationsTypesResponse = (Array<NotificationCategoryInfo>);

export type PostNotificationsAdminData = {
    /**
     * The notification's description
     */
    description: string;
    /**
     * The notification's image url
     */
    imageUrl?: string;
    /**
     * The notification level
     */
    level?: string;
    /**
     * The notification's name
     */
    name: string;
    /**
     * AddAdminNotification
     */
    requestBody: Api_AddAdminNotification;
    /**
     * The notification's info url
     */
    url?: string;
};

export type PostNotificationsAdminResponse = (unknown);

export type PostSessionsPlayingData = {
    /**
     * PlaybackStartInfo:
     */
    requestBody: PlaybackStartInfo;
};

export type PostSessionsPlayingResponse = (unknown);

export type PostSessionsPlayingProgressData = {
    /**
     * PlaybackProgressInfo:
     */
    requestBody: PlaybackProgressInfo;
};

export type PostSessionsPlayingProgressResponse = (unknown);

export type PostSessionsPlayingPingData = {
    playSessionId?: string;
};

export type PostSessionsPlayingPingResponse = (unknown);

export type PostSessionsPlayingStoppedData = {
    /**
     * PlaybackStopInfo:
     */
    requestBody: PlaybackStopInfo;
};

export type PostSessionsPlayingStoppedResponse = (unknown);

export type PostUsersByUseridPlayeditemsByIdData = {
    /**
     * The date the item was played (if any). Format = yyyyMMddHHmmss
     */
    datePlayed?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridPlayeditemsByIdResponse = (UserItemDataDto);

export type DeleteUsersByUseridPlayeditemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridPlayeditemsByIdResponse = (UserItemDataDto);

export type PostUsersByUseridPlayingitemsByIdData = {
    audioStreamIndex?: (number) | null;
    /**
     * Indicates if the client can seek
     */
    canSeek?: boolean;
    /**
     * Item Id
     */
    id: string;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    playMethod?: PlayMethod;
    playSessionId?: string;
    subtitleStreamIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridPlayingitemsByIdResponse = (unknown);

export type DeleteUsersByUseridPlayingitemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    /**
     * The next media type that will play
     */
    nextMediaType: string;
    playSessionId?: string;
    /**
     * Optional. The position, in ticks, where playback stopped. 1ms = 10000 ticks.
     */
    positionTicks?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridPlayingitemsByIdResponse = (unknown);

export type PostUsersByUseridItemsByItemidUserdataData = {
    itemId: string;
    /**
     * UserItemDataDto:
     */
    requestBody: UserItemDataDto;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridItemsByItemidUserdataResponse = (unknown);

export type PostUsersByUseridPlayingitemsByIdProgressData = {
    audioStreamIndex?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Indicates if the player is muted.
     */
    isMuted?: boolean;
    /**
     * Indicates if the player is paused.
     */
    isPaused?: boolean;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    playbackRate?: number;
    playMethod?: PlayMethod;
    playSessionId?: string;
    /**
     * Optional. The current position, in ticks. 1ms = 10000 ticks.
     */
    positionTicks?: (number) | null;
    repeatMode?: RepeatMode;
    /**
     * OnPlaybackProgress
     */
    requestBody: Api_OnPlaybackProgress;
    subtitleOffset?: number;
    subtitleStreamIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
    /**
     * Scale of 0-100
     */
    volumeLevel?: (number) | null;
};

export type PostUsersByUseridPlayingitemsByIdProgressResponse = (unknown);

export type PostUsersByUseridPlayingitemsByIdDeleteData = {
    /**
     * Item Id
     */
    id: string;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    /**
     * The next media type that will play
     */
    nextMediaType: string;
    playSessionId?: string;
    /**
     * Optional. The position, in ticks, where playback stopped. 1ms = 10000 ticks.
     */
    positionTicks?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridPlayingitemsByIdDeleteResponse = (unknown);

export type PostUsersByUseridPlayeditemsByIdDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridPlayeditemsByIdDeleteResponse = (UserItemDataDto);

export type GetShowsMissingData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetShowsMissingResponse = (unknown);

export type GetShowsUpcomingData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetShowsUpcomingResponse = (unknown);

export type GetShowsNextupData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional. Filter by series id
     */
    seriesId?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetShowsNextupResponse = (QueryResult_BaseItemDto);

export type GetShowsByIdSeasonsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * The series id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetShowsByIdSeasonsResponse = (QueryResult_BaseItemDto);

export type GetShowsByIdEpisodesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * The series id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by season number.
     */
    season?: (number) | null;
    /**
     * Optional. Filter by season id
     */
    seasonId?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetShowsByIdEpisodesResponse = (unknown);

export type GetSyncTargetsData = {
    /**
     * UserId
     */
    userId: string;
};

export type GetSyncTargetsResponse = (Array<SyncTarget>);

export type GetSyncJobsResponse = (QueryResult_SyncJob);

export type PostSyncJobsData = {
    /**
     * SyncJobRequest:
     */
    requestBody: SyncJobRequest;
};

export type PostSyncJobsResponse = (SyncJobCreationResult);

export type GetSyncJobitemsData = {
    /**
     * TargetId
     */
    targetId: string;
};

export type GetSyncJobitemsResponse = (QueryResult_SyncJobItem);

export type GetSyncOptionsData = {
    /**
     * Category
     */
    category?: SyncCategory;
    /**
     * ItemIds
     */
    itemIds?: string;
    /**
     * ParentId
     */
    parentId?: string;
    /**
     * TargetId
     */
    targetId?: string;
    /**
     * UserId
     */
    userId: string;
};

export type GetSyncOptionsResponse = (SyncDialogOptions);

export type PostSyncOfflineactionsData = {
    /**
     * List`1:
     */
    requestBody: Array<UserAction>;
};

export type PostSyncOfflineactionsResponse = (unknown);

export type PostSyncDataData = {
    /**
     * SyncDataRequest:
     */
    requestBody: SyncDataRequest;
    /**
     * TargetId
     */
    targetId: string;
};

export type PostSyncDataResponse = (SyncDataResponse);

export type PostSyncByItemidStatusData = {
    itemId: string;
    /**
     * SyncedItemProgress:
     */
    requestBody: SyncedItemProgress;
};

export type PostSyncByItemidStatusResponse = (unknown);

export type GetSyncJobsByIdData = {
    /**
     * Id
     */
    id: string;
};

export type GetSyncJobsByIdResponse = (SyncJob);

export type DeleteSyncJobsByIdData = {
    /**
     * Id
     */
    id: string;
};

export type DeleteSyncJobsByIdResponse = (unknown);

export type PostSyncJobsByIdData = {
    id: number;
    /**
     * SyncJob:
     */
    requestBody: SyncJob;
};

export type PostSyncJobsByIdResponse = (unknown);

export type PostSyncItemsCancelData = {
    /**
     * ItemIds
     */
    itemIds?: string;
};

export type PostSyncItemsCancelResponse = (unknown);

export type DeleteSyncByTargetidItemsData = {
    /**
     * ItemIds
     */
    itemIds?: string;
    /**
     * TargetId
     */
    targetId: string;
};

export type DeleteSyncByTargetidItemsResponse = (unknown);

export type GetSyncItemsReadyData = {
    /**
     * TargetId
     */
    targetId: string;
};

export type GetSyncItemsReadyResponse = (Array<SyncedItem>);

export type DeleteSyncJobitemsByIdData = {
    /**
     * Id
     */
    id: string;
};

export type DeleteSyncJobitemsByIdResponse = (unknown);

export type PostSyncJobsByIdDeleteData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobsByIdDeleteResponse = (unknown);

export type PostSyncByTargetidItemsDeleteData = {
    /**
     * ItemIds
     */
    itemIds?: string;
    /**
     * TargetId
     */
    targetId: string;
};

export type PostSyncByTargetidItemsDeleteResponse = (unknown);

export type PostSyncJobitemsByIdTransferredData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdTransferredResponse = (unknown);

export type HeadSyncJobitemsByIdFileData = {
    /**
     * Id
     */
    id: string;
};

export type HeadSyncJobitemsByIdFileResponse = (unknown);

export type GetSyncJobitemsByIdFileData = {
    /**
     * Id
     */
    id: string;
};

export type GetSyncJobitemsByIdFileResponse = (unknown);

export type GetSyncJobitemsByIdAdditionalfilesData = {
    /**
     * Id
     */
    id: string;
    /**
     * Name
     */
    name: string;
};

export type GetSyncJobitemsByIdAdditionalfilesResponse = (unknown);

export type PostSyncJobitemsByIdEnableData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdEnableResponse = (unknown);

export type PostSyncJobitemsByIdDeleteData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdDeleteResponse = (unknown);

export type PostSyncJobitemsByIdMarkforremovalData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdMarkforremovalResponse = (unknown);

export type PostSyncJobitemsByIdUnmarkforremovalData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdUnmarkforremovalResponse = (unknown);

export type GetSystemConfigurationResponse = (ServerConfiguration);

export type PostSystemConfigurationData = {
    /**
     * ServerConfiguration:
     */
    requestBody: ServerConfiguration;
};

export type PostSystemConfigurationResponse = (unknown);

export type PostSystemConfigurationPartialData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostSystemConfigurationPartialResponse = (unknown);

export type GetSystemConfigurationByKeyData = {
    /**
     * Key
     */
    key: string;
};

export type GetSystemConfigurationByKeyResponse = (unknown);

export type PostSystemConfigurationByKeyData = {
    /**
     * Key
     */
    key: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostSystemConfigurationByKeyResponse = (unknown);

export type GetSystemReleasenotesResponse = (PackageVersionInfo);

export type PostSystemPingResponse = (unknown);

export type GetSystemPingResponse = (unknown);

export type HeadSystemPingResponse = (unknown);

export type GetSystemWakeonlaninfoResponse = (Array<WakeOnLanInfo>);

export type GetSystemInfoResponse = (SystemInfo);

export type PostSystemRestartResponse = (unknown);

export type PostSystemShutdownResponse = (unknown);

export type GetSystemEndpointResponse = (Net_EndPointInfo);

export type GetSystemReleasenotesVersionsResponse = (Array<PackageVersionInfo>);

export type GetSystemLogsQueryData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetSystemLogsQueryResponse = (QueryResult_LogFile);

export type GetSystemLogsByNameData = {
    /**
     * The log file name.
     */
    name: string;
    /**
     * Return sanitized log
     */
    sanitize?: boolean;
};

export type GetSystemLogsByNameResponse = (unknown);

export type GetSystemInfoPublicResponse = (PublicSystemInfo);

export type GetSystemLogsByNameLinesData = {
    /**
     * The log file name.
     */
    name: string;
};

export type GetSystemLogsByNameLinesResponse = (QueryResult_String);

export type GetUiViewData = {
    /**
     * Locale identifier of the client
     */
    clientLocale: string;
    /**
     * Id of the page controller
     */
    pageId: string;
};

export type GetUiViewResponse = (UIViewInfo);

export type PostUiCommandData = {
    /**
     * RunUICommand
     */
    requestBody: RunUICommand;
};

export type PostUiCommandResponse = (UIViewInfo);

export type GetUsersPublicResponse = (Array<UserDto>);

export type GetUsersQueryData = {
    /**
     * Optional filter by IsDisabled=true or false
     */
    isDisabled?: (boolean) | null;
    /**
     * Optional filter by IsHidden=true or false
     */
    isHidden?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetUsersQueryResponse = (QueryResult_UserDto);

export type GetUsersPrefixesData = {
    /**
     * Optional filter by IsDisabled=true or false
     */
    isDisabled?: (boolean) | null;
    /**
     * Optional filter by IsHidden=true or false
     */
    isHidden?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetUsersPrefixesResponse = (Array<NameIdPair>);

export type GetUsersItemaccessData = {
    /**
     * Optional filter by IsDisabled=true or false
     */
    isDisabled?: (boolean) | null;
    /**
     * Optional filter by IsHidden=true or false
     */
    isHidden?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetUsersItemaccessResponse = (QueryResult_UserDto);

export type GetUsersByIdData = {
    id: string;
};

export type GetUsersByIdResponse = (UserDto);

export type DeleteUsersByIdData = {
    id: string;
};

export type DeleteUsersByIdResponse = (unknown);

export type PostUsersByIdData = {
    id: string;
    /**
     * UserDto:
     */
    requestBody: UserDto;
};

export type PostUsersByIdResponse = (unknown);

export type PostUsersAuthenticatebynameData = {
    /**
     * AuthenticateUserByName
     */
    requestBody: AuthenticateUserByName;
    /**
     * The authorization header can be either named 'Authorization' or 'X-Emby-Authorization'.
     * It must be of the following schema:
     * Emby UserId="(guid)", Client="(string)", Device="(string)", DeviceId="(string)", Version="string", Token="(string)"
     * Please consult the documentation for further details.
     */
    xEmbyAuthorization: string;
};

export type PostUsersAuthenticatebynameResponse = (Authentication_AuthenticationResult);

export type PostUsersNewData = {
    /**
     * CreateUserByName
     */
    requestBody: CreateUserByName;
};

export type PostUsersNewResponse = (UserDto);

export type PostUsersForgotpasswordData = {
    /**
     * ForgotPassword
     */
    requestBody: ForgotPassword;
};

export type PostUsersForgotpasswordResponse = (ForgotPasswordResult);

export type PostUsersByIdDeleteData = {
    id: string;
};

export type PostUsersByIdDeleteResponse = (unknown);

export type PostUsersByIdAuthenticateData = {
    id: string;
    /**
     * AuthenticateUser
     */
    requestBody: AuthenticateUser;
};

export type PostUsersByIdAuthenticateResponse = (Authentication_AuthenticationResult);

export type PostUsersByIdPasswordData = {
    id: string;
    /**
     * UpdateUserPassword
     */
    requestBody: UpdateUserPassword;
};

export type PostUsersByIdPasswordResponse = (unknown);

export type PostUsersForgotpasswordPinData = {
    /**
     * ForgotPasswordPin
     */
    requestBody: ForgotPasswordPin;
};

export type PostUsersForgotpasswordPinResponse = (PinRedeemResult);

export type PostUsersByIdConfigurationData = {
    id: string;
    /**
     * UserConfiguration:
     */
    requestBody: UserConfiguration;
};

export type PostUsersByIdConfigurationResponse = (unknown);

export type PostUsersByIdPolicyData = {
    id: string;
    /**
     * UserPolicy:
     */
    requestBody: UserPolicy;
};

export type PostUsersByIdPolicyResponse = (unknown);

export type DeleteUsersByIdTrackselectionsByTracktypeData = {
    id: string;
    trackType: string;
};

export type DeleteUsersByIdTrackselectionsByTracktypeResponse = (unknown);

export type PostUsersByIdConfigurationPartialData = {
    id: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostUsersByIdConfigurationPartialResponse = (unknown);

export type GetUsersByUseridTypedsettingsByKeyData = {
    /**
     * Key
     */
    key: string;
    userId: string;
};

export type GetUsersByUseridTypedsettingsByKeyResponse = (unknown);

export type PostUsersByUseridTypedsettingsByKeyData = {
    /**
     * Key
     */
    key: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    userId: string;
};

export type PostUsersByUseridTypedsettingsByKeyResponse = (unknown);

export type PostUsersByIdTrackselectionsByTracktypeDeleteData = {
    id: string;
    trackType: string;
};

export type PostUsersByIdTrackselectionsByTracktypeDeleteResponse = (unknown);

export type PostVideosMergeversionsData = {
    /**
     * Item id list. This allows multiple, comma delimited.
     */
    ids?: string;
};

export type PostVideosMergeversionsResponse = (unknown);

export type DeleteVideosByIdAlternatesourcesData = {
    /**
     * Item Id
     */
    id: string;
};

export type DeleteVideosByIdAlternatesourcesResponse = (unknown);

export type PostVideosByIdAlternatesourcesDeleteData = {
    /**
     * Item Id
     */
    id: string;
};

export type PostVideosByIdAlternatesourcesDeleteResponse = (unknown);

export type DeleteVideosActiveencodingsData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId: string;
    /**
     * The play session id
     */
    playSessionId: string;
};

export type DeleteVideosActiveencodingsResponse = (unknown);

export type PostVideosActiveencodingsDeleteData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId: string;
    /**
     * The play session id
     */
    playSessionId: string;
};

export type PostVideosActiveencodingsDeleteResponse = (unknown);

export type GetWebConfigurationpageResponse = (unknown);

export type GetWebConfigurationpagesResponse = (Array<Api_ConfigurationPageInfo>);

export type GetWebStringsResponse = (unknown);

export type GetWebStringsetResponse = (Array<(string)>);

export type GetAudioByIdUniversalByContainerData = {
    container: string;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
};

export type GetAudioByIdUniversalByContainerResponse = (unknown);

export type HeadAudioByIdUniversalByContainerData = {
    container: string;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
};

export type HeadAudioByIdUniversalByContainerResponse = (unknown);

export type GetAudioByIdUniversalData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
};

export type GetAudioByIdUniversalResponse = (unknown);

export type HeadAudioByIdUniversalData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
};

export type HeadAudioByIdUniversalResponse = (unknown);

export type GetAudioByIdStreamByContainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdStreamByContainerResponse = (unknown);

export type HeadAudioByIdStreamByContainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdStreamByContainerResponse = (unknown);

export type GetAudioByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdStreamResponse = (unknown);

export type HeadAudioByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdStreamResponse = (unknown);

export type GetAudioByIdByStreamfilenameData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    streamFileName: string;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdByStreamfilenameResponse = (unknown);

export type HeadAudioByIdByStreamfilenameData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    streamFileName: string;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdByStreamfilenameResponse = (unknown);

export type GetAudioByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdMasterM3U8Response = (unknown);

export type HeadAudioByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdMasterM3U8Response = (unknown);

export type GetAudioByIdLiveM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdLiveM3U8Response = (unknown);

export type GetAudioByIdMainM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdMainM3U8Response = (unknown);

export type GetVideosByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdMasterM3U8Response = (unknown);

export type HeadVideosByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdMasterM3U8Response = (unknown);

export type GetVideosByIdLiveM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdLiveM3U8Response = (unknown);

export type GetVideosByIdMainM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdMainM3U8Response = (unknown);

export type GetVideosByIdSubtitlesM3U8Data = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle segment format
     */
    manifestSubtitles: string;
    /**
     * The subtitle segment length
     */
    subtitleSegmentLength: number;
};

export type GetVideosByIdSubtitlesM3U8Response = (unknown);

export type GetVideosByIdLiveSubtitlesM3U8Data = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle segment format
     */
    manifestSubtitles: string;
    /**
     * The subtitle segment length
     */
    subtitleSegmentLength: number;
};

export type GetVideosByIdLiveSubtitlesM3U8Response = (unknown);

export type GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type GetDlnaByUuidDescriptionXmlData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidDescriptionXmlResponse = (unknown);

export type HeadDlnaByUuidDescriptionXmlData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type HeadDlnaByUuidDescriptionXmlResponse = (unknown);

export type GetDlnaByUuidDescriptionData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidDescriptionResponse = (unknown);

export type HeadDlnaByUuidDescriptionData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type HeadDlnaByUuidDescriptionResponse = (unknown);

export type GetDlnaIconsByFilenameData = {
    /**
     * The icon filename
     */
    filename: string;
    /**
     * Server UuId
     */
    uuId?: string;
};

export type GetDlnaIconsByFilenameResponse = (unknown);

export type GetDlnaByUuidContentdirectoryContentdirectoryXmlData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidContentdirectoryContentdirectoryXmlResponse = (unknown);

export type HeadDlnaByUuidContentdirectoryContentdirectoryXmlData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type HeadDlnaByUuidContentdirectoryContentdirectoryXmlResponse = (unknown);

export type GetDlnaByUuidContentdirectoryContentdirectoryData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidContentdirectoryContentdirectoryResponse = (unknown);

export type HeadDlnaByUuidContentdirectoryContentdirectoryData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type HeadDlnaByUuidContentdirectoryContentdirectoryResponse = (unknown);

export type GetDlnaByUuidConnectionmanagerConnectionmanagerXmlData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidConnectionmanagerConnectionmanagerXmlResponse = (unknown);

export type HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlResponse = (unknown);

export type GetDlnaByUuidConnectionmanagerConnectionmanagerData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidConnectionmanagerConnectionmanagerResponse = (unknown);

export type HeadDlnaByUuidConnectionmanagerConnectionmanagerData = {
    /**
     * Server UuId
     */
    uuId: string;
};

export type HeadDlnaByUuidConnectionmanagerConnectionmanagerResponse = (unknown);

export type PostDlnaByUuidContentdirectoryControlData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Server UuId
     */
    uuId: string;
};

export type PostDlnaByUuidContentdirectoryControlResponse = (unknown);

export type PostDlnaByUuidConnectionmanagerControlData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Server UuId
     */
    uuId: string;
};

export type PostDlnaByUuidConnectionmanagerControlResponse = (unknown);

export type GetDlnaByUuidIconsByFilenameData = {
    /**
     * The icon filename
     */
    filename: string;
    /**
     * Server UuId
     */
    uuId: string;
};

export type GetDlnaByUuidIconsByFilenameResponse = (unknown);

export type GetItemsByIdExternalidinfosData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdExternalidinfosResponse = (Array<ExternalIdInfo>);

export type PostItemsRemotesearchTrailerData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_TrailerInfo;
};

export type PostItemsRemotesearchTrailerResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchBookData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_BookInfo;
};

export type PostItemsRemotesearchBookResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMovieData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_MovieInfo;
};

export type PostItemsRemotesearchMovieResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchSeriesData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_SeriesInfo;
};

export type PostItemsRemotesearchSeriesResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchGameData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_GameInfo;
};

export type PostItemsRemotesearchGameResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchBoxsetData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_ItemLookupInfo;
};

export type PostItemsRemotesearchBoxsetResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMusicvideoData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_MusicVideoInfo;
};

export type PostItemsRemotesearchMusicvideoResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchPersonData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_PersonLookupInfo;
};

export type PostItemsRemotesearchPersonResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMusicalbumData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_AlbumInfo;
};

export type PostItemsRemotesearchMusicalbumResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMusicartistData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_ArtistInfo;
};

export type PostItemsRemotesearchMusicartistResponse = (Array<RemoteSearchResult>);

export type GetItemsRemotesearchImageData = {
    /**
     * The image url
     */
    imageUrl: string;
    providerName: string;
};

export type GetItemsRemotesearchImageResponse = (unknown);

export type PostItemsMetadataResetData = {
    /**
     * The item ids
     */
    itemIds: string;
};

export type PostItemsMetadataResetResponse = (unknown);

export type PostItemsRemotesearchApplyByIdData = {
    /**
     * The item id
     */
    id: string;
    /**
     * Whether or not to replace all images
     */
    replaceAllImages?: boolean;
    /**
     * RemoteSearchResult:
     */
    requestBody: RemoteSearchResult;
};

export type PostItemsRemotesearchApplyByIdResponse = (unknown);

export type PostItemsByIdRefreshData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Specifies the image refresh mode
     */
    imageRefreshMode?: MetadataRefreshMode;
    /**
     * Specifies the metadata refresh mode
     */
    metadataRefreshMode?: MetadataRefreshMode;
    /**
     * Indicates if the refresh should occur recursively.
     */
    recursive?: boolean;
    /**
     * Determines if images should be replaced. Only applicable if mode is FullRefresh
     */
    replaceAllImages?: boolean;
    /**
     * Determines if metadata should be replaced. Only applicable if mode is FullRefresh
     */
    replaceAllMetadata?: boolean;
    /**
     * BaseRefreshRequest:
     */
    requestBody: BaseRefreshRequest;
};

export type PostItemsByIdRefreshResponse = (unknown);

export type GetItemsByIdThumbnailsetData = {
    /**
     * Item Id
     */
    id: string;
    width: number;
};

export type GetItemsByIdThumbnailsetResponse = (RokuMetadata_Api_ThumbnailSetInfo);

export type GetVideosByIdIndexBifData = {
    /**
     * Item Id
     */
    id: string;
    width: number;
};

export type GetVideosByIdIndexBifResponse = (unknown);

export type PostNotificationsServicesTestData = {
    /**
     * UserNotificationInfo:
     */
    requestBody: UserNotificationInfo;
};

export type PostNotificationsServicesTestResponse = (unknown);

export type GetNotificationsServicesDefaultsResponse = (UserNotificationInfo);

export type GetSystemActivitylogEntriesData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The minimum date. Format = ISO
     */
    minDate?: (string) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
};

export type GetSystemActivitylogEntriesResponse = (QueryResult_ActivityLogEntry);

export type GetUsersByUseridSuggestionsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetUsersByUseridSuggestionsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridHomesectionsData = {
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridHomesectionsResponse = (Array<ContentSection>);

export type GetUsersByUseridSectionsBySectionidItemsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: (string) | null;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: (string) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: (string) | null;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: (string) | null;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: (string) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: (string) | null;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    sectionId: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetUsersByUseridSectionsBySectionidItemsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridViewsData = {
    /**
     * Whether or not to include external views such as channels or live tv
     */
    includeExternalContent: (boolean) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridViewsResponse = (QueryResult_BaseItemDto);

export type GetVideosByIdStreamByContainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdStreamByContainerResponse = (unknown);

export type HeadVideosByIdStreamByContainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdStreamByContainerResponse = (unknown);

export type GetVideosByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdStreamResponse = (unknown);

export type HeadVideosByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdStreamResponse = (unknown);

export type GetVideosByIdByStreamfilenameData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    streamFileName: string;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdByStreamfilenameResponse = (unknown);

export type HeadVideosByIdByStreamfilenameData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    streamFileName: string;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdByStreamfilenameResponse = (unknown);

export type DeleteItemsByIdSubtitlesByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type DeleteItemsByIdSubtitlesByIndexResponse = (unknown);

export type GetProvidersSubtitlesSubtitlesByIdData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetProvidersSubtitlesSubtitlesByIdResponse = (unknown);

export type DeleteVideosByIdSubtitlesByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type DeleteVideosByIdSubtitlesByIndexResponse = (unknown);

export type GetItemsByIdRemotesearchSubtitlesByLanguageData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * IsForced
     */
    isForced?: (boolean) | null;
    /**
     * IsHearingImpaired
     */
    isHearingImpaired?: (boolean) | null;
    /**
     * IsPerfectMatch
     */
    isPerfectMatch?: (boolean) | null;
    /**
     * Language
     */
    language: string;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type GetItemsByIdRemotesearchSubtitlesByLanguageResponse = (Array<RemoteSubtitleInfo>);

export type PostItemsByIdSubtitlesByIndexDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type PostItemsByIdSubtitlesByIndexDeleteResponse = (unknown);

export type PostItemsByIdRemotesearchSubtitlesBySubtitleidData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * SubtitleId
     */
    subtitleId: string;
};

export type PostItemsByIdRemotesearchSubtitlesBySubtitleidResponse = (Subtitles_SubtitleDownloadResult);

export type PostVideosByIdSubtitlesByIndexDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type PostVideosByIdSubtitlesByIndexDeleteResponse = (unknown);

export type GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks?: number;
};

export type GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponse = (unknown);

export type HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks?: number;
};

export type HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponse = (unknown);

export type GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks?: number;
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponse = (unknown);

export type HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks?: number;
};

export type HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponse = (unknown);

export type GetVideosByIdByMediasourceidAttachmentsByIndexStreamData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type GetVideosByIdByMediasourceidAttachmentsByIndexStreamResponse = (unknown);

export type GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks: number;
};

export type GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponse = (unknown);

export type HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks: number;
};

export type HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponse = (unknown);

export type GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks: number;
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponse = (unknown);

export type HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks: number;
};

export type HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponse = (unknown);

export type GetLivetvLivestreamfilesByIdStreamByContainerData = {
    container: string;
    id: string;
};

export type GetLivetvLivestreamfilesByIdStreamByContainerResponse = (unknown);

export type GetLivetvLiverecordingsByIdStreamData = {
    id: string;
};

export type GetLivetvLiverecordingsByIdStreamResponse = (unknown);

export type GetLivetvLivestreamfilesByIdHlsMasterM3U8Data = {
    id: string;
};

export type GetLivetvLivestreamfilesByIdHlsMasterM3U8Response = (unknown);

export type HeadLivetvLivestreamfilesByIdHlsMasterM3U8Data = {
    id: string;
};

export type HeadLivetvLivestreamfilesByIdHlsMasterM3U8Response = (unknown);

export type GetLivetvLiverecordingsByIdHlsMasterM3U8Data = {
    id: string;
};

export type GetLivetvLiverecordingsByIdHlsMasterM3U8Response = (unknown);

export type HeadLivetvLiverecordingsByIdHlsMasterM3U8Data = {
    id: string;
};

export type HeadLivetvLiverecordingsByIdHlsMasterM3U8Response = (unknown);

export type GetLivetvLiverecordingsByIdHlsLiveM3U8Data = {
    id: string;
};

export type GetLivetvLiverecordingsByIdHlsLiveM3U8Response = (unknown);

export type HeadLivetvLiverecordingsByIdHlsLiveM3U8Data = {
    id: string;
};

export type HeadLivetvLiverecordingsByIdHlsLiveM3U8Response = (unknown);

export type GetLivetvLivestreamfilesByIdHlsLiveM3U8Data = {
    id: string;
};

export type GetLivetvLivestreamfilesByIdHlsLiveM3U8Response = (unknown);

export type HeadLivetvLivestreamfilesByIdHlsLiveM3U8Data = {
    id: string;
};

export type HeadLivetvLivestreamfilesByIdHlsLiveM3U8Response = (unknown);

export type GetLivetvLivestreamfilesByIdHlsBySegmentData = {
    id: string;
    segment: string;
};

export type GetLivetvLivestreamfilesByIdHlsBySegmentResponse = (unknown);

export type HeadLivetvLivestreamfilesByIdHlsBySegmentData = {
    id: string;
    segment: string;
};

export type HeadLivetvLivestreamfilesByIdHlsBySegmentResponse = (unknown);

export type GetLivetvLiverecordingsByIdHlsBySegmentData = {
    id: string;
    segment: string;
};

export type GetLivetvLiverecordingsByIdHlsBySegmentResponse = (unknown);

export type HeadLivetvLiverecordingsByIdHlsBySegmentData = {
    id: string;
    segment: string;
};

export type HeadLivetvLiverecordingsByIdHlsBySegmentResponse = (unknown);

export type GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);