// This file is auto-generated by @hey-api/openapi-ts

export type QueryResult_BaseItemDto = {
    Items?: Array<BaseItemDto>;
    TotalRecordCount?: number;
};

export type BaseItemDto = {
    Name?: string;
    OriginalTitle?: string;
    ServerId?: string;
    Id?: string;
    Guid?: string;
    Etag?: string;
    Prefix?: string;
    PlaylistItemId?: string;
    DateCreated?: (string) | null;
    ExtraType?: string;
    SortIndexNumber?: (number) | null;
    SortParentIndexNumber?: (number) | null;
    CanDelete?: (boolean) | null;
    CanDownload?: (boolean) | null;
    CanEditItems?: (boolean) | null;
    SupportsResume?: (boolean) | null;
    PresentationUniqueKey?: string;
    PreferredMetadataLanguage?: string;
    PreferredMetadataCountryCode?: string;
    SupportsSync?: (boolean) | null;
    SyncStatus?: SyncJobItemStatus;
    CanManageAccess?: (boolean) | null;
    CanLeaveContent?: (boolean) | null;
    CanMakePublic?: (boolean) | null;
    Container?: string;
    SortName?: string;
    ForcedSortName?: string;
    Video3DFormat?: Video3DFormat;
    PremiereDate?: (string) | null;
    ExternalUrls?: Array<ExternalUrl>;
    MediaSources?: Array<MediaSourceInfo>;
    CriticRating?: (number) | null;
    GameSystemId?: (number) | null;
    AsSeries?: (boolean) | null;
    GameSystem?: string;
    ProductionLocations?: Array<(string)>;
    Path?: string;
    OfficialRating?: string;
    CustomRating?: string;
    ChannelId?: string;
    ChannelName?: string;
    Overview?: string;
    Taglines?: Array<(string)>;
    Genres?: Array<(string)>;
    CommunityRating?: (number) | null;
    RunTimeTicks?: (number) | null;
    Size?: (number) | null;
    FileName?: string;
    Bitrate?: (number) | null;
    ProductionYear?: (number) | null;
    Number?: string;
    ChannelNumber?: string;
    IndexNumber?: (number) | null;
    IndexNumberEnd?: (number) | null;
    ParentIndexNumber?: (number) | null;
    RemoteTrailers?: Array<MediaUrl>;
    ProviderIds?: ProviderIdDictionary;
    IsFolder?: (boolean) | null;
    ParentId?: string;
    Type?: string;
    People?: Array<BaseItemPerson>;
    Studios?: Array<NameLongIdPair>;
    GenreItems?: Array<NameLongIdPair>;
    TagItems?: Array<NameLongIdPair>;
    ParentLogoItemId?: string;
    ParentBackdropItemId?: string;
    ParentBackdropImageTags?: Array<(string)>;
    LocalTrailerCount?: (number) | null;
    UserData?: UserItemDataDto;
    RecursiveItemCount?: (number) | null;
    ChildCount?: (number) | null;
    SeriesName?: string;
    SeriesId?: string;
    SeasonId?: string;
    SpecialFeatureCount?: (number) | null;
    DisplayPreferencesId?: string;
    Status?: string;
    AirDays?: Array<DayOfWeek>;
    Tags?: Array<(string)>;
    PrimaryImageAspectRatio?: (number) | null;
    Artists?: Array<(string)>;
    ArtistItems?: Array<NameIdPair>;
    Composers?: Array<NameIdPair>;
    Album?: string;
    CollectionType?: string;
    DisplayOrder?: string;
    AlbumId?: string;
    AlbumPrimaryImageTag?: string;
    SeriesPrimaryImageTag?: string;
    AlbumArtist?: string;
    AlbumArtists?: Array<NameIdPair>;
    SeasonName?: string;
    MediaStreams?: Array<MediaStream>;
    PartCount?: (number) | null;
    ImageTags?: {
        [key: string]: (string);
    };
    BackdropImageTags?: Array<(string)>;
    ParentLogoImageTag?: string;
    SeriesStudio?: string;
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
    ParentThumbItemId?: string;
    ParentThumbImageTag?: string;
    Chapters?: Array<ChapterInfo>;
    LocationType?: LocationType;
    MediaType?: string;
    EndDate?: (string) | null;
    LockedFields?: Array<MetadataFields>;
    LockData?: (boolean) | null;
    Width?: (number) | null;
    Height?: (number) | null;
    CameraMake?: string;
    CameraModel?: string;
    Software?: string;
    ExposureTime?: (number) | null;
    FocalLength?: (number) | null;
    ImageOrientation?: Drawing_ImageOrientation;
    Aperture?: (number) | null;
    ShutterSpeed?: (number) | null;
    Latitude?: (number) | null;
    Longitude?: (number) | null;
    Altitude?: (number) | null;
    IsoSpeedRating?: (number) | null;
    SeriesTimerId?: string;
    ChannelPrimaryImageTag?: string;
    StartDate?: (string) | null;
    CompletionPercentage?: (number) | null;
    IsRepeat?: (boolean) | null;
    IsNew?: (boolean) | null;
    EpisodeTitle?: string;
    IsMovie?: (boolean) | null;
    IsSports?: (boolean) | null;
    IsSeries?: (boolean) | null;
    IsLive?: (boolean) | null;
    IsNews?: (boolean) | null;
    IsKids?: (boolean) | null;
    IsPremiere?: (boolean) | null;
    TimerType?: LiveTv_TimerType;
    Disabled?: (boolean) | null;
    ManagementId?: string;
    TimerId?: string;
    CurrentProgram?: BaseItemDto;
    MovieCount?: (number) | null;
    SeriesCount?: (number) | null;
    AlbumCount?: (number) | null;
    SongCount?: (number) | null;
    MusicVideoCount?: (number) | null;
    Subviews?: Array<(string)>;
    ListingsProviderId?: string;
    ListingsChannelId?: string;
    ListingsPath?: string;
    ListingsId?: string;
    ListingsChannelName?: string;
    ListingsChannelNumber?: string;
    AffiliateCallSign?: string;
};

export type SyncJobItemStatus = 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Synced' | 'Failed';

export type Video3DFormat = 'HalfSideBySide' | 'FullSideBySide' | 'FullTopAndBottom' | 'HalfTopAndBottom' | 'MVC';

export type ExternalUrl = {
    Name?: string;
    Url?: string;
};

export type MediaSourceInfo = {
    Protocol?: MediaProtocol;
    Id?: string;
    Path?: string;
    EncoderPath?: string;
    EncoderProtocol?: MediaProtocol;
    Type?: MediaSourceType;
    ProbePath?: string;
    ProbeProtocol?: MediaProtocol;
    Container?: string;
    Size?: (number) | null;
    Name?: string;
    SortName?: string;
    IsRemote?: boolean;
    HasMixedProtocols?: boolean;
    RunTimeTicks?: (number) | null;
    ContainerStartTimeTicks?: (number) | null;
    SupportsTranscoding?: boolean;
    TrancodeLiveStartIndex?: (number) | null;
    WallClockStart?: (string) | null;
    SupportsDirectStream?: boolean;
    SupportsDirectPlay?: boolean;
    IsInfiniteStream?: boolean;
    RequiresOpening?: boolean;
    OpenToken?: string;
    RequiresClosing?: boolean;
    LiveStreamId?: string;
    /**
     * @deprecated
     */
    BufferMs?: (number) | null;
    RequiresLooping?: boolean;
    /**
     * @deprecated
     */
    SupportsProbing?: boolean;
    Video3DFormat?: Video3DFormat;
    MediaStreams?: Array<MediaStream>;
    Formats?: Array<(string)>;
    Bitrate?: (number) | null;
    Timestamp?: TransportStreamTimestamp;
    RequiredHttpHeaders?: {
        [key: string]: (string);
    };
    DirectStreamUrl?: string;
    AddApiKeyToDirectStreamUrl?: boolean;
    TranscodingUrl?: string;
    TranscodingSubProtocol?: string;
    TranscodingContainer?: string;
    /**
     * @deprecated
     */
    AnalyzeDurationMs?: (number) | null;
    /**
     * @deprecated
     */
    ReadAtNativeFramerate?: boolean;
    DefaultAudioStreamIndex?: (number) | null;
    DefaultSubtitleStreamIndex?: (number) | null;
    ItemId?: string;
    ServerId?: string;
};

export type MediaProtocol = 'File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp' | 'Mms';

export type MediaSourceType = 'Default' | 'Grouping' | 'Placeholder';

export type MediaStream = {
    Codec?: string;
    CodecTag?: string;
    Language?: string;
    ColorTransfer?: string;
    ColorPrimaries?: string;
    ColorSpace?: string;
    Comment?: string;
    StreamStartTimeTicks?: (number) | null;
    TimeBase?: string;
    Title?: string;
    Extradata?: string;
    VideoRange?: string;
    DisplayTitle?: string;
    DisplayLanguage?: string;
    NalLengthSize?: string;
    IsInterlaced?: boolean;
    /**
     * @deprecated
     */
    IsAVC?: (boolean) | null;
    ChannelLayout?: string;
    BitRate?: (number) | null;
    BitDepth?: (number) | null;
    RefFrames?: (number) | null;
    Rotation?: (number) | null;
    Channels?: (number) | null;
    SampleRate?: (number) | null;
    IsDefault?: boolean;
    IsForced?: boolean;
    IsHearingImpaired?: boolean;
    Height?: (number) | null;
    Width?: (number) | null;
    AverageFrameRate?: (number) | null;
    RealFrameRate?: (number) | null;
    Profile?: string;
    Type?: MediaStreamType;
    AspectRatio?: string;
    Index?: number;
    IsExternal?: boolean;
    DeliveryMethod?: SubtitleDeliveryMethod;
    DeliveryUrl?: string;
    IsExternalUrl?: (boolean) | null;
    IsTextSubtitleStream?: boolean;
    SupportsExternalStream?: boolean;
    Path?: string;
    Protocol?: MediaProtocol;
    PixelFormat?: string;
    Level?: (number) | null;
    IsAnamorphic?: (boolean) | null;
    ExtendedVideoType?: ExtendedVideoTypes;
    ExtendedVideoSubType?: ExtendedVideoSubTypes;
    ExtendedVideoSubTypeDescription?: string;
    ItemId?: string;
    ServerId?: string;
    AttachmentSize?: (number) | null;
    MimeType?: string;
    SubtitleLocationType?: SubtitleLocationType;
};

export type MediaStreamType = 'Unknown' | 'Audio' | 'Video' | 'Subtitle' | 'EmbeddedImage' | 'Attachment' | 'Data';

export type SubtitleDeliveryMethod = 'Encode' | 'Embed' | 'External' | 'Hls' | 'VideoSideData';

export type ExtendedVideoTypes = 'None' | 'Hdr10' | 'Hdr10Plus' | 'HyperLogGamma' | 'DolbyVision';

export type ExtendedVideoSubTypes = 'None' | 'Hdr10' | 'HyperLogGamma' | 'Hdr10Plus0' | 'DoviProfile02' | 'DoviProfile10' | 'DoviProfile22' | 'DoviProfile30' | 'DoviProfile42' | 'DoviProfile50' | 'DoviProfile61' | 'DoviProfile76' | 'DoviProfile81' | 'DoviProfile82' | 'DoviProfile83' | 'DoviProfile84' | 'DoviProfile85' | 'DoviProfile92';

export type SubtitleLocationType = 'InternalStream' | 'VideoSideData';

export type TransportStreamTimestamp = 'None' | 'Zero' | 'Valid';

export type MediaUrl = {
    Url?: string;
    Name?: string;
};

export type ProviderIdDictionary = {
    [key: string]: (string);
};

export type BaseItemPerson = {
    Name?: string;
    Id?: string;
    Role?: string;
    Type?: PersonType;
    PrimaryImageTag?: string;
};

export type PersonType = 'Actor' | 'Director' | 'Writer' | 'Producer' | 'GuestStar' | 'Composer' | 'Conductor' | 'Lyricist';

export type NameLongIdPair = {
    Name?: string;
    Id?: number;
};

export type UserItemDataDto = {
    Rating?: (number) | null;
    PlayedPercentage?: (number) | null;
    UnplayedItemCount?: (number) | null;
    PlaybackPositionTicks?: number;
    PlayCount?: (number) | null;
    IsFavorite?: boolean;
    LastPlayedDate?: (string) | null;
    Played?: boolean;
    Key?: string;
    ItemId?: string;
    ServerId?: string;
};

export type DayOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday';

export type NameIdPair = {
    Name?: string;
    Id?: string;
};

export type ChapterInfo = {
    StartPositionTicks?: number;
    Name?: string;
    ImageTag?: string;
    MarkerType?: MarkerType;
    ChapterIndex?: number;
};

export type MarkerType = 'Chapter' | 'IntroStart' | 'IntroEnd' | 'CreditsStart';

export type LocationType = 'FileSystem' | 'Virtual';

export type MetadataFields = 'Cast' | 'Genres' | 'ProductionLocations' | 'Studios' | 'Tags' | 'Name' | 'Overview' | 'Runtime' | 'OfficialRating' | 'Collections' | 'ChannelNumber' | 'SortName' | 'OriginalTitle' | 'SortIndexNumber' | 'SortParentIndexNumber' | 'CommunityRating' | 'CriticRating' | 'Tagline';

export type Drawing_ImageOrientation = 'TopLeft' | 'TopRight' | 'BottomRight' | 'BottomLeft' | 'LeftTop' | 'RightTop' | 'RightBottom' | 'LeftBottom';

export type LiveTv_TimerType = 'Program' | 'DateTime' | 'Keyword';

export type QueryResult_UserLibrary_TagItem = {
    Items?: Array<UserLibrary_TagItem>;
    TotalRecordCount?: number;
};

export type UserLibrary_TagItem = {
    Name?: string;
    Id?: string;
};

export type Collections_CollectionCreationResult = {
    Id?: string;
    Name?: string;
};

export type QueryResult_Devices_DeviceInfo = {
    Items?: Array<Devices_DeviceInfo>;
    TotalRecordCount?: number;
};

export type Devices_DeviceInfo = {
    Name?: string;
    Id?: string;
    InternalId?: number;
    ReportedDeviceId?: string;
    LastUserName?: string;
    AppName?: string;
    AppVersion?: string;
    LastUserId?: string;
    DateLastActivity?: string;
    IconUrl?: string;
    IpAddress?: string;
};

export type FeatureInfo = {
    Name?: string;
    Id?: string;
    FeatureType?: FeatureType;
};

export type FeatureType = 'System' | 'User';

export type QueryResult_UserLibrary_OfficialRatingItem = {
    Items?: Array<UserLibrary_OfficialRatingItem>;
    TotalRecordCount?: number;
};

export type UserLibrary_OfficialRatingItem = {
    Name?: string;
};

export type PackageInfo = {
    id?: string;
    name?: string;
    shortDescription?: string;
    overview?: string;
    isPremium?: boolean;
    adult?: boolean;
    richDescUrl?: string;
    thumbImage?: string;
    previewImage?: string;
    type?: string;
    targetFilename?: string;
    owner?: string;
    category?: string;
    tileColor?: string;
    featureId?: string;
    price?: (number) | null;
    targetSystem?: PackageTargetSystem;
    guid?: string;
    isRegistered?: boolean;
    expDate?: string;
    versions?: Array<PackageVersionInfo>;
    enableInAppStore?: boolean;
    installs?: number;
};

export type PackageTargetSystem = 'Server' | 'MBTheater' | 'MBClassic' | 'Other';

export type PackageVersionInfo = {
    name?: string;
    guid?: string;
    versionStr?: string;
    classification?: PackageVersionClass;
    description?: string;
    requiredVersionStr?: string;
    sourceUrl?: string;
    checksum?: string;
    targetFilename?: string;
    infoUrl?: string;
    runtimes?: string;
    timestamp?: (string) | null;
};

export type PackageVersionClass = 'Release' | 'Beta' | 'Dev';

export type Playlists_PlaylistCreationResult = {
    Id?: string;
    Name?: string;
    ItemAddedCount?: number;
};

export type Plugins_PluginInfo = {
    Name?: string;
    Version?: string;
    ConfigurationFileName?: string;
    Description?: string;
    Id?: string;
    ImageTag?: string;
};

export type TaskInfo = {
    Name?: string;
    State?: TaskState;
    CurrentProgressPercentage?: (number) | null;
    Id?: string;
    LastExecutionResult?: TaskResult;
    Triggers?: Array<TaskTriggerInfo>;
    Description?: string;
    Category?: string;
    IsHidden?: boolean;
    Key?: string;
};

export type TaskState = 'Idle' | 'Cancelling' | 'Running';

export type TaskResult = {
    StartTimeUtc?: string;
    EndTimeUtc?: string;
    Status?: TaskCompletionStatus;
    Name?: string;
    Key?: string;
    Id?: string;
    ErrorMessage?: string;
    LongErrorMessage?: string;
};

export type TaskCompletionStatus = 'Completed' | 'Failed' | 'Cancelled' | 'Aborted';

export type TaskTriggerInfo = {
    Type?: string;
    TimeOfDayTicks?: (number) | null;
    IntervalTicks?: (number) | null;
    SystemEvent?: SystemEvent;
    DayOfWeek?: DayOfWeek;
    MaxRuntimeTicks?: (number) | null;
};

export type SystemEvent = 'WakeFromSleep' | 'DisplayConfigurationChange' | 'NetworkChange';

export type Session_SessionInfo = {
    PlayState?: PlayerStateInfo;
    AdditionalUsers?: Array<SessionUserInfo>;
    RemoteEndPoint?: string;
    Protocol?: string;
    PlayableMediaTypes?: Array<(string)>;
    PlaylistItemId?: string;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    Id?: string;
    ServerId?: string;
    UserId?: string;
    UserName?: string;
    UserPrimaryImageTag?: string;
    Client?: string;
    LastActivityDate?: string;
    DeviceName?: string;
    DeviceType?: string;
    NowPlayingItem?: BaseItemDto;
    InternalDeviceId?: number;
    DeviceId?: string;
    ApplicationVersion?: string;
    AppIconUrl?: string;
    SupportedCommands?: Array<(string)>;
    TranscodingInfo?: TranscodingInfo;
    SupportsRemoteControl?: boolean;
};

export type PlayerStateInfo = {
    PositionTicks?: (number) | null;
    CanSeek?: boolean;
    IsPaused?: boolean;
    IsMuted?: boolean;
    VolumeLevel?: (number) | null;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    MediaSourceId?: string;
    PlayMethod?: PlayMethod;
    RepeatMode?: RepeatMode;
    SubtitleOffset?: number;
    Shuffle?: boolean;
    PlaybackRate?: number;
};

export type PlayMethod = 'Transcode' | 'DirectStream' | 'DirectPlay';

export type RepeatMode = 'RepeatNone' | 'RepeatAll' | 'RepeatOne';

export type SessionUserInfo = {
    UserId?: string;
    UserName?: string;
    UserInternalId?: number;
};

export type TranscodingInfo = {
    AudioCodec?: string;
    VideoCodec?: string;
    SubProtocol?: string;
    Container?: string;
    IsVideoDirect?: boolean;
    IsAudioDirect?: boolean;
    Bitrate?: (number) | null;
    AudioBitrate?: (number) | null;
    VideoBitrate?: (number) | null;
    Framerate?: (number) | null;
    CompletionPercentage?: (number) | null;
    TranscodingPositionTicks?: (number) | null;
    TranscodingStartPositionTicks?: (number) | null;
    Width?: (number) | null;
    Height?: (number) | null;
    AudioChannels?: (number) | null;
    TranscodeReasons?: Array<TranscodeReason>;
    /**
     * Deprecated, please use ProcessStatistics instead
     * @deprecated
     */
    CurrentCpuUsage?: (number) | null;
    /**
     * Deprecated, please use ProcessStatistics instead
     * @deprecated
     */
    AverageCpuUsage?: (number) | null;
    /**
     * Deprecated, please use ProcessStatistics instead
     * @deprecated
     */
    CpuHistory?: Array<Tuple_Double_Double>;
    ProcessStatistics?: ProcessRun_Metrics_ProcessStatistics;
    CurrentThrottle?: (number) | null;
    VideoDecoder?: string;
    VideoDecoderIsHardware?: boolean;
    VideoDecoderMediaType?: string;
    VideoDecoderHwAccel?: string;
    VideoEncoder?: string;
    VideoEncoderIsHardware?: boolean;
    VideoEncoderMediaType?: string;
    VideoEncoderHwAccel?: string;
    VideoPipelineInfo?: Array<Transcoding_VpStepInfo>;
    SubtitlePipelineInfos?: Array<Array<Transcoding_VpStepInfo>>;
};

export type TranscodeReason = 'ContainerNotSupported' | 'VideoCodecNotSupported' | 'AudioCodecNotSupported' | 'ContainerBitrateExceedsLimit' | 'AudioBitrateNotSupported' | 'AudioChannelsNotSupported' | 'VideoResolutionNotSupported' | 'UnknownVideoStreamInfo' | 'UnknownAudioStreamInfo' | 'AudioProfileNotSupported' | 'AudioSampleRateNotSupported' | 'AnamorphicVideoNotSupported' | 'InterlacedVideoNotSupported' | 'SecondaryAudioNotSupported' | 'RefFramesNotSupported' | 'VideoBitDepthNotSupported' | 'VideoBitrateNotSupported' | 'VideoFramerateNotSupported' | 'VideoLevelNotSupported' | 'VideoProfileNotSupported' | 'AudioBitDepthNotSupported' | 'SubtitleCodecNotSupported' | 'DirectPlayError' | 'VideoRangeNotSupported' | 'SubtitleContentOptionsEnabled';

export type Tuple_Double_Double = {
    Item1?: number;
    Item2?: number;
};

export type ProcessRun_Metrics_ProcessStatistics = {
    CurrentCpu?: number;
    AverageCpu?: number;
    CurrentVirtualMemory?: number;
    CurrentWorkingSet?: number;
    Metrics?: Array<ProcessRun_Metrics_ProcessMetricPoint>;
};

export type ProcessRun_Metrics_ProcessMetricPoint = {
    Time?: string;
    CpuPercent?: number;
    VirtualMemory?: number;
    WorkingSet?: number;
};

export type Transcoding_VpStepInfo = {
    StepType?: Transcoding_VpStepTypes;
    StepTypeName?: string;
    HardwareContextName?: string;
    IsHardwareContext?: boolean;
    Name?: string;
    Short?: string;
    FfmpegName?: string;
    FfmpegDescription?: string;
    FfmpegOptions?: string;
    Param?: string;
    ParamShort?: string;
};

export type Transcoding_VpStepTypes = 'Decoder' | 'Encoder' | 'Scaling' | 'Deinterlace' | 'SubtitleOverlay' | 'ToneMapping' | 'ColorConversion' | 'SplitCaptions' | 'TextSub2Video' | 'GraphicSub2Video' | 'GraphicSub2Text' | 'BurnInTextSubs' | 'BurnInGraphicSubs' | 'ScaleSubs' | 'TextMod' | 'Censor' | 'ShowSpeaker' | 'StripStyles' | 'ConnectTo';

export type ImageType = 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail' | 'LogoLight' | 'LogoLightColor';

export type NameValuePair = {
    Name?: string;
    Value?: string;
};

export type MBBackup_Api_RestoreOptions = {
    RestoreServerId?: boolean;
    UseFiles?: string;
};

export type MBBackup_Api_DataRestoreOptions = {
    Users?: Array<MBBackup_Api_UserRestoreInfo>;
};

export type MBBackup_Api_UserRestoreInfo = {
    SourceUserId?: string;
    TargetUserId?: string;
};

export type MBBackup_Api_AllBackupsInfo = {
    FullBackupInfo?: MBBackup_BackupInfo;
    LightBackups?: Array<MBBackup_BackupInfo>;
};

export type MBBackup_BackupInfo = {
    ServerVersion?: string;
    PluginVersion?: string;
    Name?: string;
    CanRestore?: boolean;
    IsFullBackup?: boolean;
    DateCreated?: string;
    Users?: Array<NameIdPair>;
};

export type Branding_BrandingOptions = {
    LoginDisclaimer?: string;
    CustomCss?: string;
};

export type Connect_ConnectAuthenticationExchangeResult = {
    LocalUserId?: string;
    AccessToken?: string;
};

export type Devices_DeviceOptions = {
    CustomName?: string;
};

export type Devices_ContentUploadHistory = {
    DeviceId?: string;
    FilesUploaded?: Array<Devices_LocalFileInfo>;
};

export type Devices_LocalFileInfo = {
    Name?: string;
    Id?: string;
    Album?: string;
    MimeType?: string;
};

export type DisplayPreferences = {
    Id?: string;
    SortBy?: string;
    CustomPrefs?: {
        [key: string]: (string);
    };
    SortOrder?: SortOrder;
    Client?: string;
};

export type SortOrder = 'Ascending' | 'Descending';

export type Configuration_ToneMapping_ToneMapOptionsVisibility = {
    ShowAdvanced?: boolean;
    IsSoftwareToneMappingAvailable?: boolean;
    IsAnyHardwareToneMappingAvailable?: boolean;
    ShowNvidiaOptions?: boolean;
    ShowQuickSyncOptions?: boolean;
    ShowVaapiOptions?: boolean;
    IsOpenClAvailable?: boolean;
    IsOpenClSuperTAvailable?: boolean;
    IsVaapiNativeAvailable?: boolean;
    IsQuickSyncNativeAvailable?: boolean;
    OperatingSystem?: OperatingSystem;
};

export type OperatingSystem = 'Windows' | 'Linux' | 'OSX' | 'BSD' | 'Android';

export type EditObjectContainer = {
    Object?: {
        [key: string]: unknown;
    };
    DefaultObject?: {
        [key: string]: unknown;
    };
    TypeName?: string;
    EditorRoot?: Editors_EditorRoot;
};

export type Editors_EditorRoot = {
    PropertyConditions?: Array<Conditions_PropertyCondition>;
    PostbackActions?: Array<Actions_PostbackAction>;
    TitleButton?: Editors_EditorButtonItem;
    EditorItems?: Array<Editors_EditorBase>;
    EditorType?: Common_EditorTypes;
    Name?: string;
    Id?: string;
    AllowEmpty?: boolean;
    IsReadOnly?: boolean;
    IsAdvanced?: boolean;
    DisplayName?: string;
    Description?: string;
    FeatureRequiresPremiere?: boolean;
    ParentId?: string;
};

export type Conditions_PropertyCondition = {
    AffectedPropertyId?: string;
    ConditionType?: Conditions_PropertyConditionType;
    TargetPropertyId?: string;
    SimpleCondition?: Attributes_SimpleCondition;
    ValueCondition?: Attributes_ValueCondition;
    Value?: {
        [key: string]: unknown;
    };
};

export type Conditions_PropertyConditionType = 'Visible' | 'Enabled';

export type Attributes_SimpleCondition = 'IsTrue' | 'IsFalse' | 'IsNull' | 'IsNotNullOrEmpty';

export type Attributes_ValueCondition = 'IsEqual' | 'IsNotEqual' | 'IsGreater' | 'IsGreaterOrEqual' | 'IsLess' | 'IsLessOrEqual';

export type Actions_PostbackAction = {
    TargetEditorId?: string;
    PostbackCommandId?: string;
    CommandParameterPropertyId?: string;
};

export type Editors_EditorButtonItem = {
    EditorType?: Common_EditorTypes;
    Name?: string;
    Id?: string;
    AllowEmpty?: boolean;
    IsReadOnly?: boolean;
    IsAdvanced?: boolean;
    DisplayName?: string;
    Description?: string;
    FeatureRequiresPremiere?: boolean;
    ParentId?: string;
};

export type Common_EditorTypes = 'Group' | 'Text' | 'Numeric' | 'Boolean' | 'SelectSingle' | 'SelectMultiple' | 'Date' | 'FilePath' | 'FolderPath' | 'StatusItem' | 'ProgressItem' | 'ButtonItem' | 'ButtonGroup' | 'CaptionItem' | 'LabelItem' | 'ItemList' | 'RadioGroup' | 'DxDataGrid' | 'DxPivotGrid' | 'SpacerItem';

export type Editors_EditorBase = {
    EditorType?: Common_EditorTypes;
    Name?: string;
    Id?: string;
    AllowEmpty?: boolean;
    IsReadOnly?: boolean;
    IsAdvanced?: boolean;
    DisplayName?: string;
    Description?: string;
    FeatureRequiresPremiere?: boolean;
    ParentId?: string;
};

export type MediaEncoding_CodecParameterContext = 'Playback' | 'Conversion';

export type ValidatePath = {
    ValidateWriteable?: boolean;
    IsFile?: (boolean) | null;
    Username?: string;
    Password?: string;
};

export type DefaultDirectoryBrowserInfo = {
    Path?: string;
};

export type IO_FileSystemEntryInfo = {
    Name?: string;
    Path?: string;
    Type?: IO_FileSystemEntryType;
};

export type IO_FileSystemEntryType = 'File' | 'Directory' | 'NetworkComputer' | 'NetworkShare';

export type GetDirectoryContents = {
    Username?: string;
    Password?: string;
};

export type UserLibrary_UpdateUserItemAccess = {
    ItemIds?: Array<(string)>;
    UserIds?: Array<(string)>;
    ItemAccess?: UserItemShareLevel;
};

export type UserItemShareLevel = 'None' | 'Read' | 'Write' | 'Manage' | 'ManageDelete';

export type ItemCounts = {
    MovieCount?: number;
    SeriesCount?: number;
    EpisodeCount?: number;
    GameCount?: number;
    ArtistCount?: number;
    ProgramCount?: number;
    GameSystemCount?: number;
    TrailerCount?: number;
    SongCount?: number;
    AlbumCount?: number;
    MusicVideoCount?: number;
    BoxSetCount?: number;
    BookCount?: number;
    ItemCount?: number;
};

export type Persistence_IntroDebugInfo = {
    Id?: number;
    Path?: string;
    Start?: number;
    End?: number;
};

export type Library_LibraryOptionsResult = {
    MetadataSavers?: Array<Library_LibraryOptionInfo>;
    MetadataReaders?: Array<Library_LibraryOptionInfo>;
    SubtitleFetchers?: Array<Library_LibraryOptionInfo>;
    LyricsFetchers?: Array<Library_LibraryOptionInfo>;
    TypeOptions?: Array<Library_LibraryTypeOptions>;
};

export type Library_LibraryOptionInfo = {
    Name?: string;
    SetupUrl?: string;
    DefaultEnabled?: boolean;
    Features?: Array<MetadataFeatures>;
};

export type MetadataFeatures = 'Collections' | 'Adult' | 'RequiredSetup';

export type Library_LibraryTypeOptions = {
    Type?: string;
    MetadataFetchers?: Array<Library_LibraryOptionInfo>;
    ImageFetchers?: Array<Library_LibraryOptionInfo>;
    SupportedImageTypes?: Array<ImageType>;
    DefaultImageOptions?: Array<ImageOption>;
};

export type ImageOption = {
    Type?: ImageType;
    Limit?: number;
    MinWidth?: number;
};

export type Library_MediaFolder = {
    Name?: string;
    Id?: string;
    Guid?: string;
    SubFolders?: Array<Library_SubFolder>;
    IsUserAccessConfigurable?: boolean;
};

export type Library_SubFolder = {
    Name?: string;
    Id?: string;
    Path?: string;
    IsUserAccessConfigurable?: boolean;
};

export type Library_AddVirtualFolder = {
    Name?: string;
    CollectionType?: string;
    RefreshLibrary?: boolean;
    Paths?: Array<(string)>;
    LibraryOptions?: LibraryOptions;
};

export type LibraryOptions = {
    EnableArchiveMediaFiles?: boolean;
    EnablePhotos?: boolean;
    EnableRealtimeMonitor?: boolean;
    EnableMarkerDetection?: boolean;
    EnableMarkerDetectionDuringLibraryScan?: boolean;
    IntroDetectionFingerprintLength?: number;
    EnableChapterImageExtraction?: boolean;
    ExtractChapterImagesDuringLibraryScan?: boolean;
    DownloadImagesInAdvance?: boolean;
    CacheImages?: boolean;
    PathInfos?: Array<MediaPathInfo>;
    IgnoreHiddenFiles?: boolean;
    IgnoreFileExtensions?: Array<(string)>;
    SaveLocalMetadata?: boolean;
    SaveMetadataHidden?: boolean;
    SaveLocalThumbnailSets?: boolean;
    ImportPlaylists?: boolean;
    EnableAutomaticSeriesGrouping?: boolean;
    ShareEmbeddedMusicAlbumImages?: boolean;
    EnableEmbeddedTitles?: boolean;
    EnableAudioResume?: boolean;
    AutoGenerateChapters?: boolean;
    AutomaticRefreshIntervalDays?: number;
    PlaceholderMetadataRefreshIntervalDays?: number;
    PreferredMetadataLanguage?: string;
    PreferredImageLanguage?: string;
    ContentType?: string;
    MetadataCountryCode?: string;
    MetadataSavers?: Array<(string)>;
    DisabledLocalMetadataReaders?: Array<(string)>;
    LocalMetadataReaderOrder?: Array<(string)>;
    DisabledLyricsFetchers?: Array<(string)>;
    SaveLyricsWithMedia?: boolean;
    LyricsDownloadMaxAgeDays?: number;
    LyricsFetcherOrder?: Array<(string)>;
    LyricsDownloadLanguages?: Array<(string)>;
    DisabledSubtitleFetchers?: Array<(string)>;
    SubtitleFetcherOrder?: Array<(string)>;
    SkipSubtitlesIfEmbeddedSubtitlesPresent?: boolean;
    SkipSubtitlesIfAudioTrackMatches?: boolean;
    SubtitleDownloadLanguages?: Array<(string)>;
    SubtitleDownloadMaxAgeDays?: number;
    RequirePerfectSubtitleMatch?: boolean;
    SaveSubtitlesWithMedia?: boolean;
    ForcedSubtitlesOnly?: boolean;
    HearingImpairedSubtitlesOnly?: boolean;
    TypeOptions?: Array<TypeOptions>;
    CollapseSingleItemFolders?: boolean;
    EnableAdultMetadata?: boolean;
    ImportCollections?: boolean;
    MinCollectionItems?: number;
    MusicFolderStructure?: string;
    MinResumePct?: number;
    MaxResumePct?: number;
    MinResumeDurationSeconds?: number;
    ThumbnailImagesIntervalSeconds?: number;
    SampleIgnoreSize?: number;
};

export type MediaPathInfo = {
    Path?: string;
    NetworkPath?: string;
    Username?: string;
    Password?: string;
};

export type TypeOptions = {
    Type?: string;
    MetadataFetchers?: Array<(string)>;
    MetadataFetcherOrder?: Array<(string)>;
    ImageFetchers?: Array<(string)>;
    ImageFetcherOrder?: Array<(string)>;
    ImageOptions?: Array<ImageOption>;
};

export type LiveStreamRequest = {
    OpenToken?: string;
    UserId?: string;
    PlaySessionId?: string;
    MaxStreamingBitrate?: (number) | null;
    StartTimeTicks?: (number) | null;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    MaxAudioChannels?: (number) | null;
    ItemId?: number;
    DeviceProfile?: DeviceProfile;
    EnableDirectPlay?: boolean;
    EnableDirectStream?: boolean;
    EnableTranscoding?: boolean;
    AllowVideoStreamCopy?: boolean;
    AllowInterlacedVideoStreamCopy?: boolean;
    AllowAudioStreamCopy?: boolean;
    DirectPlayProtocols?: Array<MediaProtocol>;
};

export type DeviceProfile = {
    Name?: string;
    Id?: string;
    SupportedMediaTypes?: string;
    MaxStreamingBitrate?: (number) | null;
    MusicStreamingTranscodingBitrate?: (number) | null;
    MaxStaticMusicBitrate?: (number) | null;
    DirectPlayProfiles?: Array<DirectPlayProfile>;
    TranscodingProfiles?: Array<TranscodingProfile>;
    ContainerProfiles?: Array<ContainerProfile>;
    CodecProfiles?: Array<CodecProfile>;
    ResponseProfiles?: Array<ResponseProfile>;
    SubtitleProfiles?: Array<SubtitleProfile>;
};

export type DirectPlayProfile = {
    Container?: string;
    AudioCodec?: string;
    VideoCodec?: string;
    Type?: DlnaProfileType;
};

export type DlnaProfileType = 'Audio' | 'Video' | 'Photo';

export type TranscodingProfile = {
    Container?: string;
    Type?: DlnaProfileType;
    VideoCodec?: string;
    AudioCodec?: string;
    Protocol?: string;
    EstimateContentLength?: boolean;
    EnableMpegtsM2TsMode?: boolean;
    TranscodeSeekInfo?: TranscodeSeekInfo;
    CopyTimestamps?: boolean;
    Context?: EncodingContext;
    MaxAudioChannels?: string;
    MinSegments?: number;
    SegmentLength?: number;
    BreakOnNonKeyFrames?: boolean;
    AllowInterlacedVideoStreamCopy?: boolean;
    ManifestSubtitles?: string;
    MaxManifestSubtitles?: number;
    MaxWidth?: number;
    MaxHeight?: number;
    FillEmptySubtitleSegments?: boolean;
};

export type TranscodeSeekInfo = 'Auto' | 'Bytes';

export type EncodingContext = 'Streaming' | 'Static';

export type ContainerProfile = {
    Type?: DlnaProfileType;
    Conditions?: Array<ProfileCondition>;
    Container?: string;
};

export type ProfileCondition = {
    Condition?: ProfileConditionType;
    Property?: ProfileConditionValue;
    Value?: string;
    IsRequired?: boolean;
};

export type ProfileConditionType = 'Equals' | 'NotEquals' | 'LessThanEqual' | 'GreaterThanEqual' | 'EqualsAny';

export type ProfileConditionValue = 'AudioChannels' | 'AudioBitrate' | 'AudioProfile' | 'Width' | 'Height' | 'Has64BitOffsets' | 'PacketLength' | 'VideoBitDepth' | 'VideoBitrate' | 'VideoFramerate' | 'VideoLevel' | 'VideoProfile' | 'VideoTimestamp' | 'IsAnamorphic' | 'RefFrames' | 'NumAudioStreams' | 'NumVideoStreams' | 'IsSecondaryAudio' | 'VideoCodecTag' | 'IsAvc' | 'IsInterlaced' | 'AudioSampleRate' | 'AudioBitDepth' | 'VideoRange' | 'VideoRotation';

export type CodecProfile = {
    Type?: CodecType;
    Conditions?: Array<ProfileCondition>;
    ApplyConditions?: Array<ProfileCondition>;
    Codec?: string;
    Container?: string;
};

export type CodecType = 'Video' | 'VideoAudio' | 'Audio';

export type ResponseProfile = {
    Container?: string;
    AudioCodec?: string;
    VideoCodec?: string;
    Type?: DlnaProfileType;
    OrgPn?: string;
    MimeType?: string;
    Conditions?: Array<ProfileCondition>;
};

export type SubtitleProfile = {
    Format?: string;
    Method?: SubtitleDeliveryMethod;
    DidlMode?: string;
    Language?: string;
    Container?: string;
    Protocol?: string;
};

export type LiveStreamResponse = {
    MediaSource?: MediaSourceInfo;
};

export type Api_SetChannelMapping = {
    TunerChannelId?: string;
    ProviderChannelId?: string;
};

export type LiveTv_ListingsProviderInfo = {
    Name?: string;
    SetupUrl?: string;
    Id?: string;
    Type?: string;
    Username?: string;
    Password?: string;
    ListingsId?: string;
    ZipCode?: string;
    Country?: string;
    Path?: string;
    EnabledTuners?: Array<(string)>;
    EnableAllTuners?: boolean;
    NewsCategories?: Array<(string)>;
    SportsCategories?: Array<(string)>;
    KidsCategories?: Array<(string)>;
    MovieCategories?: Array<(string)>;
    ChannelMappings?: Array<NameValuePair>;
    MoviePrefix?: string;
    PreferredLanguage?: string;
    UserAgent?: string;
    DataVersion?: string;
};

export type LiveTv_TunerHostInfo = {
    Id?: string;
    Url?: string;
    Type?: string;
    DeviceId?: string;
    FriendlyName?: string;
    SetupUrl?: string;
    ImportFavoritesOnly?: boolean;
    PreferEpgChannelImages?: boolean;
    PreferEpgChannelNumbers?: boolean;
    AllowHWTranscoding?: boolean;
    AllowMappingByNumber?: boolean;
    ImportGuideData?: boolean;
    Source?: string;
    TunerCount?: number;
    UserAgent?: string;
    Referrer?: string;
    ProviderOptions?: string;
    DataVersion?: number;
};

export type LiveTv_LiveTvInfo = {
    IsEnabled?: boolean;
    EnabledUsers?: Array<(string)>;
};

export type LiveTv_ChannelType = 'TV' | 'Radio';

export type QueryResult_Api_EpgRow = {
    Items?: Array<Api_EpgRow>;
    TotalRecordCount?: number;
};

export type Api_EpgRow = {
    Channel?: BaseItemDto;
    Programs?: Array<BaseItemDto>;
};

export type Api_BaseItemsRequest = {
    Is4K?: (boolean) | null;
    EnableTotalRecordCount?: boolean;
    RecordingKeyword?: string;
    RecordingKeywordType?: LiveTv_KeywordType;
    RandomSeed?: number;
    GenreIds?: string;
    CollectionIds?: string;
    TagIds?: string;
    ExcludeTagIds?: string;
    ExcludeArtistIds?: string;
    AlbumArtistIds?: string;
    ContributingArtistIds?: string;
    AlbumIds?: string;
    OuterIds?: string;
    ListItemIds?: string;
    AudioLanguages?: string;
    SubtitleLanguages?: string;
    CanEditItems?: (boolean) | null;
    GroupItemsInto?: Library_ItemLinkType;
    MinWidth?: (number) | null;
    MinHeight?: (number) | null;
    MaxWidth?: (number) | null;
    MaxHeight?: (number) | null;
    GroupProgramsBySeries?: boolean;
    AirDays?: Array<DayOfWeek>;
    IsAiring?: (boolean) | null;
    HasAired?: (boolean) | null;
};

export type LiveTv_KeywordType = 'Name' | 'EpisodeTitle' | 'Overview' | 'Actor' | 'Director';

export type Library_ItemLinkType = 'Artists' | 'AlbumArtists' | 'Genres' | 'Studios' | 'Tags' | 'Composers' | 'Collections' | 'Albums' | 'CollectionFolders';

export type LiveTv_RecordingStatus = 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';

export type QueryResult_LiveTv_TimerInfoDto = {
    Items?: Array<LiveTv_TimerInfoDto>;
    TotalRecordCount?: number;
};

export type LiveTv_TimerInfoDto = {
    Status?: LiveTv_RecordingStatus;
    SeriesTimerId?: string;
    RunTimeTicks?: (number) | null;
    ProgramInfo?: BaseItemDto;
    TimerType?: LiveTv_TimerType;
    Id?: string;
    Type?: string;
    ServerId?: string;
    ChannelId?: string;
    ChannelName?: string;
    ChannelNumber?: string;
    ChannelPrimaryImageTag?: string;
    ProgramId?: string;
    Name?: string;
    Overview?: string;
    ParentFolderId?: string;
    StartDate?: string;
    EndDate?: string;
    Priority?: number;
    PrePaddingSeconds?: number;
    PostPaddingSeconds?: number;
    IsPrePaddingRequired?: boolean;
    ParentBackdropItemId?: string;
    ParentBackdropImageTags?: Array<(string)>;
    IsPostPaddingRequired?: boolean;
    KeepUntil?: LiveTv_KeepUntil;
};

export type LiveTv_KeepUntil = 'UntilDeleted' | 'UntilSpaceNeeded' | 'UntilWatched' | 'UntilDate';

export type QueryResult_LiveTv_SeriesTimerInfoDto = {
    Items?: Array<LiveTv_SeriesTimerInfoDto>;
    TotalRecordCount?: number;
};

export type LiveTv_SeriesTimerInfoDto = {
    RecordAnyTime?: boolean;
    SkipEpisodesInLibrary?: boolean;
    MatchExistingItemsWithAnyLibrary?: boolean;
    RecordAnyChannel?: boolean;
    KeepUpTo?: number;
    MaxRecordingSeconds?: number;
    RecordNewOnly?: boolean;
    ChannelIds?: Array<(string)>;
    Days?: Array<DayOfWeek>;
    ImageTags?: {
        [key: string]: (string);
    };
    ParentThumbItemId?: string;
    ParentThumbImageTag?: string;
    ParentPrimaryImageItemId?: string;
    ParentPrimaryImageTag?: string;
    SeriesId?: string;
    Keywords?: Array<LiveTv_KeywordInfo>;
    TimerType?: LiveTv_TimerType;
    Id?: string;
    Type?: string;
    ServerId?: string;
    ChannelId?: string;
    ChannelName?: string;
    ChannelNumber?: string;
    ChannelPrimaryImageTag?: string;
    ProgramId?: string;
    Name?: string;
    Overview?: string;
    ParentFolderId?: string;
    StartDate?: string;
    EndDate?: string;
    Priority?: number;
    PrePaddingSeconds?: number;
    PostPaddingSeconds?: number;
    IsPrePaddingRequired?: boolean;
    ParentBackdropItemId?: string;
    ParentBackdropImageTags?: Array<(string)>;
    IsPostPaddingRequired?: boolean;
    KeepUntil?: LiveTv_KeepUntil;
};

export type LiveTv_KeywordInfo = {
    KeywordType?: LiveTv_KeywordType;
    Keyword?: string;
};

export type LiveTv_SeriesTimerInfo = {
    Id?: string;
    ChannelId?: string;
    ChannelIds?: Array<(string)>;
    ParentFolderId?: number;
    ProgramId?: string;
    Name?: string;
    ServiceName?: string;
    Overview?: string;
    StartDate?: string;
    EndDate?: string;
    RecordAnyTime?: boolean;
    KeepUpTo?: number;
    KeepUntil?: LiveTv_KeepUntil;
    SkipEpisodesInLibrary?: boolean;
    MatchExistingItemsWithAnyLibrary?: boolean;
    RecordNewOnly?: boolean;
    Days?: Array<DayOfWeek>;
    Priority?: number;
    PrePaddingSeconds?: number;
    PostPaddingSeconds?: number;
    IsPrePaddingRequired?: boolean;
    IsPostPaddingRequired?: boolean;
    SeriesId?: string;
    ProviderIds?: ProviderIdDictionary;
    MaxRecordingSeconds?: number;
    Keywords?: Array<LiveTv_KeywordInfo>;
    TimerType?: LiveTv_TimerType;
};

export type LiveTv_GuideInfo = {
    StartDate?: string;
    EndDate?: string;
};

export type Api_AvailableRecordingOptions = {
    RecordingFolders?: Array<Api_NameIdDescriptionPair>;
    MovieRecordingFolders?: Array<Api_NameIdDescriptionPair>;
    SeriesRecordingFolders?: Array<Api_NameIdDescriptionPair>;
};

export type Api_NameIdDescriptionPair = {
    ShortOverview?: string;
    Name?: string;
    Id?: string;
};

export type ParentalRating = {
    Name?: string;
    Value?: number;
};

export type Globalization_LocalizatonOption = {
    Name?: string;
    Value?: string;
};

export type Globalization_CountryInfo = {
    Name?: string;
    DisplayName?: string;
    EnglishName?: string;
    TwoLetterISORegionName?: string;
    ThreeLetterISORegionName?: string;
};

export type Globalization_CultureDto = {
    Name?: string;
    DisplayName?: string;
    TwoLetterISOLanguageName?: string;
    ThreeLetterISOLanguageName?: string;
    ThreeLetterISOLanguageNames?: Array<(string)>;
    TwoLetterISOLanguageNames?: Array<(string)>;
};

export type RecommendationDto = {
    Items?: Array<BaseItemDto>;
    RecommendationType?: RecommendationType;
    BaselineItemName?: string;
    CategoryId?: number;
};

export type RecommendationType = 'SimilarToRecentlyPlayed' | 'SimilarToLikedItem' | 'HasDirectorFromRecentlyPlayed' | 'HasActorFromRecentlyPlayed' | 'HasLikedDirector' | 'HasLikedActor';

export type NotificationCategoryInfo = {
    Name?: string;
    Id?: string;
    Events?: Array<NotificationTypeInfo>;
};

export type NotificationTypeInfo = {
    Name?: string;
    Id?: string;
    CategoryName?: string;
    CategoryId?: string;
};

export type PlaybackStartInfo = {
    CanSeek?: boolean;
    Item?: BaseItemDto;
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    ItemId?: string;
    SessionId?: string;
    MediaSourceId?: string;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    IsPaused?: boolean;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    IsMuted?: boolean;
    PositionTicks?: (number) | null;
    RunTimeTicks?: (number) | null;
    PlaybackStartTimeTicks?: (number) | null;
    VolumeLevel?: (number) | null;
    Brightness?: (number) | null;
    AspectRatio?: string;
    EventName?: ProgressEvent;
    PlayMethod?: PlayMethod;
    LiveStreamId?: string;
    PlaySessionId?: string;
    RepeatMode?: RepeatMode;
    Shuffle?: boolean;
    SubtitleOffset?: number;
    PlaybackRate?: number;
    PlaylistItemIds?: Array<(string)>;
};

export type QueueItem = {
    Id?: number;
    PlaylistItemId?: string;
};

export type ProgressEvent = 'TimeUpdate' | 'Pause' | 'Unpause' | 'VolumeChange' | 'RepeatModeChange' | 'AudioTrackChange' | 'SubtitleTrackChange' | 'PlaylistItemMove' | 'PlaylistItemRemove' | 'PlaylistItemAdd' | 'QualityChange' | 'StateChange' | 'SubtitleOffsetChange' | 'PlaybackRateChange' | 'ShuffleChange';

export type SyncTarget = {
    Name?: string;
    Id?: string;
};

export type QueryResult_SyncJob = {
    Items?: Array<SyncJob>;
    TotalRecordCount?: number;
};

export type SyncJob = {
    Id?: number;
    TargetId?: string;
    InternalTargetId?: number;
    TargetName?: string;
    Quality?: string;
    Bitrate?: (number) | null;
    Container?: string;
    VideoCodec?: string;
    AudioCodec?: string;
    Profile?: string;
    Category?: SyncCategory;
    ParentId?: number;
    Progress?: number;
    Name?: string;
    Status?: SyncJobStatus;
    UserId?: number;
    UnwatchedOnly?: boolean;
    SyncNewContent?: boolean;
    ItemLimit?: (number) | null;
    RequestedItemIds?: Array<(number)>;
    ItemId?: number;
    DateCreated?: string;
    DateLastModified?: string;
    ItemCount?: number;
    ParentName?: string;
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
};

export type SyncCategory = 'Latest' | 'NextUp' | 'Resume';

export type SyncJobStatus = 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Completed' | 'CompletedWithError' | 'Failed';

export type QueryResult_SyncJobItem = {
    Items?: Array<SyncJobItem>;
    TotalRecordCount?: number;
};

export type SyncJobItem = {
    Id?: number;
    JobId?: number;
    ItemId?: number;
    ItemName?: string;
    MediaSourceId?: string;
    MediaSource?: MediaSourceInfo;
    TargetId?: string;
    InternalTargetId?: number;
    OutputPath?: string;
    Status?: SyncJobItemStatus;
    Progress?: (number) | null;
    DateCreated?: string;
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
    TemporaryPath?: string;
    AdditionalFiles?: Array<ItemFileInfo>;
};

export type ItemFileInfo = {
    Type?: ItemFileType;
    Name?: string;
    Path?: string;
    ImageType?: ImageType;
    Index?: number;
};

export type ItemFileType = 'Media' | 'Image' | 'Subtitles';

export type SyncJobRequest = {
    TargetId?: string;
    ItemIds?: Array<(string)>;
    Category?: SyncCategory;
    ParentId?: string;
    Quality?: string;
    Profile?: string;
    Container?: string;
    VideoCodec?: string;
    AudioCodec?: string;
    Name?: string;
    UserId?: string;
    UnwatchedOnly?: boolean;
    SyncNewContent?: boolean;
    ItemLimit?: (number) | null;
    Bitrate?: (number) | null;
    Downloaded?: boolean;
};

export type SyncJobCreationResult = {
    Job?: SyncJob;
    JobItems?: Array<SyncJobItem>;
};

export type SyncDialogOptions = {
    Targets?: Array<SyncTarget>;
    Options?: Array<SyncJobOption>;
    QualityOptions?: Array<SyncQualityOption>;
    ProfileOptions?: Array<SyncProfileOption>;
};

export type SyncJobOption = 'Name' | 'Quality' | 'UnwatchedOnly' | 'SyncNewContent' | 'ItemLimit' | 'Profile';

export type SyncQualityOption = {
    Name?: string;
    Description?: string;
    Id?: string;
    IsDefault?: boolean;
    IsOriginalQuality?: boolean;
};

export type SyncProfileOption = {
    Name?: string;
    Description?: string;
    Id?: string;
    IsDefault?: boolean;
    EnableQualityOptions?: boolean;
};

export type UserAction = {
    Id?: string;
    ServerId?: string;
    UserId?: string;
    ItemId?: string;
    Type?: UserActionType;
    Date?: string;
    PositionTicks?: (number) | null;
    Played?: (boolean) | null;
    IsFavorite?: (boolean) | null;
};

export type UserActionType = 'PlayedItem' | 'MarkPlayed' | 'MarkFavorite';

export type SyncDataRequest = {
    LocalItemIds?: Array<(string)>;
    InternalTargetIds?: Array<(number)>;
};

export type SyncDataResponse = {
    ItemIdsToRemove?: Array<(string)>;
};

export type ServerConfiguration = {
    EnableUPnP?: boolean;
    PublicPort?: number;
    PublicHttpsPort?: number;
    HttpServerPortNumber?: number;
    HttpsPortNumber?: number;
    EnableHttps?: boolean;
    CertificatePath?: string;
    CertificatePassword?: string;
    IsPortAuthorized?: boolean;
    AutoRunWebApp?: boolean;
    EnableRemoteAccess?: boolean;
    LogAllQueryTimes?: boolean;
    EnableCaseSensitiveItemIds?: boolean;
    MetadataPath?: string;
    MetadataNetworkPath?: string;
    PreferredMetadataLanguage?: string;
    MetadataCountryCode?: string;
    SortRemoveWords?: Array<(string)>;
    LibraryMonitorDelaySeconds?: number;
    EnableDashboardResponseCaching?: boolean;
    DashboardSourcePath?: string;
    ImageSavingConvention?: ImageSavingConvention;
    EnableAutomaticRestart?: boolean;
    ServerName?: string;
    PreferredDetectedRemoteAddressFamily?: Net_Sockets_AddressFamily;
    WanDdns?: string;
    UICulture?: string;
    RemoteClientBitrateLimit?: number;
    LocalNetworkSubnets?: Array<(string)>;
    LocalNetworkAddresses?: Array<(string)>;
    EnableExternalContentInSuggestions?: boolean;
    RequireHttps?: boolean;
    IsBehindProxy?: boolean;
    RemoteIPFilter?: Array<(string)>;
    IsRemoteIPFilterBlacklist?: boolean;
    ImageExtractionTimeoutMs?: number;
    PathSubstitutions?: Array<PathSubstitution>;
    UninstalledPlugins?: Array<(string)>;
    CollapseVideoFolders?: boolean;
    EnableOriginalTrackTitles?: boolean;
    VacuumDatabaseOnStartup?: boolean;
    SimultaneousStreamLimit?: number;
    DatabaseCacheSizeMB?: number;
    EnableSqLiteMmio?: boolean;
    PlaylistsUpgradedToM3U?: boolean;
    ImageExtractorUpgraded1?: boolean;
    EnablePeopleLetterSubFolders?: boolean;
    OptimizeDatabaseOnShutdown?: boolean;
    DatabaseAnalysisLimit?: number;
    DisableAsyncIO?: boolean;
    MigratedToUserItemShares8?: boolean;
    MigratedLibraryOptionsToDb?: boolean;
    AllowLegacyLocalNetworkPassword?: boolean;
    EnableSavedMetadataForPeople?: boolean;
    TvChannelsRefreshed?: boolean;
    ProxyHeaderMode?: ProxyHeaderMode;
    EnableDebugLevelLogging?: boolean;
    RevertDebugLogging?: string;
    EnableAutoUpdate?: boolean;
    LogFileRetentionDays?: number;
    RunAtStartup?: boolean;
    IsStartupWizardCompleted?: boolean;
    CachePath?: string;
};

export type ImageSavingConvention = 'Legacy' | 'Compatible';

export type Net_Sockets_AddressFamily = 'Unspecified' | 'Unix' | 'InterNetwork' | 'ImpLink' | 'Pup' | 'Chaos' | 'NS' | 'Ipx' | 'Osi' | 'Iso' | 'Ecma' | 'DataKit' | 'Ccitt' | 'Sna' | 'DecNet' | 'DataLink' | 'Lat' | 'HyperChannel' | 'AppleTalk' | 'NetBios' | 'VoiceView' | 'FireFox' | 'Banyan' | 'Atm' | 'InterNetworkV6' | 'Cluster' | 'Ieee12844' | 'Irda' | 'NetworkDesigners' | 'Max' | 'Packet' | 'ControllerAreaNetwork' | 'Unknown';

export type PathSubstitution = {
    From?: string;
    To?: string;
};

export type ProxyHeaderMode = 'None' | 'LanAddressesOnly' | 'RemoteAddressesOnly' | 'AllAddresses';

export type WakeOnLanInfo = {
    MacAddress?: string;
    BroadcastAddress?: string;
    Port?: number;
};

export type SystemInfo = {
    SystemUpdateLevel?: PackageVersionClass;
    OperatingSystemDisplayName?: string;
    PackageName?: string;
    HasPendingRestart?: boolean;
    IsShuttingDown?: boolean;
    HasImageEnhancers?: boolean;
    OperatingSystem?: string;
    SupportsLibraryMonitor?: boolean;
    SupportsLocalPortConfiguration?: boolean;
    SupportsWakeServer?: boolean;
    WebSocketPortNumber?: number;
    CompletedInstallations?: Array<InstallationInfo>;
    CanSelfRestart?: boolean;
    CanSelfUpdate?: boolean;
    CanLaunchWebBrowser?: boolean;
    ProgramDataPath?: string;
    ItemsByNamePath?: string;
    CachePath?: string;
    LogPath?: string;
    InternalMetadataPath?: string;
    TranscodingTempPath?: string;
    HttpServerPortNumber?: number;
    SupportsHttps?: boolean;
    HttpsPortNumber?: number;
    HasUpdateAvailable?: boolean;
    SupportsAutoRunAtStartup?: boolean;
    HardwareAccelerationRequiresPremiere?: boolean;
    WakeOnLanInfo?: Array<WakeOnLanInfo>;
    LocalAddress?: string;
    LocalAddresses?: Array<(string)>;
    WanAddress?: string;
    RemoteAddresses?: Array<(string)>;
    ServerName?: string;
    Version?: string;
    Id?: string;
};

export type InstallationInfo = {
    Id?: string;
    Name?: string;
    AssemblyGuid?: string;
    Version?: string;
    UpdateClass?: PackageVersionClass;
    PercentComplete?: (number) | null;
};

export type Net_EndPointInfo = {
    IsLocal?: boolean;
    IsInNetwork?: boolean;
};

export type UIViewInfo = {
    ViewId?: string;
    PageId?: string;
    Caption?: string;
    SubCaption?: string;
    PluginId?: string;
    ViewType?: Enums_UIViewType;
    ShowDialogFullScreen?: boolean;
    IsInSequence?: boolean;
    RedirectViewUrl?: string;
    EditObjectContainer?: GenericEdit_IEditObjectContainer;
    Commands?: Array<UICommand>;
    TabPageInfos?: Array<UITabPageInfo>;
    IsPageChangeInfo?: boolean;
};

export type Enums_UIViewType = 'RegularPage' | 'Dialog' | 'Wizard';

export type GenericEdit_IEditObjectContainer = {
    Object?: {
        [key: string]: unknown;
    };
    DefaultObject?: {
        [key: string]: unknown;
    };
    TypeName?: string;
};

export type UICommand = {
    CommandType?: Enums_UICommandType;
    CommandId?: string;
    IsVisible?: boolean;
    IsEnabled?: boolean;
    Caption?: string;
    SetFocus?: boolean;
    ConfirmationPrompt?: string;
};

export type Enums_UICommandType = 'Custom' | 'WizardCancel' | 'WizardBack' | 'WizardNext' | 'WizardFinish' | 'DialogCancel' | 'DialogOk' | 'PageSave' | 'PageBack' | 'WizardButton1' | 'WizardButton2' | 'WizardButton3';

export type UITabPageInfo = {
    PageId?: string;
    DisplayName?: string;
    PluginId?: string;
    Href?: string;
    NavKey?: string;
    Index?: number;
};

export type RunUICommand = {
    PageId?: string;
    CommandId?: string;
    Data?: string;
    ItemId?: string;
    ClientLocale?: string;
};

export type UserDto = {
    Name?: string;
    ServerId?: string;
    ServerName?: string;
    Prefix?: string;
    ConnectUserName?: string;
    DateCreated?: (string) | null;
    ConnectLinkType?: Connect_UserLinkType;
    Id?: string;
    PrimaryImageTag?: string;
    HasPassword?: boolean;
    HasConfiguredPassword?: boolean;
    EnableAutoLogin?: (boolean) | null;
    LastLoginDate?: (string) | null;
    LastActivityDate?: (string) | null;
    Configuration?: UserConfiguration;
    Policy?: UserPolicy;
    PrimaryImageAspectRatio?: (number) | null;
    /**
     * @deprecated
     */
    HasConfiguredEasyPassword?: boolean;
    UserItemShareLevel?: UserItemShareLevel;
};

export type Connect_UserLinkType = 'LinkedUser' | 'Guest';

export type UserConfiguration = {
    AudioLanguagePreference?: string;
    PlayDefaultAudioTrack?: boolean;
    SubtitleLanguagePreference?: string;
    ProfilePin?: string;
    DisplayMissingEpisodes?: boolean;
    SubtitleMode?: SubtitlePlaybackMode;
    OrderedViews?: Array<(string)>;
    LatestItemsExcludes?: Array<(string)>;
    MyMediaExcludes?: Array<(string)>;
    HidePlayedInLatest?: boolean;
    HidePlayedInMoreLikeThis?: boolean;
    HidePlayedInSuggestions?: boolean;
    RememberAudioSelections?: boolean;
    RememberSubtitleSelections?: boolean;
    EnableNextEpisodeAutoPlay?: boolean;
    ResumeRewindSeconds?: number;
    IntroSkipMode?: SegmentSkipMode;
    /**
     * @deprecated
     */
    EnableLocalPassword?: boolean;
};

export type SubtitlePlaybackMode = 'Default' | 'Always' | 'OnlyForced' | 'None' | 'Smart' | 'HearingImpaired';

export type SegmentSkipMode = 'ShowButton' | 'AutoSkip' | 'None';

export type UserPolicy = {
    IsAdministrator?: boolean;
    IsHidden?: boolean;
    IsHiddenRemotely?: boolean;
    IsHiddenFromUnusedDevices?: boolean;
    IsDisabled?: boolean;
    LockedOutDate?: number;
    MaxParentalRating?: (number) | null;
    AllowTagOrRating?: boolean;
    BlockedTags?: Array<(string)>;
    IsTagBlockingModeInclusive?: boolean;
    IncludeTags?: Array<(string)>;
    EnableUserPreferenceAccess?: boolean;
    AccessSchedules?: Array<AccessSchedule>;
    BlockUnratedItems?: Array<UnratedItem>;
    EnableRemoteControlOfOtherUsers?: boolean;
    EnableSharedDeviceControl?: boolean;
    EnableRemoteAccess?: boolean;
    EnableLiveTvManagement?: boolean;
    EnableLiveTvAccess?: boolean;
    EnableMediaPlayback?: boolean;
    EnableAudioPlaybackTranscoding?: boolean;
    EnableVideoPlaybackTranscoding?: boolean;
    EnablePlaybackRemuxing?: boolean;
    EnableContentDeletion?: boolean;
    RestrictedFeatures?: Array<(string)>;
    EnableContentDeletionFromFolders?: Array<(string)>;
    EnableContentDownloading?: boolean;
    EnableSubtitleDownloading?: boolean;
    EnableSubtitleManagement?: boolean;
    EnableSyncTranscoding?: boolean;
    EnableMediaConversion?: boolean;
    EnabledChannels?: Array<(string)>;
    EnableAllChannels?: boolean;
    EnabledFolders?: Array<(string)>;
    EnableAllFolders?: boolean;
    InvalidLoginAttemptCount?: number;
    EnablePublicSharing?: boolean;
    BlockedMediaFolders?: Array<(string)>;
    RemoteClientBitrateLimit?: number;
    AuthenticationProviderId?: string;
    ExcludedSubFolders?: Array<(string)>;
    SimultaneousStreamLimit?: number;
    EnabledDevices?: Array<(string)>;
    EnableAllDevices?: boolean;
    AllowCameraUpload?: boolean;
    AllowSharingPersonalItems?: boolean;
};

export type AccessSchedule = {
    DayOfWeek?: DynamicDayOfWeek;
    StartHour?: number;
    EndHour?: number;
};

export type DynamicDayOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday' | 'Everyday' | 'Weekday' | 'Weekend';

export type UnratedItem = 'Movie' | 'Trailer' | 'Series' | 'Music' | 'Game' | 'Book' | 'LiveTvChannel' | 'LiveTvProgram' | 'ChannelContent' | 'Other';

export type QueryResult_UserDto = {
    Items?: Array<UserDto>;
    TotalRecordCount?: number;
};

export type AuthenticateUserByName = {
    Username?: string;
    Pw?: string;
};

export type Authentication_AuthenticationResult = {
    User?: UserDto;
    SessionInfo?: Session_SessionInfo;
    AccessToken?: string;
    ServerId?: string;
};

export type CreateUserByName = {
    Name?: string;
    CopyFromUserId?: string;
    UserCopyOptions?: Array<Library_UserCopyOptions>;
};

export type Library_UserCopyOptions = 'UserPolicy' | 'UserConfiguration';

export type ForgotPassword = {
    EnteredUsername?: string;
};

export type ForgotPasswordResult = {
    Action?: ForgotPasswordAction;
    PinFile?: string;
    PinExpirationDate?: (string) | null;
};

export type ForgotPasswordAction = 'ContactAdmin' | 'PinCode';

export type playback_reporting_Api_CustomQuery = {
    CustomQueryString?: string;
    ReplaceUserId?: boolean;
};

export type Api_ConfigurationPageInfo = {
    Name?: string;
    EnableInMainMenu?: boolean;
    EnableInUserMenu?: boolean;
    FeatureId?: string;
    MenuSection?: string;
    MenuIcon?: string;
    DisplayName?: string;
    ConfigurationPageType?: Plugins_ConfigurationPageType;
    PluginId?: string;
    Href?: string;
    NavMenuId?: string;
    Plugin?: Common_Plugins_IPlugin;
    Translations?: Array<(string)>;
};

export type Plugins_ConfigurationPageType = 'PluginConfiguration' | 'None';

export type Common_Plugins_IPlugin = {
    Name?: string;
    Description?: string;
    Id?: string;
    Version?: Version;
    AssemblyFilePath?: string;
    DataFolderPath?: string;
};

export type Version = {
    Major?: number;
    Minor?: number;
    Build?: number;
    Revision?: number;
    MajorRevision?: number;
    MinorRevision?: number;
};

export type VideoCodecBase = {
    CodecDeviceInfo?: Common_Interfaces_ICodecDeviceInfo;
    CodecKind?: CodecKinds;
    MediaTypeName?: string;
    VideoMediaType?: VideoMediaTypes;
    MinWidth?: (number) | null;
    MaxWidth?: (number) | null;
    MinHeight?: (number) | null;
    MaxHeight?: (number) | null;
    WidthAlignment?: (number) | null;
    HeightAlignment?: (number) | null;
    MaxBitRate?: BitRate;
    SupportedColorFormats?: Array<ColorFormats>;
    SupportedColorFormatStrings?: Array<(string)>;
    ProfileAndLevelInformation?: Array<ProfileLevelInformation>;
    Id?: string;
    Direction?: CodecDirections;
    Name?: string;
    Description?: string;
    FrameworkCodec?: string;
    IsHardwareCodec?: boolean;
    SecondaryFramework?: SecondaryFrameworks;
    SecondaryFrameworkCodec?: string;
    MaxInstanceCount?: (number) | null;
    IsEnabledByDefault?: boolean;
    DefaultPriority?: number;
};

export type Common_Interfaces_ICodecDeviceInfo = {
    Capabilities?: Common_Interfaces_ICodecDeviceCapabilities;
    Adapter?: number;
    Name?: string;
    Desription?: string;
    Driver?: string;
    DriverVersion?: Version;
    ApiVersion?: Version;
    VendorId?: number;
    DeviceId?: number;
    DeviceIdentifier?: string;
    HardwareContextFramework?: SecondaryFrameworks;
    DevPath?: string;
    DrmNode?: string;
    VendorName?: string;
    DeviceName?: string;
};

export type Common_Interfaces_ICodecDeviceCapabilities = {
    SupportsHwUpload?: boolean;
    SupportsHwDownload?: boolean;
    SupportsStandaloneDeviceInit?: boolean;
    Supports10BitProcessing?: boolean;
    SupportsNativeToneMapping?: boolean;
};

export type SecondaryFrameworks = 'Unknown' | 'None' | 'AmdAmf' | 'MediaCodec' | 'NvEncDec' | 'OpenMax' | 'QuickSync' | 'VaApi' | 'V4L2' | 'DxVa' | 'D3d11va' | 'VideoToolbox' | 'Mmal';

export type CodecKinds = 'Audio' | 'Video' | 'SubTitles';

export type VideoMediaTypes = 'Unknown' | 'copy' | 'flv1' | 'h263' | 'h263p' | 'h264' | 'hevc' | 'mjpeg' | 'mpeg1video' | 'mpeg2video' | 'mpeg4' | 'msvideo1' | 'theora' | 'vc1image' | 'vc1' | 'vp8' | 'vp9' | 'wmv1' | 'wmv2' | 'wmv3' | '_012v' | '_4xm' | '_8bps' | 'a64_multi' | 'a64_multi5' | 'aasc' | 'aic' | 'alias_pix' | 'amv' | 'anm' | 'ansi' | 'apng' | 'asv1' | 'asv2' | 'aura' | 'aura2' | 'av1' | 'avrn' | 'avrp' | 'avs' | 'avui' | 'ayuv' | 'bethsoftvid' | 'bfi' | 'binkvideo' | 'bintext' | 'bitpacked' | 'bmp' | 'bmv_video' | 'brender_pix' | 'c93' | 'cavs' | 'cdgraphics' | 'cdxl' | 'cfhd' | 'cinepak' | 'clearvideo' | 'cljr' | 'cllc' | 'cmv' | 'cpia' | 'cscd' | 'cyuv' | 'daala' | 'dds' | 'dfa' | 'dirac' | 'dnxhd' | 'dpx' | 'dsicinvideo' | 'dvvideo' | 'dxa' | 'dxtory' | 'dxv' | 'escape124' | 'escape130' | 'exr' | 'ffv1' | 'ffvhuff' | 'fic' | 'fits' | 'flashsv' | 'flashsv2' | 'flic' | 'fmvc' | 'fraps' | 'frwu' | 'g2m' | 'gdv' | 'gif' | 'h261' | 'h263i' | 'hap' | 'hnm4video' | 'hq_hqa' | 'hqx' | 'huffyuv' | 'idcin' | 'idf' | 'iff_ilbm' | 'indeo2' | 'indeo3' | 'indeo4' | 'indeo5' | 'interplayvideo' | 'jpeg2000' | 'jpegls' | 'jv' | 'kgv1' | 'kmvc' | 'lagarith' | 'ljpeg' | 'loco' | 'm101' | 'mad' | 'magicyuv' | 'mdec' | 'mimic' | 'mjpegb' | 'mmvideo' | 'motionpixels' | 'msa1' | 'mscc' | 'msmpeg4v1' | 'msmpeg4v2' | 'msmpeg4v3' | 'msrle' | 'mss1' | 'mss2' | 'mszh' | 'mts2' | 'mvc1' | 'mvc2' | 'mxpeg' | 'nuv' | 'paf_video' | 'pam' | 'pbm' | 'pcx' | 'pgm' | 'pgmyuv' | 'pictor' | 'pixlet' | 'png' | 'ppm' | 'prores' | 'psd' | 'ptx' | 'qdraw' | 'qpeg' | 'qtrle' | 'r10k' | 'r210' | 'rawvideo' | 'rl2' | 'roq' | 'rpza' | 'rscc' | 'rv10' | 'rv20' | 'rv30' | 'rv40' | 'sanm' | 'scpr' | 'screenpresso' | 'sgi' | 'sgirle' | 'sheervideo' | 'smackvideo' | 'smc' | 'smvjpeg' | 'snow' | 'sp5x' | 'speedhq' | 'srgc' | 'sunrast' | 'svg' | 'svq1' | 'svq3' | 'targa' | 'targa_y216' | 'tdsc' | 'tgq' | 'tgv' | 'thp' | 'tiertexseqvideo' | 'tiff' | 'tmv' | 'tqi' | 'truemotion1' | 'truemotion2' | 'truemotion2rt' | 'tscc' | 'tscc2' | 'txd' | 'ulti' | 'utvideo' | 'v210' | 'v210x' | 'v308' | 'v408' | 'v410' | 'vb' | 'vble' | 'vcr1' | 'vixl' | 'vmdvideo' | 'vmnc' | 'vp3' | 'vp5' | 'vp6' | 'vp6a' | 'vp6f' | 'vp7' | 'webp' | 'wmv3image' | 'wnv1' | 'wrapped_avframe' | 'ws_vqa' | 'xan_wc3' | 'xan_wc4' | 'xbin' | 'xbm' | 'xface' | 'xpm' | 'xwd' | 'y41p' | 'ylc' | 'yop' | 'yuv4' | 'zerocodec' | 'zlib' | 'zmbv';

export type BitRate = {
    bps?: number;
    kbps?: number;
    Mbps?: number;
};

export type ColorFormats = 'Unknown' | 'yuv420p' | 'yuyv422' | 'rgb24' | 'bgr24' | 'yuv422p' | 'yuv444p' | 'yuv410p' | 'yuv411p' | 'gray' | 'monow' | 'monob' | 'pal8' | 'yuvj420p' | 'yuvj422p' | 'yuvj444p' | 'uyvy422' | 'uyyvyy411' | 'bgr8' | 'bgr4' | 'bgr4_byte' | 'rgb8' | 'rgb4' | 'rgb4_byte' | 'nv12' | 'nv21' | 'argb' | 'rgba' | 'abgr' | 'bgra' | 'gray16' | 'yuv440p' | 'yuvj440p' | 'yuva420p' | 'rgb48' | 'rgb565' | 'rgb555' | 'bgr565' | 'bgr555' | 'vaapi_moco' | 'vaapi_idct' | 'vaapi_vld' | 'yuv420p16' | 'yuv422p16' | 'yuv444p16' | 'dxva2_vld' | 'rgb444' | 'bgr444' | 'ya8' | 'bgr48' | 'yuv420p9' | 'yuv420p10' | 'yuv422p10' | 'yuv444p9' | 'yuv444p10' | 'yuv422p9' | 'gbrp' | 'gbrp9' | 'gbrp10' | 'gbrp16' | 'yuva422p' | 'yuva444p' | 'yuva420p9' | 'yuva422p9' | 'yuva444p9' | 'yuva420p10' | 'yuva422p10' | 'yuva444p10' | 'yuva420p16' | 'yuva422p16' | 'yuva444p16' | 'vdpau' | 'xyz12' | 'nv16' | 'nv20' | 'rgba64' | 'bgra64' | 'yvyu422' | 'ya16' | 'gbrap' | 'gbrap16' | 'qsv' | 'mmal' | 'd3d11va_vld' | 'cuda' | '_0rgb' | 'rgb0' | '_0bgr' | 'bgr0' | 'yuv420p12' | 'yuv420p14' | 'yuv422p12' | 'yuv422p14' | 'yuv444p12' | 'yuv444p14' | 'gbrp12' | 'gbrp14' | 'yuvj411p' | 'bayer_bggr8' | 'bayer_rggb8' | 'bayer_gbrg8' | 'bayer_grbg8' | 'bayer_bggr16' | 'bayer_rggb16' | 'bayer_gbrg16' | 'bayer_grbg16' | 'xvmc' | 'yuv440p10' | 'yuv440p12' | 'ayuv64' | 'videotoolbox_vld' | 'p010' | 'gbrap12' | 'gbrap10' | 'mediacodec' | 'gray12' | 'gray10' | 'gray14' | 'p016' | 'd3d11' | 'gray9' | 'gbrpf32' | 'gbrapf32' | 'drm_prime' | 'opencl' | 'grayf32' | 'yuva422p12' | 'yuva444p12' | 'nv24' | 'nv42';

export type ProfileLevelInformation = {
    Profile?: ProfileInformation;
    Level?: LevelInformation;
};

export type ProfileInformation = {
    ShortName?: string;
    Description?: string;
    Details?: string;
    Id?: string;
    BitDepths?: Array<(number)>;
};

export type LevelInformation = {
    ShortName?: string;
    Description?: string;
    Ordinal?: (number) | null;
    MaxBitRate?: BitRate;
    MaxBitRateDisplay?: string;
    Id?: string;
    ResolutionRates?: Array<ResolutionWithRate>;
    ResolutionRateStrings?: Array<(string)>;
    ResolutionRatesDisplay?: string;
};

export type ResolutionWithRate = {
    Width?: number;
    Height?: number;
    FrameRate?: number;
    Resolution?: Resolution;
};

export type Resolution = {
    Width?: number;
    Height?: number;
};

export type CodecDirections = 'Encoder' | 'Decoder';

export type CodecConfiguration = {
    IsEnabled?: boolean;
    Priority?: number;
    CodecId?: string;
};

export type ExternalIdInfo = {
    Name?: string;
    Key?: string;
    Website?: string;
    UrlFormatString?: string;
    IsSupportedAsIdentifier?: boolean;
};

export type RemoteSearchQuery_TrailerInfo = {
    SearchInfo?: TrailerInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type TrailerInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchResult = {
    Name?: string;
    ProviderIds?: ProviderIdDictionary;
    ProductionYear?: (number) | null;
    IndexNumber?: (number) | null;
    IndexNumberEnd?: (number) | null;
    ParentIndexNumber?: (number) | null;
    SortIndexNumber?: (number) | null;
    SortParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    ImageUrl?: string;
    SearchProviderName?: string;
    GameSystem?: string;
    Overview?: string;
    DisambiguationComment?: string;
    AlbumArtist?: RemoteSearchResult;
    Artists?: Array<RemoteSearchResult>;
};

export type RemoteSearchQuery_BookInfo = {
    SearchInfo?: BookInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type BookInfo = {
    SeriesName?: string;
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_MovieInfo = {
    SearchInfo?: MovieInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type MovieInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_SeriesInfo = {
    SearchInfo?: SeriesInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type SeriesInfo = {
    EpisodeAirDate?: (string) | null;
    DisplayOrder?: SeriesDisplayOrder;
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type SeriesDisplayOrder = 'Aired' | 'Dvd' | 'Absolute';

export type RemoteSearchQuery_GameInfo = {
    SearchInfo?: GameInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type GameInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_ItemLookupInfo = {
    SearchInfo?: ItemLookupInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type ItemLookupInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_MusicVideoInfo = {
    SearchInfo?: MusicVideoInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type MusicVideoInfo = {
    Artists?: Array<(string)>;
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_PersonLookupInfo = {
    SearchInfo?: PersonLookupInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type PersonLookupInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_AlbumInfo = {
    SearchInfo?: AlbumInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type AlbumInfo = {
    AlbumArtists?: Array<(string)>;
    SongInfos?: Array<SongInfo>;
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type SongInfo = {
    AlbumArtists?: Array<(string)>;
    Album?: string;
    Artists?: Array<(string)>;
    Composers?: Array<(string)>;
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuery_ArtistInfo = {
    SearchInfo?: ArtistInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<(string)>;
    IncludeDisabledProviders?: boolean;
};

export type ArtistInfo = {
    Name?: string;
    MetadataLanguage?: string;
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<Globalization_CultureDto>;
    ProviderIds?: ProviderIdDictionary;
    Year?: (number) | null;
    IndexNumber?: (number) | null;
    ParentIndexNumber?: (number) | null;
    PremiereDate?: (string) | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type MetadataRefreshMode = 'ValidationOnly' | 'Default' | 'FullRefresh';

export type MetadataEditorInfo = {
    ParentalRatingOptions?: Array<ParentalRating>;
    Countries?: Array<Globalization_CountryInfo>;
    Cultures?: Array<Globalization_CultureDto>;
    ExternalIdInfos?: Array<ExternalIdInfo>;
};

export type UserLibrary_LeaveSharedItems = {
    ItemIds?: Array<(string)>;
    UserId?: string;
};

export type Library_DeleteInfo = {
    Paths?: Array<(string)>;
};

export type AllThemeMediaResult = {
    ThemeVideosResult?: ThemeMediaResult;
    ThemeSongsResult?: ThemeMediaResult;
    SoundtrackSongsResult?: ThemeMediaResult;
};

export type ThemeMediaResult = {
    OwnerId?: number;
    Items?: Array<BaseItemDto>;
    TotalRecordCount?: number;
};

export type ImageInfo = {
    ImageType?: ImageType;
    ImageIndex?: (number) | null;
    Path?: string;
    Filename?: string;
    Height?: (number) | null;
    Width?: (number) | null;
    Size?: number;
};

export type RemoteImageResult = {
    Images?: Array<RemoteImageInfo>;
    TotalRecordCount?: number;
    Providers?: Array<(string)>;
};

export type RemoteImageInfo = {
    ProviderName?: string;
    Url?: string;
    ThumbnailUrl?: string;
    Height?: (number) | null;
    Width?: (number) | null;
    CommunityRating?: (number) | null;
    VoteCount?: (number) | null;
    Language?: string;
    DisplayLanguage?: string;
    Type?: ImageType;
    RatingType?: RatingType;
};

export type RatingType = 'Score' | 'Likes';

export type RokuMetadata_Api_ThumbnailSetInfo = {
    AspectRatio?: (number) | null;
    Thumbnails?: Array<RokuMetadata_Api_ThumbnailInfo>;
};

export type RokuMetadata_Api_ThumbnailInfo = {
    PositionTicks?: number;
    ImageTag?: string;
};

export type PlaybackInfoResponse = {
    MediaSources?: Array<MediaSourceInfo>;
    PlaySessionId?: string;
    ErrorCode?: PlaybackErrorCode;
};

export type PlaybackErrorCode = 'NotAllowed' | 'NoCompatibleStream' | 'RateLimitExceeded';

export type PlaybackInfoRequest = {
    Id?: string;
    UserId?: string;
    MaxStreamingBitrate?: (number) | null;
    StartTimeTicks?: (number) | null;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    MaxAudioChannels?: (number) | null;
    MediaSourceId?: string;
    LiveStreamId?: string;
    DeviceProfile?: DeviceProfile;
    EnableDirectPlay?: boolean;
    EnableDirectStream?: boolean;
    EnableTranscoding?: boolean;
    AllowInterlacedVideoStreamCopy?: boolean;
    AllowVideoStreamCopy?: boolean;
    AllowAudioStreamCopy?: boolean;
    IsPlayback?: boolean;
    AutoOpenLiveStream?: boolean;
    DirectPlayProtocols?: Array<MediaProtocol>;
    CurrentPlaySessionId?: string;
};

export type Library_PostUpdatedMedia = {
    Updates?: Array<Library_MediaUpdateInfo>;
};

export type Library_MediaUpdateInfo = {
    Path?: string;
    UpdateType?: string;
};

export type QueryResult_VirtualFolderInfo = {
    Items?: Array<VirtualFolderInfo>;
    TotalRecordCount?: number;
};

export type VirtualFolderInfo = {
    Name?: string;
    Locations?: Array<(string)>;
    CollectionType?: string;
    LibraryOptions?: LibraryOptions;
    ItemId?: string;
    Id?: string;
    Guid?: string;
    PrimaryImageItemId?: string;
    RefreshProgress?: (number) | null;
    RefreshStatus?: string;
};

export type Library_UpdateLibraryOptions = {
    Id?: string;
    LibraryOptions?: LibraryOptions;
};

export type Library_RenameVirtualFolder = {
    Id?: string;
    NewName?: string;
};

export type Library_RemoveVirtualFolder = {
    Id?: string;
    RefreshLibrary?: boolean;
};

export type Library_AddMediaPath = {
    Id?: string;
    Path?: string;
    PathInfo?: MediaPathInfo;
    RefreshLibrary?: boolean;
};

export type QueryResult_ChannelManagementInfo = {
    Items?: Array<ChannelManagementInfo>;
    TotalRecordCount?: number;
};

export type ChannelManagementInfo = {
    Id?: string;
    Name?: string;
};

export type Api_TagItem = {
    Name?: string;
    Id?: string;
};

export type Api_ListingProviderTypeInfo = {
    Name?: string;
    Id?: string;
    SetupUrl?: string;
};

export type UserNotificationInfo = {
    NotifierKey?: string;
    SetupModuleUrl?: string;
    ServiceName?: string;
    PluginId?: string;
    FriendlyName?: string;
    Id?: string;
    Enabled?: boolean;
    UserIds?: Array<(string)>;
    DeviceIds?: Array<(string)>;
    LibraryIds?: Array<(string)>;
    EventIds?: Array<(string)>;
    UserId?: string;
    IsSelfNotification?: boolean;
    GroupItems?: boolean;
    Options?: {
        [key: string]: (string);
    };
};

export type Playlists_AddToPlaylistResult = {
    Id?: string;
    ItemAddedCount?: number;
};

export type PlayCommand = 'PlayNow' | 'PlayNext' | 'PlayLast' | 'PlayInstantMix' | 'PlayShuffle';

export type PlayRequest = {
    ControllingUserId?: string;
    SubtitleStreamIndex?: (number) | null;
    AudioStreamIndex?: (number) | null;
    MediaSourceId?: string;
    StartIndex?: (number) | null;
};

export type GeneralCommand = {
    Name?: string;
    ControllingUserId?: string;
    Arguments?: {
        [key: string]: (string);
    };
};

export type ClientCapabilities = {
    PlayableMediaTypes?: Array<(string)>;
    SupportedCommands?: Array<(string)>;
    SupportsMediaControl?: boolean;
    PushToken?: string;
    PushTokenType?: string;
    SupportsSync?: boolean;
    DeviceProfile?: DeviceProfile;
    IconUrl?: string;
    AppId?: string;
};

export type PlaybackProgressInfo = {
    CanSeek?: boolean;
    Item?: BaseItemDto;
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    ItemId?: string;
    SessionId?: string;
    MediaSourceId?: string;
    AudioStreamIndex?: (number) | null;
    SubtitleStreamIndex?: (number) | null;
    IsPaused?: boolean;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    IsMuted?: boolean;
    PositionTicks?: (number) | null;
    RunTimeTicks?: (number) | null;
    PlaybackStartTimeTicks?: (number) | null;
    VolumeLevel?: (number) | null;
    Brightness?: (number) | null;
    AspectRatio?: string;
    EventName?: ProgressEvent;
    PlayMethod?: PlayMethod;
    LiveStreamId?: string;
    PlaySessionId?: string;
    RepeatMode?: RepeatMode;
    Shuffle?: boolean;
    SubtitleOffset?: number;
    PlaybackRate?: number;
    PlaylistItemIds?: Array<(string)>;
};

export type PlaybackStopInfo = {
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    Item?: BaseItemDto;
    ItemId?: string;
    SessionId?: string;
    MediaSourceId?: string;
    PositionTicks?: (number) | null;
    LiveStreamId?: string;
    PlaySessionId?: string;
    Failed?: boolean;
    IsAutomated?: boolean;
    NextMediaType?: string;
};

export type SyncedItemProgress = {
    Progress?: (number) | null;
    Status?: SyncJobItemStatus;
};

export type SyncedItem = {
    ServerId?: string;
    SyncJobId?: number;
    SyncJobName?: string;
    SyncJobDateCreated?: string;
    SyncJobItemId?: number;
    OriginalFileName?: string;
    Item?: BaseItemDto;
    UserId?: string;
    AdditionalFiles?: Array<ItemFileInfo>;
};

export type QueryResult_LogFile = {
    Items?: Array<LogFile>;
    TotalRecordCount?: number;
};

export type LogFile = {
    DateCreated?: string;
    DateModified?: string;
    Size?: number;
    Name?: string;
};

export type PublicSystemInfo = {
    LocalAddress?: string;
    LocalAddresses?: Array<(string)>;
    WanAddress?: string;
    RemoteAddresses?: Array<(string)>;
    ServerName?: string;
    Version?: string;
    Id?: string;
};

export type QueryResult_ActivityLogEntry = {
    Items?: Array<ActivityLogEntry>;
    TotalRecordCount?: number;
};

export type ActivityLogEntry = {
    Id?: number;
    Name?: string;
    Overview?: string;
    ShortOverview?: string;
    Type?: string;
    ItemId?: string;
    Date?: string;
    UserId?: string;
    UserPrimaryImageTag?: string;
    Severity?: Logging_LogSeverity;
};

export type Logging_LogSeverity = 'Info' | 'Debug' | 'Warn' | 'Error' | 'Fatal';

export type AuthenticateUser = {
    Pw?: string;
};

export type UpdateUserPassword = {
    Id?: string;
    NewPw?: string;
    ResetPassword?: boolean;
};

export type ForgotPasswordPin = {
    Pin?: string;
};

export type PinRedeemResult = {
    Success?: boolean;
    UsersReset?: Array<(string)>;
};

export type UserLibrary_AddTags = {
    Tags?: Array<NameIdPair>;
};

export type UserLibrary_RemoveTags = {
    Tags?: Array<NameIdPair>;
};

export type ImageProviderInfo = {
    Name?: string;
    SupportedImages?: Array<ImageType>;
};

export type Library_UpdateMediaPath = {
    Id?: string;
    PathInfo?: MediaPathInfo;
};

export type Library_RemoveMediaPath = {
    Id?: string;
    Path?: string;
    RefreshLibrary?: boolean;
};

export type PlaystateCommand = 'Stop' | 'Pause' | 'Unpause' | 'NextTrack' | 'PreviousTrack' | 'Seek' | 'Rewind' | 'FastForward' | 'PlayPause' | 'SeekRelative';

export type PlaystateRequest = {
    Command?: PlaystateCommand;
    SeekPositionTicks?: (number) | null;
    ControllingUserId?: string;
};

export type QueryResult_String = {
    Items?: Array<(string)>;
    TotalRecordCount?: number;
};

export type Connect_UserLinkResult = {
    IsPending?: boolean;
    IsNewUserInvitation?: boolean;
    GuestDisplayName?: string;
};

export type RemoteSubtitleInfo = {
    /**
     * Use language instead to return the language specified by the subtitle provider
     * @deprecated
     */
    ThreeLetterISOLanguageName?: string;
    Id?: string;
    ProviderName?: string;
    Name?: string;
    Format?: string;
    Author?: string;
    Comment?: string;
    DateCreated?: (string) | null;
    CommunityRating?: (number) | null;
    DownloadCount?: (number) | null;
    IsHashMatch?: (boolean) | null;
    IsForced?: (boolean) | null;
    IsHearingImpaired?: (boolean) | null;
    Language?: string;
};

export type Subtitles_SubtitleDownloadResult = {
    NewIndex?: (number) | null;
};

export type Api_SetChannelDisabled = {
    Id?: string;
    ManagementId?: string;
    Disabled?: boolean;
};

export type Api_SetChannelSortIndex = {
    Id?: string;
    ManagementId?: string;
    NewIndex?: number;
};

export type Api_OnPlaybackProgress = {
    PlaylistIndex?: number;
    PlaylistLength?: number;
    Shuffle?: boolean;
    EventName?: ProgressEvent;
};

export type GetArtistsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsResponse = (QueryResult_BaseItemDto);

export type GetArtistsByNameData = {
    /**
     * The artist name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetArtistsByNameResponse = (BaseItemDto);

export type GetArtistsAlbumartistsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsAlbumartistsResponse = (QueryResult_BaseItemDto);

export type GetAudiocodecsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetAudiocodecsResponse = (QueryResult_UserLibrary_TagItem);

export type GetAudiolayoutsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetAudiolayoutsResponse = (QueryResult_UserLibrary_TagItem);

export type GetContainersData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetContainersResponse = (QueryResult_UserLibrary_TagItem);

export type GetExtendedvideotypesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetExtendedvideotypesResponse = (QueryResult_UserLibrary_TagItem);

export type GetItemtypesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemtypesResponse = (QueryResult_UserLibrary_TagItem);

export type GetStreamlanguagesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetStreamlanguagesResponse = (QueryResult_UserLibrary_TagItem);

export type GetSubtitlecodecsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetSubtitlecodecsResponse = (QueryResult_UserLibrary_TagItem);

export type GetTagsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetTagsResponse = (QueryResult_UserLibrary_TagItem);

export type GetVideocodecsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetVideocodecsResponse = (QueryResult_UserLibrary_TagItem);

export type GetYearsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetYearsResponse = (QueryResult_UserLibrary_TagItem);

export type GetArtistsPrefixesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetArtistsPrefixesResponse = (Array<NameValuePair>);

export type GetItemsPrefixesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsPrefixesResponse = (Array<NameValuePair>);

export type PostItemsByIdTagsAddData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * AddTags
     */
    requestBody: UserLibrary_AddTags;
};

export type PostItemsByIdTagsAddResponse = (unknown);

export type PostItemsByIdTagsDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * RemoveTags
     */
    requestBody: UserLibrary_RemoveTags;
};

export type PostItemsByIdTagsDeleteResponse = (unknown);

export type GetChannelsData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId?: string;
};

export type GetChannelsResponse = (QueryResult_BaseItemDto);

export type PostCollectionsData = {
    /**
     * Item Ids to add to the collection
     */
    ids?: string;
    /**
     * Whether or not to lock the new collection.
     */
    isLocked?: boolean;
    /**
     * The name of the new collection.
     */
    name?: string;
    /**
     * Optional - create the collection within a specific folder
     */
    parentId?: string;
};

export type PostCollectionsResponse = (Collections_CollectionCreationResult);

export type PostCollectionsByIdItemsData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
};

export type PostCollectionsByIdItemsResponse = (unknown);

export type DeleteCollectionsByIdItemsData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
};

export type DeleteCollectionsByIdItemsResponse = (unknown);

export type PostCollectionsByIdItemsDeleteData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
};

export type PostCollectionsByIdItemsDeleteResponse = (unknown);

export type GetDevicesData = {
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
};

export type GetDevicesResponse = (QueryResult_Devices_DeviceInfo);

export type DeleteDevicesData = {
    /**
     * Device Id
     */
    id: string;
};

export type DeleteDevicesResponse = (unknown);

export type PostDevicesOptionsData = {
    /**
     * Device Id
     */
    id: string;
    /**
     * DeviceOptions:
     */
    requestBody: Devices_DeviceOptions;
};

export type PostDevicesOptionsResponse = (unknown);

export type GetDevicesOptionsData = {
    /**
     * Device Id
     */
    id: string;
};

export type GetDevicesOptionsResponse = (Devices_DeviceOptions);

export type GetDevicesInfoData = {
    /**
     * Device Id
     */
    id: string;
};

export type GetDevicesInfoResponse = (Devices_DeviceInfo);

export type GetDevicesCamerauploadsResponse = (Devices_ContentUploadHistory);

export type PostDevicesCamerauploadsData = {
    /**
     * Album
     */
    album: string;
    /**
     * Id
     */
    id: string;
    /**
     * Name
     */
    name: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostDevicesCamerauploadsResponse = (unknown);

export type PostDevicesDeleteData = {
    /**
     * Device Id
     */
    id: string;
};

export type PostDevicesDeleteResponse = (unknown);

export type GetFeaturesResponse = (Array<FeatureInfo>);

export type GetGamegenresData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetGamegenresResponse = (QueryResult_BaseItemDto);

export type GetGamegenresByNameData = {
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetGamegenresByNameResponse = (BaseItemDto);

export type GetGenresData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetGenresResponse = (QueryResult_BaseItemDto);

export type GetGenresByNameData = {
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetGenresByNameResponse = (BaseItemDto);

export type GetItemsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetItemsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridItemsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetUsersByUseridItemsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridItemsResumeData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetUsersByUseridItemsResumeResponse = (QueryResult_BaseItemDto);

export type DeleteItemsData = {
    /**
     * Ids
     */
    ids: string;
};

export type DeleteItemsResponse = (unknown);

export type GetItemsCountsData = {
    /**
     * Optional. Get counts of favorite items
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional. Get counts from a specific user's library.
     */
    userId?: string;
};

export type GetItemsCountsResponse = (ItemCounts);

export type GetItemsIntrosResponse = (Array<Persistence_IntroDebugInfo>);

export type PostItemsDeleteData = {
    /**
     * Ids
     */
    ids: string;
};

export type PostItemsDeleteResponse = (unknown);

export type DeleteItemsByIdData = {
    /**
     * Item Id
     */
    id: string;
};

export type DeleteItemsByIdResponse = (unknown);

export type GetLibrariesAvailableoptionsResponse = (Library_LibraryOptionsResult);

export type GetLibrarySelectablemediafoldersResponse = (Array<Library_MediaFolder>);

export type GetLibraryMediafoldersData = {
    /**
     * Optional. Filter by folders that are marked hidden, or not.
     */
    isHidden?: (boolean) | null;
};

export type GetLibraryMediafoldersResponse = (QueryResult_BaseItemDto);

export type GetLibraryPhysicalpathsResponse = (Array<(string)>);

export type PostLibraryRefreshResponse = (unknown);

export type GetAlbumsByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetAlbumsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetArtistsByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetArtistsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetGamesByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetGamesByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdDeleteinfoData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdDeleteinfoResponse = (Library_DeleteInfo);

export type GetItemsByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdDownloadData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdDownloadResponse = (unknown);

export type GetItemsByIdFileData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdFileResponse = (unknown);

export type GetItemsByIdAncestorsData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdAncestorsResponse = (Array<BaseItemDto>);

export type GetItemsByIdCriticreviewsData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
};

export type GetItemsByIdCriticreviewsResponse = (QueryResult_BaseItemDto);

export type PostItemsByIdDeleteData = {
    /**
     * Item Id
     */
    id: string;
};

export type PostItemsByIdDeleteResponse = (unknown);

export type GetItemsByIdThememediaData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Determines whether or not parent items should be searched for theme media.
     */
    inheritFromParent?: boolean;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdThememediaResponse = (AllThemeMediaResult);

export type GetItemsByIdThemesongsData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Determines whether or not parent items should be searched for theme media.
     */
    inheritFromParent?: boolean;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdThemesongsResponse = (ThemeMediaResult);

export type GetItemsByIdThemevideosData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Determines whether or not parent items should be searched for theme media.
     */
    inheritFromParent?: boolean;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdThemevideosResponse = (ThemeMediaResult);

export type PostLibrarySeriesAddedResponse = (unknown);

export type PostLibrarySeriesUpdatedResponse = (unknown);

export type PostLibraryMediaUpdatedData = {
    /**
     * PostUpdatedMedia
     */
    requestBody: Library_PostUpdatedMedia;
};

export type PostLibraryMediaUpdatedResponse = (unknown);

export type PostLibraryMoviesAddedResponse = (unknown);

export type PostLibraryMoviesUpdatedResponse = (unknown);

export type GetMoviesByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMoviesByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetShowsByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetShowsByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetTrailersByIdSimilarData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetTrailersByIdSimilarResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetMusicgenresResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresByNameData = {
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMusicgenresByNameResponse = (BaseItemDto);

export type GetOfficialratingsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetOfficialratingsResponse = (QueryResult_UserLibrary_OfficialRatingItem);

export type GetOpenapiResponse = (string);

export type GetOpenapiJsonResponse = (string);

export type GetSwaggerResponse = (string);

export type GetSwaggerJsonResponse = (string);

export type GetPackagesData = {
    /**
     * Optional. Filter by package that contain adult content.
     */
    isAdult?: (boolean) | null;
    /**
     * Optional. Filter by premium status
     */
    isPremium?: (boolean) | null;
    /**
     * Optional package type filter (System/UserInstalled)
     */
    packageType?: string;
    /**
     * Optional. Filter by target system type. Allows multiple, comma delimited.
     */
    targetSystems?: string;
};

export type GetPackagesResponse = (Array<PackageInfo>);

export type GetPackagesUpdatesData = {
    /**
     * Package type filter (System/UserInstalled)
     */
    packageType: string;
};

export type GetPackagesUpdatesResponse = (Array<PackageVersionInfo>);

export type GetPackagesByNameData = {
    /**
     * The guid of the associated assembly
     */
    assemblyGuid?: string;
    /**
     * The name of the package
     */
    name: string;
};

export type GetPackagesByNameResponse = (PackageInfo);

export type PostPackagesInstalledByNameData = {
    /**
     * Guid of the associated assembly
     */
    assemblyGuid?: string;
    /**
     * Package name
     */
    name: string;
    /**
     * Optional update class (Dev, Beta, Release). Defaults to Release.
     */
    updateClass?: PackageVersionClass;
    /**
     * Optional version. Defaults to latest version.
     */
    version?: string;
};

export type PostPackagesInstalledByNameResponse = (unknown);

export type DeletePackagesInstallingByIdData = {
    /**
     * Installation Id
     */
    id: string;
};

export type DeletePackagesInstallingByIdResponse = (unknown);

export type PostPackagesInstallingByIdDeleteData = {
    /**
     * Installation Id
     */
    id: string;
};

export type PostPackagesInstallingByIdDeleteResponse = (unknown);

export type GetPersonsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetPersonsResponse = (QueryResult_BaseItemDto);

export type GetPersonsByNameData = {
    /**
     * The person name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetPersonsByNameResponse = (BaseItemDto);

export type PostPlaylistsData = {
    /**
     * Item Ids to add to the playlist
     */
    ids?: string;
    /**
     * The playlist media type
     */
    mediaType?: string;
    /**
     * The name of the new playlist.
     */
    name?: string;
};

export type PostPlaylistsResponse = (Playlists_PlaylistCreationResult);

export type GetPlaylistsByIdAddtoplaylistinfoData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
    /**
     * User Id
     */
    userId?: string;
};

export type GetPlaylistsByIdAddtoplaylistinfoResponse = (unknown);

export type PostPlaylistsByIdItemsData = {
    id: string;
    /**
     * Item id, comma delimited
     */
    ids: string;
    /**
     * User Id
     */
    userId?: string;
};

export type PostPlaylistsByIdItemsResponse = (Playlists_AddToPlaylistResult);

export type DeletePlaylistsByIdItemsData = {
    entryIds: string;
    id: string;
};

export type DeletePlaylistsByIdItemsResponse = (unknown);

export type GetPlaylistsByIdItemsData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId?: string;
};

export type GetPlaylistsByIdItemsResponse = (QueryResult_BaseItemDto);

export type PostPlaylistsByIdItemsDeleteData = {
    entryIds: string;
    id: string;
};

export type PostPlaylistsByIdItemsDeleteResponse = (unknown);

export type PostPlaylistsByIdItemsByItemidMoveByNewindexData = {
    id: string;
    /**
     * ItemId
     */
    itemId: number;
    /**
     * NewIndex
     */
    newIndex: number;
};

export type PostPlaylistsByIdItemsByItemidMoveByNewindexResponse = (unknown);

export type GetPluginsResponse = (Array<Plugins_PluginInfo>);

export type DeletePluginsByIdData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type DeletePluginsByIdResponse = (unknown);

export type GetPluginsByIdThumbData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type GetPluginsByIdThumbResponse = (unknown);

export type GetPluginsByIdConfigurationData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type GetPluginsByIdConfigurationResponse = (unknown);

export type PostPluginsByIdConfigurationData = {
    /**
     * Plugin Id
     */
    id: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostPluginsByIdConfigurationResponse = (unknown);

export type PostPluginsByIdDeleteData = {
    /**
     * Plugin Id
     */
    id: string;
};

export type PostPluginsByIdDeleteResponse = (unknown);

export type GetScheduledtasksData = {
    /**
     * Optional filter tasks that are enabled, or not.
     */
    isEnabled?: (boolean) | null;
    /**
     * Optional filter tasks that are hidden, or not.
     */
    isHidden?: (boolean) | null;
};

export type GetScheduledtasksResponse = (Array<TaskInfo>);

export type GetScheduledtasksByIdData = {
    id: string;
};

export type GetScheduledtasksByIdResponse = (TaskInfo);

export type PostScheduledtasksRunningByIdData = {
    id: string;
};

export type PostScheduledtasksRunningByIdResponse = (unknown);

export type DeleteScheduledtasksRunningByIdData = {
    id: string;
};

export type DeleteScheduledtasksRunningByIdResponse = (unknown);

export type PostScheduledtasksByIdTriggersData = {
    id: string;
    /**
     * List`1:
     */
    requestBody: Array<TaskTriggerInfo>;
};

export type PostScheduledtasksByIdTriggersResponse = (unknown);

export type PostScheduledtasksRunningByIdDeleteData = {
    id: string;
};

export type PostScheduledtasksRunningByIdDeleteResponse = (unknown);

export type GetSessionsData = {
    /**
     * Optional. Filter by sessions that a given user is allowed to remote control.
     */
    controllableByUserId?: string;
    /**
     * Optional. Filter by device id.
     */
    deviceId?: string;
    /**
     * Optional. Filter by session id.
     */
    id?: string;
};

export type GetSessionsResponse = (Array<Session_SessionInfo>);

export type GetAuthProvidersResponse = (Array<NameIdPair>);

export type PostAuthKeysData = {
    /**
     * App
     */
    app: string;
};

export type PostAuthKeysResponse = (unknown);

export type GetAuthKeysData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetAuthKeysResponse = (unknown);

export type GetSessionsPlayqueueData = {
    /**
     * Optional. Filter by device id.
     */
    deviceId?: string;
    /**
     * Optional. Filter by session id.
     */
    id?: string;
};

export type GetSessionsPlayqueueResponse = (QueryResult_BaseItemDto);

export type PostSessionsLogoutResponse = (unknown);

export type PostSessionsCapabilitiesData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
     */
    playableMediaTypes?: string;
    /**
     * A list of supported remote control commands, comma delimited
     */
    supportedCommands?: string;
    /**
     * Determines whether media can be played remotely.
     */
    supportsMediaControl?: boolean;
    /**
     * Determines whether sync is supported.
     */
    supportsSync?: boolean;
};

export type PostSessionsCapabilitiesResponse = (unknown);

export type DeleteAuthKeysByKeyData = {
    /**
     * Auth Key
     */
    key: string;
};

export type DeleteAuthKeysByKeyResponse = (unknown);

export type PostSessionsByIdViewingData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * The Id of the item.
     */
    itemId: string;
    /**
     * The name of the item.
     */
    itemName: string;
    /**
     * The type of item to browse to.
     */
    itemType: string;
};

export type PostSessionsByIdViewingResponse = (unknown);

export type PostSessionsByIdMessageData = {
    /**
     * The message header.
     */
    header: string;
    /**
     * Session Id
     */
    id: string;
    /**
     * The message text.
     */
    text: string;
    /**
     * The message timeout. If omitted the user will have to confirm viewing the message.
     */
    timeoutMs?: (number) | null;
};

export type PostSessionsByIdMessageResponse = (unknown);

export type PostSessionsByIdPlayingData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * The ids of the items to play, comma delimited
     */
    itemIds: Array<(number)>;
    /**
     * The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
     */
    playCommand: PlayCommand;
    /**
     * PlayRequest:
     */
    requestBody: PlayRequest;
    /**
     * The starting position of the first item.
     */
    startPositionTicks?: (number) | null;
};

export type PostSessionsByIdPlayingResponse = (unknown);

export type PostSessionsByIdCommandData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * GeneralCommand:
     */
    requestBody: GeneralCommand;
};

export type PostSessionsByIdCommandResponse = (unknown);

export type PostSessionsCapabilitiesFullData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * ClientCapabilities:
     */
    requestBody: ClientCapabilities;
};

export type PostSessionsCapabilitiesFullResponse = (unknown);

export type PostAuthKeysByKeyDeleteData = {
    /**
     * Auth Key
     */
    key: string;
};

export type PostAuthKeysByKeyDeleteResponse = (unknown);

export type PostSessionsByIdPlayingByCommandData = {
    command: PlaystateCommand;
    /**
     * Session Id
     */
    id: string;
    /**
     * PlaystateRequest:
     */
    requestBody: PlaystateRequest;
};

export type PostSessionsByIdPlayingByCommandResponse = (unknown);

export type PostSessionsByIdSystemByCommandData = {
    /**
     * The command to send.
     */
    command: string;
    /**
     * Session Id
     */
    id: string;
};

export type PostSessionsByIdSystemByCommandResponse = (unknown);

export type PostSessionsByIdCommandByCommandData = {
    /**
     * The command to send.
     */
    command: string;
    /**
     * Session Id
     */
    id: string;
};

export type PostSessionsByIdCommandByCommandResponse = (unknown);

export type PostSessionsByIdUsersByUseridData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * UserId Id
     */
    userId: string;
};

export type PostSessionsByIdUsersByUseridResponse = (unknown);

export type DeleteSessionsByIdUsersByUseridData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * UserId Id
     */
    userId: string;
};

export type DeleteSessionsByIdUsersByUseridResponse = (unknown);

export type PostSessionsByIdUsersByUseridDeleteData = {
    /**
     * Session Id
     */
    id: string;
    /**
     * UserId Id
     */
    userId: string;
};

export type PostSessionsByIdUsersByUseridDeleteResponse = (unknown);

export type GetStudiosData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetStudiosResponse = (QueryResult_BaseItemDto);

export type GetStudiosByNameData = {
    /**
     * The studio name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetStudiosByNameResponse = (BaseItemDto);

export type GetTrailersData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetTrailersResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight: number;
    /**
     * The maximum image width to return.
     */
    maxWidth: number;
    percentPlayed: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag: string;
    /**
     * Image Type
     */
    type: ImageType;
    unPlayedCount: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse = (unknown);

export type HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight: number;
    /**
     * The maximum image width to return.
     */
    maxWidth: number;
    percentPlayed: (number) | null;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag: string;
    /**
     * Image Type
     */
    type: ImageType;
    unPlayedCount: (number) | null;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse = (unknown);

export type GetItemsByIdImagesData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdImagesResponse = (Array<ImageInfo>);

export type GetArtistsByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetArtistsByNameImagesByTypeResponse = (unknown);

export type HeadArtistsByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadArtistsByNameImagesByTypeResponse = (unknown);

export type GetGamegenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetGamegenresByNameImagesByTypeResponse = (unknown);

export type HeadGamegenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadGamegenresByNameImagesByTypeResponse = (unknown);

export type GetGenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetGenresByNameImagesByTypeResponse = (unknown);

export type HeadGenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadGenresByNameImagesByTypeResponse = (unknown);

export type GetItemsByIdImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetItemsByIdImagesByTypeResponse = (unknown);

export type HeadItemsByIdImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadItemsByIdImagesByTypeResponse = (unknown);

export type PostItemsByIdImagesByTypeData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostItemsByIdImagesByTypeResponse = (unknown);

export type DeleteItemsByIdImagesByTypeData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type DeleteItemsByIdImagesByTypeResponse = (unknown);

export type GetMusicgenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetMusicgenresByNameImagesByTypeResponse = (unknown);

export type HeadMusicgenresByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadMusicgenresByNameImagesByTypeResponse = (unknown);

export type GetPersonsByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetPersonsByNameImagesByTypeResponse = (unknown);

export type HeadPersonsByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadPersonsByNameImagesByTypeResponse = (unknown);

export type GetStudiosByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetStudiosByNameImagesByTypeResponse = (unknown);

export type HeadStudiosByNameImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadStudiosByNameImagesByTypeResponse = (unknown);

export type GetUsersByIdImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetUsersByIdImagesByTypeResponse = (unknown);

export type HeadUsersByIdImagesByTypeData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadUsersByIdImagesByTypeResponse = (unknown);

export type PostUsersByIdImagesByTypeData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostUsersByIdImagesByTypeResponse = (unknown);

export type DeleteUsersByIdImagesByTypeData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type DeleteUsersByIdImagesByTypeResponse = (unknown);

export type GetArtistsByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetArtistsByNameImagesByTypeByIndexResponse = (unknown);

export type HeadArtistsByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadArtistsByNameImagesByTypeByIndexResponse = (unknown);

export type GetGamegenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetGamegenresByNameImagesByTypeByIndexResponse = (unknown);

export type HeadGamegenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadGamegenresByNameImagesByTypeByIndexResponse = (unknown);

export type GetGenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetGenresByNameImagesByTypeByIndexResponse = (unknown);

export type HeadGenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadGenresByNameImagesByTypeByIndexResponse = (unknown);

export type GetItemsByIdImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetItemsByIdImagesByTypeByIndexResponse = (unknown);

export type HeadItemsByIdImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadItemsByIdImagesByTypeByIndexResponse = (unknown);

export type PostItemsByIdImagesByTypeByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostItemsByIdImagesByTypeByIndexResponse = (unknown);

export type DeleteItemsByIdImagesByTypeByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type DeleteItemsByIdImagesByTypeByIndexResponse = (unknown);

export type PostItemsByIdImagesByTypeDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostItemsByIdImagesByTypeDeleteResponse = (unknown);

export type GetMusicgenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetMusicgenresByNameImagesByTypeByIndexResponse = (unknown);

export type HeadMusicgenresByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadMusicgenresByNameImagesByTypeByIndexResponse = (unknown);

export type GetPersonsByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetPersonsByNameImagesByTypeByIndexResponse = (unknown);

export type HeadPersonsByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadPersonsByNameImagesByTypeByIndexResponse = (unknown);

export type GetStudiosByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetStudiosByNameImagesByTypeByIndexResponse = (unknown);

export type HeadStudiosByNameImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Item name
     */
    name: string;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadStudiosByNameImagesByTypeByIndexResponse = (unknown);

export type GetUsersByIdImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type GetUsersByIdImagesByTypeByIndexResponse = (unknown);

export type HeadUsersByIdImagesByTypeByIndexData = {
    /**
     * Set to true to force normalization of orientation in the event the renderer does not support it.
     */
    autoOrient?: boolean;
    /**
     * Optional. Apply a background color for transparent images.
     */
    backgroundColor?: string;
    /**
     * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     */
    cropWhitespace?: (boolean) | null;
    /**
     * Enable or disable image enhancers such as cover art.
     */
    enableImageEnhancers?: boolean;
    /**
     * Optional. Apply a foreground layer on top of the image.
     */
    foregroundLayer?: string;
    /**
     * Determines the output foramt of the image - original,gif,jpg,png
     */
    format?: string;
    /**
     * The fixed image height to return.
     */
    height?: number;
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Set to true to retain image animation (when supported).
     */
    keepAnimation?: boolean;
    /**
     * The maximum image height to return.
     */
    maxHeight?: number;
    /**
     * The maximum image width to return.
     */
    maxWidth?: number;
    /**
     * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     */
    quality?: number;
    /**
     * Optional. Supply the cache tag from the item object to receive strong caching headers.
     */
    tag?: string;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The fixed image width to return.
     */
    width?: number;
};

export type HeadUsersByIdImagesByTypeByIndexResponse = (unknown);

export type PostUsersByIdImagesByTypeByIndexData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostUsersByIdImagesByTypeByIndexResponse = (unknown);

export type DeleteUsersByIdImagesByTypeByIndexData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type DeleteUsersByIdImagesByTypeByIndexResponse = (unknown);

export type PostUsersByIdImagesByTypeDeleteData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index?: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostUsersByIdImagesByTypeDeleteResponse = (unknown);

export type PostItemsByIdImagesByTypeByIndexDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostItemsByIdImagesByTypeByIndexDeleteResponse = (unknown);

export type PostItemsByIdImagesByTypeByIndexIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * The new image index
     */
    newIndex: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostItemsByIdImagesByTypeByIndexIndexResponse = (unknown);

export type PostItemsByIdImagesByTypeByIndexUrlData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: ImageType;
    /**
     * The url for the new image
     */
    url: string;
};

export type PostItemsByIdImagesByTypeByIndexUrlResponse = (unknown);

export type PostUsersByIdImagesByTypeByIndexDeleteData = {
    /**
     * User Id
     */
    id: string;
    /**
     * Image Index
     */
    index: number;
    /**
     * Image Type
     */
    type: ImageType;
};

export type PostUsersByIdImagesByTypeByIndexDeleteResponse = (unknown);

export type GetArtistsInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetArtistsInstantmixResponse = (QueryResult_BaseItemDto);

export type GetAudiobooksNextupData = {
    /**
     * Optional. Filter by series id
     */
    albumId?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetAudiobooksNextupResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMusicgenresInstantmixResponse = (QueryResult_BaseItemDto);

export type GetAlbumsByIdInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetAlbumsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type GetItemsByIdInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetItemsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type GetMusicgenresByNameInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * The genre name
     */
    name: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMusicgenresByNameInstantmixResponse = (QueryResult_BaseItemDto);

export type GetPlaylistsByIdInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetPlaylistsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type GetSongsByIdInstantmixData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetSongsByIdInstantmixResponse = (QueryResult_BaseItemDto);

export type PostBackuprestoreRestoreData = {
    /**
     * RestoreOptions:
     */
    requestBody: MBBackup_Api_RestoreOptions;
};

export type PostBackuprestoreRestoreResponse = (unknown);

export type PostBackuprestoreRestoredataData = {
    /**
     * DataRestoreOptions:
     */
    requestBody: MBBackup_Api_DataRestoreOptions;
};

export type PostBackuprestoreRestoredataResponse = (unknown);

export type GetBackuprestoreBackupinfoResponse = (MBBackup_Api_AllBackupsInfo);

export type GetBrandingConfigurationResponse = (Branding_BrandingOptions);

export type GetBrandingCssResponse = (unknown);

export type GetBrandingCssCssResponse = (unknown);

export type GetConnectPendingResponse = (unknown);

export type GetConnectExchangeData = {
    /**
     * ConnectUserId
     */
    connectUserId: string;
};

export type GetConnectExchangeResponse = (Connect_ConnectAuthenticationExchangeResult);

export type PostUsersByIdConnectLinkData = {
    /**
     * Connect username
     */
    connectUsername: string;
    /**
     * User Id
     */
    id: string;
};

export type PostUsersByIdConnectLinkResponse = (Connect_UserLinkResult);

export type DeleteUsersByIdConnectLinkData = {
    /**
     * User Id
     */
    id: string;
};

export type DeleteUsersByIdConnectLinkResponse = (unknown);

export type PostUsersByIdConnectLinkDeleteData = {
    /**
     * User Id
     */
    id: string;
};

export type PostUsersByIdConnectLinkDeleteResponse = (unknown);

export type GetDisplaypreferencesByIdData = {
    /**
     * Client
     */
    client: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetDisplaypreferencesByIdResponse = (DisplayPreferences);

export type PostDisplaypreferencesByDisplaypreferencesidData = {
    /**
     * DisplayPreferences Id
     */
    displayPreferencesId: string;
    /**
     * DisplayPreferences:
     */
    requestBody: DisplayPreferences;
    /**
     * User Id
     */
    userId: string;
};

export type PostDisplaypreferencesByDisplaypreferencesidResponse = (unknown);

export type GetEncodingTonemapoptionsResponse = (Configuration_ToneMapping_ToneMapOptionsVisibility);

export type GetEncodingCodecinformationVideoResponse = (Array<VideoCodecBase>);

export type GetEncodingCodecconfigurationDefaultsResponse = (Array<CodecConfiguration>);

export type GetEncodingFulltonemapoptionsResponse = (EditObjectContainer);

export type PostEncodingFulltonemapoptionsData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostEncodingFulltonemapoptionsResponse = (unknown);

export type GetEncodingPublictonemapoptionsResponse = (EditObjectContainer);

export type PostEncodingPublictonemapoptionsData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostEncodingPublictonemapoptionsResponse = (unknown);

export type GetEncodingSubtitleoptionsResponse = (EditObjectContainer);

export type PostEncodingSubtitleoptionsData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostEncodingSubtitleoptionsResponse = (unknown);

export type GetEncodingFfmpegoptionsResponse = (EditObjectContainer);

export type PostEncodingFfmpegoptionsData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostEncodingFfmpegoptionsResponse = (unknown);

export type GetEncodingCodecparametersData = {
    /**
     * Codec Id
     */
    codecId: string;
    /**
     * Parameter Context
     */
    parameterContext: MediaEncoding_CodecParameterContext;
};

export type GetEncodingCodecparametersResponse = (EditObjectContainer);

export type PostEncodingCodecparametersData = {
    /**
     * Codec Id
     */
    codecId: string;
    /**
     * Parameter Context
     */
    parameterContext: MediaEncoding_CodecParameterContext;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostEncodingCodecparametersResponse = (unknown);

export type PostEnvironmentValidatepathData = {
    path: string;
    /**
     * ValidatePath
     */
    requestBody: ValidatePath;
};

export type PostEnvironmentValidatepathResponse = (unknown);

export type GetEnvironmentDefaultdirectorybrowserResponse = (DefaultDirectoryBrowserInfo);

export type GetEnvironmentDirectorycontentsData = {
    /**
     * An optional filter to include or exclude folders from the results. true/false
     */
    includeDirectories?: boolean;
    /**
     * An optional filter to include or exclude files from the results. true/false
     */
    includeFiles?: boolean;
    path: string;
};

export type GetEnvironmentDirectorycontentsResponse = (Array<IO_FileSystemEntryInfo>);

export type PostEnvironmentDirectorycontentsData = {
    /**
     * An optional filter to include or exclude folders from the results. true/false
     */
    includeDirectories?: boolean;
    /**
     * An optional filter to include or exclude files from the results. true/false
     */
    includeFiles?: boolean;
    path: string;
    /**
     * GetDirectoryContents
     */
    requestBody: GetDirectoryContents;
};

export type PostEnvironmentDirectorycontentsResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentNetworksharesData = {
    path: string;
};

export type GetEnvironmentNetworksharesResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentDrivesResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentNetworkdevicesResponse = (Array<IO_FileSystemEntryInfo>);

export type GetEnvironmentParentpathData = {
    path: string;
};

export type GetEnvironmentParentpathResponse = (string);

export type GetImagesRemoteData = {
    /**
     * The image url
     */
    imageUrl: string;
};

export type GetImagesRemoteResponse = (unknown);

export type GetItemsByIdRemoteimagesData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional.
     */
    includeAllLanguages?: boolean;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The image provider to use
     */
    providerName?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * The image type
     */
    type?: ImageType;
};

export type GetItemsByIdRemoteimagesResponse = (RemoteImageResult);

export type GetItemsByIdRemoteimagesProvidersData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdRemoteimagesProvidersResponse = (Array<ImageProviderInfo>);

export type PostItemsByIdRemoteimagesDownloadData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The image url
     */
    imageUrl?: string;
    /**
     * The image provider
     */
    providerName?: string;
    /**
     * The image type
     */
    type: ImageType;
};

export type PostItemsByIdRemoteimagesDownloadResponse = (unknown);

export type PostItemsByItemidData = {
    /**
     * The id of the item
     */
    itemId: string;
    /**
     * BaseItemDto:
     */
    requestBody: BaseItemDto;
};

export type PostItemsByItemidResponse = (unknown);

export type GetItemsByItemidMetadataeditorData = {
    /**
     * The id of the item
     */
    itemId: string;
};

export type GetItemsByItemidMetadataeditorResponse = (MetadataEditorInfo);

export type PostItemsAccessData = {
    /**
     * UpdateUserItemAccess
     */
    requestBody: UserLibrary_UpdateUserItemAccess;
};

export type PostItemsAccessResponse = (unknown);

export type PostItemsByIdMakepublicData = {
    /**
     * Item Id
     */
    id: string;
};

export type PostItemsByIdMakepublicResponse = (unknown);

export type PostItemsByIdMakeprivateData = {
    /**
     * Item Id
     */
    id: string;
};

export type PostItemsByIdMakeprivateResponse = (unknown);

export type PostItemsSharedLeaveData = {
    /**
     * LeaveSharedItems
     */
    requestBody: UserLibrary_LeaveSharedItems;
};

export type PostItemsSharedLeaveResponse = (unknown);

export type GetLivetvProgramsByIdData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetLivetvProgramsByIdResponse = (BaseItemDto);

export type GetVideosByIdAdditionalpartsData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetVideosByIdAdditionalpartsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridItemsLatestData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Whether or not to group items into a parent container.
     */
    groupItems?: boolean;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Filter by items that are folders, or not.
     */
    isFolder?: (boolean) | null;
    /**
     * Filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Limit
     */
    limit?: number;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsLatestResponse = (Array<BaseItemDto>);

export type GetUsersByUseridItemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdResponse = (BaseItemDto);

export type GetUsersByUseridItemsRootData = {
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsRootResponse = (BaseItemDto);

export type PostUsersByUseridFavoriteitemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridFavoriteitemsByIdResponse = (UserItemDataDto);

export type DeleteUsersByUseridFavoriteitemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridFavoriteitemsByIdResponse = (UserItemDataDto);

export type GetUsersByUseridItemsByIdSpecialfeaturesData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Movie Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdSpecialfeaturesResponse = (Array<BaseItemDto>);

export type GetUsersByUseridItemsByIdLocaltrailersData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdLocaltrailersResponse = (Array<BaseItemDto>);

export type GetUsersByUseridItemsByIdIntrosData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridItemsByIdIntrosResponse = (QueryResult_BaseItemDto);

export type PostUsersByUseridFavoriteitemsByIdDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridFavoriteitemsByIdDeleteResponse = (UserItemDataDto);

export type DeleteUsersByUseridItemsByIdRatingData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridItemsByIdRatingResponse = (UserItemDataDto);

export type PostUsersByUseridItemsByIdRatingData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Whether the user likes the item or not. true/false
     */
    likes: boolean;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridItemsByIdRatingResponse = (UserItemDataDto);

export type PostUsersByUseridItemsByIdHidefromresumeData = {
    /**
     * Whether the item should be hidden from reusme or not. true/false
     */
    hide: boolean;
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridItemsByIdHidefromresumeResponse = (UserItemDataDto);

export type PostUsersByUseridItemsByIdRatingDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridItemsByIdRatingDeleteResponse = (UserItemDataDto);

export type PostLibraryVirtualfoldersData = {
    /**
     * AddVirtualFolder
     */
    requestBody: Library_AddVirtualFolder;
};

export type PostLibraryVirtualfoldersResponse = (unknown);

export type DeleteLibraryVirtualfoldersResponse = (unknown);

export type GetLibraryVirtualfoldersQueryData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetLibraryVirtualfoldersQueryResponse = (QueryResult_VirtualFolderInfo);

export type PostLibraryVirtualfoldersLibraryoptionsData = {
    /**
     * UpdateLibraryOptions
     */
    requestBody: Library_UpdateLibraryOptions;
};

export type PostLibraryVirtualfoldersLibraryoptionsResponse = (unknown);

export type PostLibraryVirtualfoldersNameData = {
    /**
     * RenameVirtualFolder
     */
    requestBody: Library_RenameVirtualFolder;
};

export type PostLibraryVirtualfoldersNameResponse = (unknown);

export type PostLibraryVirtualfoldersDeleteData = {
    /**
     * RemoveVirtualFolder
     */
    requestBody: Library_RemoveVirtualFolder;
};

export type PostLibraryVirtualfoldersDeleteResponse = (unknown);

export type PostLibraryVirtualfoldersPathsData = {
    /**
     * AddMediaPath
     */
    requestBody: Library_AddMediaPath;
};

export type PostLibraryVirtualfoldersPathsResponse = (unknown);

export type DeleteLibraryVirtualfoldersPathsResponse = (unknown);

export type PostLibraryVirtualfoldersPathsUpdateData = {
    /**
     * UpdateMediaPath
     */
    requestBody: Library_UpdateMediaPath;
};

export type PostLibraryVirtualfoldersPathsUpdateResponse = (unknown);

export type PostLibraryVirtualfoldersPathsDeleteData = {
    /**
     * RemoveMediaPath
     */
    requestBody: Library_RemoveMediaPath;
};

export type PostLibraryVirtualfoldersPathsDeleteResponse = (unknown);

export type PostLivestreamsOpenData = {
    /**
     * LiveStreamRequest:
     */
    requestBody: LiveStreamRequest;
};

export type PostLivestreamsOpenResponse = (LiveStreamResponse);

export type PostLivestreamsCloseData = {
    /**
     * LiveStreamId
     */
    liveStreamId: string;
};

export type PostLivestreamsCloseResponse = (unknown);

export type PostLivestreamsMediainfoData = {
    /**
     * LiveStreamId
     */
    liveStreamId: string;
};

export type PostLivestreamsMediainfoResponse = (unknown);

export type GetPlaybackBitratetestData = {
    /**
     * Size
     */
    size: number;
};

export type GetPlaybackBitratetestResponse = (unknown);

export type GetItemsByIdPlaybackinfoData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetItemsByIdPlaybackinfoResponse = (PlaybackInfoResponse);

export type PostItemsByIdPlaybackinfoData = {
    id: string;
    /**
     * PlaybackInfoRequest:
     */
    requestBody: PlaybackInfoRequest;
};

export type PostItemsByIdPlaybackinfoResponse = (PlaybackInfoResponse);

export type GetLivetvChanneltagsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvChanneltagsResponse = (QueryResult_BaseItemDto);

export type GetLivetvFolderResponse = (BaseItemDto);

export type GetLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type GetLivetvChannelmappingsResponse = (unknown);

export type HeadLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type HeadLivetvChannelmappingsResponse = (unknown);

export type PostLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
    /**
     * SetChannelMapping
     */
    requestBody: Api_SetChannelMapping;
};

export type PostLivetvChannelmappingsResponse = (unknown);

export type PutLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
    /**
     * SetChannelMapping
     */
    requestBody: Api_SetChannelMapping;
};

export type PutLivetvChannelmappingsResponse = (unknown);

export type DeleteLivetvChannelmappingsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type DeleteLivetvChannelmappingsResponse = (unknown);

export type GetLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type GetLivetvChannelmappingoptionsResponse = (unknown);

export type HeadLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type HeadLivetvChannelmappingoptionsResponse = (unknown);

export type PostLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type PostLivetvChannelmappingoptionsResponse = (unknown);

export type PutLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type PutLivetvChannelmappingoptionsResponse = (unknown);

export type DeleteLivetvChannelmappingoptionsData = {
    /**
     * Provider id
     */
    providerId: string;
};

export type DeleteLivetvChannelmappingoptionsResponse = (unknown);

export type PostLivetvListingprovidersData = {
    /**
     * ListingsProviderInfo:
     */
    requestBody: LiveTv_ListingsProviderInfo;
};

export type PostLivetvListingprovidersResponse = (LiveTv_ListingsProviderInfo);

export type DeleteLivetvListingprovidersData = {
    /**
     * Provider id
     */
    id?: string;
};

export type DeleteLivetvListingprovidersResponse = (unknown);

export type GetLivetvListingprovidersData = {
    /**
     * Channel id
     */
    channelId: string;
};

export type GetLivetvListingprovidersResponse = (Array<LiveTv_ListingsProviderInfo>);

export type GetLivetvTunerhostsResponse = (Array<LiveTv_TunerHostInfo>);

export type PostLivetvTunerhostsData = {
    /**
     * TunerHostInfo:
     */
    requestBody: LiveTv_TunerHostInfo;
};

export type PostLivetvTunerhostsResponse = (LiveTv_TunerHostInfo);

export type DeleteLivetvTunerhostsData = {
    /**
     * Tuner host id
     */
    id?: string;
};

export type DeleteLivetvTunerhostsResponse = (unknown);

export type GetLivetvInfoResponse = (LiveTv_LiveTvInfo);

export type GetLivetvEpgData = {
    /**
     * Optional. Adds current program info to each channel
     */
    addCurrentProgram?: boolean;
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * The channels to return guide information for.
     */
    channelIds?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Incorporate favorite and like status into channel sorting.
     */
    enableFavoriteSorting?: boolean;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Filter by channels that are disliked, or not.
     */
    isDisliked?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Filter by channels that are liked, or not.
     */
    isLiked?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * Optional filter by channel type.
     */
    type?: LiveTv_ChannelType;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvEpgResponse = (QueryResult_Api_EpgRow);

export type GetLivetvChannelsData = {
    /**
     * Optional. Adds current program info to each channel
     */
    addCurrentProgram?: boolean;
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Incorporate favorite and like status into channel sorting.
     */
    enableFavoriteSorting?: boolean;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Filter by channels that are disliked, or not.
     */
    isDisliked?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Filter by channels that are liked, or not.
     */
    isLiked?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * Optional filter by channel type.
     */
    type?: LiveTv_ChannelType;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvChannelsResponse = (QueryResult_BaseItemDto);

export type GetLivetvProgramsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * The channels to return guide information for.
     */
    channelIds?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvProgramsResponse = (unknown);

export type PostLivetvProgramsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * The channels to return guide information for.
     */
    channelIds?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * BaseItemsRequest:
     */
    requestBody: Api_BaseItemsRequest;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type PostLivetvProgramsResponse = (unknown);

export type GetLivetvRecordingsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by channel id.
     */
    channelId?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter by recordings that are in progress, or not.
     */
    isInProgress?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional filter by recordings belonging to a series timer
     */
    seriesTimerId?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional filter by recording status.
     */
    status?: LiveTv_RecordingStatus;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvRecordingsResponse = (unknown);

export type GetLivetvTimersData = {
    /**
     * Optional filter by channel id.
     */
    channelId?: string;
    /**
     * Optional filter by timers belonging to a series timer
     */
    seriesTimerId?: string;
};

export type GetLivetvTimersResponse = (QueryResult_LiveTv_TimerInfoDto);

export type PostLivetvTimersData = {
    /**
     * TimerInfoDto:
     */
    requestBody: LiveTv_TimerInfoDto;
};

export type PostLivetvTimersResponse = (unknown);

export type GetLivetvSeriestimersData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Sort by SortName or Priority
     */
    sortBy?: string;
    /**
     * Optional. Sort in Ascending or Descending order
     */
    sortOrder?: SortOrder;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetLivetvSeriestimersResponse = (QueryResult_LiveTv_SeriesTimerInfoDto);

export type PostLivetvSeriestimersData = {
    /**
     * SeriesTimerInfo:
     */
    requestBody: LiveTv_SeriesTimerInfo;
};

export type PostLivetvSeriestimersResponse = (unknown);

export type GetLivetvGuideinfoResponse = (LiveTv_GuideInfo);

export type GetLivetvAvailablerecordingoptionsResponse = (Api_AvailableRecordingOptions);

export type GetLivetvTunerhostsTypesResponse = (Array<NameIdPair>);

export type GetLivetvManageChannelsData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
};

export type GetLivetvManageChannelsResponse = (QueryResult_ChannelManagementInfo);

export type GetLivetvChanneltagsPrefixesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetLivetvChanneltagsPrefixesResponse = (Array<Api_TagItem>);

export type GetLivetvRecordingsFoldersData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional filter by user and attach user data.
     */
    userId?: string;
};

export type GetLivetvRecordingsFoldersResponse = (Array<BaseItemDto>);

export type GetLivetvTunersDiscvoverResponse = (Array<LiveTv_TunerHostInfo>);

export type GetLivetvListingprovidersDefaultResponse = (LiveTv_ListingsProviderInfo);

export type PostLivetvListingprovidersDeleteData = {
    /**
     * Provider id
     */
    id?: string;
};

export type PostLivetvListingprovidersDeleteResponse = (unknown);

export type PostLivetvTunerhostsDeleteData = {
    /**
     * Tuner host id
     */
    id?: string;
};

export type PostLivetvTunerhostsDeleteResponse = (unknown);

export type GetLivetvListingprovidersLineupsData = {
    /**
     * Country
     */
    country?: string;
    /**
     * Provider id
     */
    id?: string;
    /**
     * Location
     */
    location?: string;
    /**
     * Provider Type
     */
    type?: string;
};

export type GetLivetvListingprovidersLineupsResponse = (Array<NameIdPair>);

export type GetLivetvChannelsByIdData = {
    /**
     * Channel Id
     */
    id: string;
    /**
     * Optional attach user data.
     */
    userId?: string;
};

export type GetLivetvChannelsByIdResponse = (BaseItemDto);

export type GetLivetvProgramsRecommendedData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * The genres to return guide information for.
     */
    genreIds?: string;
    /**
     * Optional. Filter by programs that have completed airing, or not.
     */
    hasAired?: (boolean) | null;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. Filter by programs that are currently airing, or not.
     */
    isAiring?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional filter by user id.
     */
    userId?: string;
};

export type GetLivetvProgramsRecommendedResponse = (QueryResult_BaseItemDto);

export type GetLivetvRecordingsSeriesResponse = (QueryResult_BaseItemDto);

export type GetLivetvRecordingsByIdData = {
    /**
     * Recording Id
     */
    id: string;
    /**
     * Optional attach user data.
     */
    userId?: string;
};

export type GetLivetvRecordingsByIdResponse = (BaseItemDto);

export type DeleteLivetvRecordingsByIdData = {
    /**
     * Recording Id
     */
    id: string;
};

export type DeleteLivetvRecordingsByIdResponse = (unknown);

export type GetLivetvTimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type GetLivetvTimersByIdResponse = (LiveTv_TimerInfoDto);

export type DeleteLivetvTimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type DeleteLivetvTimersByIdResponse = (unknown);

export type PostLivetvTimersByIdData = {
    id: string;
    /**
     * TimerInfoDto:
     */
    requestBody: LiveTv_TimerInfoDto;
};

export type PostLivetvTimersByIdResponse = (unknown);

export type GetLivetvSeriestimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type GetLivetvSeriestimersByIdResponse = (LiveTv_TimerInfoDto);

export type DeleteLivetvSeriestimersByIdData = {
    /**
     * Timer Id
     */
    id: string;
};

export type DeleteLivetvSeriestimersByIdResponse = (unknown);

export type PostLivetvSeriestimersByIdData = {
    id: string;
    /**
     * SeriesTimerInfo:
     */
    requestBody: LiveTv_SeriesTimerInfo;
};

export type PostLivetvSeriestimersByIdResponse = (unknown);

export type GetLivetvTimersDefaultsData = {
    /**
     * Optional, to attach default values based on a program.
     */
    programId?: string;
};

export type GetLivetvTimersDefaultsResponse = (LiveTv_SeriesTimerInfoDto);

export type GetLivetvRecordingsGroupsResponse = (QueryResult_BaseItemDto);

export type GetLivetvListingprovidersAvailableResponse = (Array<Api_ListingProviderTypeInfo>);

export type GetLivetvListingprovidersSchedulesdirectCountriesResponse = (unknown);

export type GetLivetvTunerhostsDefaultByTypeData = {
    /**
     * Type
     */
    type: string;
};

export type GetLivetvTunerhostsDefaultByTypeResponse = (LiveTv_TunerHostInfo);

export type PostLivetvRecordingsByIdDeleteData = {
    /**
     * Recording Id
     */
    id: string;
};

export type PostLivetvRecordingsByIdDeleteResponse = (unknown);

export type PostLivetvTimersByIdDeleteData = {
    /**
     * Timer Id
     */
    id: string;
};

export type PostLivetvTimersByIdDeleteResponse = (unknown);

export type PostLivetvSeriestimersByIdDeleteData = {
    /**
     * Timer Id
     */
    id: string;
};

export type PostLivetvSeriestimersByIdDeleteResponse = (unknown);

export type PostLivetvTunersByIdResetData = {
    /**
     * Tuner Id
     */
    id: string;
};

export type PostLivetvTunersByIdResetResponse = (unknown);

export type PostLivetvManageChannelsByIdDisabledData = {
    id: string;
    /**
     * SetChannelDisabled
     */
    requestBody: Api_SetChannelDisabled;
};

export type PostLivetvManageChannelsByIdDisabledResponse = (QueryResult_ChannelManagementInfo);

export type PostLivetvManageChannelsByIdSortindexData = {
    id: string;
    /**
     * SetChannelSortIndex
     */
    requestBody: Api_SetChannelSortIndex;
};

export type PostLivetvManageChannelsByIdSortindexResponse = (QueryResult_ChannelManagementInfo);

export type GetLocalizationParentalratingsResponse = (Array<ParentalRating>);

export type GetLocalizationOptionsResponse = (Array<Globalization_LocalizatonOption>);

export type GetLocalizationCountriesResponse = (Array<Globalization_CountryInfo>);

export type GetLocalizationCulturesResponse = (Array<Globalization_CultureDto>);

export type GetMoviesRecommendationsData = {
    /**
     * The max number of categories to return
     */
    categoryLimit?: number;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * The max number of items to return per category
     */
    itemLimit?: number;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional. Filter by user id, and attach user data
     */
    userId?: string;
};

export type GetMoviesRecommendationsResponse = (Array<RecommendationDto>);

export type GetNotificationsTypesResponse = (Array<NotificationCategoryInfo>);

export type PostNotificationsAdminData = {
    /**
     * The notification's description
     */
    description: string;
    /**
     * The notification's image url
     */
    imageUrl?: string;
    /**
     * The notification level
     */
    level?: string;
    /**
     * The notification's name
     */
    name: string;
    /**
     * The notification's info url
     */
    url?: string;
};

export type PostNotificationsAdminResponse = (unknown);

export type PostSessionsPlayingData = {
    /**
     * PlaybackStartInfo:
     */
    requestBody: PlaybackStartInfo;
};

export type PostSessionsPlayingResponse = (unknown);

export type PostSessionsPlayingProgressData = {
    /**
     * PlaybackProgressInfo:
     */
    requestBody: PlaybackProgressInfo;
};

export type PostSessionsPlayingProgressResponse = (unknown);

export type PostSessionsPlayingPingData = {
    playSessionId?: string;
};

export type PostSessionsPlayingPingResponse = (unknown);

export type PostSessionsPlayingStoppedData = {
    /**
     * PlaybackStopInfo:
     */
    requestBody: PlaybackStopInfo;
};

export type PostSessionsPlayingStoppedResponse = (unknown);

export type PostUsersByUseridPlayeditemsByIdData = {
    /**
     * The date the item was played (if any). Format = yyyyMMddHHmmss
     */
    datePlayed?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridPlayeditemsByIdResponse = (UserItemDataDto);

export type DeleteUsersByUseridPlayeditemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridPlayeditemsByIdResponse = (UserItemDataDto);

export type PostUsersByUseridPlayingitemsByIdData = {
    audioStreamIndex?: (number) | null;
    /**
     * Indicates if the client can seek
     */
    canSeek?: boolean;
    /**
     * Item Id
     */
    id: string;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    playMethod?: PlayMethod;
    playSessionId?: string;
    subtitleStreamIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridPlayingitemsByIdResponse = (unknown);

export type DeleteUsersByUseridPlayingitemsByIdData = {
    /**
     * Item Id
     */
    id: string;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    /**
     * The next media type that will play
     */
    nextMediaType: string;
    playSessionId?: string;
    /**
     * Optional. The position, in ticks, where playback stopped. 1ms = 10000 ticks.
     */
    positionTicks?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type DeleteUsersByUseridPlayingitemsByIdResponse = (unknown);

export type PostUsersByUseridItemsByItemidUserdataData = {
    itemId: string;
    /**
     * UserItemDataDto:
     */
    requestBody: UserItemDataDto;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridItemsByItemidUserdataResponse = (unknown);

export type PostUsersByUseridPlayingitemsByIdProgressData = {
    audioStreamIndex?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Indicates if the player is muted.
     */
    isMuted?: boolean;
    /**
     * Indicates if the player is paused.
     */
    isPaused?: boolean;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    playbackRate?: number;
    playMethod?: PlayMethod;
    playSessionId?: string;
    /**
     * Optional. The current position, in ticks. 1ms = 10000 ticks.
     */
    positionTicks?: (number) | null;
    repeatMode?: RepeatMode;
    /**
     * OnPlaybackProgress
     */
    requestBody: Api_OnPlaybackProgress;
    subtitleOffset?: number;
    subtitleStreamIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
    /**
     * Scale of 0-100
     */
    volumeLevel?: (number) | null;
};

export type PostUsersByUseridPlayingitemsByIdProgressResponse = (unknown);

export type PostUsersByUseridPlayingitemsByIdDeleteData = {
    /**
     * Item Id
     */
    id: string;
    liveStreamId?: string;
    /**
     * The id of the MediaSource
     */
    mediaSourceId: string;
    /**
     * The next media type that will play
     */
    nextMediaType: string;
    playSessionId?: string;
    /**
     * Optional. The position, in ticks, where playback stopped. 1ms = 10000 ticks.
     */
    positionTicks?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridPlayingitemsByIdDeleteResponse = (unknown);

export type PostUsersByUseridPlayeditemsByIdDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * User Id
     */
    userId: string;
};

export type PostUsersByUseridPlayeditemsByIdDeleteResponse = (UserItemDataDto);

export type GetShowsMissingData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetShowsMissingResponse = (unknown);

export type GetShowsUpcomingData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetShowsUpcomingResponse = (unknown);

export type GetShowsNextupData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional. Filter by series id
     */
    seriesId?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetShowsNextupResponse = (QueryResult_BaseItemDto);

export type GetShowsByIdSeasonsData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * The series id
     */
    id: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. Filter by special season.
     */
    isSpecialSeason?: (boolean) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetShowsByIdSeasonsResponse = (QueryResult_BaseItemDto);

export type GetShowsByIdEpisodesData = {
    /**
     * Optional. Return items that are siblings of a supplied item.
     */
    adjacentTo?: string;
    /**
     * Gets all episodes that aired during a season, including specials.
     */
    airedDuringSeason?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    albumArtistStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     */
    albums?: string;
    /**
     * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     */
    anyProviderIdEquals?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artistIds?: string;
    /**
     * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     */
    artists?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    artistStartsWithOrGreater?: string;
    /**
     * Artist or AlbumArtist
     */
    artistType?: string;
    /**
     * Optional filter by AudioCodec. Allows multiple, comma delimeted.
     */
    audioCodecs?: string;
    /**
     * Optional filter by AudioLayout. Allows multiple, comma delimeted.
     */
    audioLayouts?: string;
    /**
     * Optional filter by Container. Allows multiple, comma delimeted.
     */
    containers?: string;
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     */
    excludeItemIds?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    excludeItemTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    excludeTags?: string;
    /**
     * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     */
    extendedVideoTypes?: string;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     */
    fields?: string;
    /**
     * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     */
    filters?: string;
    /**
     * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     */
    genres?: string;
    /**
     * Whether or not to hide items behind their boxsets.
     */
    groupItemsIntoCollections?: boolean;
    /**
     * Optional filter by items that have an imdb id or not.
     */
    hasImdbId?: (boolean) | null;
    /**
     * Optional filter by items that have official ratings
     */
    hasOfficialRating?: (boolean) | null;
    /**
     * Optional filter by items that have an overview or not.
     */
    hasOverview?: (boolean) | null;
    /**
     * Optional filter by items that have or do not have a parental rating
     */
    hasParentalRating?: (boolean) | null;
    /**
     * Optional filter by items with special features.
     */
    hasSpecialFeature?: (boolean) | null;
    /**
     * Optional filter by items with subtitles.
     */
    hasSubtitles?: (boolean) | null;
    /**
     * Optional filter by items with theme songs.
     */
    hasThemeSong?: (boolean) | null;
    /**
     * Optional filter by items with theme videos.
     */
    hasThemeVideo?: (boolean) | null;
    /**
     * Optional filter by items that have a tmdb id or not.
     */
    hasTmdbId?: (boolean) | null;
    /**
     * Optional filter by items with trailers.
     */
    hasTrailer?: (boolean) | null;
    /**
     * Optional filter by items that have a tvdb id or not.
     */
    hasTvdbId?: (boolean) | null;
    /**
     * The series id
     */
    id: string;
    /**
     * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     */
    ids?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    /**
     * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     */
    imageTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     */
    includeItemTypes?: string;
    /**
     * Optional filter by items that are 3D, or not.
     */
    is3D?: (boolean) | null;
    /**
     * Optional filter by items that are marked as favorite, or not.
     */
    isFavorite?: (boolean) | null;
    /**
     * Optional filter for folders.
     */
    isFolder?: (boolean) | null;
    /**
     * Optional filter by items that are HD or not.
     */
    isHd?: (boolean) | null;
    /**
     * Optional filter for kids.
     */
    isKids?: (boolean) | null;
    /**
     * Optional filter by items that are locked.
     */
    isLocked?: (boolean) | null;
    /**
     * Optional filter for movies.
     */
    isMovie?: (boolean) | null;
    /**
     * Optional filter for IsNew.
     */
    isNew?: (boolean) | null;
    /**
     * Optional filter for IsNewOrPremiere.
     */
    isNewOrPremiere?: (boolean) | null;
    /**
     * Optional filter for news.
     */
    isNews?: (boolean) | null;
    /**
     * Optional filter by items that are placeholders
     */
    isPlaceHolder?: (boolean) | null;
    /**
     * Optional filter by items that are played, or not.
     */
    isPlayed?: (boolean) | null;
    /**
     * Optional filter for IsPremiere.
     */
    isPremiere?: (boolean) | null;
    /**
     * Optional filter for IsRepeat.
     */
    isRepeat?: (boolean) | null;
    /**
     * Optional filter for series.
     */
    isSeries?: (boolean) | null;
    /**
     * Optional filter for sports.
     */
    isSports?: (boolean) | null;
    /**
     * Optional filter by items that are unaired episodes or not.
     */
    isUnaired?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxEndDate?: string;
    /**
     * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     */
    maxOfficialRating?: string;
    /**
     * Optional filter by maximum number of game players.
     */
    maxPlayers?: (number) | null;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxPremiereDate?: string;
    /**
     * Optional. The maximum premiere date. Format = ISO
     */
    maxStartDate?: string;
    /**
     * Optional filter by MediaType. Allows multiple, comma delimited.
     */
    mediaTypes?: string;
    /**
     * Optional filter by minimum community rating.
     */
    minCommunityRating?: (number) | null;
    /**
     * Optional filter by minimum critic rating.
     */
    minCriticRating?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSaved?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minDateLastSavedForUser?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minEndDate?: string;
    /**
     * Optional filter by minimum index number.
     */
    minIndexNumber?: (number) | null;
    /**
     * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     */
    minOfficialRating?: string;
    /**
     * Optional filter by minimum number of game players.
     */
    minPlayers?: (number) | null;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minPremiereDate?: string;
    /**
     * Optional. The minimum premiere date. Format = ISO
     */
    minStartDate?: string;
    /**
     * Optional filter by items whose name is equally or lesser than a given input string.
     */
    nameLessThan?: string;
    /**
     * Optional filter by items whose name is sorted equally than a given input string.
     */
    nameStartsWith?: string;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     */
    officialRatings?: string;
    /**
     * Specify this to localize the search to a specific item or folder. Omit to use the root
     */
    parentId?: string;
    /**
     * Optional filter by parent index number.
     */
    parentIndexNumber?: (number) | null;
    /**
     * Optional filter by Path.
     */
    path?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    person?: string;
    /**
     * Optional. If specified, results will be filtered to include only those containing the specified person.
     */
    personIds?: string;
    /**
     * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     */
    personTypes?: string;
    /**
     * ProjectToMedia
     */
    projectToMedia?: boolean;
    /**
     * When searching within folders, this determines whether or not the search will be recursive. true/false
     */
    recursive?: boolean;
    /**
     * Enter a search term to perform a search request
     */
    searchTerm?: string;
    /**
     * Optional filter by season number.
     */
    season?: (number) | null;
    /**
     * Optional. Filter by season id
     */
    seasonId?: string;
    /**
     * Optional filter by Series Status. Allows multiple, comma delimeted.
     */
    seriesStatus?: string;
    /**
     * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     */
    sortBy?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
    /**
     * Optional. Skip through the list until a given item is found.
     */
    startItemId?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studioIds?: string;
    /**
     * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     */
    studios?: string;
    /**
     * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     */
    subtitleCodecs?: string;
    /**
     * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     */
    tags?: string;
    /**
     * User Id
     */
    userId?: string;
    /**
     * Optional filter by VideoCodec. Allows multiple, comma delimeted.
     */
    videoCodecs?: string;
    /**
     * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     */
    videoTypes?: string;
    /**
     * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     */
    years?: string;
};

export type GetShowsByIdEpisodesResponse = (unknown);

export type GetSyncTargetsData = {
    /**
     * UserId
     */
    userId: string;
};

export type GetSyncTargetsResponse = (Array<SyncTarget>);

export type GetSyncJobsResponse = (QueryResult_SyncJob);

export type PostSyncJobsData = {
    /**
     * SyncJobRequest:
     */
    requestBody: SyncJobRequest;
};

export type PostSyncJobsResponse = (SyncJobCreationResult);

export type GetSyncJobitemsData = {
    /**
     * TargetId
     */
    targetId: string;
};

export type GetSyncJobitemsResponse = (QueryResult_SyncJobItem);

export type GetSyncOptionsData = {
    /**
     * Category
     */
    category?: SyncCategory;
    /**
     * ItemIds
     */
    itemIds?: string;
    /**
     * ParentId
     */
    parentId?: string;
    /**
     * TargetId
     */
    targetId?: string;
    /**
     * UserId
     */
    userId: string;
};

export type GetSyncOptionsResponse = (SyncDialogOptions);

export type PostSyncOfflineactionsData = {
    /**
     * List`1:
     */
    requestBody: Array<UserAction>;
};

export type PostSyncOfflineactionsResponse = (unknown);

export type PostSyncDataData = {
    /**
     * SyncDataRequest:
     */
    requestBody: SyncDataRequest;
    /**
     * TargetId
     */
    targetId: string;
};

export type PostSyncDataResponse = (SyncDataResponse);

export type PostSyncByItemidStatusData = {
    itemId: string;
    /**
     * SyncedItemProgress:
     */
    requestBody: SyncedItemProgress;
};

export type PostSyncByItemidStatusResponse = (unknown);

export type GetSyncJobsByIdData = {
    /**
     * Id
     */
    id: string;
};

export type GetSyncJobsByIdResponse = (SyncJob);

export type DeleteSyncJobsByIdData = {
    /**
     * Id
     */
    id: string;
};

export type DeleteSyncJobsByIdResponse = (unknown);

export type PostSyncJobsByIdData = {
    id: number;
    /**
     * SyncJob:
     */
    requestBody: SyncJob;
};

export type PostSyncJobsByIdResponse = (unknown);

export type PostSyncItemsCancelData = {
    /**
     * ItemIds
     */
    itemIds?: string;
};

export type PostSyncItemsCancelResponse = (unknown);

export type DeleteSyncByTargetidItemsData = {
    /**
     * ItemIds
     */
    itemIds?: string;
    /**
     * TargetId
     */
    targetId: string;
};

export type DeleteSyncByTargetidItemsResponse = (unknown);

export type GetSyncItemsReadyData = {
    /**
     * TargetId
     */
    targetId: string;
};

export type GetSyncItemsReadyResponse = (Array<SyncedItem>);

export type DeleteSyncJobitemsByIdData = {
    /**
     * Id
     */
    id: string;
};

export type DeleteSyncJobitemsByIdResponse = (unknown);

export type PostSyncJobsByIdDeleteData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobsByIdDeleteResponse = (unknown);

export type PostSyncByTargetidItemsDeleteData = {
    /**
     * ItemIds
     */
    itemIds?: string;
    /**
     * TargetId
     */
    targetId: string;
};

export type PostSyncByTargetidItemsDeleteResponse = (unknown);

export type PostSyncJobitemsByIdTransferredData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdTransferredResponse = (unknown);

export type HeadSyncJobitemsByIdFileData = {
    /**
     * Id
     */
    id: string;
};

export type HeadSyncJobitemsByIdFileResponse = (unknown);

export type GetSyncJobitemsByIdFileData = {
    /**
     * Id
     */
    id: string;
};

export type GetSyncJobitemsByIdFileResponse = (unknown);

export type GetSyncJobitemsByIdAdditionalfilesData = {
    /**
     * Id
     */
    id: string;
    /**
     * Name
     */
    name: string;
};

export type GetSyncJobitemsByIdAdditionalfilesResponse = (unknown);

export type PostSyncJobitemsByIdEnableData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdEnableResponse = (unknown);

export type PostSyncJobitemsByIdDeleteData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdDeleteResponse = (unknown);

export type PostSyncJobitemsByIdMarkforremovalData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdMarkforremovalResponse = (unknown);

export type PostSyncJobitemsByIdUnmarkforremovalData = {
    /**
     * Id
     */
    id: string;
};

export type PostSyncJobitemsByIdUnmarkforremovalResponse = (unknown);

export type GetSystemConfigurationResponse = (ServerConfiguration);

export type PostSystemConfigurationData = {
    /**
     * ServerConfiguration:
     */
    requestBody: ServerConfiguration;
};

export type PostSystemConfigurationResponse = (unknown);

export type PostSystemConfigurationPartialData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostSystemConfigurationPartialResponse = (unknown);

export type GetSystemConfigurationByKeyData = {
    /**
     * Key
     */
    key: string;
};

export type GetSystemConfigurationByKeyResponse = (unknown);

export type PostSystemConfigurationByKeyData = {
    /**
     * Key
     */
    key: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostSystemConfigurationByKeyResponse = (unknown);

export type GetSystemReleasenotesResponse = (PackageVersionInfo);

export type PostSystemPingResponse = (unknown);

export type GetSystemPingResponse = (unknown);

export type GetSystemWakeonlaninfoResponse = (Array<WakeOnLanInfo>);

export type GetSystemInfoResponse = (SystemInfo);

export type PostSystemRestartResponse = (unknown);

export type PostSystemShutdownResponse = (unknown);

export type GetSystemEndpointResponse = (Net_EndPointInfo);

export type GetSystemReleasenotesVersionsResponse = (Array<PackageVersionInfo>);

export type GetSystemLogsQueryData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetSystemLogsQueryResponse = (QueryResult_LogFile);

export type GetSystemLogsByNameData = {
    /**
     * The log file name.
     */
    name: string;
    /**
     * Return sanitized log
     */
    sanitize?: boolean;
};

export type GetSystemLogsByNameResponse = (unknown);

export type GetSystemInfoPublicResponse = (PublicSystemInfo);

export type GetSystemLogsByNameLinesData = {
    /**
     * The log file name.
     */
    name: string;
};

export type GetSystemLogsByNameLinesResponse = (QueryResult_String);

export type GetUiViewData = {
    /**
     * Locale identifier of the client
     */
    clientLocale: string;
    /**
     * Id of the page controller
     */
    pageId: string;
};

export type GetUiViewResponse = (UIViewInfo);

export type PostUiCommandData = {
    /**
     * RunUICommand
     */
    requestBody: RunUICommand;
};

export type PostUiCommandResponse = (UIViewInfo);

export type GetUsersPublicResponse = (Array<UserDto>);

export type GetUsersQueryData = {
    /**
     * Optional filter by IsDisabled=true or false
     */
    isDisabled?: (boolean) | null;
    /**
     * Optional filter by IsHidden=true or false
     */
    isHidden?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetUsersQueryResponse = (QueryResult_UserDto);

export type GetUsersPrefixesData = {
    /**
     * Optional filter by IsDisabled=true or false
     */
    isDisabled?: (boolean) | null;
    /**
     * Optional filter by IsHidden=true or false
     */
    isHidden?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetUsersPrefixesResponse = (Array<NameIdPair>);

export type GetUsersItemaccessData = {
    /**
     * Optional filter by IsDisabled=true or false
     */
    isDisabled?: (boolean) | null;
    /**
     * Optional filter by IsHidden=true or false
     */
    isHidden?: (boolean) | null;
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional filter by items whose name is sorted equally or greater than a given input string.
     */
    nameStartsWithOrGreater?: string;
    /**
     * Sort Order - Ascending,Descending
     */
    sortOrder?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: number;
};

export type GetUsersItemaccessResponse = (QueryResult_UserDto);

export type GetUsersByIdData = {
    id: string;
};

export type GetUsersByIdResponse = (UserDto);

export type DeleteUsersByIdData = {
    id: string;
};

export type DeleteUsersByIdResponse = (unknown);

export type PostUsersByIdData = {
    id: string;
    /**
     * UserDto:
     */
    requestBody: UserDto;
};

export type PostUsersByIdResponse = (unknown);

export type PostUsersAuthenticatebynameData = {
    /**
     * AuthenticateUserByName
     */
    requestBody: AuthenticateUserByName;
    /**
     * The authorization header can be either named 'Authorization' or 'X-Emby-Authorization'.
     * It must be of the following schema:
     * Emby UserId="(guid)", Client="(string)", Device="(string)", DeviceId="(string)", Version="string", Token="(string)"
     * Please consult the documentation for further details.
     */
    xEmbyAuthorization: string;
};

export type PostUsersAuthenticatebynameResponse = (Authentication_AuthenticationResult);

export type PostUsersNewData = {
    /**
     * CreateUserByName
     */
    requestBody: CreateUserByName;
};

export type PostUsersNewResponse = (UserDto);

export type PostUsersForgotpasswordData = {
    /**
     * ForgotPassword
     */
    requestBody: ForgotPassword;
};

export type PostUsersForgotpasswordResponse = (ForgotPasswordResult);

export type PostUsersByIdDeleteData = {
    id: string;
};

export type PostUsersByIdDeleteResponse = (unknown);

export type PostUsersByIdAuthenticateData = {
    id: string;
    /**
     * AuthenticateUser
     */
    requestBody: AuthenticateUser;
};

export type PostUsersByIdAuthenticateResponse = (Authentication_AuthenticationResult);

export type PostUsersByIdPasswordData = {
    id: string;
    /**
     * UpdateUserPassword
     */
    requestBody: UpdateUserPassword;
};

export type PostUsersByIdPasswordResponse = (unknown);

export type PostUsersForgotpasswordPinData = {
    /**
     * ForgotPasswordPin
     */
    requestBody: ForgotPasswordPin;
};

export type PostUsersForgotpasswordPinResponse = (PinRedeemResult);

export type PostUsersByIdConfigurationData = {
    id: string;
    /**
     * UserConfiguration:
     */
    requestBody: UserConfiguration;
};

export type PostUsersByIdConfigurationResponse = (unknown);

export type PostUsersByIdPolicyData = {
    id: string;
    /**
     * UserPolicy:
     */
    requestBody: UserPolicy;
};

export type PostUsersByIdPolicyResponse = (unknown);

export type DeleteUsersByIdTrackselectionsByTracktypeData = {
    id: string;
    trackType: string;
};

export type DeleteUsersByIdTrackselectionsByTracktypeResponse = (unknown);

export type PostUsersByIdConfigurationPartialData = {
    id: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostUsersByIdConfigurationPartialResponse = (unknown);

export type GetUsersByUseridTypedsettingsByKeyData = {
    /**
     * Key
     */
    key: string;
    userId: string;
};

export type GetUsersByUseridTypedsettingsByKeyResponse = (unknown);

export type PostUsersByUseridTypedsettingsByKeyData = {
    /**
     * Key
     */
    key: string;
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
    userId: string;
};

export type PostUsersByUseridTypedsettingsByKeyResponse = (unknown);

export type PostUsersByIdTrackselectionsByTracktypeDeleteData = {
    id: string;
    trackType: string;
};

export type PostUsersByIdTrackselectionsByTracktypeDeleteResponse = (unknown);

export type GetUserUsageStatsGetItemPathData = {
    /**
     * item id
     */
    id: number;
};

export type GetUserUsageStatsGetItemPathResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsGetItemStatsData = {
    /**
     * item id
     */
    id: number;
};

export type GetUserUsageStatsGetItemStatsResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsGetItemsData = {
    /**
     * filter string
     */
    filter?: string;
    /**
     * type of items to return
     */
    itemType?: string;
    /**
     * parentid
     */
    parent?: number;
};

export type GetUserUsageStatsGetItemsResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsTypeFilterListResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsUserActivityData = {
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
};

export type GetUserUsageStatsUserActivityResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsUserListResponse = ({
    [key: string]: unknown;
});

export type PostUserUsageStatsImportBackupData = {
    /**
     * Binary stream
     */
    requestBody: (Blob | File);
};

export type PostUserUsageStatsImportBackupResponse = (unknown);

export type GetUserUsageStatsLoadBackupData = {
    /**
     * File name of file to load
     */
    backupfile: string;
};

export type GetUserUsageStatsLoadBackupResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsSaveBackupResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsPlayactivityData = {
    /**
     * Data type to return (count,time)
     */
    dataType?: string;
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
    /**
     * Comma separated list of media types to filter (movies,series)
     */
    filter?: string;
};

export type GetUserUsageStatsPlayactivityResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsHourlyreportData = {
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
    /**
     * Comma separated list of media types to filter (movies,series)
     */
    filter?: string;
    /**
     * User Id
     */
    userId?: string;
};

export type GetUserUsageStatsHourlyreportResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsTvshowsreportData = {
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
    /**
     * User Id
     */
    userId?: string;
};

export type GetUserUsageStatsTvshowsreportResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsMoviesreportData = {
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
    /**
     * User Id
     */
    userId?: string;
};

export type GetUserUsageStatsMoviesreportResponse = ({
    [key: string]: unknown;
});

export type PostUserUsageStatsSubmitCustomQueryData = {
    /**
     * CustomQuery
     */
    requestBody: playback_reporting_Api_CustomQuery;
};

export type PostUserUsageStatsSubmitCustomQueryResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsUserplaylistData = {
    /**
     * Aggregate the data to total duration per user per item
     */
    aggregateData: boolean;
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
    /**
     * Comma separated list of media types to filter (movies,series)
     */
    filter?: string;
    /**
     * Name Filter
     */
    filterName?: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUserUsageStatsUserplaylistResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsSessionListResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsByBreakdowntypeBreakdownreportData = {
    /**
     * Breakdown type
     */
    breakdownType: string;
    /**
     * Number of Days
     */
    days?: number;
    /**
     * End date of the report in yyyy-MM-dd format
     */
    endDate?: string;
    /**
     * User Id
     */
    userId?: string;
};

export type GetUserUsageStatsByBreakdowntypeBreakdownreportResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsUserManageByActionByIdData = {
    /**
     * action to perform
     */
    action: string;
    /**
     * user Id to perform the action on
     */
    id: string;
};

export type GetUserUsageStatsUserManageByActionByIdResponse = ({
    [key: string]: unknown;
});

export type GetUserUsageStatsByUseridByDateGetitemsData = {
    /**
     * UTC DateTime, Format yyyy-MM-dd
     */
    date: string;
    /**
     * Comma separated list of media types to filter (movies,series)
     */
    filter?: string;
    /**
     * User Id
     */
    userId: string;
};

export type GetUserUsageStatsByUseridByDateGetitemsResponse = ({
    [key: string]: unknown;
});

export type PostVideosMergeversionsData = {
    /**
     * Item id list. This allows multiple, comma delimited.
     */
    ids?: string;
};

export type PostVideosMergeversionsResponse = (unknown);

export type DeleteVideosByIdAlternatesourcesData = {
    /**
     * Item Id
     */
    id: string;
};

export type DeleteVideosByIdAlternatesourcesResponse = (unknown);

export type PostVideosByIdAlternatesourcesDeleteData = {
    /**
     * Item Id
     */
    id: string;
};

export type PostVideosByIdAlternatesourcesDeleteResponse = (unknown);

export type DeleteVideosActiveencodingsData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId: string;
    /**
     * The play session id
     */
    playSessionId: string;
};

export type DeleteVideosActiveencodingsResponse = (unknown);

export type PostVideosActiveencodingsDeleteData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId: string;
    /**
     * The play session id
     */
    playSessionId: string;
};

export type PostVideosActiveencodingsDeleteResponse = (unknown);

export type GetVirtualtvChannelsM3UResponse = (unknown);

export type GetVirtualtvChannelsData = {
    /**
     * StreamType Universal only: original, mpegts or hls (Container of the catchup stream. Defaults to original)
     */
    catchupContainer?: string;
    /**
     * StreamType Universal only: vod, flussonic, shift or append (Defaults to vod)
     */
    catchupType?: string;
    /**
     * StreamType Universal only: Max. video bitrate in Kbps (Optional)
     */
    maxBitrate?: (number) | null;
    /**
     * Returns real live tv channels (Optional)
     */
    realLiveTv?: boolean;
    /**
     * Type of channel playlist streaming urls: Universal, EmbyCon or EmbyNextGen (Mandatory)
     */
    streamType: string;
    /**
     * StreamType Universal only: Time in seconds after streaming is stopped if client has disconnected (Defaults to 10 sec)
     */
    timeout?: (number) | null;
    /**
     * Token
     */
    token: string;
};

export type GetVirtualtvChannelsResponse = (unknown);

export type GetVirtualtvGuideXmlResponse = (unknown);

export type GetVirtualtvGuideData = {
    /**
     * Aspect ratio of program images: Thumb or Poster (Defaults to Thumb)
     */
    imageType?: string;
    /**
     * Matches programs to library items to enable catchup streams (Only for real live tv. Optional)
     */
    matchProgramToLibrary?: boolean;
    /**
     * Returns program for real live tv channels (Optional)
     */
    realLiveTv?: boolean;
    /**
     * Type of channel playlist catchup urls: Universal, EmbyCon or EmbyNextGen (Mandatory)
     */
    streamType: string;
    /**
     * Token
     */
    token: string;
};

export type GetVirtualtvGuideResponse = (unknown);

export type GetWebConfigurationpageResponse = (unknown);

export type GetWebConfigurationpagesResponse = (Array<Api_ConfigurationPageInfo>);

export type GetWebStringsResponse = (unknown);

export type GetWebStringsetResponse = (Array<(string)>);

export type GetAudioByIdUniversalByContainerData = {
    container: string;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
};

export type GetAudioByIdUniversalByContainerResponse = (unknown);

export type HeadAudioByIdUniversalByContainerData = {
    container: string;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
};

export type HeadAudioByIdUniversalByContainerResponse = (unknown);

export type GetAudioByIdUniversalData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
};

export type GetAudioByIdUniversalResponse = (unknown);

export type HeadAudioByIdUniversalData = {
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
};

export type HeadAudioByIdUniversalResponse = (unknown);

export type GetAudioByIdStreamByContainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdStreamByContainerResponse = (unknown);

export type HeadAudioByIdStreamByContainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdStreamByContainerResponse = (unknown);

export type GetAudioByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdStreamResponse = (unknown);

export type HeadAudioByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdStreamResponse = (unknown);

export type GetAudioByIdByStreamfilenameData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    streamFileName: string;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdByStreamfilenameResponse = (unknown);

export type HeadAudioByIdByStreamfilenameData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    streamFileName: string;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdByStreamfilenameResponse = (unknown);

export type GetAudioByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdMasterM3U8Response = (unknown);

export type HeadAudioByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadAudioByIdMasterM3U8Response = (unknown);

export type GetAudioByIdLiveM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdLiveM3U8Response = (unknown);

export type GetAudioByIdMainM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetAudioByIdMainM3U8Response = (unknown);

export type GetVideosByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdMasterM3U8Response = (unknown);

export type HeadVideosByIdMasterM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdMasterM3U8Response = (unknown);

export type GetVideosByIdLiveM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdLiveM3U8Response = (unknown);

export type GetVideosByIdMainM3U8Data = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdMainM3U8Response = (unknown);

export type GetVideosByIdSubtitlesM3U8Data = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle segment format
     */
    manifestSubtitles: string;
    /**
     * The subtitle segment length
     */
    subtitleSegmentLength: number;
};

export type GetVideosByIdSubtitlesM3U8Response = (unknown);

export type GetVideosByIdLiveSubtitlesM3U8Data = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle segment format
     */
    manifestSubtitles: string;
    /**
     * The subtitle segment length
     */
    subtitleSegmentLength: number;
};

export type GetVideosByIdLiveSubtitlesM3U8Response = (unknown);

export type GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type GetItemsByIdExternalidinfosData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetItemsByIdExternalidinfosResponse = (Array<ExternalIdInfo>);

export type PostItemsRemotesearchTrailerData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_TrailerInfo;
};

export type PostItemsRemotesearchTrailerResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchBookData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_BookInfo;
};

export type PostItemsRemotesearchBookResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMovieData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_MovieInfo;
};

export type PostItemsRemotesearchMovieResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchSeriesData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_SeriesInfo;
};

export type PostItemsRemotesearchSeriesResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchGameData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_GameInfo;
};

export type PostItemsRemotesearchGameResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchBoxsetData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_ItemLookupInfo;
};

export type PostItemsRemotesearchBoxsetResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMusicvideoData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_MusicVideoInfo;
};

export type PostItemsRemotesearchMusicvideoResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchPersonData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_PersonLookupInfo;
};

export type PostItemsRemotesearchPersonResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMusicalbumData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_AlbumInfo;
};

export type PostItemsRemotesearchMusicalbumResponse = (Array<RemoteSearchResult>);

export type PostItemsRemotesearchMusicartistData = {
    /**
     * RemoteSearchQuery`1:
     */
    requestBody: RemoteSearchQuery_ArtistInfo;
};

export type PostItemsRemotesearchMusicartistResponse = (Array<RemoteSearchResult>);

export type GetItemsRemotesearchImageData = {
    /**
     * The image url
     */
    imageUrl: string;
    providerName: string;
};

export type GetItemsRemotesearchImageResponse = (unknown);

export type PostItemsMetadataResetData = {
    /**
     * The item ids
     */
    itemIds: string;
};

export type PostItemsMetadataResetResponse = (unknown);

export type PostItemsRemotesearchApplyByIdData = {
    /**
     * The item id
     */
    id: string;
    /**
     * Whether or not to replace all images
     */
    replaceAllImages?: boolean;
    /**
     * RemoteSearchResult:
     */
    requestBody: RemoteSearchResult;
};

export type PostItemsRemotesearchApplyByIdResponse = (unknown);

export type PostItemsByIdRefreshData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * Specifies the image refresh mode
     */
    imageRefreshMode?: MetadataRefreshMode;
    /**
     * Specifies the metadata refresh mode
     */
    metadataRefreshMode?: MetadataRefreshMode;
    /**
     * Indicates if the refresh should occur recursively.
     */
    recursive?: boolean;
    /**
     * Determines if images should be replaced. Only applicable if mode is FullRefresh
     */
    replaceAllImages?: boolean;
    /**
     * Determines if metadata should be replaced. Only applicable if mode is FullRefresh
     */
    replaceAllMetadata?: boolean;
};

export type PostItemsByIdRefreshResponse = (unknown);

export type GetItemsByIdThumbnailsetData = {
    /**
     * Item Id
     */
    id: string;
    width: number;
};

export type GetItemsByIdThumbnailsetResponse = (RokuMetadata_Api_ThumbnailSetInfo);

export type GetVideosByIdIndexBifData = {
    /**
     * Item Id
     */
    id: string;
    width: number;
};

export type GetVideosByIdIndexBifResponse = (unknown);

export type PostNotificationsServicesTestData = {
    /**
     * UserNotificationInfo:
     */
    requestBody: UserNotificationInfo;
};

export type PostNotificationsServicesTestResponse = (unknown);

export type GetNotificationsServicesDefaultsResponse = (UserNotificationInfo);

export type GetSystemActivitylogEntriesData = {
    /**
     * Optional. The maximum number of records to return
     */
    limit?: (number) | null;
    /**
     * Optional. The minimum date. Format = ISO
     */
    minDate?: string;
    /**
     * Optional. The record index to start at. All items with a lower index will be dropped from the results.
     */
    startIndex?: (number) | null;
};

export type GetSystemActivitylogEntriesResponse = (QueryResult_ActivityLogEntry);

export type GetUsersByUseridSuggestionsData = {
    /**
     * Optional, include image information in output
     */
    enableImages?: (boolean) | null;
    /**
     * Optional. The image types to include in the output.
     */
    enableImageTypes?: string;
    /**
     * Optional, include user data
     */
    enableUserData?: (boolean) | null;
    /**
     * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     */
    fields?: string;
    /**
     * Optional, the max number of images to return, per image type
     */
    imageTypeLimit?: (number) | null;
    userId: string;
};

export type GetUsersByUseridSuggestionsResponse = (QueryResult_BaseItemDto);

export type GetUsersByUseridViewsData = {
    /**
     * Whether or not to include external views such as channels or live tv
     */
    includeExternalContent: (boolean) | null;
    /**
     * User Id
     */
    userId: string;
};

export type GetUsersByUseridViewsResponse = (QueryResult_BaseItemDto);

export type GetVideosByIdStreamByContainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdStreamByContainerResponse = (unknown);

export type HeadVideosByIdStreamByContainerData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdStreamByContainerResponse = (unknown);

export type GetVideosByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdStreamResponse = (unknown);

export type HeadVideosByIdStreamData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdStreamResponse = (unknown);

export type GetVideosByIdByStreamfilenameData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    streamFileName: string;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type GetVideosByIdByStreamfilenameResponse = (unknown);

export type HeadVideosByIdByStreamfilenameData = {
    /**
     * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     */
    _static?: boolean;
    /**
     * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     */
    audioBitRate?: (number) | null;
    /**
     * Optional. Specify a specific number of audio channels to encode to, e.g. 2
     */
    audioChannels?: (number) | null;
    /**
     * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     */
    audioCodec?: string;
    /**
     * Optional. Specify a specific audio sample rate, e.g. 44100
     */
    audioSampleRate?: (number) | null;
    /**
     * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     */
    audioStreamIndex?: (number) | null;
    /**
     * Container
     */
    container: string;
    /**
     * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     */
    copyTimestamps?: boolean;
    /**
     * The device id of the client requesting. Used to stop encoding processes when needed.
     */
    deviceId?: string;
    /**
     * Optional. The dlna device profile id to utilize.
     */
    deviceProfileId?: string;
    /**
     * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     */
    enableAutoStreamCopy?: boolean;
    /**
     * Optional. The fixed vertical resolution of the encoded video.
     */
    height?: (number) | null;
    /**
     * Item Id
     */
    id: string;
    /**
     * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     */
    maxAudioChannels?: (number) | null;
    /**
     * Optional. The maximum vertical resolution of the encoded video.
     */
    maxHeight?: (number) | null;
    /**
     * Optional.
     */
    maxVideoBitDepth?: (number) | null;
    /**
     * Optional. The maximum horizontal resolution of the encoded video.
     */
    maxWidth?: (number) | null;
    /**
     * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     */
    startTimeTicks?: (number) | null;
    streamFileName: string;
    /**
     * Optional. Specify the subtitle delivery method.
     */
    subtitleMethod?: SubtitleDeliveryMethod;
    /**
     * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     */
    subtitleStreamIndex?: (number) | null;
    /**
     * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     */
    videoBitRate?: (number) | null;
    /**
     * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     */
    videoCodec?: string;
    /**
     * Optional. The index of the video stream to use. If omitted the first video stream will be used.
     */
    videoStreamIndex?: (number) | null;
    /**
     * Optional. The fixed horizontal resolution of the encoded video.
     */
    width?: (number) | null;
};

export type HeadVideosByIdByStreamfilenameResponse = (unknown);

export type DeleteItemsByIdSubtitlesByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type DeleteItemsByIdSubtitlesByIndexResponse = (unknown);

export type GetProvidersSubtitlesSubtitlesByIdData = {
    /**
     * Item Id
     */
    id: string;
};

export type GetProvidersSubtitlesSubtitlesByIdResponse = (unknown);

export type DeleteVideosByIdSubtitlesByIndexData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type DeleteVideosByIdSubtitlesByIndexResponse = (unknown);

export type GetItemsByIdRemotesearchSubtitlesByLanguageData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * IsForced
     */
    isForced?: (boolean) | null;
    /**
     * IsHearingImpaired
     */
    isHearingImpaired?: (boolean) | null;
    /**
     * IsPerfectMatch
     */
    isPerfectMatch?: (boolean) | null;
    /**
     * Language
     */
    language: string;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type GetItemsByIdRemotesearchSubtitlesByLanguageResponse = (Array<RemoteSubtitleInfo>);

export type PostItemsByIdSubtitlesByIndexDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type PostItemsByIdSubtitlesByIndexDeleteResponse = (unknown);

export type PostItemsByIdRemotesearchSubtitlesBySubtitleidData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * SubtitleId
     */
    subtitleId: string;
};

export type PostItemsByIdRemotesearchSubtitlesBySubtitleidResponse = (Subtitles_SubtitleDownloadResult);

export type PostVideosByIdSubtitlesByIndexDeleteData = {
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
};

export type PostVideosByIdSubtitlesByIndexDeleteResponse = (unknown);

export type GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks?: number;
};

export type GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponse = (unknown);

export type GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks?: number;
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponse = (unknown);

export type GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks: number;
};

export type GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponse = (unknown);

export type GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData = {
    /**
     * CopyTimestamps
     */
    copyTimestamps?: boolean;
    /**
     * EndPositionTicks
     */
    endPositionTicks?: (number) | null;
    /**
     * Format
     */
    format: string;
    /**
     * Item Id
     */
    id: string;
    /**
     * The subtitle stream index
     */
    index: number;
    /**
     * MediaSourceId
     */
    mediaSourceId: string;
    /**
     * StartPositionTicks
     */
    startPositionTicks: number;
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponse = (unknown);

export type GetLivetvLivestreamfilesByIdStreamByContainerData = {
    container: string;
    id: string;
};

export type GetLivetvLivestreamfilesByIdStreamByContainerResponse = (unknown);

export type GetLivetvLiverecordingsByIdStreamData = {
    id: string;
};

export type GetLivetvLiverecordingsByIdStreamResponse = (unknown);

export type GetLivetvLivestreamfilesByIdHlsMasterM3U8Data = {
    id: string;
};

export type GetLivetvLivestreamfilesByIdHlsMasterM3U8Response = (unknown);

export type HeadLivetvLivestreamfilesByIdHlsMasterM3U8Data = {
    id: string;
};

export type HeadLivetvLivestreamfilesByIdHlsMasterM3U8Response = (unknown);

export type GetLivetvLiverecordingsByIdHlsMasterM3U8Data = {
    id: string;
};

export type GetLivetvLiverecordingsByIdHlsMasterM3U8Response = (unknown);

export type HeadLivetvLiverecordingsByIdHlsMasterM3U8Data = {
    id: string;
};

export type HeadLivetvLiverecordingsByIdHlsMasterM3U8Response = (unknown);

export type GetLivetvLiverecordingsByIdHlsLiveM3U8Data = {
    id: string;
};

export type GetLivetvLiverecordingsByIdHlsLiveM3U8Response = (unknown);

export type HeadLivetvLiverecordingsByIdHlsLiveM3U8Data = {
    id: string;
};

export type HeadLivetvLiverecordingsByIdHlsLiveM3U8Response = (unknown);

export type GetLivetvLivestreamfilesByIdHlsLiveM3U8Data = {
    id: string;
};

export type GetLivetvLivestreamfilesByIdHlsLiveM3U8Response = (unknown);

export type HeadLivetvLivestreamfilesByIdHlsLiveM3U8Data = {
    id: string;
};

export type HeadLivetvLivestreamfilesByIdHlsLiveM3U8Response = (unknown);

export type GetLivetvLivestreamfilesByIdHlsBySegmentData = {
    id: string;
    segment: string;
};

export type GetLivetvLivestreamfilesByIdHlsBySegmentResponse = (unknown);

export type HeadLivetvLivestreamfilesByIdHlsBySegmentData = {
    id: string;
    segment: string;
};

export type HeadLivetvLivestreamfilesByIdHlsBySegmentResponse = (unknown);

export type GetLivetvLiverecordingsByIdHlsBySegmentData = {
    id: string;
    segment: string;
};

export type GetLivetvLiverecordingsByIdHlsBySegmentResponse = (unknown);

export type HeadLivetvLiverecordingsByIdHlsBySegmentData = {
    id: string;
    segment: string;
};

export type HeadLivetvLiverecordingsByIdHlsBySegmentResponse = (unknown);

export type GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);

export type GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerData = {
    id: string;
    playlistId: string;
    segmentContainer: string;
    segmentId: string;
};

export type GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse = (unknown);