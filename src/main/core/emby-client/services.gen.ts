// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import type { BaseHttpRequest } from './core/BaseHttpRequest';
import type { GetArtistsData, GetArtistsResponse, GetArtistsByNameData, GetArtistsByNameResponse, GetArtistsAlbumartistsData, GetArtistsAlbumartistsResponse, GetAudiocodecsData, GetAudiocodecsResponse, GetContainersData, GetContainersResponse, GetSubtitlecodecsData, GetSubtitlecodecsResponse, GetTagsData, GetTagsResponse, GetVideocodecsData, GetVideocodecsResponse, GetYearsData, GetYearsResponse, GetArtistsPrefixesData, GetArtistsPrefixesResponse, GetItemsPrefixesData, GetItemsPrefixesResponse, GetChannelsData, GetChannelsResponse, GetChannelsByIdItemsResponse, GetChannelsItemsLatestResponse, PostCollectionsData, PostCollectionsResponse, PostCollectionsByIdItemsData, PostCollectionsByIdItemsResponse, DeleteCollectionsByIdItemsData, DeleteCollectionsByIdItemsResponse, GetDevicesResponse, DeleteDevicesData, DeleteDevicesResponse, PostDevicesOptionsData, PostDevicesOptionsResponse, GetDevicesOptionsData, GetDevicesOptionsResponse, GetDevicesInfoData, GetDevicesInfoResponse, GetDevicesCamerauploadsData, GetDevicesCamerauploadsResponse, PostDevicesCamerauploadsData, PostDevicesCamerauploadsResponse, GetGamegenresData, GetGamegenresResponse, GetGamegenresByNameData, GetGamegenresByNameResponse, GetGenresData, GetGenresResponse, GetGenresByNameData, GetGenresByNameResponse, GetItemsData, GetItemsResponse, GetUsersByUseridItemsData, GetUsersByUseridItemsResponse, GetUsersByUseridItemsResumeData, GetUsersByUseridItemsResumeResponse, DeleteItemsData, DeleteItemsResponse, GetItemsCountsData, GetItemsCountsResponse, DeleteItemsByIdData, DeleteItemsByIdResponse, GetLibrariesAvailableoptionsResponse, GetLibrarySelectablemediafoldersResponse, GetLibraryMediafoldersData, GetLibraryMediafoldersResponse, GetLibraryPhysicalpathsResponse, PostLibraryRefreshResponse, GetAlbumsByIdSimilarData, GetAlbumsByIdSimilarResponse, GetArtistsByIdSimilarData, GetArtistsByIdSimilarResponse, GetGamesByIdSimilarData, GetGamesByIdSimilarResponse, GetItemsByIdDeleteinfoData, GetItemsByIdDeleteinfoResponse, GetItemsByIdSimilarData, GetItemsByIdSimilarResponse, GetItemsByIdDownloadData, GetItemsByIdDownloadResponse, GetItemsByIdFileData, GetItemsByIdFileResponse, GetItemsByIdAncestorsData, GetItemsByIdAncestorsResponse, GetItemsByIdCriticreviewsData, GetItemsByIdCriticreviewsResponse, GetItemsByIdThememediaData, GetItemsByIdThememediaResponse, GetItemsByIdThemesongsData, GetItemsByIdThemesongsResponse, GetItemsByIdThemevideosData, GetItemsByIdThemevideosResponse, PostLibrarySeriesAddedResponse, PostLibrarySeriesUpdatedResponse, PostLibraryMediaUpdatedData, PostLibraryMediaUpdatedResponse, PostLibraryMoviesAddedResponse, PostLibraryMoviesUpdatedResponse, GetMoviesByIdSimilarData, GetMoviesByIdSimilarResponse, GetShowsByIdSimilarData, GetShowsByIdSimilarResponse, GetTrailersByIdSimilarData, GetTrailersByIdSimilarResponse, GetMusicgenresData, GetMusicgenresResponse, GetMusicgenresByNameData, GetMusicgenresByNameResponse, GetOfficialratingsData, GetOfficialratingsResponse, GetOpenapiResponse, GetOpenapiJsonResponse, GetSwaggerResponse, GetSwaggerJsonResponse, GetPackagesData, GetPackagesResponse, GetPackagesUpdatesData, GetPackagesUpdatesResponse, GetPackagesByNameData, GetPackagesByNameResponse, PostPackagesInstalledByNameData, PostPackagesInstalledByNameResponse, DeletePackagesInstallingByIdData, DeletePackagesInstallingByIdResponse, GetPersonsData, GetPersonsResponse, GetPersonsByNameData, GetPersonsByNameResponse, PostPlaylistsData, PostPlaylistsResponse, PostPlaylistsByIdItemsData, PostPlaylistsByIdItemsResponse, DeletePlaylistsByIdItemsData, DeletePlaylistsByIdItemsResponse, GetPlaylistsByIdItemsData, GetPlaylistsByIdItemsResponse, PostPlaylistsByIdItemsByItemidMoveByNewindexData, PostPlaylistsByIdItemsByItemidMoveByNewindexResponse, GetPluginsResponse, DeletePluginsByIdData, DeletePluginsByIdResponse, GetPluginsByIdThumbData, GetPluginsByIdThumbResponse, GetPluginsByIdConfigurationData, GetPluginsByIdConfigurationResponse, PostPluginsByIdConfigurationData, PostPluginsByIdConfigurationResponse, GetScheduledtasksData, GetScheduledtasksResponse, GetScheduledtasksByIdData, GetScheduledtasksByIdResponse, PostScheduledtasksRunningByIdData, PostScheduledtasksRunningByIdResponse, DeleteScheduledtasksRunningByIdData, DeleteScheduledtasksRunningByIdResponse, PostScheduledtasksByIdTriggersData, PostScheduledtasksByIdTriggersResponse, GetSessionsData, GetSessionsResponse, GetAuthProvidersResponse, PostAuthKeysData, PostAuthKeysResponse, GetAuthKeysResponse, PostSessionsLogoutResponse, PostSessionsCapabilitiesData, PostSessionsCapabilitiesResponse, DeleteAuthKeysByKeyData, DeleteAuthKeysByKeyResponse, PostSessionsByIdViewingData, PostSessionsByIdViewingResponse, PostSessionsByIdMessageData, PostSessionsByIdMessageResponse, PostSessionsByIdPlayingData, PostSessionsByIdPlayingResponse, PostSessionsByIdCommandData, PostSessionsByIdCommandResponse, PostSessionsCapabilitiesFullData, PostSessionsCapabilitiesFullResponse, PostSessionsByIdPlayingByCommandData, PostSessionsByIdPlayingByCommandResponse, PostSessionsByIdSystemByCommandData, PostSessionsByIdSystemByCommandResponse, PostSessionsByIdCommandByCommandData, PostSessionsByIdCommandByCommandResponse, PostSessionsByIdUsersByUseridData, PostSessionsByIdUsersByUseridResponse, DeleteSessionsByIdUsersByUseridData, DeleteSessionsByIdUsersByUseridResponse, GetStudiosData, GetStudiosResponse, GetStudiosByNameData, GetStudiosByNameResponse, GetTrailersData, GetTrailersResponse, GetUsersData, GetUsersResponse, GetUsersPublicResponse, GetUsersByIdData, GetUsersByIdResponse, DeleteUsersByIdData, DeleteUsersByIdResponse, PostUsersByIdData, PostUsersByIdResponse, PostUsersAuthenticatebynameData, PostUsersAuthenticatebynameResponse, PostUsersNewData, PostUsersNewResponse, PostUsersForgotpasswordData, PostUsersForgotpasswordResponse, PostUsersByIdAuthenticateData, PostUsersByIdAuthenticateResponse, PostUsersByIdPasswordData, PostUsersByIdPasswordResponse, PostUsersByIdEasypasswordData, PostUsersByIdEasypasswordResponse, PostUsersForgotpasswordPinData, PostUsersForgotpasswordPinResponse, PostUsersByIdConfigurationData, PostUsersByIdConfigurationResponse, PostUsersByIdPolicyData, PostUsersByIdPolicyResponse, GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData, GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse, HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData, HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse, GetItemsByIdImagesData, GetItemsByIdImagesResponse, GetArtistsByNameImagesByTypeData, GetArtistsByNameImagesByTypeResponse, HeadArtistsByNameImagesByTypeData, HeadArtistsByNameImagesByTypeResponse, GetGamegenresByNameImagesByTypeData, GetGamegenresByNameImagesByTypeResponse, HeadGamegenresByNameImagesByTypeData, HeadGamegenresByNameImagesByTypeResponse, GetGenresByNameImagesByTypeData, GetGenresByNameImagesByTypeResponse, HeadGenresByNameImagesByTypeData, HeadGenresByNameImagesByTypeResponse, GetItemsByIdImagesByTypeData, GetItemsByIdImagesByTypeResponse, HeadItemsByIdImagesByTypeData, HeadItemsByIdImagesByTypeResponse, PostItemsByIdImagesByTypeData, PostItemsByIdImagesByTypeResponse, DeleteItemsByIdImagesByTypeData, DeleteItemsByIdImagesByTypeResponse, GetMusicgenresByNameImagesByTypeData, GetMusicgenresByNameImagesByTypeResponse, HeadMusicgenresByNameImagesByTypeData, HeadMusicgenresByNameImagesByTypeResponse, GetPersonsByNameImagesByTypeData, GetPersonsByNameImagesByTypeResponse, HeadPersonsByNameImagesByTypeData, HeadPersonsByNameImagesByTypeResponse, GetStudiosByNameImagesByTypeData, GetStudiosByNameImagesByTypeResponse, HeadStudiosByNameImagesByTypeData, HeadStudiosByNameImagesByTypeResponse, GetUsersByIdImagesByTypeData, GetUsersByIdImagesByTypeResponse, HeadUsersByIdImagesByTypeData, HeadUsersByIdImagesByTypeResponse, PostUsersByIdImagesByTypeData, PostUsersByIdImagesByTypeResponse, DeleteUsersByIdImagesByTypeData, DeleteUsersByIdImagesByTypeResponse, GetArtistsByNameImagesByTypeByIndexData, GetArtistsByNameImagesByTypeByIndexResponse, HeadArtistsByNameImagesByTypeByIndexData, HeadArtistsByNameImagesByTypeByIndexResponse, GetGamegenresByNameImagesByTypeByIndexData, GetGamegenresByNameImagesByTypeByIndexResponse, HeadGamegenresByNameImagesByTypeByIndexData, HeadGamegenresByNameImagesByTypeByIndexResponse, GetGenresByNameImagesByTypeByIndexData, GetGenresByNameImagesByTypeByIndexResponse, HeadGenresByNameImagesByTypeByIndexData, HeadGenresByNameImagesByTypeByIndexResponse, GetItemsByIdImagesByTypeByIndexData, GetItemsByIdImagesByTypeByIndexResponse, HeadItemsByIdImagesByTypeByIndexData, HeadItemsByIdImagesByTypeByIndexResponse, PostItemsByIdImagesByTypeByIndexData, PostItemsByIdImagesByTypeByIndexResponse, DeleteItemsByIdImagesByTypeByIndexData, DeleteItemsByIdImagesByTypeByIndexResponse, GetMusicgenresByNameImagesByTypeByIndexData, GetMusicgenresByNameImagesByTypeByIndexResponse, HeadMusicgenresByNameImagesByTypeByIndexData, HeadMusicgenresByNameImagesByTypeByIndexResponse, GetPersonsByNameImagesByTypeByIndexData, GetPersonsByNameImagesByTypeByIndexResponse, HeadPersonsByNameImagesByTypeByIndexData, HeadPersonsByNameImagesByTypeByIndexResponse, GetStudiosByNameImagesByTypeByIndexData, GetStudiosByNameImagesByTypeByIndexResponse, HeadStudiosByNameImagesByTypeByIndexData, HeadStudiosByNameImagesByTypeByIndexResponse, GetUsersByIdImagesByTypeByIndexData, GetUsersByIdImagesByTypeByIndexResponse, HeadUsersByIdImagesByTypeByIndexData, HeadUsersByIdImagesByTypeByIndexResponse, PostUsersByIdImagesByTypeByIndexData, PostUsersByIdImagesByTypeByIndexResponse, DeleteUsersByIdImagesByTypeByIndexData, DeleteUsersByIdImagesByTypeByIndexResponse, PostItemsByIdImagesByTypeByIndexIndexData, PostItemsByIdImagesByTypeByIndexIndexResponse, GetArtistsInstantmixData, GetArtistsInstantmixResponse, GetMusicgenresInstantmixData, GetMusicgenresInstantmixResponse, GetAlbumsByIdInstantmixData, GetAlbumsByIdInstantmixResponse, GetItemsByIdInstantmixData, GetItemsByIdInstantmixResponse, GetMusicgenresByNameInstantmixData, GetMusicgenresByNameInstantmixResponse, GetPlaylistsByIdInstantmixData, GetPlaylistsByIdInstantmixResponse, GetSongsByIdInstantmixData, GetSongsByIdInstantmixResponse, GetBrandingConfigurationResponse, GetBrandingCssResponse, GetBrandingCssCssResponse, GetConnectPendingResponse, GetConnectExchangeData, GetConnectExchangeResponse, PostUsersByIdConnectLinkData, PostUsersByIdConnectLinkResponse, DeleteUsersByIdConnectLinkData, DeleteUsersByIdConnectLinkResponse, GetDisplaypreferencesByIdData, GetDisplaypreferencesByIdResponse, PostDisplaypreferencesByDisplaypreferencesidData, PostDisplaypreferencesByDisplaypreferencesidResponse, GetDlnaProfileinfosResponse, PostDlnaProfilesData, PostDlnaProfilesResponse, GetDlnaProfilesByIdData, GetDlnaProfilesByIdResponse, DeleteDlnaProfilesByIdData, DeleteDlnaProfilesByIdResponse, PostDlnaProfilesByIdData, PostDlnaProfilesByIdResponse, GetDlnaProfilesDefaultResponse, PostEnvironmentValidatepathData, PostEnvironmentValidatepathResponse, GetEnvironmentDefaultdirectorybrowserResponse, GetEnvironmentDirectorycontentsData, GetEnvironmentDirectorycontentsResponse, GetEnvironmentNetworksharesData, GetEnvironmentNetworksharesResponse, GetEnvironmentDrivesResponse, GetEnvironmentNetworkdevicesResponse, GetEnvironmentParentpathData, GetEnvironmentParentpathResponse, GetGamesSystemsummariesData, GetGamesSystemsummariesResponse, GetImagesMediainfoResponse, GetImagesRatingsResponse, GetImagesGeneralResponse, GetImagesGeneralByNameByTypeData, GetImagesGeneralByNameByTypeResponse, GetImagesRatingsByThemeByNameData, GetImagesRatingsByThemeByNameResponse, GetImagesMediainfoByThemeByNameData, GetImagesMediainfoByThemeByNameResponse, GetImagesRemoteData, GetImagesRemoteResponse, GetItemsByIdRemoteimagesData, GetItemsByIdRemoteimagesResponse, GetItemsByIdRemoteimagesProvidersData, GetItemsByIdRemoteimagesProvidersResponse, PostItemsByIdRemoteimagesDownloadData, PostItemsByIdRemoteimagesDownloadResponse, GetItemsFilters2Data, GetItemsFilters2Response, GetItemsFiltersData, GetItemsFiltersResponse, PostItemsByItemidData, PostItemsByItemidResponse, GetItemsByItemidMetadataeditorData, GetItemsByItemidMetadataeditorResponse, GetItemsFileResponse, GetVideosByIdByContainerData, GetVideosByIdByContainerResponse, HeadVideosByIdByContainerData, HeadVideosByIdByContainerResponse, GetVideosByIdStreamData, GetVideosByIdStreamResponse, HeadVideosByIdStreamData, HeadVideosByIdStreamResponse, GetLibraryVirtualfoldersResponse, PostLibraryVirtualfoldersData, PostLibraryVirtualfoldersResponse, DeleteLibraryVirtualfoldersResponse, PostLibraryVirtualfoldersLibraryoptionsData, PostLibraryVirtualfoldersLibraryoptionsResponse, PostLibraryVirtualfoldersNameData, PostLibraryVirtualfoldersNameResponse, PostLibraryVirtualfoldersPathsData, PostLibraryVirtualfoldersPathsResponse, DeleteLibraryVirtualfoldersPathsResponse, PostLibraryVirtualfoldersPathsUpdateData, PostLibraryVirtualfoldersPathsUpdateResponse, PostLivestreamsOpenData, PostLivestreamsOpenResponse, PostLivestreamsCloseData, PostLivestreamsCloseResponse, PostLivestreamsMediainfoData, PostLivestreamsMediainfoResponse, GetPlaybackBitratetestData, GetPlaybackBitratetestResponse, GetItemsByIdPlaybackinfoData, GetItemsByIdPlaybackinfoResponse, PostItemsByIdPlaybackinfoData, PostItemsByIdPlaybackinfoResponse, OptionsLivetvChannelmappingsData, OptionsLivetvChannelmappingsResponse, GetLivetvChannelmappingsData, GetLivetvChannelmappingsResponse, HeadLivetvChannelmappingsData, HeadLivetvChannelmappingsResponse, PostLivetvChannelmappingsData, PostLivetvChannelmappingsResponse, PutLivetvChannelmappingsData, PutLivetvChannelmappingsResponse, DeleteLivetvChannelmappingsData, DeleteLivetvChannelmappingsResponse, TraceLivetvChannelmappingsData, TraceLivetvChannelmappingsResponse, PatchLivetvChannelmappingsData, PatchLivetvChannelmappingsResponse, OptionsLivetvChannelmappingoptionsData, OptionsLivetvChannelmappingoptionsResponse, GetLivetvChannelmappingoptionsData, GetLivetvChannelmappingoptionsResponse, HeadLivetvChannelmappingoptionsData, HeadLivetvChannelmappingoptionsResponse, PostLivetvChannelmappingoptionsData, PostLivetvChannelmappingoptionsResponse, PutLivetvChannelmappingoptionsData, PutLivetvChannelmappingoptionsResponse, DeleteLivetvChannelmappingoptionsData, DeleteLivetvChannelmappingoptionsResponse, TraceLivetvChannelmappingoptionsData, TraceLivetvChannelmappingoptionsResponse, PatchLivetvChannelmappingoptionsData, PatchLivetvChannelmappingoptionsResponse, PostLivetvListingprovidersData, PostLivetvListingprovidersResponse, DeleteLivetvListingprovidersData, DeleteLivetvListingprovidersResponse, GetLivetvListingprovidersResponse, GetLivetvTunerhostsResponse, PostLivetvTunerhostsData, PostLivetvTunerhostsResponse, DeleteLivetvTunerhostsData, DeleteLivetvTunerhostsResponse, GetLivetvInfoResponse, GetLivetvChannelsData, GetLivetvChannelsResponse, GetLivetvProgramsData, GetLivetvProgramsResponse, PostLivetvProgramsData, PostLivetvProgramsResponse, GetLivetvRecordingsData, GetLivetvRecordingsResponse, GetLivetvTimersData, GetLivetvTimersResponse, PostLivetvTimersData, PostLivetvTimersResponse, GetLivetvSeriestimersData, GetLivetvSeriestimersResponse, PostLivetvSeriestimersData, PostLivetvSeriestimersResponse, GetLivetvGuideinfoResponse, GetLivetvTunerhostsTypesResponse, GetLivetvRecordingsFoldersData, GetLivetvRecordingsFoldersResponse, GetLivetvTunersDiscvoverResponse, GetLivetvListingprovidersDefaultResponse, GetLivetvListingprovidersLineupsData, GetLivetvListingprovidersLineupsResponse, GetLivetvChannelsByIdData, GetLivetvChannelsByIdResponse, GetLivetvProgramsRecommendedData, GetLivetvProgramsRecommendedResponse, GetLivetvRecordingsSeriesData, GetLivetvRecordingsSeriesResponse, GetLivetvRecordingsByIdData, GetLivetvRecordingsByIdResponse, DeleteLivetvRecordingsByIdData, DeleteLivetvRecordingsByIdResponse, GetLivetvTimersByIdData, GetLivetvTimersByIdResponse, DeleteLivetvTimersByIdData, DeleteLivetvTimersByIdResponse, PostLivetvTimersByIdData, PostLivetvTimersByIdResponse, GetLivetvSeriestimersByIdData, GetLivetvSeriestimersByIdResponse, DeleteLivetvSeriestimersByIdData, DeleteLivetvSeriestimersByIdResponse, PostLivetvSeriestimersByIdData, PostLivetvSeriestimersByIdResponse, GetLivetvTimersDefaultsData, GetLivetvTimersDefaultsResponse, GetLivetvRecordingsGroupsData, GetLivetvRecordingsGroupsResponse, GetLivetvListingprovidersAvailableResponse, GetLivetvLiverecordingsByIdStreamData, GetLivetvLiverecordingsByIdStreamResponse, GetLivetvLivestreamfilesByIdByContainerData, GetLivetvLivestreamfilesByIdByContainerResponse, GetLivetvListingprovidersSchedulesdirectCountriesResponse, GetLivetvRecordingsGroupsByIdData, GetLivetvRecordingsGroupsByIdResponse, PostLivetvTunersByIdResetData, PostLivetvTunersByIdResetResponse, GetLocalizationParentalratingsResponse, GetLocalizationOptionsResponse, GetLocalizationCountriesResponse, GetLocalizationCulturesResponse, GetMoviesRecommendationsData, GetMoviesRecommendationsResponse, GetNewsProductData, GetNewsProductResponse, GetNotificationsTypesResponse, GetNotificationsServicesResponse, PostNotificationsAdminData, PostNotificationsAdminResponse, GetNotificationsByUseridData, GetNotificationsByUseridResponse, GetNotificationsByUseridSummaryData, GetNotificationsByUseridSummaryResponse, PostNotificationsByUseridReadData, PostNotificationsByUseridReadResponse, PostNotificationsByUseridUnreadData, PostNotificationsByUseridUnreadResponse, GetReportsActivitiesData, GetReportsActivitiesResponse, GetReportsHeadersData, GetReportsHeadersResponse, GetReportsItemsData, GetReportsItemsResponse, GetReportsItemsDownloadData, GetReportsItemsDownloadResponse, GetSearchHintsData, GetSearchHintsResponse, PostSessionsPlayingData, PostSessionsPlayingResponse, PostSessionsPlayingProgressData, PostSessionsPlayingProgressResponse, PostSessionsPlayingPingData, PostSessionsPlayingPingResponse, PostSessionsPlayingStoppedData, PostSessionsPlayingStoppedResponse, PostUsersByUseridPlayeditemsByIdData, PostUsersByUseridPlayeditemsByIdResponse, DeleteUsersByUseridPlayeditemsByIdData, DeleteUsersByUseridPlayeditemsByIdResponse, PostUsersByUseridPlayingitemsByIdData, PostUsersByUseridPlayingitemsByIdResponse, DeleteUsersByUseridPlayingitemsByIdData, DeleteUsersByUseridPlayingitemsByIdResponse, PostUsersByUseridPlayingitemsByIdProgressData, PostUsersByUseridPlayingitemsByIdProgressResponse, GetShowsUpcomingData, GetShowsUpcomingResponse, GetShowsNextupData, GetShowsNextupResponse, GetShowsByIdSeasonsData, GetShowsByIdSeasonsResponse, GetShowsByIdEpisodesData, GetShowsByIdEpisodesResponse, GetSyncTargetsData, GetSyncTargetsResponse, GetSyncJobsResponse, PostSyncJobsData, PostSyncJobsResponse, GetSyncJobitemsResponse, GetSyncOptionsData, GetSyncOptionsResponse, PostSyncOfflineactionsData, PostSyncOfflineactionsResponse, PostSyncDataData, PostSyncDataResponse, PostSyncByItemidStatusData, PostSyncByItemidStatusResponse, GetSyncJobsByIdData, GetSyncJobsByIdResponse, DeleteSyncJobsByIdData, DeleteSyncJobsByIdResponse, PostSyncJobsByIdData, PostSyncJobsByIdResponse, PostSyncItemsCancelData, PostSyncItemsCancelResponse, DeleteSyncByTargetidItemsData, DeleteSyncByTargetidItemsResponse, GetSyncItemsReadyData, GetSyncItemsReadyResponse, DeleteSyncJobitemsByIdData, DeleteSyncJobitemsByIdResponse, PostSyncJobitemsByIdTransferredData, PostSyncJobitemsByIdTransferredResponse, GetSyncJobitemsByIdFileData, GetSyncJobitemsByIdFileResponse, GetSyncJobitemsByIdAdditionalfilesData, GetSyncJobitemsByIdAdditionalfilesResponse, PostSyncJobitemsByIdEnableData, PostSyncJobitemsByIdEnableResponse, PostSyncJobitemsByIdMarkforremovalData, PostSyncJobitemsByIdMarkforremovalResponse, PostSyncJobitemsByIdUnmarkforremovalData, PostSyncJobitemsByIdUnmarkforremovalResponse, GetSystemConfigurationResponse, PostSystemConfigurationData, PostSystemConfigurationResponse, GetSystemConfigurationByKeyData, GetSystemConfigurationByKeyResponse, PostSystemConfigurationByKeyData, PostSystemConfigurationByKeyResponse, PostSystemPingResponse, GetSystemPingResponse, GetSystemWakeonlaninfoResponse, GetSystemLogsResponse, GetSystemInfoResponse, PostSystemRestartResponse, PostSystemShutdownResponse, GetSystemEndpointResponse, GetSystemLogsLogData, GetSystemLogsLogResponse, GetSystemInfoPublicResponse, GetUserUsageStatsTypeFilterListResponse, GetUserUsageStatsUserActivityData, GetUserUsageStatsUserActivityResponse, GetUserUsageStatsUserListResponse, PostUserUsageStatsImportBackupData, PostUserUsageStatsImportBackupResponse, GetUserUsageStatsLoadBackupData, GetUserUsageStatsLoadBackupResponse, GetUserUsageStatsSaveBackupResponse, GetUserUsageStatsPlayactivityData, GetUserUsageStatsPlayactivityResponse, GetUserUsageStatsHourlyreportData, GetUserUsageStatsHourlyreportResponse, GetUserUsageStatsDurationhistogramreportData, GetUserUsageStatsDurationhistogramreportResponse, GetUserUsageStatsTvshowsreportData, GetUserUsageStatsTvshowsreportResponse, GetUserUsageStatsMoviesreportData, GetUserUsageStatsMoviesreportResponse, PostUserUsageStatsSubmitCustomQueryData, PostUserUsageStatsSubmitCustomQueryResponse, GetUserUsageStatsUserplaylistData, GetUserUsageStatsUserplaylistResponse, GetUserUsageStatsSessionListResponse, GetUserUsageStatsResourceUsageData, GetUserUsageStatsResourceUsageResponse, GetUserUsageStatsProcessListResponse, GetUserUsageStatsByBreakdowntypeBreakdownreportData, GetUserUsageStatsByBreakdowntypeBreakdownreportResponse, GetUserUsageStatsUserManageByActionByIdData, GetUserUsageStatsUserManageByActionByIdResponse, GetUserUsageStatsByUseridByDateGetitemsData, GetUserUsageStatsByUseridByDateGetitemsResponse, PostVideosMergeversionsData, PostVideosMergeversionsResponse, GetVideosByIdAdditionalpartsData, GetVideosByIdAdditionalpartsResponse, DeleteVideosByIdAlternatesourcesData, DeleteVideosByIdAlternatesourcesResponse, DeleteVideosActiveencodingsData, DeleteVideosActiveencodingsResponse, GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerData, GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse, GetWebConfigurationpageResponse, GetWebConfigurationpagesResponse, GetAudioByIdByContainerData, GetAudioByIdByContainerResponse, HeadAudioByIdByContainerData, HeadAudioByIdByContainerResponse, GetAudioByIdUniversalData, GetAudioByIdUniversalResponse, HeadAudioByIdUniversalData, HeadAudioByIdUniversalResponse, GetAudioByIdStreamData, GetAudioByIdStreamResponse, HeadAudioByIdStreamData, HeadAudioByIdStreamResponse, GetAudioByIdMasterM3U8Data, GetAudioByIdMasterM3U8Response, HeadAudioByIdMasterM3U8Data, HeadAudioByIdMasterM3U8Response, GetAudioByIdMainM3U8Data, GetAudioByIdMainM3U8Response, GetVideosByIdMasterM3U8Data, GetVideosByIdMasterM3U8Response, HeadVideosByIdMasterM3U8Data, HeadVideosByIdMasterM3U8Response, GetVideosByIdMainM3U8Data, GetVideosByIdMainM3U8Response, GetVideosByIdSubtitlesM3U8Data, GetVideosByIdSubtitlesM3U8Response, GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse, HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse, GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse, HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse, GetDlnaByUuidDescriptionXmlData, GetDlnaByUuidDescriptionXmlResponse, GetDlnaByUuidDescriptionData, GetDlnaByUuidDescriptionResponse, GetDlnaIconsByFilenameData, GetDlnaIconsByFilenameResponse, GetDlnaByUuidContentdirectoryContentdirectoryXmlData, GetDlnaByUuidContentdirectoryContentdirectoryXmlResponse, GetDlnaByUuidContentdirectoryContentdirectoryData, GetDlnaByUuidContentdirectoryContentdirectoryResponse, GetDlnaByUuidConnectionmanagerConnectionmanagerXmlData, GetDlnaByUuidConnectionmanagerConnectionmanagerXmlResponse, GetDlnaByUuidConnectionmanagerConnectionmanagerData, GetDlnaByUuidConnectionmanagerConnectionmanagerResponse, PostDlnaByUuidContentdirectoryControlData, PostDlnaByUuidContentdirectoryControlResponse, PostDlnaByUuidConnectionmanagerControlData, PostDlnaByUuidConnectionmanagerControlResponse, GetDlnaByUuidIconsByFilenameData, GetDlnaByUuidIconsByFilenameResponse, GetEncodingCodecinformationVideoResponse, GetEncodingCodecconfigurationDefaultsResponse, GetItemsByIdExternalidinfosData, GetItemsByIdExternalidinfosResponse, PostItemsRemotesearchTrailerData, PostItemsRemotesearchTrailerResponse, PostItemsRemotesearchBookData, PostItemsRemotesearchBookResponse, PostItemsRemotesearchMovieData, PostItemsRemotesearchMovieResponse, PostItemsRemotesearchSeriesData, PostItemsRemotesearchSeriesResponse, PostItemsRemotesearchGameData, PostItemsRemotesearchGameResponse, PostItemsRemotesearchBoxsetData, PostItemsRemotesearchBoxsetResponse, PostItemsRemotesearchMusicvideoData, PostItemsRemotesearchMusicvideoResponse, PostItemsRemotesearchPersonData, PostItemsRemotesearchPersonResponse, PostItemsRemotesearchMusicalbumData, PostItemsRemotesearchMusicalbumResponse, PostItemsRemotesearchMusicartistData, PostItemsRemotesearchMusicartistResponse, GetItemsRemotesearchImageData, GetItemsRemotesearchImageResponse, PostItemsRemotesearchApplyByIdData, PostItemsRemotesearchApplyByIdResponse, PostItemsByIdRefreshData, PostItemsByIdRefreshResponse, GetItemsByIdThumbnailsetData, GetItemsByIdThumbnailsetResponse, GetVideosByIdIndexBifData, GetVideosByIdIndexBifResponse, GetLivetvProgramsByIdData, GetLivetvProgramsByIdResponse, GetUsersByUseridItemsLatestData, GetUsersByUseridItemsLatestResponse, GetUsersByUseridItemsByIdData, GetUsersByUseridItemsByIdResponse, GetUsersByUseridItemsRootData, GetUsersByUseridItemsRootResponse, PostUsersByUseridFavoriteitemsByIdData, PostUsersByUseridFavoriteitemsByIdResponse, DeleteUsersByUseridFavoriteitemsByIdData, DeleteUsersByUseridFavoriteitemsByIdResponse, GetUsersByUseridItemsByIdSpecialfeaturesData, GetUsersByUseridItemsByIdSpecialfeaturesResponse, GetUsersByUseridItemsByIdLocaltrailersData, GetUsersByUseridItemsByIdLocaltrailersResponse, GetUsersByUseridItemsByIdIntrosData, GetUsersByUseridItemsByIdIntrosResponse, DeleteUsersByUseridItemsByIdRatingData, DeleteUsersByUseridItemsByIdRatingResponse, PostUsersByUseridItemsByIdRatingData, PostUsersByUseridItemsByIdRatingResponse, GetSystemActivitylogEntriesData, GetSystemActivitylogEntriesResponse, GetUsersByUseridSuggestionsData, GetUsersByUseridSuggestionsResponse, GetUsersByUseridViewsData, GetUsersByUseridViewsResponse, GetUsersByUseridGroupingoptionsData, GetUsersByUseridGroupingoptionsResponse, GetVideosByIdLiveM3U8Data, GetVideosByIdLiveM3U8Response, PostNotificationSmtpTestByUseridData, PostNotificationSmtpTestByUseridResponse, GetProvidersSubtitlesSubtitlesByIdData, GetProvidersSubtitlesSubtitlesByIdResponse, DeleteVideosByIdSubtitlesByIndexData, DeleteVideosByIdSubtitlesByIndexResponse, GetItemsByIdRemotesearchSubtitlesByLanguageData, GetItemsByIdRemotesearchSubtitlesByLanguageResponse, PostItemsByIdRemotesearchSubtitlesBySubtitleidData, PostItemsByIdRemotesearchSubtitlesBySubtitleidResponse, GetVideosByIdByMediasourceidSubtitlesByIndexByFormatData, GetVideosByIdByMediasourceidSubtitlesByIndexByFormatResponse, GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksByFormatData, GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksByFormatResponse } from './types.gen';

export class ArtistsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all artists from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getArtists(data: GetArtistsData = {}): CancelablePromise<GetArtistsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an artist, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The artist name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getArtistsByName(data: GetArtistsByNameData): CancelablePromise<GetArtistsByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets all album artists from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getArtistsAlbumartists(data: GetArtistsAlbumartistsData = {}): CancelablePromise<GetArtistsAlbumartistsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/AlbumArtists',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class TagServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets items based on a query.
     * No authentication required
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getAudiocodecs(data: GetAudiocodecsData = {}): CancelablePromise<GetAudiocodecsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/AudioCodecs',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * No authentication required
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getContainers(data: GetContainersData = {}): CancelablePromise<GetContainersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Containers',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * No authentication required
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getSubtitlecodecs(data: GetSubtitlecodecsData = {}): CancelablePromise<GetSubtitlecodecsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/SubtitleCodecs',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * No authentication required
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getTags(data: GetTagsData = {}): CancelablePromise<GetTagsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Tags',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * No authentication required
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getVideocodecs(data: GetVideocodecsData = {}): CancelablePromise<GetVideocodecsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/VideoCodecs',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * No authentication required
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getYears(data: GetYearsData = {}): CancelablePromise<GetYearsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Years',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * No authentication required
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns NameValuePair Operation successful. Returning a NameValuePair[] object.
     * @throws ApiError
     */
    public getArtistsPrefixes(data: GetArtistsPrefixesData = {}): CancelablePromise<GetArtistsPrefixesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/Prefixes',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * No authentication required
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns NameValuePair Operation successful. Returning a NameValuePair[] object.
     * @throws ApiError
     */
    public getItemsPrefixes(data: GetItemsPrefixesData = {}): CancelablePromise<GetItemsPrefixesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/Prefixes',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ChannelServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets available channels
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getChannels(data: GetChannelsData = {}): CancelablePromise<GetChannelsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Channels',
            query: {
                UserId: data.userId,
                StartIndex: data.startIndex,
                Limit: data.limit
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets channel items
     * Requires authentication as user
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getChannelsByIdItems(): CancelablePromise<GetChannelsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Channels/{Id}/Items',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets channel items
     * Requires authentication as user
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getChannelsItemsLatest(): CancelablePromise<GetChannelsItemsLatestResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Channels/Items/Latest',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class CollectionServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Creates a new collection
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.isLocked Whether or not to lock the new collection.
     * @param data.name The name of the new collection.
     * @param data.parentId Optional - create the collection within a specific folder
     * @param data.ids Item Ids to add to the collection
     * @returns Collections_CollectionCreationResult Operation successful. Returning a CollectionCreationResult object.
     * @throws ApiError
     */
    public postCollections(data: PostCollectionsData = {}): CancelablePromise<PostCollectionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Collections',
            query: {
                IsLocked: data.isLocked,
                Name: data.name,
                ParentId: data.parentId,
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Adds items to a collection
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Item id, comma delimited
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postCollectionsByIdItems(data: PostCollectionsByIdItemsData): CancelablePromise<PostCollectionsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Collections/{Id}/Items',
            path: {
                Id: data.id
            },
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Removes items from a collection
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Item id, comma delimited
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteCollectionsByIdItems(data: DeleteCollectionsByIdItemsData): CancelablePromise<DeleteCollectionsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Collections/{Id}/Items',
            path: {
                Id: data.id
            },
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class DeviceServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all devices
     * Requires authentication as administrator
     * @returns QueryResult_Devices_DeviceInfo Operation successful. Returning a QueryResult<DeviceInfo> object.
     * @throws ApiError
     */
    public getDevices(): CancelablePromise<GetDevicesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Devices',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a device
     * No authentication required
     * @param data The data for the request.
     * @param data.id Device Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteDevices(data: DeleteDevicesData): CancelablePromise<DeleteDevicesResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Devices',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates device options
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody DeviceOptions:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postDevicesOptions(data: PostDevicesOptionsData): CancelablePromise<PostDevicesOptionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Devices/Options',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets options for a device
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Device Id
     * @returns Devices_DeviceOptions Operation successful. Returning a DeviceOptions object.
     * @throws ApiError
     */
    public getDevicesOptions(data: GetDevicesOptionsData): CancelablePromise<GetDevicesOptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Devices/Options',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets info for a device
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Device Id
     * @returns Devices_DeviceInfo Operation successful. Returning a DeviceInfo object.
     * @throws ApiError
     */
    public getDevicesInfo(data: GetDevicesInfoData): CancelablePromise<GetDevicesInfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Devices/Info',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets camera upload history for a device
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.deviceId Device Id
     * @returns Devices_ContentUploadHistory Operation successful. Returning a ContentUploadHistory object.
     * @throws ApiError
     */
    public getDevicesCamerauploads(data: GetDevicesCamerauploadsData): CancelablePromise<GetDevicesCamerauploadsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Devices/CameraUploads',
            query: {
                DeviceId: data.deviceId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Uploads content
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.deviceId Device Id
     * @param data.album Album
     * @param data.name Name
     * @param data.id Id
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postDevicesCamerauploads(data: PostDevicesCamerauploadsData): CancelablePromise<PostDevicesCamerauploadsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Devices/CameraUploads',
            query: {
                DeviceId: data.deviceId,
                Album: data.album,
                Name: data.name,
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class GameGenresServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all Game genres from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getGamegenres(data: GetGamegenresData = {}): CancelablePromise<GetGamegenresResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/GameGenres',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a Game genre, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The genre name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getGamegenresByName(data: GetGamegenresByNameData): CancelablePromise<GetGamegenresByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/GameGenres/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class GenresServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all genres from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getGenres(data: GetGenresData = {}): CancelablePromise<GetGenresResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Genres',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a genre, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The genre name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getGenresByName(data: GetGenresByNameData): CancelablePromise<GetGenresByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Genres/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ItemsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getItems(data: GetItemsData = {}): CancelablePromise<GetItemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getUsersByUseridItems(data: GetUsersByUseridItemsData): CancelablePromise<GetUsersByUseridItemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items',
            path: {
                UserId: data.userId
            },
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getUsersByUseridItemsResume(data: GetUsersByUseridItemsResumeData): CancelablePromise<GetUsersByUseridItemsResumeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/Resume',
            path: {
                UserId: data.userId
            },
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class LibraryServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Deletes an item from the library and file system
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Ids
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteItems(data: DeleteItemsData): CancelablePromise<DeleteItemsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Items',
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId Optional. Get counts from a specific user's library.
     * @param data.isFavorite Optional. Get counts of favorite items
     * @returns ItemCounts Operation successful. Returning a ItemCounts object.
     * @throws ApiError
     */
    public getItemsCounts(data: GetItemsCountsData = {}): CancelablePromise<GetItemsCountsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/Counts',
            query: {
                UserId: data.userId,
                IsFavorite: data.isFavorite
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deletes an item from the library and file system
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteItemsById(data: DeleteItemsByIdData): CancelablePromise<DeleteItemsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Items/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns Library_LibraryOptionsResult Operation successful. Returning a LibraryOptionsResult object.
     * @throws ApiError
     */
    public getLibrariesAvailableoptions(): CancelablePromise<GetLibrariesAvailableoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Libraries/AvailableOptions',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets all user media folders.
     * Requires authentication as user
     * @returns Library_MediaFolder Operation successful. Returning a MediaFolder[] object.
     * @throws ApiError
     */
    public getLibrarySelectablemediafolders(): CancelablePromise<GetLibrarySelectablemediafoldersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Library/SelectableMediaFolders',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets all user media folders.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.isHidden Optional. Filter by folders that are marked hidden, or not.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLibraryMediafolders(data: GetLibraryMediafoldersData = {}): CancelablePromise<GetLibraryMediafoldersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Library/MediaFolders',
            query: {
                IsHidden: data.isHidden
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of physical paths from virtual folders
     * Requires authentication as administrator
     * @returns string Operation successful. Returning a List<String> object.
     * @throws ApiError
     */
    public getLibraryPhysicalpaths(): CancelablePromise<GetLibraryPhysicalpathsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Library/PhysicalPaths',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Starts a library scan
     * Requires authentication as administrator
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryRefresh(): CancelablePromise<PostLibraryRefreshResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Refresh',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Finds albums similar to a given album.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getAlbumsByIdSimilar(data: GetAlbumsByIdSimilarData): CancelablePromise<GetAlbumsByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Albums/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Finds albums similar to a given album.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getArtistsByIdSimilar(data: GetArtistsByIdSimilarData): CancelablePromise<GetArtistsByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Finds games similar to a given game.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getGamesByIdSimilar(data: GetGamesByIdSimilarData): CancelablePromise<GetGamesByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Games/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets delete info for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns Library_DeleteInfo Operation successful. Returning a DeleteInfo object.
     * @throws ApiError
     */
    public getItemsByIdDeleteinfo(data: GetItemsByIdDeleteinfoData): CancelablePromise<GetItemsByIdDeleteinfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/DeleteInfo',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets similar items
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getItemsByIdSimilar(data: GetItemsByIdSimilarData): CancelablePromise<GetItemsByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Downloads item media
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdDownload(data: GetItemsByIdDownloadData): CancelablePromise<GetItemsByIdDownloadResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Download',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets the original file of an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdFile(data: GetItemsByIdFileData): CancelablePromise<GetItemsByIdFileResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/File',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets all parents of an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getItemsByIdAncestors(data: GetItemsByIdAncestorsData): CancelablePromise<GetItemsByIdAncestorsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Ancestors',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets critic reviews for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getItemsByIdCriticreviews(data: GetItemsByIdCriticreviewsData): CancelablePromise<GetItemsByIdCriticreviewsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/CriticReviews',
            path: {
                Id: data.id
            },
            query: {
                StartIndex: data.startIndex,
                Limit: data.limit
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets theme videos and songs for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.inheritFromParent Determines whether or not parent items should be searched for theme media.
     * @returns AllThemeMediaResult Operation successful. Returning a AllThemeMediaResult object.
     * @throws ApiError
     */
    public getItemsByIdThememedia(data: GetItemsByIdThememediaData): CancelablePromise<GetItemsByIdThememediaResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/ThemeMedia',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                InheritFromParent: data.inheritFromParent
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets theme songs for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.inheritFromParent Determines whether or not parent items should be searched for theme media.
     * @returns ThemeMediaResult Operation successful. Returning a ThemeMediaResult object.
     * @throws ApiError
     */
    public getItemsByIdThemesongs(data: GetItemsByIdThemesongsData): CancelablePromise<GetItemsByIdThemesongsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/ThemeSongs',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                InheritFromParent: data.inheritFromParent
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets theme videos for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.inheritFromParent Determines whether or not parent items should be searched for theme media.
     * @returns ThemeMediaResult Operation successful. Returning a ThemeMediaResult object.
     * @throws ApiError
     */
    public getItemsByIdThemevideos(data: GetItemsByIdThemevideosData): CancelablePromise<GetItemsByIdThemevideosResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/ThemeVideos',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                InheritFromParent: data.inheritFromParent
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deprecated. Use /Library/Media/Updated
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibrarySeriesAdded(): CancelablePromise<PostLibrarySeriesAddedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Series/Added',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deprecated. Use /Library/Media/Updated
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibrarySeriesUpdated(): CancelablePromise<PostLibrarySeriesUpdatedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Series/Updated',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Reports that new movies have been added by an external source
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody PostUpdatedMedia
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryMediaUpdated(data: PostLibraryMediaUpdatedData): CancelablePromise<PostLibraryMediaUpdatedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Media/Updated',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deprecated. Use /Library/Media/Updated
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryMoviesAdded(): CancelablePromise<PostLibraryMoviesAddedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Movies/Added',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deprecated. Use /Library/Media/Updated
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryMoviesUpdated(): CancelablePromise<PostLibraryMoviesUpdatedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Movies/Updated',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Finds movies and trailers similar to a given movie.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getMoviesByIdSimilar(data: GetMoviesByIdSimilarData): CancelablePromise<GetMoviesByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Movies/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Finds tv shows similar to a given one.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getShowsByIdSimilar(data: GetShowsByIdSimilarData): CancelablePromise<GetShowsByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Finds movies and trailers similar to a given trailer.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getTrailersByIdSimilar(data: GetTrailersByIdSimilarData): CancelablePromise<GetTrailersByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Trailers/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class MusicGenresServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all music genres from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getMusicgenres(data: GetMusicgenresData = {}): CancelablePromise<GetMusicgenresResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a music genre, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The genre name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getMusicgenresByName(data: GetMusicgenresByNameData): CancelablePromise<GetMusicgenresByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class OfficialRatingServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets items based on a query.
     * No authentication required
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_OfficialRatingItem Operation successful. Returning a QueryResult<OfficialRatingItem> object.
     * @throws ApiError
     */
    public getOfficialratings(data: GetOfficialratingsData = {}): CancelablePromise<GetOfficialratingsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/OfficialRatings',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class OpenApiServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets the OpenAPI 3 specifications
     * No authentication required
     * @returns string Operation successful. Returning a String object.
     * @throws ApiError
     */
    public getOpenapi(): CancelablePromise<GetOpenapiResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/openapi',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets OpenAPI 3 specifications
     * No authentication required
     * @returns string Operation successful. Returning a String object.
     * @throws ApiError
     */
    public getOpenapiJson(): CancelablePromise<GetOpenapiJsonResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/openapi.json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets the swagger specifications
     * No authentication required
     * @returns string Operation successful. Returning a String object.
     * @throws ApiError
     */
    public getSwagger(): CancelablePromise<GetSwaggerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/swagger',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets the swagger specifications
     * No authentication required
     * @returns string Operation successful. Returning a String object.
     * @throws ApiError
     */
    public getSwaggerJson(): CancelablePromise<GetSwaggerJsonResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/swagger.json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class PackageServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets available packages
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.packageType Optional package type filter (System/UserInstalled)
     * @param data.targetSystems Optional. Filter by target system type. Allows multiple, comma delimited.
     * @param data.isPremium Optional. Filter by premium status
     * @param data.isAdult Optional. Filter by package that contain adult content.
     * @returns Updates_PackageInfo Operation successful. Returning a PackageInfo[] object.
     * @throws ApiError
     */
    public getPackages(data: GetPackagesData = {}): CancelablePromise<GetPackagesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Packages',
            query: {
                PackageType: data.packageType,
                TargetSystems: data.targetSystems,
                IsPremium: data.isPremium,
                IsAdult: data.isAdult
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available package updates for currently installed packages
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.packageType Package type filter (System/UserInstalled)
     * @returns Updates_PackageVersionInfo Operation successful. Returning a PackageVersionInfo[] object.
     * @throws ApiError
     */
    public getPackagesUpdates(data: GetPackagesUpdatesData): CancelablePromise<GetPackagesUpdatesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Packages/Updates',
            query: {
                PackageType: data.packageType
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a package, by name or assembly guid
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The name of the package
     * @param data.assemblyGuid The guid of the associated assembly
     * @returns Updates_PackageInfo Operation successful. Returning a PackageInfo object.
     * @throws ApiError
     */
    public getPackagesByName(data: GetPackagesByNameData): CancelablePromise<GetPackagesByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Packages/{Name}',
            path: {
                Name: data.name
            },
            query: {
                AssemblyGuid: data.assemblyGuid
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Installs a package
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.name Package name
     * @param data.assemblyGuid Guid of the associated assembly
     * @param data.version Optional version. Defaults to latest version.
     * @param data.updateClass Optional update class (Dev, Beta, Release). Defaults to Release.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postPackagesInstalledByName(data: PostPackagesInstalledByNameData): CancelablePromise<PostPackagesInstalledByNameResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Packages/Installed/{Name}',
            path: {
                Name: data.name
            },
            query: {
                AssemblyGuid: data.assemblyGuid,
                Version: data.version,
                UpdateClass: data.updateClass
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a package installation
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Installation Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deletePackagesInstallingById(data: DeletePackagesInstallingByIdData): CancelablePromise<DeletePackagesInstallingByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Packages/Installing/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class PersonsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all persons from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getPersons(data: GetPersonsData = {}): CancelablePromise<GetPersonsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Persons',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a person, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The person name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getPersonsByName(data: GetPersonsByNameData): CancelablePromise<GetPersonsByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Persons/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class PlaylistServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Creates a new playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The name of the new playlist.
     * @param data.ids Item Ids to add to the playlist
     * @param data.mediaType The playlist media type
     * @returns Playlists_PlaylistCreationResult Operation successful. Returning a PlaylistCreationResult object.
     * @throws ApiError
     */
    public postPlaylists(data: PostPlaylistsData = {}): CancelablePromise<PostPlaylistsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Playlists',
            query: {
                Name: data.name,
                Ids: data.ids,
                MediaType: data.mediaType
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Adds items to a playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Item id, comma delimited
     * @param data.id
     * @param data.userId User Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postPlaylistsByIdItems(data: PostPlaylistsByIdItemsData): CancelablePromise<PostPlaylistsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Playlists/{Id}/Items',
            path: {
                Id: data.id
            },
            query: {
                Ids: data.ids,
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Removes items from a playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.entryIds
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deletePlaylistsByIdItems(data: DeletePlaylistsByIdItemsData): CancelablePromise<DeletePlaylistsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Playlists/{Id}/Items',
            path: {
                Id: data.id
            },
            query: {
                EntryIds: data.entryIds
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets the original items of a playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.userId User Id
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getPlaylistsByIdItems(data: GetPlaylistsByIdItemsData): CancelablePromise<GetPlaylistsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Playlists/{Id}/Items',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Fields: data.fields,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Moves a playlist item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.itemId ItemId
     * @param data.id
     * @param data.newIndex NewIndex
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postPlaylistsByIdItemsByItemidMoveByNewindex(data: PostPlaylistsByIdItemsByItemidMoveByNewindexData): CancelablePromise<PostPlaylistsByIdItemsByItemidMoveByNewindexResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Playlists/{Id}/Items/{ItemId}/Move/{NewIndex}',
            path: {
                ItemId: data.itemId,
                Id: data.id,
                NewIndex: data.newIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class PluginServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of currently installed plugins
     * Requires authentication as user
     * @returns Plugins_PluginInfo Operation successful. Returning a PluginInfo[] object.
     * @throws ApiError
     */
    public getPlugins(): CancelablePromise<GetPluginsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Plugins',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Uninstalls a plugin
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Plugin Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deletePluginsById(data: DeletePluginsByIdData): CancelablePromise<DeletePluginsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Plugins/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a plugin thumb image
     * No authentication required
     * @param data The data for the request.
     * @param data.id Plugin Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getPluginsByIdThumb(data: GetPluginsByIdThumbData): CancelablePromise<GetPluginsByIdThumbResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Plugins/{Id}/Thumb',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a plugin's configuration
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Plugin Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getPluginsByIdConfiguration(data: GetPluginsByIdConfigurationData): CancelablePromise<GetPluginsByIdConfigurationResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Plugins/{Id}/Configuration',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a plugin's configuration
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Plugin Id
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postPluginsByIdConfiguration(data: PostPluginsByIdConfigurationData): CancelablePromise<PostPluginsByIdConfigurationResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Plugins/{Id}/Configuration',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ScheduledTaskServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets scheduled tasks
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.isHidden Optional filter tasks that are hidden, or not.
     * @param data.isEnabled Optional filter tasks that are enabled, or not.
     * @returns Tasks_TaskInfo Operation successful. Returning a TaskInfo[] object.
     * @throws ApiError
     */
    public getScheduledtasks(data: GetScheduledtasksData = {}): CancelablePromise<GetScheduledtasksResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/ScheduledTasks',
            query: {
                IsHidden: data.isHidden,
                IsEnabled: data.isEnabled
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a scheduled task, by Id
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @returns Tasks_TaskInfo Operation successful. Returning a TaskInfo object.
     * @throws ApiError
     */
    public getScheduledtasksById(data: GetScheduledtasksByIdData): CancelablePromise<GetScheduledtasksByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/ScheduledTasks/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Starts a scheduled task
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postScheduledtasksRunningById(data: PostScheduledtasksRunningByIdData): CancelablePromise<PostScheduledtasksRunningByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/ScheduledTasks/Running/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Stops a scheduled task
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteScheduledtasksRunningById(data: DeleteScheduledtasksRunningByIdData): CancelablePromise<DeleteScheduledtasksRunningByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/ScheduledTasks/Running/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates the triggers for a scheduled task
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody List`1:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postScheduledtasksByIdTriggers(data: PostScheduledtasksByIdTriggersData): CancelablePromise<PostScheduledtasksByIdTriggersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/ScheduledTasks/{Id}/Triggers',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class SessionsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of sessions
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.controllableByUserId Optional. Filter by sessions that a given user is allowed to remote control.
     * @param data.deviceId Optional. Filter by device id.
     * @returns Session_SessionInfo Operation successful. Returning a SessionInfo[] object.
     * @throws ApiError
     */
    public getSessions(data: GetSessionsData = {}): CancelablePromise<GetSessionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sessions',
            query: {
                ControllableByUserId: data.controllableByUserId,
                DeviceId: data.deviceId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @returns NameIdPair Operation successful. Returning a NameIdPair[] object.
     * @throws ApiError
     */
    public getAuthProviders(): CancelablePromise<GetAuthProvidersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Auth/Providers',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.app App
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postAuthKeys(data: PostAuthKeysData): CancelablePromise<PostAuthKeysResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Auth/Keys',
            query: {
                App: data.app
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAuthKeys(): CancelablePromise<GetAuthKeysResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Auth/Keys',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Reports that a session has ended
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsLogout(): CancelablePromise<PostSessionsLogoutResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Logout',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates capabilities for a device
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.playableMediaTypes A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
     * @param data.supportedCommands A list of supported remote control commands, comma delimited
     * @param data.supportsMediaControl Determines whether media can be played remotely.
     * @param data.supportsSync Determines whether sync is supported.
     * @param data.supportsPersistentIdentifier Determines whether the device supports a unique identifier.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsCapabilities(data: PostSessionsCapabilitiesData): CancelablePromise<PostSessionsCapabilitiesResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Capabilities',
            query: {
                Id: data.id,
                PlayableMediaTypes: data.playableMediaTypes,
                SupportedCommands: data.supportedCommands,
                SupportsMediaControl: data.supportsMediaControl,
                SupportsSync: data.supportsSync,
                SupportsPersistentIdentifier: data.supportsPersistentIdentifier
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.key Auth Key
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteAuthKeysByKey(data: DeleteAuthKeysByKeyData): CancelablePromise<DeleteAuthKeysByKeyResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Auth/Keys/{Key}',
            path: {
                Key: data.key
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Instructs a session to browse to an item or view
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.itemType The type of item to browse to.
     * @param data.itemId The Id of the item.
     * @param data.itemName The name of the item.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdViewing(data: PostSessionsByIdViewingData): CancelablePromise<PostSessionsByIdViewingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Viewing',
            path: {
                Id: data.id
            },
            query: {
                ItemType: data.itemType,
                ItemId: data.itemId,
                ItemName: data.itemName
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Issues a command to a client to display a message to the user
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.text The message text.
     * @param data.header The message header.
     * @param data.timeoutMs The message timeout. If omitted the user will have to confirm viewing the message.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdMessage(data: PostSessionsByIdMessageData): CancelablePromise<PostSessionsByIdMessageResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Message',
            path: {
                Id: data.id
            },
            query: {
                Text: data.text,
                Header: data.header,
                TimeoutMs: data.timeoutMs
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Instructs a session to play an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.itemIds The ids of the items to play, comma delimited
     * @param data.playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
     * @param data.requestBody PlayRequest:
     * @param data.startPositionTicks The starting position of the first item.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postSessionsByIdPlaying(data: PostSessionsByIdPlayingData): CancelablePromise<PostSessionsByIdPlayingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Playing',
            path: {
                Id: data.id
            },
            query: {
                ItemIds: data.itemIds,
                StartPositionTicks: data.startPositionTicks,
                PlayCommand: data.playCommand
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Issues a system command to a client
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.requestBody GeneralCommand:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdCommand(data: PostSessionsByIdCommandData): CancelablePromise<PostSessionsByIdCommandResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Command',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates capabilities for a device
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.requestBody ClientCapabilities:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsCapabilitiesFull(data: PostSessionsCapabilitiesFullData): CancelablePromise<PostSessionsCapabilitiesFullResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Capabilities/Full',
            query: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Issues a playstate command to a client
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.command
     * @param data.requestBody PlaystateRequest:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdPlayingByCommand(data: PostSessionsByIdPlayingByCommandData): CancelablePromise<PostSessionsByIdPlayingByCommandResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Playing/{Command}',
            path: {
                Id: data.id,
                Command: data.command
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Issues a system command to a client
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.command The command to send.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdSystemByCommand(data: PostSessionsByIdSystemByCommandData): CancelablePromise<PostSessionsByIdSystemByCommandResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/System/{Command}',
            path: {
                Id: data.id,
                Command: data.command
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Issues a system command to a client
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.command The command to send.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdCommandByCommand(data: PostSessionsByIdCommandByCommandData): CancelablePromise<PostSessionsByIdCommandByCommandResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Command/{Command}',
            path: {
                Id: data.id,
                Command: data.command
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Adds an additional user to a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.userId UserId Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdUsersByUserid(data: PostSessionsByIdUsersByUseridData): CancelablePromise<PostSessionsByIdUsersByUseridResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Users/{UserId}',
            path: {
                Id: data.id,
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Removes an additional user from a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.userId UserId Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteSessionsByIdUsersByUserid(data: DeleteSessionsByIdUsersByUseridData): CancelablePromise<DeleteSessionsByIdUsersByUseridResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Sessions/{Id}/Users/{UserId}',
            path: {
                Id: data.id,
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class StudiosServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all studios from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getStudios(data: GetStudiosData = {}): CancelablePromise<GetStudiosResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Studios',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a studio, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The studio name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getStudiosByName(data: GetStudiosByNameData): CancelablePromise<GetStudiosByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Studios/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class TrailersServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Finds movies and trailers similar to a given trailer.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getTrailers(data: GetTrailersData = {}): CancelablePromise<GetTrailersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Trailers',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class UserServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of users
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.isHidden Optional filter by IsHidden=true or false
     * @param data.isDisabled Optional filter by IsDisabled=true or false
     * @returns UserDto Operation successful. Returning a UserDto[] object.
     * @throws ApiError
     */
    public getUsers(data: GetUsersData = {}): CancelablePromise<GetUsersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users',
            query: {
                IsHidden: data.isHidden,
                IsDisabled: data.isDisabled
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of publicly visible users for display on a login screen.
     * No authentication required
     * @returns UserDto Operation successful. Returning a UserDto[] object.
     * @throws ApiError
     */
    public getUsersPublic(): CancelablePromise<GetUsersPublicResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/Public',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a user by Id
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns UserDto Operation successful. Returning a UserDto object.
     * @throws ApiError
     */
    public getUsersById(data: GetUsersByIdData): CancelablePromise<GetUsersByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a user
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersById(data: DeleteUsersByIdData): CancelablePromise<DeleteUsersByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody UserDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersById(data: PostUsersByIdData): CancelablePromise<PostUsersByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Authenticates a user
     * Authenticate a user by nane and password. A 200 status code indicates success, while anything in the 400 or 500 range indicates failure
     * ---
     * No authentication required
     * @param data The data for the request.
     * @param data.xEmbyAuthorization The authorization header can be either named 'Authorization' or 'X-Emby-Authorization'.
     * It must be of the following schema:
     * Emby UserId="(guid)", Client="(string)", Device="(string)", DeviceId="(string)", Version="string", Token="(string)"
     * Please consult the documentation for further details.
     * @param data.requestBody AuthenticateUserByName
     * @returns Authentication_AuthenticationResult Operation successful. Returning a AuthenticationResult object.
     * @throws ApiError
     */
    public postUsersAuthenticatebyname(data: PostUsersAuthenticatebynameData): CancelablePromise<PostUsersAuthenticatebynameResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/AuthenticateByName',
            headers: {
                'X-Emby-Authorization': data.xEmbyAuthorization
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates a user
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody CreateUserByName
     * @returns UserDto Operation successful. Returning a UserDto object.
     * @throws ApiError
     */
    public postUsersNew(data: PostUsersNewData): CancelablePromise<PostUsersNewResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/New',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Initiates the forgot password process for a local user
     * No authentication required
     * @param data The data for the request.
     * @param data.requestBody ForgotPassword
     * @returns Users_ForgotPasswordResult Operation successful. Returning a ForgotPasswordResult object.
     * @throws ApiError
     */
    public postUsersForgotpassword(data: PostUsersForgotpasswordData): CancelablePromise<PostUsersForgotpasswordResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/ForgotPassword',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Authenticates a user
     * No authentication required
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody AuthenticateUser
     * @returns Authentication_AuthenticationResult Operation successful. Returning a AuthenticationResult object.
     * @throws ApiError
     */
    public postUsersByIdAuthenticate(data: PostUsersByIdAuthenticateData): CancelablePromise<PostUsersByIdAuthenticateResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Authenticate',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user's password
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody UpdateUserPassword
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdPassword(data: PostUsersByIdPasswordData): CancelablePromise<PostUsersByIdPasswordResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Password',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user's easy password
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody UpdateUserEasyPassword
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdEasypassword(data: PostUsersByIdEasypasswordData): CancelablePromise<PostUsersByIdEasypasswordResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/EasyPassword',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Redeems a forgot password pin
     * No authentication required
     * @param data The data for the request.
     * @param data.requestBody ForgotPasswordPin
     * @returns Users_PinRedeemResult Operation successful. Returning a PinRedeemResult object.
     * @throws ApiError
     */
    public postUsersForgotpasswordPin(data: PostUsersForgotpasswordPinData): CancelablePromise<PostUsersForgotpasswordPinResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/ForgotPassword/Pin',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user configuration
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody UserConfiguration:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdConfiguration(data: PostUsersByIdConfigurationData): CancelablePromise<PostUsersByIdConfigurationResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Configuration',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user policy
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody UserPolicy:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdPolicy(data: PostUsersByIdPolicyData): CancelablePromise<PostUsersByIdPolicyResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Policy',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ImageServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(data: GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData): CancelablePromise<GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnplayedCount}',
            path: {
                Id: data.id,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Tag: data.tag,
                Format: data.format,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                Type: data.type,
                Index: data.index
            },
            query: {
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                AddPlayedIndicator: data.addPlayedIndicator,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(data: HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData): CancelablePromise<HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnplayedCount}',
            path: {
                Id: data.id,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Tag: data.tag,
                Format: data.format,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                Type: data.type,
                Index: data.index
            },
            query: {
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                AddPlayedIndicator: data.addPlayedIndicator,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets information about an item's images
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns ImageInfo Operation successful. Returning a List<ImageInfo> object.
     * @throws ApiError
     */
    public getItemsByIdImages(data: GetItemsByIdImagesData): CancelablePromise<GetItemsByIdImagesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Images',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getArtistsByNameImagesByType(data: GetArtistsByNameImagesByTypeData): CancelablePromise<GetArtistsByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headArtistsByNameImagesByType(data: HeadArtistsByNameImagesByTypeData): CancelablePromise<HeadArtistsByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Artists/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getGamegenresByNameImagesByType(data: GetGamegenresByNameImagesByTypeData): CancelablePromise<GetGamegenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/GameGenres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headGamegenresByNameImagesByType(data: HeadGamegenresByNameImagesByTypeData): CancelablePromise<HeadGamegenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/GameGenres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getGenresByNameImagesByType(data: GetGenresByNameImagesByTypeData): CancelablePromise<GetGenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Genres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headGenresByNameImagesByType(data: HeadGenresByNameImagesByTypeData): CancelablePromise<HeadGenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Genres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdImagesByType(data: GetItemsByIdImagesByTypeData): CancelablePromise<GetItemsByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headItemsByIdImagesByType(data: HeadItemsByIdImagesByTypeData): CancelablePromise<HeadItemsByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Items/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.requestBody Binary stream
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdImagesByType(data: PostItemsByIdImagesByTypeData): CancelablePromise<PostItemsByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                Index: data.index
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteItemsByIdImagesByType(data: DeleteItemsByIdImagesByTypeData): CancelablePromise<DeleteItemsByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Items/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getMusicgenresByNameImagesByType(data: GetMusicgenresByNameImagesByTypeData): CancelablePromise<GetMusicgenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headMusicgenresByNameImagesByType(data: HeadMusicgenresByNameImagesByTypeData): CancelablePromise<HeadMusicgenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/MusicGenres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getPersonsByNameImagesByType(data: GetPersonsByNameImagesByTypeData): CancelablePromise<GetPersonsByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Persons/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headPersonsByNameImagesByType(data: HeadPersonsByNameImagesByTypeData): CancelablePromise<HeadPersonsByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Persons/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getStudiosByNameImagesByType(data: GetStudiosByNameImagesByTypeData): CancelablePromise<GetStudiosByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Studios/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headStudiosByNameImagesByType(data: HeadStudiosByNameImagesByTypeData): CancelablePromise<HeadStudiosByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Studios/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getUsersByIdImagesByType(data: GetUsersByIdImagesByTypeData): CancelablePromise<GetUsersByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headUsersByIdImagesByType(data: HeadUsersByIdImagesByTypeData): CancelablePromise<HeadUsersByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Users/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.requestBody Binary stream
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdImagesByType(data: PostUsersByIdImagesByTypeData): CancelablePromise<PostUsersByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                Index: data.index
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersByIdImagesByType(data: DeleteUsersByIdImagesByTypeData): CancelablePromise<DeleteUsersByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getArtistsByNameImagesByTypeByIndex(data: GetArtistsByNameImagesByTypeByIndexData): CancelablePromise<GetArtistsByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headArtistsByNameImagesByTypeByIndex(data: HeadArtistsByNameImagesByTypeByIndexData): CancelablePromise<HeadArtistsByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Artists/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getGamegenresByNameImagesByTypeByIndex(data: GetGamegenresByNameImagesByTypeByIndexData): CancelablePromise<GetGamegenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/GameGenres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headGamegenresByNameImagesByTypeByIndex(data: HeadGamegenresByNameImagesByTypeByIndexData): CancelablePromise<HeadGamegenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/GameGenres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getGenresByNameImagesByTypeByIndex(data: GetGenresByNameImagesByTypeByIndexData): CancelablePromise<GetGenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Genres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headGenresByNameImagesByTypeByIndex(data: HeadGenresByNameImagesByTypeByIndexData): CancelablePromise<HeadGenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Genres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdImagesByTypeByIndex(data: GetItemsByIdImagesByTypeByIndexData): CancelablePromise<GetItemsByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headItemsByIdImagesByTypeByIndex(data: HeadItemsByIdImagesByTypeByIndexData): CancelablePromise<HeadItemsByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Items/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdImagesByTypeByIndex(data: PostItemsByIdImagesByTypeByIndexData): CancelablePromise<PostItemsByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteItemsByIdImagesByTypeByIndex(data: DeleteItemsByIdImagesByTypeByIndexData): CancelablePromise<DeleteItemsByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Items/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getMusicgenresByNameImagesByTypeByIndex(data: GetMusicgenresByNameImagesByTypeByIndexData): CancelablePromise<GetMusicgenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headMusicgenresByNameImagesByTypeByIndex(data: HeadMusicgenresByNameImagesByTypeByIndexData): CancelablePromise<HeadMusicgenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/MusicGenres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getPersonsByNameImagesByTypeByIndex(data: GetPersonsByNameImagesByTypeByIndexData): CancelablePromise<GetPersonsByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Persons/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headPersonsByNameImagesByTypeByIndex(data: HeadPersonsByNameImagesByTypeByIndexData): CancelablePromise<HeadPersonsByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Persons/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getStudiosByNameImagesByTypeByIndex(data: GetStudiosByNameImagesByTypeByIndexData): CancelablePromise<GetStudiosByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Studios/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headStudiosByNameImagesByTypeByIndex(data: HeadStudiosByNameImagesByTypeByIndexData): CancelablePromise<HeadStudiosByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Studios/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getUsersByIdImagesByTypeByIndex(data: GetUsersByIdImagesByTypeByIndexData): CancelablePromise<GetUsersByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.addPlayedIndicator Optional. Add a played indicator
     * @param data.percentPlayed Optional percent to render for the percent played overlay
     * @param data.unplayedCount Optional unplayed count overlay to render
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headUsersByIdImagesByTypeByIndex(data: HeadUsersByIdImagesByTypeByIndexData): CancelablePromise<HeadUsersByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Users/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                AddPlayedIndicator: data.addPlayedIndicator,
                PercentPlayed: data.percentPlayed,
                UnplayedCount: data.unplayedCount,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdImagesByTypeByIndex(data: PostUsersByIdImagesByTypeByIndexData): CancelablePromise<PostUsersByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersByIdImagesByTypeByIndex(data: DeleteUsersByIdImagesByTypeByIndexData): CancelablePromise<DeleteUsersByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates the index for an item image
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.newIndex The new image index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdImagesByTypeByIndexIndex(data: PostItemsByIdImagesByTypeByIndexIndexData): CancelablePromise<PostItemsByIdImagesByTypeByIndexIndexResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Images/{Type}/{Index}/Index',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                NewIndex: data.newIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class InstantMixServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Creates an instant playlist based on a given artist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id The artist Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getArtistsInstantmix(data: GetArtistsInstantmixData): CancelablePromise<GetArtistsInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/InstantMix',
            query: {
                Id: data.id,
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a music genre
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id The genre Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getMusicgenresInstantmix(data: GetMusicgenresInstantmixData): CancelablePromise<GetMusicgenresInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres/InstantMix',
            query: {
                Id: data.id,
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a given album
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getAlbumsByIdInstantmix(data: GetAlbumsByIdInstantmixData): CancelablePromise<GetAlbumsByIdInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Albums/{Id}/InstantMix',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a given item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getItemsByIdInstantmix(data: GetItemsByIdInstantmixData): CancelablePromise<GetItemsByIdInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/InstantMix',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a music genre
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The genre name
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getMusicgenresByNameInstantmix(data: GetMusicgenresByNameInstantmixData): CancelablePromise<GetMusicgenresByNameInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres/{Name}/InstantMix',
            path: {
                Name: data.name
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a given playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getPlaylistsByIdInstantmix(data: GetPlaylistsByIdInstantmixData): CancelablePromise<GetPlaylistsByIdInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Playlists/{Id}/InstantMix',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a given song
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getSongsByIdInstantmix(data: GetSongsByIdInstantmixData): CancelablePromise<GetSongsByIdInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Songs/{Id}/InstantMix',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class BrandingServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets branding configuration
     * No authentication required
     * @returns Branding_BrandingOptions Operation successful. Returning a BrandingOptions object.
     * @throws ApiError
     */
    public getBrandingConfiguration(): CancelablePromise<GetBrandingConfigurationResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Branding/Configuration',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets custom css
     * No authentication required
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getBrandingCss(): CancelablePromise<GetBrandingCssResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Branding/Css',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets custom css
     * No authentication required
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getBrandingCssCss(): CancelablePromise<GetBrandingCssCssResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Branding/Css.css',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ConnectServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Creates a Connect link for a user
     * Requires authentication as administrator
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getConnectPending(): CancelablePromise<GetConnectPendingResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Connect/Pending',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets the corresponding local user from a connect user id
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.connectUserId ConnectUserId
     * @returns Connect_ConnectAuthenticationExchangeResult Operation successful. Returning a ConnectAuthenticationExchangeResult object.
     * @throws ApiError
     */
    public getConnectExchange(data: GetConnectExchangeData): CancelablePromise<GetConnectExchangeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Connect/Exchange',
            query: {
                ConnectUserId: data.connectUserId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates a Connect link for a user
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.connectUsername Connect username
     * @returns Connect_UserLinkResult Operation successful. Returning a UserLinkResult object.
     * @throws ApiError
     */
    public postUsersByIdConnectLink(data: PostUsersByIdConnectLinkData): CancelablePromise<PostUsersByIdConnectLinkResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Connect/Link',
            path: {
                Id: data.id
            },
            query: {
                ConnectUsername: data.connectUsername
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Removes a Connect link for a user
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id User Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersByIdConnectLink(data: DeleteUsersByIdConnectLinkData): CancelablePromise<DeleteUsersByIdConnectLinkResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{Id}/Connect/Link',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class DisplayPreferencesServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a user's display preferences for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId User Id
     * @param data.client Client
     * @returns DisplayPreferences Operation successful. Returning a DisplayPreferences object.
     * @throws ApiError
     */
    public getDisplaypreferencesById(data: GetDisplaypreferencesByIdData): CancelablePromise<GetDisplaypreferencesByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/DisplayPreferences/{Id}',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                Client: data.client
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user's display preferences for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.displayPreferencesId DisplayPreferences Id
     * @param data.userId User Id
     * @param data.requestBody DisplayPreferences:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postDisplaypreferencesByDisplaypreferencesid(data: PostDisplaypreferencesByDisplaypreferencesidData): CancelablePromise<PostDisplaypreferencesByDisplaypreferencesidResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/DisplayPreferences/{DisplayPreferencesId}',
            path: {
                DisplayPreferencesId: data.displayPreferencesId
            },
            query: {
                UserId: data.userId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class DlnaServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of profiles
     * Requires authentication as administrator
     * @returns Dlna_DeviceProfileInfo Operation successful. Returning a DeviceProfileInfo[] object.
     * @throws ApiError
     */
    public getDlnaProfileinfos(): CancelablePromise<GetDlnaProfileinfosResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/ProfileInfos',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates a profile
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody DeviceProfile:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postDlnaProfiles(data: PostDlnaProfilesData): CancelablePromise<PostDlnaProfilesResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Dlna/Profiles',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a single profile
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Profile Id
     * @returns Dlna_DeviceProfile Operation successful. Returning a DeviceProfile object.
     * @throws ApiError
     */
    public getDlnaProfilesById(data: GetDlnaProfilesByIdData): CancelablePromise<GetDlnaProfilesByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/Profiles/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a profile
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Profile Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteDlnaProfilesById(data: DeleteDlnaProfilesByIdData): CancelablePromise<DeleteDlnaProfilesByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Dlna/Profiles/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a profile
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody DeviceProfile:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postDlnaProfilesById(data: PostDlnaProfilesByIdData): CancelablePromise<PostDlnaProfilesByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Dlna/Profiles/{Id}',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets the default profile
     * Requires authentication as administrator
     * @returns Dlna_DeviceProfile Operation successful. Returning a DeviceProfile object.
     * @throws ApiError
     */
    public getDlnaProfilesDefault(): CancelablePromise<GetDlnaProfilesDefaultResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/Profiles/Default',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class EnvironmentServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets the contents of a given directory in the file system
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.path
     * @param data.requestBody ValidatePath
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postEnvironmentValidatepath(data: PostEnvironmentValidatepathData): CancelablePromise<PostEnvironmentValidatepathResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Environment/ValidatePath',
            query: {
                Path: data.path
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets the parent path of a given path
     * Requires authentication as administrator
     * @returns DefaultDirectoryBrowserInfo Operation successful. Returning a DefaultDirectoryBrowserInfo object.
     * @throws ApiError
     */
    public getEnvironmentDefaultdirectorybrowser(): CancelablePromise<GetEnvironmentDefaultdirectorybrowserResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/DefaultDirectoryBrowser',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets the contents of a given directory in the file system
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.path
     * @param data.includeFiles An optional filter to include or exclude files from the results. true/false
     * @param data.includeDirectories An optional filter to include or exclude folders from the results. true/false
     * @returns IO_FileSystemEntryInfo Operation successful. Returning a List<FileSystemEntryInfo> object.
     * @throws ApiError
     */
    public getEnvironmentDirectorycontents(data: GetEnvironmentDirectorycontentsData): CancelablePromise<GetEnvironmentDirectorycontentsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/DirectoryContents',
            query: {
                Path: data.path,
                IncludeFiles: data.includeFiles,
                IncludeDirectories: data.includeDirectories
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets shares from a network device
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.path
     * @returns IO_FileSystemEntryInfo Operation successful. Returning a List<FileSystemEntryInfo> object.
     * @throws ApiError
     */
    public getEnvironmentNetworkshares(data: GetEnvironmentNetworksharesData): CancelablePromise<GetEnvironmentNetworksharesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/NetworkShares',
            query: {
                Path: data.path
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available drives from the server's file system
     * Requires authentication as administrator
     * @returns IO_FileSystemEntryInfo Operation successful. Returning a List<FileSystemEntryInfo> object.
     * @throws ApiError
     */
    public getEnvironmentDrives(): CancelablePromise<GetEnvironmentDrivesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/Drives',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of devices on the network
     * Requires authentication as administrator
     * @returns IO_FileSystemEntryInfo Operation successful. Returning a List<FileSystemEntryInfo> object.
     * @throws ApiError
     */
    public getEnvironmentNetworkdevices(): CancelablePromise<GetEnvironmentNetworkdevicesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/NetworkDevices',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets the parent path of a given path
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.path
     * @returns string Operation successful. Returning a String object.
     * @throws ApiError
     */
    public getEnvironmentParentpath(data: GetEnvironmentParentpathData): CancelablePromise<GetEnvironmentParentpathResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/ParentPath',
            query: {
                Path: data.path
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class GamesServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Finds games similar to a given game.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId Optional. Filter by user id
     * @returns GameSystemSummary Operation successful. Returning a GameSystemSummary[] object.
     * @throws ApiError
     */
    public getGamesSystemsummaries(data: GetGamesSystemsummariesData = {}): CancelablePromise<GetGamesSystemsummariesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Games/SystemSummaries',
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ImageByNameServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all media info image by name
     * Requires authentication as user
     * @returns ImageByNameInfo Operation successful. Returning a List<ImageByNameInfo> object.
     * @throws ApiError
     */
    public getImagesMediainfo(): CancelablePromise<GetImagesMediainfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Images/MediaInfo',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets all rating images by name
     * Requires authentication as user
     * @returns ImageByNameInfo Operation successful. Returning a List<ImageByNameInfo> object.
     * @throws ApiError
     */
    public getImagesRatings(): CancelablePromise<GetImagesRatingsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Images/Ratings',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets all general images by name
     * Requires authentication as user
     * @returns ImageByNameInfo Operation successful. Returning a List<ImageByNameInfo> object.
     * @throws ApiError
     */
    public getImagesGeneral(): CancelablePromise<GetImagesGeneralResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Images/General',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a general image by name
     * No authentication required
     * @param data The data for the request.
     * @param data.name The name of the image
     * @param data.type Image Type (primary, backdrop, logo, etc).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getImagesGeneralByNameByType(data: GetImagesGeneralByNameByTypeData): CancelablePromise<GetImagesGeneralByNameByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Images/General/{Name}/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a rating image by name
     * No authentication required
     * @param data The data for the request.
     * @param data.name The name of the image
     * @param data.theme The theme to get the image from
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getImagesRatingsByThemeByName(data: GetImagesRatingsByThemeByNameData): CancelablePromise<GetImagesRatingsByThemeByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Images/Ratings/{Theme}/{Name}',
            path: {
                Name: data.name,
                Theme: data.theme
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a media info image by name
     * No authentication required
     * @param data The data for the request.
     * @param data.name The name of the image
     * @param data.theme The theme to get the image from
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getImagesMediainfoByThemeByName(data: GetImagesMediainfoByThemeByNameData): CancelablePromise<GetImagesMediainfoByThemeByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Images/MediaInfo/{Theme}/{Name}',
            path: {
                Name: data.name,
                Theme: data.theme
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class RemoteImageServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a remote image
     * No authentication required
     * @param data The data for the request.
     * @param data.imageUrl The image url
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getImagesRemote(data: GetImagesRemoteData): CancelablePromise<GetImagesRemoteResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Images/Remote',
            query: {
                ImageUrl: data.imageUrl
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available remote images for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type The image type
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.providerName Optional. The image provider to use
     * @param data.includeAllLanguages Optional.
     * @returns RemoteImageResult Operation successful. Returning a RemoteImageResult object.
     * @throws ApiError
     */
    public getItemsByIdRemoteimages(data: GetItemsByIdRemoteimagesData): CancelablePromise<GetItemsByIdRemoteimagesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/RemoteImages',
            path: {
                Id: data.id
            },
            query: {
                Type: data.type,
                StartIndex: data.startIndex,
                Limit: data.limit,
                ProviderName: data.providerName,
                IncludeAllLanguages: data.includeAllLanguages
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available remote image providers for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns ImageProviderInfo Operation successful. Returning a List<ImageProviderInfo> object.
     * @throws ApiError
     */
    public getItemsByIdRemoteimagesProviders(data: GetItemsByIdRemoteimagesProvidersData): CancelablePromise<GetItemsByIdRemoteimagesProvidersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/RemoteImages/Providers',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Downloads a remote image for an item
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type The image type
     * @param data.providerName The image provider
     * @param data.imageUrl The image url
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdRemoteimagesDownload(data: PostItemsByIdRemoteimagesDownloadData): CancelablePromise<PostItemsByIdRemoteimagesDownloadResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/RemoteImages/Download',
            path: {
                Id: data.id
            },
            query: {
                Type: data.type,
                ProviderName: data.providerName,
                ImageUrl: data.imageUrl
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class FilterServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets branding configuration
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @returns QueryFilters Operation successful. Returning a QueryFilters object.
     * @throws ApiError
     */
    public getItemsFilters2(data: GetItemsFilters2Data = {}): CancelablePromise<GetItemsFilters2Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/Filters2',
            query: {
                UserId: data.userId,
                ParentId: data.parentId,
                IncludeItemTypes: data.includeItemTypes,
                MediaTypes: data.mediaTypes
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets branding configuration
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @returns QueryFiltersLegacy Operation successful. Returning a QueryFiltersLegacy object.
     * @throws ApiError
     */
    public getItemsFilters(data: GetItemsFiltersData = {}): CancelablePromise<GetItemsFiltersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/Filters',
            query: {
                UserId: data.userId,
                ParentId: data.parentId,
                IncludeItemTypes: data.includeItemTypes,
                MediaTypes: data.mediaTypes
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ItemUpdateServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Updates an item
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.itemId The id of the item
     * @param data.requestBody BaseItemDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByItemid(data: PostItemsByItemidData): CancelablePromise<PostItemsByItemidResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{ItemId}',
            path: {
                ItemId: data.itemId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets metadata editor info for an item
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.itemId The id of the item
     * @returns MetadataEditorInfo Operation successful. Returning a MetadataEditorInfo object.
     * @throws ApiError
     */
    public getItemsByItemidMetadataeditor(data: GetItemsByItemidMetadataeditorData): CancelablePromise<GetItemsByItemidMetadataeditorResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{ItemId}/MetadataEditor',
            path: {
                ItemId: data.itemId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class VideoServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets the original file of an item
     * Requires authentication as user
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsFile(): CancelablePromise<GetItemsFileResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/File',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdByContainer(data: GetVideosByIdByContainerData): CancelablePromise<GetVideosByIdByContainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/stream.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headVideosByIdByContainer(data: HeadVideosByIdByContainerData): CancelablePromise<HeadVideosByIdByContainerResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Videos/{Id}/stream.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdStream(data: GetVideosByIdStreamData): CancelablePromise<GetVideosByIdStreamResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/stream',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headVideosByIdStream(data: HeadVideosByIdStreamData): CancelablePromise<HeadVideosByIdStreamResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Videos/{Id}/stream',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class LibraryStructureServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as administrator
     * @returns VirtualFolderInfo Operation successful. Returning a List<VirtualFolderInfo> object.
     * @throws ApiError
     */
    public getLibraryVirtualfolders(): CancelablePromise<GetLibraryVirtualfoldersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Library/VirtualFolders',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody AddVirtualFolder
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfolders(data: PostLibraryVirtualfoldersData): CancelablePromise<PostLibraryVirtualfoldersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLibraryVirtualfolders(): CancelablePromise<DeleteLibraryVirtualfoldersResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Library/VirtualFolders',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody UpdateLibraryOptions
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfoldersLibraryoptions(data: PostLibraryVirtualfoldersLibraryoptionsData): CancelablePromise<PostLibraryVirtualfoldersLibraryoptionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders/LibraryOptions',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody RenameVirtualFolder
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfoldersName(data: PostLibraryVirtualfoldersNameData): CancelablePromise<PostLibraryVirtualfoldersNameResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders/Name',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody AddMediaPath
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfoldersPaths(data: PostLibraryVirtualfoldersPathsData): CancelablePromise<PostLibraryVirtualfoldersPathsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders/Paths',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLibraryVirtualfoldersPaths(): CancelablePromise<DeleteLibraryVirtualfoldersPathsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Library/VirtualFolders/Paths',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody UpdateMediaPath
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfoldersPathsUpdate(data: PostLibraryVirtualfoldersPathsUpdateData): CancelablePromise<PostLibraryVirtualfoldersPathsUpdateResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders/Paths/Update',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class MediaInfoServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Opens a media source
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody LiveStreamRequest:
     * @returns MediaInfo_LiveStreamResponse Operation successful. Returning a LiveStreamResponse object.
     * @throws ApiError
     */
    public postLivestreamsOpen(data: PostLivestreamsOpenData): CancelablePromise<PostLivestreamsOpenResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveStreams/Open',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Closes a media source
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.liveStreamId LiveStreamId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivestreamsClose(data: PostLivestreamsCloseData): CancelablePromise<PostLivestreamsCloseResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveStreams/Close',
            query: {
                LiveStreamId: data.liveStreamId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Closes a media source
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.liveStreamId LiveStreamId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postLivestreamsMediainfo(data: PostLivestreamsMediainfoData): CancelablePromise<PostLivestreamsMediainfoResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveStreams/MediaInfo',
            query: {
                LiveStreamId: data.liveStreamId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.size Size
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getPlaybackBitratetest(data: GetPlaybackBitratetestData): CancelablePromise<GetPlaybackBitratetestResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Playback/BitrateTest',
            query: {
                Size: data.size
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets live playback media info for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId User Id
     * @returns MediaInfo_PlaybackInfoResponse Operation successful. Returning a PlaybackInfoResponse object.
     * @throws ApiError
     */
    public getItemsByIdPlaybackinfo(data: GetItemsByIdPlaybackinfoData): CancelablePromise<GetItemsByIdPlaybackinfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/PlaybackInfo',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets live playback media info for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody PlaybackInfoRequest:
     * @returns MediaInfo_PlaybackInfoResponse Operation successful. Returning a PlaybackInfoResponse object.
     * @throws ApiError
     */
    public postItemsByIdPlaybackinfo(data: PostItemsByIdPlaybackinfoData): CancelablePromise<PostItemsByIdPlaybackinfoResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/PlaybackInfo',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class LiveTvServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public optionsLivetvChannelmappings(data: OptionsLivetvChannelmappingsData): CancelablePromise<OptionsLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'OPTIONS',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvChannelmappings(data: GetLivetvChannelmappingsData): CancelablePromise<GetLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headLivetvChannelmappings(data: HeadLivetvChannelmappingsData): CancelablePromise<HeadLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @param data.requestBody SetChannelMapping
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postLivetvChannelmappings(data: PostLivetvChannelmappingsData): CancelablePromise<PostLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @param data.requestBody SetChannelMapping
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public putLivetvChannelmappings(data: PutLivetvChannelmappingsData): CancelablePromise<PutLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'PUT',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteLivetvChannelmappings(data: DeleteLivetvChannelmappingsData): CancelablePromise<DeleteLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public traceLivetvChannelmappings(data: TraceLivetvChannelmappingsData): CancelablePromise<TraceLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'TRACE',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public patchLivetvChannelmappings(data: PatchLivetvChannelmappingsData): CancelablePromise<PatchLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'PATCH',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public optionsLivetvChannelmappingoptions(data: OptionsLivetvChannelmappingoptionsData): CancelablePromise<OptionsLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'OPTIONS',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvChannelmappingoptions(data: GetLivetvChannelmappingoptionsData): CancelablePromise<GetLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headLivetvChannelmappingoptions(data: HeadLivetvChannelmappingoptionsData): CancelablePromise<HeadLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postLivetvChannelmappingoptions(data: PostLivetvChannelmappingoptionsData): CancelablePromise<PostLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public putLivetvChannelmappingoptions(data: PutLivetvChannelmappingoptionsData): CancelablePromise<PutLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'PUT',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteLivetvChannelmappingoptions(data: DeleteLivetvChannelmappingoptionsData): CancelablePromise<DeleteLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public traceLivetvChannelmappingoptions(data: TraceLivetvChannelmappingoptionsData): CancelablePromise<TraceLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'TRACE',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public patchLivetvChannelmappingoptions(data: PatchLivetvChannelmappingoptionsData): CancelablePromise<PatchLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'PATCH',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Adds a listing provider
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody ListingsProviderInfo:
     * @returns LiveTv_ListingsProviderInfo Operation successful. Returning a ListingsProviderInfo object.
     * @throws ApiError
     */
    public postLivetvListingproviders(data: PostLivetvListingprovidersData): CancelablePromise<PostLivetvListingprovidersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/ListingProviders',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a listing provider
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Provider id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLivetvListingproviders(data: DeleteLivetvListingprovidersData = {}): CancelablePromise<DeleteLivetvListingprovidersResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/ListingProviders',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets current listing providers
     * Requires authentication as user
     * @returns LiveTv_ListingsProviderInfo Operation successful. Returning a ListingsProviderInfo[] object.
     * @throws ApiError
     */
    public getLivetvListingproviders(): CancelablePromise<GetLivetvListingprovidersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ListingProviders',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets tuner hosts
     * Requires authentication as user
     * @returns LiveTv_TunerHostInfo Operation successful. Returning a TunerHostInfo[] object.
     * @throws ApiError
     */
    public getLivetvTunerhosts(): CancelablePromise<GetLivetvTunerhostsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/TunerHosts',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Adds a tuner host
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody TunerHostInfo:
     * @returns LiveTv_TunerHostInfo Operation successful. Returning a TunerHostInfo object.
     * @throws ApiError
     */
    public postLivetvTunerhosts(data: PostLivetvTunerhostsData): CancelablePromise<PostLivetvTunerhostsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/TunerHosts',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a tuner host
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Tuner host id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLivetvTunerhosts(data: DeleteLivetvTunerhostsData = {}): CancelablePromise<DeleteLivetvTunerhostsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/TunerHosts',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available live tv services.
     * Requires authentication as user
     * @returns LiveTv_LiveTvInfo Operation successful. Returning a LiveTvInfo object.
     * @throws ApiError
     */
    public getLivetvInfo(): CancelablePromise<GetLivetvInfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Info',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available live tv channels.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.type Optional filter by channel type.
     * @param data.userId Optional filter by user and attach user data.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.isFavorite Filter by channels that are favorites, or not.
     * @param data.isLiked Filter by channels that are liked, or not.
     * @param data.isDisliked Filter by channels that are disliked, or not.
     * @param data.enableFavoriteSorting Incorporate favorite and like status into channel sorting.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.addCurrentProgram Optional. Adds current program info to each channel
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLivetvChannels(data: GetLivetvChannelsData = {}): CancelablePromise<GetLivetvChannelsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Channels',
            query: {
                Type: data.type,
                UserId: data.userId,
                StartIndex: data.startIndex,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                Limit: data.limit,
                IsFavorite: data.isFavorite,
                IsLiked: data.isLiked,
                IsDisliked: data.isDisliked,
                EnableFavoriteSorting: data.enableFavoriteSorting,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Fields: data.fields,
                AddCurrentProgram: data.addCurrentProgram,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available live tv epgs..
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.channelIds The channels to return guide information for.
     * @param data.userId Optional filter by user id.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.hasAired Optional. Filter by programs that have completed airing, or not.
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.genreIds The genres to return guide information for.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLivetvPrograms(data: GetLivetvProgramsData = {}): CancelablePromise<GetLivetvProgramsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Programs',
            query: {
                ChannelIds: data.channelIds,
                UserId: data.userId,
                MinStartDate: data.minStartDate,
                HasAired: data.hasAired,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                StartIndex: data.startIndex,
                Limit: data.limit,
                SortBy: data.sortBy,
                SortOrder: data.sortOrder,
                GenreIds: data.genreIds,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available live tv epgs..
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody GetPrograms
     * @param data.channelIds The channels to return guide information for.
     * @param data.userId Optional filter by user id.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.genreIds The genres to return guide information for.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public postLivetvPrograms(data: PostLivetvProgramsData): CancelablePromise<PostLivetvProgramsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Programs',
            query: {
                ChannelIds: data.channelIds,
                UserId: data.userId,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                GenreIds: data.genreIds
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv recordings
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.channelId Optional filter by channel id.
     * @param data.status Optional filter by recording status.
     * @param data.isInProgress Optional filter by recordings that are in progress, or not.
     * @param data.seriesTimerId Optional filter by recordings belonging to a series timer
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvRecordings(data: GetLivetvRecordingsData = {}): CancelablePromise<GetLivetvRecordingsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings',
            query: {
                ChannelId: data.channelId,
                Status: data.status,
                IsInProgress: data.isInProgress,
                SeriesTimerId: data.seriesTimerId,
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                VideoCodecs: data.videoCodecs,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv timers
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.channelId Optional filter by channel id.
     * @param data.seriesTimerId Optional filter by timers belonging to a series timer
     * @returns QueryResult_LiveTv_TimerInfoDto Operation successful. Returning a QueryResult<TimerInfoDto> object.
     * @throws ApiError
     */
    public getLivetvTimers(data: GetLivetvTimersData = {}): CancelablePromise<GetLivetvTimersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Timers',
            query: {
                ChannelId: data.channelId,
                SeriesTimerId: data.seriesTimerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates a live tv timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody TimerInfoDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvTimers(data: PostLivetvTimersData): CancelablePromise<PostLivetvTimersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Timers',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv series timers
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.sortBy Optional. Sort by SortName or Priority
     * @param data.sortOrder Optional. Sort in Ascending or Descending order
     * @returns QueryResult_LiveTv_SeriesTimerInfoDto Operation successful. Returning a QueryResult<SeriesTimerInfoDto> object.
     * @throws ApiError
     */
    public getLivetvSeriestimers(data: GetLivetvSeriestimersData = {}): CancelablePromise<GetLivetvSeriestimersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/SeriesTimers',
            query: {
                SortBy: data.sortBy,
                SortOrder: data.sortOrder
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Creates a live tv series timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody SeriesTimerInfoDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvSeriestimers(data: PostLivetvSeriestimersData): CancelablePromise<PostLivetvSeriestimersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/SeriesTimers',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets guide info
     * Requires authentication as user
     * @returns LiveTv_GuideInfo Operation successful. Returning a GuideInfo object.
     * @throws ApiError
     */
    public getLivetvGuideinfo(): CancelablePromise<GetLivetvGuideinfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/GuideInfo',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns NameIdPair Operation successful. Returning a List<NameIdPair> object.
     * @throws ApiError
     */
    public getLivetvTunerhostsTypes(): CancelablePromise<GetLivetvTunerhostsTypesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/TunerHosts/Types',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets recording folders
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId Optional filter by user and attach user data.
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getLivetvRecordingsFolders(data: GetLivetvRecordingsFoldersData = {}): CancelablePromise<GetLivetvRecordingsFoldersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings/Folders',
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns LiveTv_TunerHostInfo Operation successful. Returning a List<TunerHostInfo> object.
     * @throws ApiError
     */
    public getLivetvTunersDiscvover(): CancelablePromise<GetLivetvTunersDiscvoverResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Tuners/Discvover',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns LiveTv_ListingsProviderInfo Operation successful. Returning a ListingsProviderInfo object.
     * @throws ApiError
     */
    public getLivetvListingprovidersDefault(): CancelablePromise<GetLivetvListingprovidersDefaultResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ListingProviders/Default',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available lineups
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Provider id
     * @param data.type Provider Type
     * @param data.location Location
     * @param data.country Country
     * @returns NameIdPair Operation successful. Returning a List<NameIdPair> object.
     * @throws ApiError
     */
    public getLivetvListingprovidersLineups(data: GetLivetvListingprovidersLineupsData = {}): CancelablePromise<GetLivetvListingprovidersLineupsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ListingProviders/Lineups',
            query: {
                Id: data.id,
                Type: data.type,
                Location: data.location,
                Country: data.country
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Channel Id
     * @param data.userId Optional attach user data.
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getLivetvChannelsById(data: GetLivetvChannelsByIdData): CancelablePromise<GetLivetvChannelsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Channels/{Id}',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available live tv epgs..
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId Optional filter by user id.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.isAiring Optional. Filter by programs that are currently airing, or not.
     * @param data.hasAired Optional. Filter by programs that have completed airing, or not.
     * @param data.isSeries Optional filter for movies.
     * @param data.isMovie Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.genreIds The genres to return guide information for.
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLivetvProgramsRecommended(data: GetLivetvProgramsRecommendedData = {}): CancelablePromise<GetLivetvProgramsRecommendedResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Programs/Recommended',
            query: {
                UserId: data.userId,
                Limit: data.limit,
                IsAiring: data.isAiring,
                HasAired: data.hasAired,
                IsSeries: data.isSeries,
                IsMovie: data.isMovie,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                GenreIds: data.genreIds,
                Fields: data.fields,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv recordings
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.channelId Optional filter by channel id.
     * @param data.userId Optional filter by user and attach user data.
     * @param data.groupId Optional filter by recording group.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.status Optional filter by recording status.
     * @param data.isInProgress Optional filter by recordings that are in progress, or not.
     * @param data.seriesTimerId Optional filter by recordings belonging to a series timer
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLivetvRecordingsSeries(data: GetLivetvRecordingsSeriesData = {}): CancelablePromise<GetLivetvRecordingsSeriesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings/Series',
            query: {
                ChannelId: data.channelId,
                UserId: data.userId,
                GroupId: data.groupId,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Status: data.status,
                IsInProgress: data.isInProgress,
                SeriesTimerId: data.seriesTimerId,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Fields: data.fields,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Recording Id
     * @param data.userId Optional attach user data.
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getLivetvRecordingsById(data: GetLivetvRecordingsByIdData): CancelablePromise<GetLivetvRecordingsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings/{Id}',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a live tv recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Recording Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLivetvRecordingsById(data: DeleteLivetvRecordingsByIdData): CancelablePromise<DeleteLivetvRecordingsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/Recordings/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Timer Id
     * @returns LiveTv_TimerInfoDto Operation successful. Returning a TimerInfoDto object.
     * @throws ApiError
     */
    public getLivetvTimersById(data: GetLivetvTimersByIdData): CancelablePromise<GetLivetvTimersByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Timers/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a live tv timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Timer Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLivetvTimersById(data: DeleteLivetvTimersByIdData): CancelablePromise<DeleteLivetvTimersByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/Timers/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a live tv timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody TimerInfoDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvTimersById(data: PostLivetvTimersByIdData): CancelablePromise<PostLivetvTimersByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Timers/{Id}',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv series timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Timer Id
     * @returns LiveTv_TimerInfoDto Operation successful. Returning a TimerInfoDto object.
     * @throws ApiError
     */
    public getLivetvSeriestimersById(data: GetLivetvSeriestimersByIdData): CancelablePromise<GetLivetvSeriestimersByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/SeriesTimers/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a live tv series timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Timer Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLivetvSeriestimersById(data: DeleteLivetvSeriestimersByIdData): CancelablePromise<DeleteLivetvSeriestimersByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/SeriesTimers/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a live tv series timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody SeriesTimerInfoDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvSeriestimersById(data: PostLivetvSeriestimersByIdData): CancelablePromise<PostLivetvSeriestimersByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/SeriesTimers/{Id}',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets default values for a new timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.programId Optional, to attach default values based on a program.
     * @returns LiveTv_SeriesTimerInfoDto Operation successful. Returning a SeriesTimerInfoDto object.
     * @throws ApiError
     */
    public getLivetvTimersDefaults(data: GetLivetvTimersDefaultsData = {}): CancelablePromise<GetLivetvTimersDefaultsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Timers/Defaults',
            query: {
                ProgramId: data.programId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv recording groups
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId Optional filter by user and attach user data.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLivetvRecordingsGroups(data: GetLivetvRecordingsGroupsData = {}): CancelablePromise<GetLivetvRecordingsGroupsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings/Groups',
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets listing provider
     * Requires authentication as user
     * @returns LiveTv_ListingProviderTypeInfo Operation successful. Returning a ListingProviderTypeInfo[] object.
     * @throws ApiError
     */
    public getLivetvListingprovidersAvailable(): CancelablePromise<GetLivetvListingprovidersAvailableResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ListingProviders/Available',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * No authentication required
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvLiverecordingsByIdStream(data: GetLivetvLiverecordingsByIdStreamData): CancelablePromise<GetLivetvLiverecordingsByIdStreamResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/LiveRecordings/{Id}/stream',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * No authentication required
     * @param data The data for the request.
     * @param data.id
     * @param data.container
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvLivestreamfilesByIdByContainer(data: GetLivetvLivestreamfilesByIdByContainerData): CancelablePromise<GetLivetvLivestreamfilesByIdByContainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/LiveStreamFiles/{Id}/stream.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets available lineups
     * Requires authentication as user
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvListingprovidersSchedulesdirectCountries(): CancelablePromise<GetLivetvListingprovidersSchedulesdirectCountriesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ListingProviders/SchedulesDirect/Countries',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a recording group
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Recording group Id
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getLivetvRecordingsGroupsById(data: GetLivetvRecordingsGroupsByIdData): CancelablePromise<GetLivetvRecordingsGroupsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings/Groups/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Resets a tv tuner
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Tuner Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvTunersByIdReset(data: PostLivetvTunersByIdResetData): CancelablePromise<PostLivetvTunersByIdResetResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Tuners/{Id}/Reset',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class LocalizationServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets known parental ratings
     * Requires authentication as user
     * @returns ParentalRating Operation successful. Returning a ParentalRating[] object.
     * @throws ApiError
     */
    public getLocalizationParentalratings(): CancelablePromise<GetLocalizationParentalratingsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Localization/ParentalRatings',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets localization options
     * Requires authentication as user
     * @returns Globalization_LocalizatonOption Operation successful. Returning a LocalizatonOption[] object.
     * @throws ApiError
     */
    public getLocalizationOptions(): CancelablePromise<GetLocalizationOptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Localization/Options',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets known countries
     * Requires authentication as user
     * @returns Globalization_CountryInfo Operation successful. Returning a CountryInfo[] object.
     * @throws ApiError
     */
    public getLocalizationCountries(): CancelablePromise<GetLocalizationCountriesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Localization/Countries',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets known cultures
     * Requires authentication as user
     * @returns Globalization_CultureDto Operation successful. Returning a CultureDto[] object.
     * @throws ApiError
     */
    public getLocalizationCultures(): CancelablePromise<GetLocalizationCulturesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Localization/Cultures',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class MoviesServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets movie recommendations
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.categoryLimit The max number of categories to return
     * @param data.itemLimit The max number of items to return per category
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @returns RecommendationDto Operation successful. Returning a RecommendationDto[] object.
     * @throws ApiError
     */
    public getMoviesRecommendations(data: GetMoviesRecommendationsData = {}): CancelablePromise<GetMoviesRecommendationsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Movies/Recommendations',
            query: {
                CategoryLimit: data.categoryLimit,
                ItemLimit: data.itemLimit,
                UserId: data.userId,
                ParentId: data.parentId,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class NewsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets the latest product news.
     * No authentication required
     * @param data The data for the request.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @returns QueryResult_News_NewsItem Operation successful. Returning a QueryResult<NewsItem> object.
     * @throws ApiError
     */
    public getNewsProduct(data: GetNewsProductData = {}): CancelablePromise<GetNewsProductResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/News/Product',
            query: {
                StartIndex: data.startIndex,
                Limit: data.limit
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class NotificationsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets notification types
     * Requires authentication as user
     * @returns Notifications_NotificationTypeInfo Operation successful. Returning a List<NotificationTypeInfo> object.
     * @throws ApiError
     */
    public getNotificationsTypes(): CancelablePromise<GetNotificationsTypesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Notifications/Types',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets notification types
     * Requires authentication as user
     * @returns NameIdPair Operation successful. Returning a List<NameIdPair> object.
     * @throws ApiError
     */
    public getNotificationsServices(): CancelablePromise<GetNotificationsServicesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Notifications/Services',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Sends a notification to all admin users
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The notification's name
     * @param data.description The notification's description
     * @param data.imageUrl The notification's image url
     * @param data.url The notification's info url
     * @param data.level The notification level
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postNotificationsAdmin(data: PostNotificationsAdminData): CancelablePromise<PostNotificationsAdminResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Notifications/Admin',
            query: {
                Name: data.name,
                Description: data.description,
                ImageUrl: data.imageUrl,
                Url: data.url,
                Level: data.level
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets notifications
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.isRead An optional filter by IsRead
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @returns Emby_Notifications_Api_NotificationResult Operation successful. Returning a NotificationResult object.
     * @throws ApiError
     */
    public getNotificationsByUserid(data: GetNotificationsByUseridData): CancelablePromise<GetNotificationsByUseridResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Notifications/{UserId}',
            path: {
                UserId: data.userId
            },
            query: {
                IsRead: data.isRead,
                StartIndex: data.startIndex,
                Limit: data.limit
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a notification summary for a user
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @returns Emby_Notifications_Api_NotificationsSummary Operation successful. Returning a NotificationsSummary object.
     * @throws ApiError
     */
    public getNotificationsByUseridSummary(data: GetNotificationsByUseridSummaryData): CancelablePromise<GetNotificationsByUseridSummaryResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Notifications/{UserId}/Summary',
            path: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Marks notifications as read
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.ids A list of notification ids, comma delimited
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postNotificationsByUseridRead(data: PostNotificationsByUseridReadData): CancelablePromise<PostNotificationsByUseridReadResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Notifications/{UserId}/Read',
            path: {
                UserId: data.userId
            },
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Marks notifications as unread
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.ids A list of notification ids, comma delimited
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postNotificationsByUseridUnread(data: PostNotificationsByUseridUnreadData): CancelablePromise<PostNotificationsByUseridUnreadResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Notifications/{UserId}/Unread',
            path: {
                UserId: data.userId
            },
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ReportsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets activities entries
     * No authentication required
     * @param data The data for the request.
     * @param data.reportView The report view. Values (ReportData, ReportActivities)
     * @param data.displayType The report display type. Values (None, Screen, Export, ScreenExport)
     * @param data.hasQueryLimit Optional. If specified, results will include all records.
     * @param data.groupBy Optional. If specified, results will include grouped records.
     * @param data.reportColumns Optional. The columns to show.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @returns EmbyReports_Api_Model_ReportResult Operation successful. Returning a ReportResult object.
     * @throws ApiError
     */
    public getReportsActivities(data: GetReportsActivitiesData): CancelablePromise<GetReportsActivitiesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Reports/Activities',
            query: {
                ReportView: data.reportView,
                DisplayType: data.displayType,
                HasQueryLimit: data.hasQueryLimit,
                GroupBy: data.groupBy,
                ReportColumns: data.reportColumns,
                StartIndex: data.startIndex,
                Limit: data.limit,
                IncludeItemTypes: data.includeItemTypes
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets reports headers based on library items
     * No authentication required
     * @param data The data for the request.
     * @param data.reportView The report view. Values (ReportData, ReportActivities)
     * @param data.displayType The report display type. Values (None, Screen, Export, ScreenExport)
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.reportColumns Optional. The columns to show.
     * @returns EmbyReports_Api_Model_ReportHeader Operation successful. Returning a List<ReportHeader> object.
     * @throws ApiError
     */
    public getReportsHeaders(data: GetReportsHeadersData): CancelablePromise<GetReportsHeadersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Reports/Headers',
            query: {
                ReportView: data.reportView,
                DisplayType: data.displayType,
                IncludeItemTypes: data.includeItemTypes,
                ReportColumns: data.reportColumns
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets reports based on library items
     * No authentication required
     * @param data The data for the request.
     * @param data.reportView The report view. Values (ReportData, ReportActivities)
     * @param data.displayType The report display type. Values (None, Screen, Export, ScreenExport)
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.collapseBoxSetItems Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @param data.hasQueryLimit Optional. If specified, results will include all records.
     * @param data.groupBy Optional. If specified, results will include grouped records.
     * @param data.reportColumns Optional. The columns to show.
     * @returns EmbyReports_Api_Model_ReportResult Operation successful. Returning a ReportResult object.
     * @throws ApiError
     */
    public getReportsItems(data: GetReportsItemsData): CancelablePromise<GetReportsItemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Reports/Items',
            query: {
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                CollapseBoxSetItems: data.collapseBoxSetItems,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan,
                ReportView: data.reportView,
                DisplayType: data.displayType,
                HasQueryLimit: data.hasQueryLimit,
                GroupBy: data.groupBy,
                ReportColumns: data.reportColumns
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Downloads report
     * No authentication required
     * @param data The data for the request.
     * @param data.reportView The report view. Values (ReportData, ReportActivities)
     * @param data.displayType The report display type. Values (None, Screen, Export, ScreenExport)
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.locationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.excludeLocationTypes Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimeted.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.collapseBoxSetItems Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @param data.hasQueryLimit Optional. If specified, results will include all records.
     * @param data.groupBy Optional. If specified, results will include grouped records.
     * @param data.reportColumns Optional. The columns to show.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getReportsItemsDownload(data: GetReportsItemsDownloadData): CancelablePromise<GetReportsItemsDownloadResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Reports/Items/Download',
            query: {
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                LocationTypes: data.locationTypes,
                ExcludeLocationTypes: data.excludeLocationTypes,
                IsMissing: data.isMissing,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                CollapseBoxSetItems: data.collapseBoxSetItems,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan,
                ReportView: data.reportView,
                DisplayType: data.displayType,
                HasQueryLimit: data.hasQueryLimit,
                GroupBy: data.groupBy,
                ReportColumns: data.reportColumns
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class SearchServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets search hints based on a search term
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.searchTerm The search term to filter on
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.userId Optional. Supply a user id to search within a user's library or omit to search all.
     * @param data.includePeople
     * @param data.includeMedia
     * @param data.includeGenres
     * @param data.includeStudios
     * @param data.includeArtists
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.mediaTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @returns Search_SearchHintResult Operation successful. Returning a SearchHintResult object.
     * @throws ApiError
     */
    public getSearchHints(data: GetSearchHintsData): CancelablePromise<GetSearchHintsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Search/Hints',
            query: {
                StartIndex: data.startIndex,
                Limit: data.limit,
                UserId: data.userId,
                SearchTerm: data.searchTerm,
                IncludePeople: data.includePeople,
                IncludeMedia: data.includeMedia,
                IncludeGenres: data.includeGenres,
                IncludeStudios: data.includeStudios,
                IncludeArtists: data.includeArtists,
                IncludeItemTypes: data.includeItemTypes,
                ExcludeItemTypes: data.excludeItemTypes,
                MediaTypes: data.mediaTypes,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class PlaystateServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Reports playback has started within a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody PlaybackStartInfo:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsPlaying(data: PostSessionsPlayingData): CancelablePromise<PostSessionsPlayingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Playing',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Reports playback progress within a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody PlaybackProgressInfo:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsPlayingProgress(data: PostSessionsPlayingProgressData): CancelablePromise<PostSessionsPlayingProgressResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Playing/Progress',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Pings a playback session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.playSessionId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsPlayingPing(data: PostSessionsPlayingPingData = {}): CancelablePromise<PostSessionsPlayingPingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Playing/Ping',
            query: {
                PlaySessionId: data.playSessionId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Reports playback has stopped within a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody PlaybackStopInfo:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsPlayingStopped(data: PostSessionsPlayingStoppedData): CancelablePromise<PostSessionsPlayingStoppedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Playing/Stopped',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Marks an item as played
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.datePlayed The date the item was played (if any). Format = yyyyMMddHHmmss
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public postUsersByUseridPlayeditemsById(data: PostUsersByUseridPlayeditemsByIdData): CancelablePromise<PostUsersByUseridPlayeditemsByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/PlayedItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                DatePlayed: data.datePlayed
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Marks an item as unplayed
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public deleteUsersByUseridPlayeditemsById(data: DeleteUsersByUseridPlayeditemsByIdData): CancelablePromise<DeleteUsersByUseridPlayeditemsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{UserId}/PlayedItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Reports that a user has begun playing an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.mediaSourceId The id of the MediaSource
     * @param data.canSeek Indicates if the client can seek
     * @param data.audioStreamIndex
     * @param data.subtitleStreamIndex
     * @param data.playMethod
     * @param data.liveStreamId
     * @param data.playSessionId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByUseridPlayingitemsById(data: PostUsersByUseridPlayingitemsByIdData): CancelablePromise<PostUsersByUseridPlayingitemsByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/PlayingItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                MediaSourceId: data.mediaSourceId,
                CanSeek: data.canSeek,
                AudioStreamIndex: data.audioStreamIndex,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                PlayMethod: data.playMethod,
                LiveStreamId: data.liveStreamId,
                PlaySessionId: data.playSessionId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Reports that a user has stopped playing an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.mediaSourceId The id of the MediaSource
     * @param data.nextMediaType The next media type that will play
     * @param data.positionTicks Optional. The position, in ticks, where playback stopped. 1 tick = 10000 ms
     * @param data.liveStreamId
     * @param data.playSessionId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersByUseridPlayingitemsById(data: DeleteUsersByUseridPlayingitemsByIdData): CancelablePromise<DeleteUsersByUseridPlayingitemsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{UserId}/PlayingItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                MediaSourceId: data.mediaSourceId,
                NextMediaType: data.nextMediaType,
                PositionTicks: data.positionTicks,
                LiveStreamId: data.liveStreamId,
                PlaySessionId: data.playSessionId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Reports a user's playback progress
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.mediaSourceId The id of the MediaSource
     * @param data.positionTicks Optional. The current position, in ticks. 1 tick = 10000 ms
     * @param data.isPaused Indicates if the player is paused.
     * @param data.isMuted Indicates if the player is muted.
     * @param data.audioStreamIndex
     * @param data.subtitleStreamIndex
     * @param data.volumeLevel Scale of 0-100
     * @param data.playMethod
     * @param data.liveStreamId
     * @param data.playSessionId
     * @param data.repeatMode
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByUseridPlayingitemsByIdProgress(data: PostUsersByUseridPlayingitemsByIdProgressData): CancelablePromise<PostUsersByUseridPlayingitemsByIdProgressResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/PlayingItems/{Id}/Progress',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                MediaSourceId: data.mediaSourceId,
                PositionTicks: data.positionTicks,
                IsPaused: data.isPaused,
                IsMuted: data.isMuted,
                AudioStreamIndex: data.audioStreamIndex,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                VolumeLevel: data.volumeLevel,
                PlayMethod: data.playMethod,
                LiveStreamId: data.liveStreamId,
                PlaySessionId: data.playSessionId,
                RepeatMode: data.repeatMode
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class TvShowsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of upcoming episodes
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getShowsUpcoming(data: GetShowsUpcomingData): CancelablePromise<GetShowsUpcomingResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/Upcoming',
            query: {
                UserId: data.userId,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Fields: data.fields,
                ParentId: data.parentId,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of next up episodes
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.seriesId Optional. Filter by series id
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getShowsNextup(data: GetShowsNextupData): CancelablePromise<GetShowsNextupResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/NextUp',
            query: {
                UserId: data.userId,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Fields: data.fields,
                SeriesId: data.seriesId,
                ParentId: data.parentId,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets seasons for a tv series
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id The series id
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.isSpecialSeason Optional. Filter by special season.
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getShowsByIdSeasons(data: GetShowsByIdSeasonsData): CancelablePromise<GetShowsByIdSeasonsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/{Id}/Seasons',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                Fields: data.fields,
                IsSpecialSeason: data.isSpecialSeason,
                IsMissing: data.isMissing,
                AdjacentTo: data.adjacentTo,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets episodes for a tv season
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id The series id
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.season Optional filter by season number.
     * @param data.seasonId Optional. Filter by season id
     * @param data.isMissing Optional filter by items that are missing episodes or not.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.startItemId Optional. Skip through the list until a given item is found.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getShowsByIdEpisodes(data: GetShowsByIdEpisodesData): CancelablePromise<GetShowsByIdEpisodesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/{Id}/Episodes',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                Fields: data.fields,
                Season: data.season,
                SeasonId: data.seasonId,
                IsMissing: data.isMissing,
                AdjacentTo: data.adjacentTo,
                StartItemId: data.startItemId,
                StartIndex: data.startIndex,
                Limit: data.limit,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData,
                SortBy: data.sortBy,
                SortOrder: data.sortOrder
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class SyncServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of available sync targets.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId UserId
     * @returns Sync_SyncTarget Operation successful. Returning a List<SyncTarget> object.
     * @throws ApiError
     */
    public getSyncTargets(data: GetSyncTargetsData): CancelablePromise<GetSyncTargetsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/Targets',
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets sync jobs.
     * Requires authentication as user
     * @returns QueryResult_Sync_SyncJob Operation successful. Returning a QueryResult<SyncJob> object.
     * @throws ApiError
     */
    public getSyncJobs(): CancelablePromise<GetSyncJobsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/Jobs',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets sync jobs.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody SyncJobRequest:
     * @returns Sync_Model_SyncJobCreationResult Operation successful. Returning a SyncJobCreationResult object.
     * @throws ApiError
     */
    public postSyncJobs(data: PostSyncJobsData): CancelablePromise<PostSyncJobsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/Jobs',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets sync job items.
     * Requires authentication as user
     * @returns QueryResult_Sync_Model_SyncJobItem Operation successful. Returning a QueryResult<SyncJobItem> object.
     * @throws ApiError
     */
    public getSyncJobitems(): CancelablePromise<GetSyncJobitemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/JobItems',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of available sync targets.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId UserId
     * @param data.itemIds ItemIds
     * @param data.parentId ParentId
     * @param data.targetId TargetId
     * @param data.category Category
     * @returns Sync_Model_SyncDialogOptions Operation successful. Returning a SyncDialogOptions object.
     * @throws ApiError
     */
    public getSyncOptions(data: GetSyncOptionsData): CancelablePromise<GetSyncOptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/Options',
            query: {
                UserId: data.userId,
                ItemIds: data.itemIds,
                ParentId: data.parentId,
                TargetId: data.targetId,
                Category: data.category
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Reports an action that occurred while offline.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody List`1:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncOfflineactions(data: PostSyncOfflineactionsData): CancelablePromise<PostSyncOfflineactionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/OfflineActions',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Syncs data between device and server
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody SyncDataRequest:
     * @returns Sync_Model_SyncDataResponse Operation successful. Returning a SyncDataResponse object.
     * @throws ApiError
     */
    public postSyncData(data: PostSyncDataData): CancelablePromise<PostSyncDataResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/Data',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets sync status for an item.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.itemId
     * @param data.requestBody SyncedItemProgress:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncByItemidStatus(data: PostSyncByItemidStatusData): CancelablePromise<PostSyncByItemidStatusResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/{ItemId}/Status',
            path: {
                ItemId: data.itemId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a sync job.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns Sync_SyncJob Operation successful. Returning a SyncJob object.
     * @throws ApiError
     */
    public getSyncJobsById(data: GetSyncJobsByIdData): CancelablePromise<GetSyncJobsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/Jobs/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a sync job.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteSyncJobsById(data: DeleteSyncJobsByIdData): CancelablePromise<DeleteSyncJobsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Sync/Jobs/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a sync job.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody SyncJob:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobsById(data: PostSyncJobsByIdData): CancelablePromise<PostSyncJobsByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/Jobs/{Id}',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Cancels items from a sync target
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.itemIds ItemIds
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncItemsCancel(data: PostSyncItemsCancelData = {}): CancelablePromise<PostSyncItemsCancelResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/Items/Cancel',
            query: {
                ItemIds: data.itemIds
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Cancels items from a sync target
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.targetId TargetId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteSyncByTargetidItems(data: DeleteSyncByTargetidItemsData): CancelablePromise<DeleteSyncByTargetidItemsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Sync/{TargetId}/Items',
            path: {
                TargetId: data.targetId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets ready to download sync items.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.targetId TargetId
     * @returns Sync_Model_SyncedItem Operation successful. Returning a List<SyncedItem> object.
     * @throws ApiError
     */
    public getSyncItemsReady(data: GetSyncItemsReadyData): CancelablePromise<GetSyncItemsReadyResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/Items/Ready',
            query: {
                TargetId: data.targetId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a sync job item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteSyncJobitemsById(data: DeleteSyncJobitemsByIdData): CancelablePromise<DeleteSyncJobitemsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Sync/JobItems/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Reports that a sync job item has successfully been transferred.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobitemsByIdTransferred(data: PostSyncJobitemsByIdTransferredData): CancelablePromise<PostSyncJobitemsByIdTransferredResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/JobItems/{Id}/Transferred',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a sync job item file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getSyncJobitemsByIdFile(data: GetSyncJobitemsByIdFileData): CancelablePromise<GetSyncJobitemsByIdFileResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/JobItems/{Id}/File',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a sync job item file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @param data.name Name
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getSyncJobitemsByIdAdditionalfiles(data: GetSyncJobitemsByIdAdditionalfilesData): CancelablePromise<GetSyncJobitemsByIdAdditionalfilesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/JobItems/{Id}/AdditionalFiles',
            path: {
                Id: data.id
            },
            query: {
                Name: data.name
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Enables a cancelled or queued sync job item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobitemsByIdEnable(data: PostSyncJobitemsByIdEnableData): CancelablePromise<PostSyncJobitemsByIdEnableResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/JobItems/{Id}/Enable',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Marks a job item for removal
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobitemsByIdMarkforremoval(data: PostSyncJobitemsByIdMarkforremovalData): CancelablePromise<PostSyncJobitemsByIdMarkforremovalResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/JobItems/{Id}/MarkForRemoval',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Unmarks a job item for removal
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobitemsByIdUnmarkforremoval(data: PostSyncJobitemsByIdUnmarkforremovalData): CancelablePromise<PostSyncJobitemsByIdUnmarkforremovalResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/JobItems/{Id}/UnmarkForRemoval',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ConfigurationServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets application configuration
     * Requires authentication as user
     * @returns Configuration_ServerConfiguration Operation successful. Returning a ServerConfiguration object.
     * @throws ApiError
     */
    public getSystemConfiguration(): CancelablePromise<GetSystemConfigurationResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Configuration',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates application configuration
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody ServerConfiguration:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSystemConfiguration(data: PostSystemConfigurationData): CancelablePromise<PostSystemConfigurationResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Configuration',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a named configuration
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.key Key
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getSystemConfigurationByKey(data: GetSystemConfigurationByKeyData): CancelablePromise<GetSystemConfigurationByKeyResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Configuration/{Key}',
            path: {
                Key: data.key
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates named configuration
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.key Key
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSystemConfigurationByKey(data: PostSystemConfigurationByKeyData): CancelablePromise<PostSystemConfigurationByKeyResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Configuration/{Key}',
            path: {
                Key: data.key
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class SystemServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * No authentication required
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSystemPing(): CancelablePromise<PostSystemPingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Ping',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public getSystemPing(): CancelablePromise<GetSystemPingResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Ping',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets wake on lan information
     * Requires authentication as user
     * @returns WakeOnLanInfo Operation successful. Returning a WakeOnLanInfo[] object.
     * @throws ApiError
     */
    public getSystemWakeonlaninfo(): CancelablePromise<GetSystemWakeonlaninfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/WakeOnLanInfo',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of available server log files
     * Requires authentication as administrator
     * @returns LogFile Operation successful. Returning a LogFile[] object.
     * @throws ApiError
     */
    public getSystemLogs(): CancelablePromise<GetSystemLogsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Logs',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets information about the server
     * Requires authentication as user
     * @returns SystemInfo Operation successful. Returning a SystemInfo object.
     * @throws ApiError
     */
    public getSystemInfo(): CancelablePromise<GetSystemInfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Info',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Restarts the application, if needed
     * Requires authentication as administrator
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postSystemRestart(): CancelablePromise<PostSystemRestartResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Restart',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Shuts down the application
     * Requires authentication as administrator
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postSystemShutdown(): CancelablePromise<PostSystemShutdownResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Shutdown',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets information about the request endpoint
     * Requires authentication as user
     * @returns Net_EndPointInfo Operation successful. Returning a EndPointInfo object.
     * @throws ApiError
     */
    public getSystemEndpoint(): CancelablePromise<GetSystemEndpointResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Endpoint',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a log file
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.name The log file name.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getSystemLogsLog(data: GetSystemLogsLogData): CancelablePromise<GetSystemLogsLogResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Logs/Log',
            query: {
                Name: data.name
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets public information about the server
     * No authentication required
     * @returns PublicSystemInfo Operation successful. Returning a PublicSystemInfo object.
     * @throws ApiError
     */
    public getSystemInfoPublic(): CancelablePromise<GetSystemInfoPublicResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Info/Public',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class UserActivityApiService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets types filter list items
     * No authentication required
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsTypeFilterList(): CancelablePromise<GetUserUsageStatsTypeFilterListResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/type_filter_list',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a report of the available activity per hour
     * No authentication required
     * @param data The data for the request.
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsUserActivity(data: GetUserUsageStatsUserActivityData = {}): CancelablePromise<GetUserUsageStatsUserActivityResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/user_activity',
            query: {
                days: data.days,
                end_date: data.endDate
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Get users
     * No authentication required
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsUserList(): CancelablePromise<GetUserUsageStatsUserListResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/user_list',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Post a backup for importing
     * No authentication required
     * @param data The data for the request.
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUserUsageStatsImportBackup(data: PostUserUsageStatsImportBackupData): CancelablePromise<PostUserUsageStatsImportBackupResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/user_usage_stats/import_backup',
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Loads a backup from a file
     * No authentication required
     * @param data The data for the request.
     * @param data.backupfile File name of file to load
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsLoadBackup(data: GetUserUsageStatsLoadBackupData): CancelablePromise<GetUserUsageStatsLoadBackupResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/load_backup',
            query: {
                backupfile: data.backupfile
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Saves a backup of the playback report data to the backup path
     * No authentication required
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsSaveBackup(): CancelablePromise<GetUserUsageStatsSaveBackupResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/save_backup',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets play activity for number of days
     * No authentication required
     * @param data The data for the request.
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @param data.filter Comma separated list of media types to filter (movies,series)
     * @param data.dataType Data type to return (count,time)
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsPlayactivity(data: GetUserUsageStatsPlayactivityData = {}): CancelablePromise<GetUserUsageStatsPlayactivityResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/PlayActivity',
            query: {
                days: data.days,
                end_date: data.endDate,
                filter: data.filter,
                data_type: data.dataType
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a report of the available activity per hour
     * No authentication required
     * @param data The data for the request.
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @param data.filter Comma separated list of media types to filter (movies,series)
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsHourlyreport(data: GetUserUsageStatsHourlyreportData = {}): CancelablePromise<GetUserUsageStatsHourlyreportResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/HourlyReport',
            query: {
                days: data.days,
                end_date: data.endDate,
                filter: data.filter
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets duration histogram
     * No authentication required
     * @param data The data for the request.
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @param data.filter Comma separated list of media types to filter (movies,series)
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsDurationhistogramreport(data: GetUserUsageStatsDurationhistogramreportData = {}): CancelablePromise<GetUserUsageStatsDurationhistogramreportResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/DurationHistogramReport',
            query: {
                days: data.days,
                end_date: data.endDate,
                filter: data.filter
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets TV Shows counts
     * No authentication required
     * @param data The data for the request.
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsTvshowsreport(data: GetUserUsageStatsTvshowsreportData = {}): CancelablePromise<GetUserUsageStatsTvshowsreportResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/TvShowsReport',
            query: {
                days: data.days,
                end_date: data.endDate
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets Movies counts
     * No authentication required
     * @param data The data for the request.
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsMoviesreport(data: GetUserUsageStatsMoviesreportData = {}): CancelablePromise<GetUserUsageStatsMoviesreportResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/MoviesReport',
            query: {
                days: data.days,
                end_date: data.endDate
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Submit an SQL query
     * No authentication required
     * @param data The data for the request.
     * @param data.requestBody CustomQuery
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public postUserUsageStatsSubmitCustomQuery(data: PostUserUsageStatsSubmitCustomQueryData): CancelablePromise<PostUserUsageStatsSubmitCustomQueryResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/user_usage_stats/submit_custom_query',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a report of all played items for a user in a date period
     * No authentication required
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @param data.filter Comma separated list of media types to filter (movies,series)
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsUserplaylist(data: GetUserUsageStatsUserplaylistData): CancelablePromise<GetUserUsageStatsUserplaylistResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/UserPlaylist',
            query: {
                user_id: data.userId,
                days: data.days,
                end_date: data.endDate,
                filter: data.filter
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets Session Info
     * No authentication required
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsSessionList(): CancelablePromise<GetUserUsageStatsSessionListResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/session_list',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets Resource Usage Info
     * No authentication required
     * @param data The data for the request.
     * @param data.hours Number of Hours
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsResourceUsage(data: GetUserUsageStatsResourceUsageData = {}): CancelablePromise<GetUserUsageStatsResourceUsageResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/resource_usage',
            query: {
                hours: data.hours
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of process Info
     * No authentication required
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsProcessList(): CancelablePromise<GetUserUsageStatsProcessListResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/process_list',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a breakdown of a usage metric
     * No authentication required
     * @param data The data for the request.
     * @param data.breakdownType Breakdown type
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsByBreakdowntypeBreakdownreport(data: GetUserUsageStatsByBreakdowntypeBreakdownreportData): CancelablePromise<GetUserUsageStatsByBreakdowntypeBreakdownreportResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/{BreakdownType}/BreakdownReport',
            path: {
                BreakdownType: data.breakdownType
            },
            query: {
                days: data.days,
                end_date: data.endDate
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Get users
     * No authentication required
     * @param data The data for the request.
     * @param data.action action to perform
     * @param data.id user Id to perform the action on
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsUserManageByActionById(data: GetUserUsageStatsUserManageByActionByIdData): CancelablePromise<GetUserUsageStatsUserManageByActionByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/user_manage/{Action}/{Id}',
            path: {
                Action: data.action,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets activity for {USER} for {Date} formatted as yyyy-MM-dd
     * No authentication required
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.date UTC DateTime, Format yyyy-MM-dd
     * @param data.filter Comma separated list of media types to filter (movies,series)
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsByUseridByDateGetitems(data: GetUserUsageStatsByUseridByDateGetitemsData): CancelablePromise<GetUserUsageStatsByUseridByDateGetitemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/{UserID}/{Date}/GetItems',
            path: {
                UserID: data.userId,
                Date: data.date
            },
            query: {
                Filter: data.filter
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class VideosServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Merges videos into a single record
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.ids Item id list. This allows multiple, comma delimited.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postVideosMergeversions(data: PostVideosMergeversionsData = {}): CancelablePromise<PostVideosMergeversionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Videos/MergeVersions',
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets additional parts for a video.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getVideosByIdAdditionalparts(data: GetVideosByIdAdditionalpartsData): CancelablePromise<GetVideosByIdAdditionalpartsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/AdditionalParts',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Removes alternate video sources.
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteVideosByIdAlternatesources(data: DeleteVideosByIdAlternatesourcesData): CancelablePromise<DeleteVideosByIdAlternatesourcesResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Videos/{Id}/AlternateSources',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class HlsSegmentServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.playSessionId The play session id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteVideosActiveencodings(data: DeleteVideosActiveencodingsData): CancelablePromise<DeleteVideosActiveencodingsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Videos/ActiveEncodings',
            query: {
                DeviceId: data.deviceId,
                PlaySessionId: data.playSessionId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.playlistId
     * @param data.segmentId SegmentId
     * @param data.segmentContainer SegmentContainer
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainer(data: GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                PlaylistId: data.playlistId,
                SegmentId: data.segmentId,
                SegmentContainer: data.segmentContainer,
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class DashboardServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * No authentication required
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getWebConfigurationpage(): CancelablePromise<GetWebConfigurationpageResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/web/ConfigurationPage',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @returns WebDashboard_Api_ConfigurationPageInfo Operation successful. Returning a List<ConfigurationPageInfo> object.
     * @throws ApiError
     */
    public getWebConfigurationpages(): CancelablePromise<GetWebConfigurationpagesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/web/ConfigurationPages',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class UniversalAudioServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdByContainer(data: GetAudioByIdByContainerData): CancelablePromise<GetAudioByIdByContainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/universal.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceId: data.deviceId,
                StartTimeTicks: data.startTimeTicks
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdByContainer(data: HeadAudioByIdByContainerData): CancelablePromise<HeadAudioByIdByContainerResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/universal.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceId: data.deviceId,
                StartTimeTicks: data.startTimeTicks
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdUniversal(data: GetAudioByIdUniversalData): CancelablePromise<GetAudioByIdUniversalResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/universal',
            path: {
                Id: data.id
            },
            query: {
                DeviceId: data.deviceId,
                StartTimeTicks: data.startTimeTicks
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdUniversal(data: HeadAudioByIdUniversalData): CancelablePromise<HeadAudioByIdUniversalResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/universal',
            path: {
                Id: data.id
            },
            query: {
                DeviceId: data.deviceId,
                StartTimeTicks: data.startTimeTicks
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class AudioServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets an audio stream
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdByContainer(data: GetAudioByIdByContainerData): CancelablePromise<GetAudioByIdByContainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/stream.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdByContainer(data: HeadAudioByIdByContainerData): CancelablePromise<HeadAudioByIdByContainerResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/stream.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdStream(data: GetAudioByIdStreamData): CancelablePromise<GetAudioByIdStreamResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/stream',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdStream(data: HeadAudioByIdStreamData): CancelablePromise<HeadAudioByIdStreamResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/stream',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class DynamicHlsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets an audio stream using HTTP live streaming.
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdMasterM3U8(data: GetAudioByIdMasterM3U8Data): CancelablePromise<GetAudioByIdMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/master.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream using HTTP live streaming.
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdMasterM3U8(data: HeadAudioByIdMasterM3U8Data): CancelablePromise<HeadAudioByIdMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/master.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream using HTTP live streaming.
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdMainM3U8(data: GetAudioByIdMainM3U8Data): CancelablePromise<GetAudioByIdMainM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/main.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream using HTTP live streaming.
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdMasterM3U8(data: GetVideosByIdMasterM3U8Data): CancelablePromise<GetVideosByIdMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/master.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream using HTTP live streaming.
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headVideosByIdMasterM3U8(data: HeadVideosByIdMasterM3U8Data): CancelablePromise<HeadVideosByIdMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Videos/{Id}/master.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream using HTTP live streaming.
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdMainM3U8(data: GetVideosByIdMainM3U8Data): CancelablePromise<GetVideosByIdMainM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/main.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an HLS subtitle playlist.
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.subtitleSegmentLength The subtitle segment length
     * @param data.manifestSubtitles The subtitle segment format
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdSubtitlesM3U8(data: GetVideosByIdSubtitlesM3U8Data): CancelablePromise<GetVideosByIdSubtitlesM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/subtitles.m3u8',
            path: {
                Id: data.id
            },
            query: {
                SubtitleSegmentLength: data.subtitleSegmentLength,
                ManifestSubtitles: data.manifestSubtitles
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.playlistId
     * @param data.segmentId
     * @param data.segmentContainer SegmentContainer
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(data: GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                PlaylistId: data.playlistId,
                SegmentId: data.segmentId,
                SegmentContainer: data.segmentContainer,
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.playlistId
     * @param data.segmentId
     * @param data.segmentContainer SegmentContainer
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(data: HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                PlaylistId: data.playlistId,
                SegmentId: data.segmentId,
                SegmentContainer: data.segmentContainer,
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.playlistId
     * @param data.segmentId
     * @param data.segmentContainer SegmentContainer
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(data: GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                PlaylistId: data.playlistId,
                SegmentId: data.segmentId,
                SegmentContainer: data.segmentContainer,
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.playlistId
     * @param data.segmentId
     * @param data.segmentContainer SegmentContainer
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(data: HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                PlaylistId: data.playlistId,
                SegmentId: data.segmentId,
                SegmentContainer: data.segmentContainer,
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class DlnaServerServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets dlna server info
     * No authentication required
     * @param data The data for the request.
     * @param data.uuId Server UuId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getDlnaByUuidDescriptionXml(data: GetDlnaByUuidDescriptionXmlData): CancelablePromise<GetDlnaByUuidDescriptionXmlResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/{UuId}/description.xml',
            path: {
                UuId: data.uuId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets dlna server info
     * No authentication required
     * @param data The data for the request.
     * @param data.uuId Server UuId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getDlnaByUuidDescription(data: GetDlnaByUuidDescriptionData): CancelablePromise<GetDlnaByUuidDescriptionResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/{UuId}/description',
            path: {
                UuId: data.uuId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a server icon
     * No authentication required
     * @param data The data for the request.
     * @param data.filename The icon filename
     * @param data.uuId Server UuId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getDlnaIconsByFilename(data: GetDlnaIconsByFilenameData): CancelablePromise<GetDlnaIconsByFilenameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/icons/{Filename}',
            path: {
                Filename: data.filename
            },
            query: {
                UuId: data.uuId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets dlna content directory xml
     * No authentication required
     * @param data The data for the request.
     * @param data.uuId Server UuId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getDlnaByUuidContentdirectoryContentdirectoryXml(data: GetDlnaByUuidContentdirectoryContentdirectoryXmlData): CancelablePromise<GetDlnaByUuidContentdirectoryContentdirectoryXmlResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/{UuId}/contentdirectory/contentdirectory.xml',
            path: {
                UuId: data.uuId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets dlna content directory xml
     * No authentication required
     * @param data The data for the request.
     * @param data.uuId Server UuId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getDlnaByUuidContentdirectoryContentdirectory(data: GetDlnaByUuidContentdirectoryContentdirectoryData): CancelablePromise<GetDlnaByUuidContentdirectoryContentdirectoryResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/{UuId}/contentdirectory/contentdirectory',
            path: {
                UuId: data.uuId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets dlna connection manager xml
     * No authentication required
     * @param data The data for the request.
     * @param data.uuId Server UuId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getDlnaByUuidConnectionmanagerConnectionmanagerXml(data: GetDlnaByUuidConnectionmanagerConnectionmanagerXmlData): CancelablePromise<GetDlnaByUuidConnectionmanagerConnectionmanagerXmlResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/{UuId}/connectionmanager/connectionmanager.xml',
            path: {
                UuId: data.uuId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets dlna connection manager xml
     * No authentication required
     * @param data The data for the request.
     * @param data.uuId Server UuId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getDlnaByUuidConnectionmanagerConnectionmanager(data: GetDlnaByUuidConnectionmanagerConnectionmanagerData): CancelablePromise<GetDlnaByUuidConnectionmanagerConnectionmanagerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/{UuId}/connectionmanager/connectionmanager',
            path: {
                UuId: data.uuId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Processes a control request
     * No authentication required
     * @param data The data for the request.
     * @param data.uuId Server UuId
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postDlnaByUuidContentdirectoryControl(data: PostDlnaByUuidContentdirectoryControlData): CancelablePromise<PostDlnaByUuidContentdirectoryControlResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Dlna/{UuId}/contentdirectory/control',
            path: {
                UuId: data.uuId
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Processes a control request
     * No authentication required
     * @param data The data for the request.
     * @param data.uuId Server UuId
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postDlnaByUuidConnectionmanagerControl(data: PostDlnaByUuidConnectionmanagerControlData): CancelablePromise<PostDlnaByUuidConnectionmanagerControlResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Dlna/{UuId}/connectionmanager/control',
            path: {
                UuId: data.uuId
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a server icon
     * No authentication required
     * @param data The data for the request.
     * @param data.uuId Server UuId
     * @param data.filename The icon filename
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getDlnaByUuidIconsByFilename(data: GetDlnaByUuidIconsByFilenameData): CancelablePromise<GetDlnaByUuidIconsByFilenameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Dlna/{UuId}/icons/{Filename}',
            path: {
                UuId: data.uuId,
                Filename: data.filename
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class EncodingInfoServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets details about available video encoders and decoders
     * Requires authentication as user
     * @returns MediaEncoding_Codecs_VideoCodecs_VideoCodecBase Operation successful. Returning a VideoCodecBase[] object.
     * @throws ApiError
     */
    public getEncodingCodecinformationVideo(): CancelablePromise<GetEncodingCodecinformationVideoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Encoding/CodecInformation/Video',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets default codec configurations
     * Requires authentication as user
     * @returns Configuration_CodecConfiguration Operation successful. Returning a CodecConfiguration[] object.
     * @throws ApiError
     */
    public getEncodingCodecconfigurationDefaults(): CancelablePromise<GetEncodingCodecconfigurationDefaultsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Encoding/CodecConfiguration/Defaults',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ItemLookupServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets external id infos for an item
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns ExternalIdInfo Operation successful. Returning a List<ExternalIdInfo> object.
     * @throws ApiError
     */
    public getItemsByIdExternalidinfos(data: GetItemsByIdExternalidinfosData): CancelablePromise<GetItemsByIdExternalidinfosResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/ExternalIdInfos',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchTrailer(data: PostItemsRemotesearchTrailerData): CancelablePromise<PostItemsRemotesearchTrailerResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Trailer',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchBook(data: PostItemsRemotesearchBookData): CancelablePromise<PostItemsRemotesearchBookResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Book',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchMovie(data: PostItemsRemotesearchMovieData): CancelablePromise<PostItemsRemotesearchMovieResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Movie',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchSeries(data: PostItemsRemotesearchSeriesData): CancelablePromise<PostItemsRemotesearchSeriesResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Series',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchGame(data: PostItemsRemotesearchGameData): CancelablePromise<PostItemsRemotesearchGameResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Game',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchBoxset(data: PostItemsRemotesearchBoxsetData): CancelablePromise<PostItemsRemotesearchBoxsetResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/BoxSet',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchMusicvideo(data: PostItemsRemotesearchMusicvideoData): CancelablePromise<PostItemsRemotesearchMusicvideoResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/MusicVideo',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchPerson(data: PostItemsRemotesearchPersonData): CancelablePromise<PostItemsRemotesearchPersonResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Person',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchMusicalbum(data: PostItemsRemotesearchMusicalbumData): CancelablePromise<PostItemsRemotesearchMusicalbumResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/MusicAlbum',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchMusicartist(data: PostItemsRemotesearchMusicartistData): CancelablePromise<PostItemsRemotesearchMusicartistResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/MusicArtist',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets a remote image
     * No authentication required
     * @param data The data for the request.
     * @param data.imageUrl The image url
     * @param data.providerName
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsRemotesearchImage(data: GetItemsRemotesearchImageData): CancelablePromise<GetItemsRemotesearchImageResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/RemoteSearch/Image',
            query: {
                ImageUrl: data.imageUrl,
                ProviderName: data.providerName
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Applies search criteria to an item and refreshes metadata
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id The item id
     * @param data.requestBody RemoteSearchResult:
     * @param data.replaceAllImages Whether or not to replace all images
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsRemotesearchApplyById(data: PostItemsRemotesearchApplyByIdData): CancelablePromise<PostItemsRemotesearchApplyByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Apply/{Id}',
            path: {
                Id: data.id
            },
            query: {
                ReplaceAllImages: data.replaceAllImages
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ItemRefreshServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Refreshes metadata for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.recursive Indicates if the refresh should occur recursively.
     * @param data.metadataRefreshMode Specifies the metadata refresh mode
     * @param data.imageRefreshMode Specifies the image refresh mode
     * @param data.replaceAllMetadata Determines if metadata should be replaced. Only applicable if mode is FullRefresh
     * @param data.replaceAllImages Determines if images should be replaced. Only applicable if mode is FullRefresh
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdRefresh(data: PostItemsByIdRefreshData): CancelablePromise<PostItemsByIdRefreshResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Refresh',
            path: {
                Id: data.id
            },
            query: {
                Recursive: data.recursive,
                MetadataRefreshMode: data.metadataRefreshMode,
                ImageRefreshMode: data.imageRefreshMode,
                ReplaceAllMetadata: data.replaceAllMetadata,
                ReplaceAllImages: data.replaceAllImages
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class BifServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.width
     * @param data.id Item Id
     * @returns RokuMetadata_Api_ThumbnailSetInfo Operation successful. Returning a ThumbnailSetInfo object.
     * @throws ApiError
     */
    public getItemsByIdThumbnailset(data: GetItemsByIdThumbnailsetData): CancelablePromise<GetItemsByIdThumbnailsetResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/ThumbnailSet',
            path: {
                Id: data.id
            },
            query: {
                Width: data.width
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.width
     * @param data.id Item Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdIndexBif(data: GetVideosByIdIndexBifData): CancelablePromise<GetVideosByIdIndexBifResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/index.bif',
            path: {
                Id: data.id
            },
            query: {
                Width: data.width
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class UserLibraryServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a live tv program
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getLivetvProgramsById(data: GetLivetvProgramsByIdData): CancelablePromise<GetLivetvProgramsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Programs/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets latest media
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.limit Limit
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, SortName, Studios, Taglines
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.isFolder Filter by items that are folders, or not.
     * @param data.isPlayed Filter by items that are played, or not.
     * @param data.groupItems Whether or not to group items into a parent container.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getUsersByUseridItemsLatest(data: GetUsersByUseridItemsLatestData): CancelablePromise<GetUsersByUseridItemsLatestResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/Latest',
            path: {
                UserId: data.userId
            },
            query: {
                Limit: data.limit,
                ParentId: data.parentId,
                Fields: data.fields,
                IncludeItemTypes: data.includeItemTypes,
                IsFolder: data.isFolder,
                IsPlayed: data.isPlayed,
                GroupItems: data.groupItems,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets an item from a user's library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getUsersByUseridItemsById(data: GetUsersByUseridItemsByIdData): CancelablePromise<GetUsersByUseridItemsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets the root folder from a user's library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getUsersByUseridItemsRoot(data: GetUsersByUseridItemsRootData): CancelablePromise<GetUsersByUseridItemsRootResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/Root',
            path: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Marks an item as a favorite
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public postUsersByUseridFavoriteitemsById(data: PostUsersByUseridFavoriteitemsByIdData): CancelablePromise<PostUsersByUseridFavoriteitemsByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/FavoriteItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Unmarks an item as a favorite
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public deleteUsersByUseridFavoriteitemsById(data: DeleteUsersByUseridFavoriteitemsByIdData): CancelablePromise<DeleteUsersByUseridFavoriteitemsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{UserId}/FavoriteItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets special features for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Movie Id
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getUsersByUseridItemsByIdSpecialfeatures(data: GetUsersByUseridItemsByIdSpecialfeaturesData): CancelablePromise<GetUsersByUseridItemsByIdSpecialfeaturesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/{Id}/SpecialFeatures',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets local trailers for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getUsersByUseridItemsByIdLocaltrailers(data: GetUsersByUseridItemsByIdLocaltrailersData): CancelablePromise<GetUsersByUseridItemsByIdLocaltrailersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/{Id}/LocalTrailers',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets intros to play before the main media item plays
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getUsersByUseridItemsByIdIntros(data: GetUsersByUseridItemsByIdIntrosData): CancelablePromise<GetUsersByUseridItemsByIdIntrosResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/{Id}/Intros',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a user's saved personal rating for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public deleteUsersByUseridItemsByIdRating(data: DeleteUsersByUseridItemsByIdRatingData): CancelablePromise<DeleteUsersByUseridItemsByIdRatingResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{UserId}/Items/{Id}/Rating',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user's rating for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.likes Whether the user likes the item or not. true/false
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public postUsersByUseridItemsByIdRating(data: PostUsersByUseridItemsByIdRatingData): CancelablePromise<PostUsersByUseridItemsByIdRatingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/Items/{Id}/Rating',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                Likes: data.likes
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ActivityLogServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets activity log entries
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.minDate Optional. The minimum date. Format = ISO
     * @returns QueryResult_ActivityLogEntry Operation successful. Returning a QueryResult<ActivityLogEntry> object.
     * @throws ApiError
     */
    public getSystemActivitylogEntries(data: GetSystemActivitylogEntriesData = {}): CancelablePromise<GetSystemActivitylogEntriesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/ActivityLog/Entries',
            query: {
                StartIndex: data.startIndex,
                Limit: data.limit,
                MinDate: data.minDate
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class SuggestionsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets items based on a query.
     * No authentication required
     * @param data The data for the request.
     * @param data.userId
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getUsersByUseridSuggestions(data: GetUsersByUseridSuggestionsData): CancelablePromise<GetUsersByUseridSuggestionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Suggestions',
            path: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class UserViewsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.includeExternalContent Whether or not to include external views such as channels or live tv
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getUsersByUseridViews(data: GetUsersByUseridViewsData): CancelablePromise<GetUsersByUseridViewsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Views',
            path: {
                UserId: data.userId
            },
            query: {
                IncludeExternalContent: data.includeExternalContent
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.userId User Id
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getUsersByUseridGroupingoptions(data: GetUsersByUseridGroupingoptionsData): CancelablePromise<GetUsersByUseridGroupingoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/GroupingOptions',
            path: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class VideoHlsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.profile Optional. Specify a specific h264 profile, e.g. main, baseline, high.
     * @param data.level Optional. Specify a level for the h264 profile, e.g. 3, 3.1.
     * @param data.framerate Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.maxFramerate Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxRefFrames Optional.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdLiveM3U8(data: GetVideosByIdLiveM3U8Data): CancelablePromise<GetVideosByIdLiveM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/live.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                Profile: data.profile,
                Level: data.level,
                Framerate: data.framerate,
                MaxFramerate: data.maxFramerate,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxRefFrames: data.maxRefFrames,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class ServerApiEndpointsService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Tests SMTP
     * No authentication required
     * @param data The data for the request.
     * @param data.userId User Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postNotificationSmtpTestByUserid(data: PostNotificationSmtpTestByUseridData): CancelablePromise<PostNotificationSmtpTestByUseridResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Notification/SMTP/Test/{UserID}',
            path: {
                UserID: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}

export class SubtitleServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public getProvidersSubtitlesSubtitlesById(data: GetProvidersSubtitlesSubtitlesByIdData): CancelablePromise<GetProvidersSubtitlesSubtitlesByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Providers/Subtitles/Subtitles/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Deletes an external subtitle file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.index The subtitle stream index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteVideosByIdSubtitlesByIndex(data: DeleteVideosByIdSubtitlesByIndexData): CancelablePromise<DeleteVideosByIdSubtitlesByIndexResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Videos/{Id}/Subtitles/{Index}',
            path: {
                Id: data.id,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.language Language
     * @param data.isPerfectMatch IsPerfectMatch
     * @param data.isForced IsForced
     * @returns RemoteSubtitleInfo Operation successful. Returning a RemoteSubtitleInfo[] object.
     * @throws ApiError
     */
    public getItemsByIdRemotesearchSubtitlesByLanguage(data: GetItemsByIdRemotesearchSubtitlesByLanguageData): CancelablePromise<GetItemsByIdRemotesearchSubtitlesByLanguageResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/RemoteSearch/Subtitles/{Language}',
            path: {
                Id: data.id,
                Language: data.language
            },
            query: {
                IsPerfectMatch: data.isPerfectMatch,
                IsForced: data.isForced
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.subtitleId SubtitleId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdRemotesearchSubtitlesBySubtitleid(data: PostItemsByIdRemotesearchSubtitlesBySubtitleidData): CancelablePromise<PostItemsByIdRemotesearchSubtitlesBySubtitleidResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/RemoteSearch/Subtitles/{SubtitleId}',
            path: {
                Id: data.id,
                SubtitleId: data.subtitleId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets subtitles in a specified format.
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.index The subtitle stream index
     * @param data.format Format
     * @param data.startPositionTicks StartPositionTicks
     * @param data.endPositionTicks EndPositionTicks
     * @param data.copyTimestamps CopyTimestamps
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdByMediasourceidSubtitlesByIndexByFormat(data: GetVideosByIdByMediasourceidSubtitlesByIndexByFormatData): CancelablePromise<GetVideosByIdByMediasourceidSubtitlesByIndexByFormatResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}',
            path: {
                Id: data.id,
                MediaSourceId: data.mediaSourceId,
                Index: data.index,
                Format: data.format
            },
            query: {
                StartPositionTicks: data.startPositionTicks,
                EndPositionTicks: data.endPositionTicks,
                CopyTimestamps: data.copyTimestamps
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
    /**
     * Gets subtitles in a specified format.
     * No authentication required
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.index The subtitle stream index
     * @param data.format Format
     * @param data.startPositionTicks StartPositionTicks
     * @param data.endPositionTicks EndPositionTicks
     * @param data.copyTimestamps CopyTimestamps
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksByFormat(data: GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksByFormatData): CancelablePromise<GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksByFormatResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}',
            path: {
                Id: data.id,
                MediaSourceId: data.mediaSourceId,
                Index: data.index,
                Format: data.format,
                StartPositionTicks: data.startPositionTicks
            },
            query: {
                EndPositionTicks: data.endPositionTicks,
                CopyTimestamps: data.copyTimestamps
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                '5XX': 'Server error.'
            }
        });
    }
    
}