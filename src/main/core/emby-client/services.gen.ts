// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import type { BaseHttpRequest } from './core/BaseHttpRequest';
import type { GetArtistsData, GetArtistsResponse, GetArtistsByNameData, GetArtistsByNameResponse, GetArtistsAlbumartistsData, GetArtistsAlbumartistsResponse, GetAudiocodecsData, GetAudiocodecsResponse, GetAudiolayoutsData, GetAudiolayoutsResponse, GetContainersData, GetContainersResponse, GetExtendedvideotypesData, GetExtendedvideotypesResponse, GetItemtypesData, GetItemtypesResponse, GetStreamlanguagesData, GetStreamlanguagesResponse, GetSubtitlecodecsData, GetSubtitlecodecsResponse, GetTagsData, GetTagsResponse, GetVideocodecsData, GetVideocodecsResponse, GetYearsData, GetYearsResponse, GetArtistsPrefixesData, GetArtistsPrefixesResponse, GetItemsPrefixesData, GetItemsPrefixesResponse, PostItemsByIdTagsAddData, PostItemsByIdTagsAddResponse, PostItemsByIdTagsDeleteData, PostItemsByIdTagsDeleteResponse, GetChannelsData, GetChannelsResponse, PostCollectionsData, PostCollectionsResponse, PostCollectionsByIdItemsData, PostCollectionsByIdItemsResponse, DeleteCollectionsByIdItemsData, DeleteCollectionsByIdItemsResponse, PostCollectionsByIdItemsDeleteData, PostCollectionsByIdItemsDeleteResponse, GetDevicesData, GetDevicesResponse, DeleteDevicesData, DeleteDevicesResponse, PostDevicesOptionsData, PostDevicesOptionsResponse, GetDevicesOptionsData, GetDevicesOptionsResponse, GetDevicesInfoData, GetDevicesInfoResponse, GetDevicesCamerauploadsResponse, PostDevicesCamerauploadsData, PostDevicesCamerauploadsResponse, PostDevicesDeleteData, PostDevicesDeleteResponse, GetFeaturesResponse, GetGamegenresData, GetGamegenresResponse, GetGamegenresByNameData, GetGamegenresByNameResponse, GetGenresData, GetGenresResponse, GetGenresByNameData, GetGenresByNameResponse, GetItemsData, GetItemsResponse, GetUsersByUseridItemsData, GetUsersByUseridItemsResponse, GetUsersByUseridItemsResumeData, GetUsersByUseridItemsResumeResponse, DeleteItemsData, DeleteItemsResponse, GetItemsCountsData, GetItemsCountsResponse, GetItemsIntrosResponse, PostItemsDeleteData, PostItemsDeleteResponse, DeleteItemsByIdData, DeleteItemsByIdResponse, GetLibrariesAvailableoptionsResponse, GetLibrarySelectablemediafoldersResponse, GetLibraryMediafoldersData, GetLibraryMediafoldersResponse, GetLibraryPhysicalpathsResponse, PostLibraryRefreshResponse, GetAlbumsByIdSimilarData, GetAlbumsByIdSimilarResponse, GetArtistsByIdSimilarData, GetArtistsByIdSimilarResponse, GetGamesByIdSimilarData, GetGamesByIdSimilarResponse, GetItemsByIdDeleteinfoData, GetItemsByIdDeleteinfoResponse, GetItemsByIdSimilarData, GetItemsByIdSimilarResponse, GetItemsByIdDownloadData, GetItemsByIdDownloadResponse, GetItemsByIdFileData, GetItemsByIdFileResponse, GetItemsByIdAncestorsData, GetItemsByIdAncestorsResponse, GetItemsByIdCriticreviewsData, GetItemsByIdCriticreviewsResponse, PostItemsByIdDeleteData, PostItemsByIdDeleteResponse, GetItemsByIdThememediaData, GetItemsByIdThememediaResponse, GetItemsByIdThemesongsData, GetItemsByIdThemesongsResponse, GetItemsByIdThemevideosData, GetItemsByIdThemevideosResponse, PostLibrarySeriesAddedResponse, PostLibrarySeriesUpdatedResponse, PostLibraryMediaUpdatedData, PostLibraryMediaUpdatedResponse, PostLibraryMoviesAddedResponse, PostLibraryMoviesUpdatedResponse, GetMoviesByIdSimilarData, GetMoviesByIdSimilarResponse, GetShowsByIdSimilarData, GetShowsByIdSimilarResponse, GetTrailersByIdSimilarData, GetTrailersByIdSimilarResponse, GetMusicgenresData, GetMusicgenresResponse, GetMusicgenresByNameData, GetMusicgenresByNameResponse, GetOfficialratingsData, GetOfficialratingsResponse, GetOpenapiResponse, GetOpenapiJsonResponse, GetSwaggerResponse, GetSwaggerJsonResponse, GetPackagesData, GetPackagesResponse, GetPackagesUpdatesData, GetPackagesUpdatesResponse, GetPackagesByNameData, GetPackagesByNameResponse, PostPackagesInstalledByNameData, PostPackagesInstalledByNameResponse, DeletePackagesInstallingByIdData, DeletePackagesInstallingByIdResponse, PostPackagesInstallingByIdDeleteData, PostPackagesInstallingByIdDeleteResponse, GetPersonsData, GetPersonsResponse, GetPersonsByNameData, GetPersonsByNameResponse, PostPlaylistsData, PostPlaylistsResponse, GetPlaylistsByIdAddtoplaylistinfoData, GetPlaylistsByIdAddtoplaylistinfoResponse, PostPlaylistsByIdItemsData, PostPlaylistsByIdItemsResponse, DeletePlaylistsByIdItemsData, DeletePlaylistsByIdItemsResponse, GetPlaylistsByIdItemsData, GetPlaylistsByIdItemsResponse, PostPlaylistsByIdItemsDeleteData, PostPlaylistsByIdItemsDeleteResponse, PostPlaylistsByIdItemsByItemidMoveByNewindexData, PostPlaylistsByIdItemsByItemidMoveByNewindexResponse, GetPluginsResponse, DeletePluginsByIdData, DeletePluginsByIdResponse, GetPluginsByIdThumbData, GetPluginsByIdThumbResponse, GetPluginsByIdConfigurationData, GetPluginsByIdConfigurationResponse, PostPluginsByIdConfigurationData, PostPluginsByIdConfigurationResponse, PostPluginsByIdDeleteData, PostPluginsByIdDeleteResponse, GetScheduledtasksData, GetScheduledtasksResponse, GetScheduledtasksByIdData, GetScheduledtasksByIdResponse, PostScheduledtasksRunningByIdData, PostScheduledtasksRunningByIdResponse, DeleteScheduledtasksRunningByIdData, DeleteScheduledtasksRunningByIdResponse, PostScheduledtasksByIdTriggersData, PostScheduledtasksByIdTriggersResponse, PostScheduledtasksRunningByIdDeleteData, PostScheduledtasksRunningByIdDeleteResponse, GetSessionsData, GetSessionsResponse, GetAuthProvidersResponse, PostAuthKeysData, PostAuthKeysResponse, GetAuthKeysData, GetAuthKeysResponse, GetSessionsPlayqueueData, GetSessionsPlayqueueResponse, PostSessionsLogoutResponse, PostSessionsCapabilitiesData, PostSessionsCapabilitiesResponse, DeleteAuthKeysByKeyData, DeleteAuthKeysByKeyResponse, PostSessionsByIdViewingData, PostSessionsByIdViewingResponse, PostSessionsByIdMessageData, PostSessionsByIdMessageResponse, PostSessionsByIdPlayingData, PostSessionsByIdPlayingResponse, PostSessionsByIdCommandData, PostSessionsByIdCommandResponse, PostSessionsCapabilitiesFullData, PostSessionsCapabilitiesFullResponse, PostAuthKeysByKeyDeleteData, PostAuthKeysByKeyDeleteResponse, PostSessionsByIdPlayingByCommandData, PostSessionsByIdPlayingByCommandResponse, PostSessionsByIdSystemByCommandData, PostSessionsByIdSystemByCommandResponse, PostSessionsByIdCommandByCommandData, PostSessionsByIdCommandByCommandResponse, PostSessionsByIdUsersByUseridData, PostSessionsByIdUsersByUseridResponse, DeleteSessionsByIdUsersByUseridData, DeleteSessionsByIdUsersByUseridResponse, PostSessionsByIdUsersByUseridDeleteData, PostSessionsByIdUsersByUseridDeleteResponse, GetStudiosData, GetStudiosResponse, GetStudiosByNameData, GetStudiosByNameResponse, GetTrailersData, GetTrailersResponse, GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData, GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse, HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData, HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse, GetItemsByIdImagesData, GetItemsByIdImagesResponse, GetArtistsByNameImagesByTypeData, GetArtistsByNameImagesByTypeResponse, HeadArtistsByNameImagesByTypeData, HeadArtistsByNameImagesByTypeResponse, GetGamegenresByNameImagesByTypeData, GetGamegenresByNameImagesByTypeResponse, HeadGamegenresByNameImagesByTypeData, HeadGamegenresByNameImagesByTypeResponse, GetGenresByNameImagesByTypeData, GetGenresByNameImagesByTypeResponse, HeadGenresByNameImagesByTypeData, HeadGenresByNameImagesByTypeResponse, GetItemsByIdImagesByTypeData, GetItemsByIdImagesByTypeResponse, HeadItemsByIdImagesByTypeData, HeadItemsByIdImagesByTypeResponse, PostItemsByIdImagesByTypeData, PostItemsByIdImagesByTypeResponse, DeleteItemsByIdImagesByTypeData, DeleteItemsByIdImagesByTypeResponse, GetMusicgenresByNameImagesByTypeData, GetMusicgenresByNameImagesByTypeResponse, HeadMusicgenresByNameImagesByTypeData, HeadMusicgenresByNameImagesByTypeResponse, GetPersonsByNameImagesByTypeData, GetPersonsByNameImagesByTypeResponse, HeadPersonsByNameImagesByTypeData, HeadPersonsByNameImagesByTypeResponse, GetStudiosByNameImagesByTypeData, GetStudiosByNameImagesByTypeResponse, HeadStudiosByNameImagesByTypeData, HeadStudiosByNameImagesByTypeResponse, GetUsersByIdImagesByTypeData, GetUsersByIdImagesByTypeResponse, HeadUsersByIdImagesByTypeData, HeadUsersByIdImagesByTypeResponse, PostUsersByIdImagesByTypeData, PostUsersByIdImagesByTypeResponse, DeleteUsersByIdImagesByTypeData, DeleteUsersByIdImagesByTypeResponse, GetArtistsByNameImagesByTypeByIndexData, GetArtistsByNameImagesByTypeByIndexResponse, HeadArtistsByNameImagesByTypeByIndexData, HeadArtistsByNameImagesByTypeByIndexResponse, GetGamegenresByNameImagesByTypeByIndexData, GetGamegenresByNameImagesByTypeByIndexResponse, HeadGamegenresByNameImagesByTypeByIndexData, HeadGamegenresByNameImagesByTypeByIndexResponse, GetGenresByNameImagesByTypeByIndexData, GetGenresByNameImagesByTypeByIndexResponse, HeadGenresByNameImagesByTypeByIndexData, HeadGenresByNameImagesByTypeByIndexResponse, GetItemsByIdImagesByTypeByIndexData, GetItemsByIdImagesByTypeByIndexResponse, HeadItemsByIdImagesByTypeByIndexData, HeadItemsByIdImagesByTypeByIndexResponse, PostItemsByIdImagesByTypeByIndexData, PostItemsByIdImagesByTypeByIndexResponse, DeleteItemsByIdImagesByTypeByIndexData, DeleteItemsByIdImagesByTypeByIndexResponse, PostItemsByIdImagesByTypeDeleteData, PostItemsByIdImagesByTypeDeleteResponse, GetMusicgenresByNameImagesByTypeByIndexData, GetMusicgenresByNameImagesByTypeByIndexResponse, HeadMusicgenresByNameImagesByTypeByIndexData, HeadMusicgenresByNameImagesByTypeByIndexResponse, GetPersonsByNameImagesByTypeByIndexData, GetPersonsByNameImagesByTypeByIndexResponse, HeadPersonsByNameImagesByTypeByIndexData, HeadPersonsByNameImagesByTypeByIndexResponse, GetStudiosByNameImagesByTypeByIndexData, GetStudiosByNameImagesByTypeByIndexResponse, HeadStudiosByNameImagesByTypeByIndexData, HeadStudiosByNameImagesByTypeByIndexResponse, GetUsersByIdImagesByTypeByIndexData, GetUsersByIdImagesByTypeByIndexResponse, HeadUsersByIdImagesByTypeByIndexData, HeadUsersByIdImagesByTypeByIndexResponse, PostUsersByIdImagesByTypeByIndexData, PostUsersByIdImagesByTypeByIndexResponse, DeleteUsersByIdImagesByTypeByIndexData, DeleteUsersByIdImagesByTypeByIndexResponse, PostUsersByIdImagesByTypeDeleteData, PostUsersByIdImagesByTypeDeleteResponse, PostItemsByIdImagesByTypeByIndexDeleteData, PostItemsByIdImagesByTypeByIndexDeleteResponse, PostItemsByIdImagesByTypeByIndexIndexData, PostItemsByIdImagesByTypeByIndexIndexResponse, PostItemsByIdImagesByTypeByIndexUrlData, PostItemsByIdImagesByTypeByIndexUrlResponse, PostUsersByIdImagesByTypeByIndexDeleteData, PostUsersByIdImagesByTypeByIndexDeleteResponse, GetArtistsInstantmixData, GetArtistsInstantmixResponse, GetAudiobooksNextupData, GetAudiobooksNextupResponse, GetMusicgenresInstantmixData, GetMusicgenresInstantmixResponse, GetAlbumsByIdInstantmixData, GetAlbumsByIdInstantmixResponse, GetItemsByIdInstantmixData, GetItemsByIdInstantmixResponse, GetMusicgenresByNameInstantmixData, GetMusicgenresByNameInstantmixResponse, GetPlaylistsByIdInstantmixData, GetPlaylistsByIdInstantmixResponse, GetSongsByIdInstantmixData, GetSongsByIdInstantmixResponse, PostBackuprestoreRestoreData, PostBackuprestoreRestoreResponse, PostBackuprestoreRestoredataData, PostBackuprestoreRestoredataResponse, GetBackuprestoreBackupinfoResponse, GetBrandingConfigurationResponse, GetBrandingCssResponse, GetBrandingCssCssResponse, GetConnectPendingResponse, GetConnectExchangeData, GetConnectExchangeResponse, PostUsersByIdConnectLinkData, PostUsersByIdConnectLinkResponse, DeleteUsersByIdConnectLinkData, DeleteUsersByIdConnectLinkResponse, PostUsersByIdConnectLinkDeleteData, PostUsersByIdConnectLinkDeleteResponse, GetDisplaypreferencesByIdData, GetDisplaypreferencesByIdResponse, PostDisplaypreferencesByDisplaypreferencesidData, PostDisplaypreferencesByDisplaypreferencesidResponse, GetEncodingTonemapoptionsResponse, GetEncodingCodecinformationVideoResponse, GetEncodingCodecconfigurationDefaultsResponse, GetEncodingFulltonemapoptionsResponse, PostEncodingFulltonemapoptionsData, PostEncodingFulltonemapoptionsResponse, GetEncodingPublictonemapoptionsResponse, PostEncodingPublictonemapoptionsData, PostEncodingPublictonemapoptionsResponse, GetEncodingSubtitleoptionsResponse, PostEncodingSubtitleoptionsData, PostEncodingSubtitleoptionsResponse, GetEncodingFfmpegoptionsResponse, PostEncodingFfmpegoptionsData, PostEncodingFfmpegoptionsResponse, GetEncodingCodecparametersData, GetEncodingCodecparametersResponse, PostEncodingCodecparametersData, PostEncodingCodecparametersResponse, PostEnvironmentValidatepathData, PostEnvironmentValidatepathResponse, GetEnvironmentDefaultdirectorybrowserResponse, GetEnvironmentDirectorycontentsData, GetEnvironmentDirectorycontentsResponse, PostEnvironmentDirectorycontentsData, PostEnvironmentDirectorycontentsResponse, GetEnvironmentNetworksharesData, GetEnvironmentNetworksharesResponse, GetEnvironmentDrivesResponse, GetEnvironmentNetworkdevicesResponse, GetEnvironmentParentpathData, GetEnvironmentParentpathResponse, GetImagesRemoteData, GetImagesRemoteResponse, GetItemsByIdRemoteimagesData, GetItemsByIdRemoteimagesResponse, GetItemsByIdRemoteimagesProvidersData, GetItemsByIdRemoteimagesProvidersResponse, PostItemsByIdRemoteimagesDownloadData, PostItemsByIdRemoteimagesDownloadResponse, PostItemsByItemidData, PostItemsByItemidResponse, GetItemsByItemidMetadataeditorData, GetItemsByItemidMetadataeditorResponse, PostItemsAccessData, PostItemsAccessResponse, PostItemsByIdMakepublicData, PostItemsByIdMakepublicResponse, PostItemsByIdMakeprivateData, PostItemsByIdMakeprivateResponse, PostItemsSharedLeaveData, PostItemsSharedLeaveResponse, GetLivetvProgramsByIdData, GetLivetvProgramsByIdResponse, GetVideosByIdAdditionalpartsData, GetVideosByIdAdditionalpartsResponse, GetUsersByUseridItemsLatestData, GetUsersByUseridItemsLatestResponse, GetUsersByUseridItemsByIdData, GetUsersByUseridItemsByIdResponse, GetUsersByUseridItemsRootData, GetUsersByUseridItemsRootResponse, PostUsersByUseridFavoriteitemsByIdData, PostUsersByUseridFavoriteitemsByIdResponse, DeleteUsersByUseridFavoriteitemsByIdData, DeleteUsersByUseridFavoriteitemsByIdResponse, GetUsersByUseridItemsByIdSpecialfeaturesData, GetUsersByUseridItemsByIdSpecialfeaturesResponse, GetUsersByUseridItemsByIdLocaltrailersData, GetUsersByUseridItemsByIdLocaltrailersResponse, GetUsersByUseridItemsByIdIntrosData, GetUsersByUseridItemsByIdIntrosResponse, PostUsersByUseridFavoriteitemsByIdDeleteData, PostUsersByUseridFavoriteitemsByIdDeleteResponse, DeleteUsersByUseridItemsByIdRatingData, DeleteUsersByUseridItemsByIdRatingResponse, PostUsersByUseridItemsByIdRatingData, PostUsersByUseridItemsByIdRatingResponse, PostUsersByUseridItemsByIdHidefromresumeData, PostUsersByUseridItemsByIdHidefromresumeResponse, PostUsersByUseridItemsByIdRatingDeleteData, PostUsersByUseridItemsByIdRatingDeleteResponse, PostLibraryVirtualfoldersData, PostLibraryVirtualfoldersResponse, DeleteLibraryVirtualfoldersResponse, GetLibraryVirtualfoldersQueryData, GetLibraryVirtualfoldersQueryResponse, PostLibraryVirtualfoldersLibraryoptionsData, PostLibraryVirtualfoldersLibraryoptionsResponse, PostLibraryVirtualfoldersNameData, PostLibraryVirtualfoldersNameResponse, PostLibraryVirtualfoldersDeleteData, PostLibraryVirtualfoldersDeleteResponse, PostLibraryVirtualfoldersPathsData, PostLibraryVirtualfoldersPathsResponse, DeleteLibraryVirtualfoldersPathsResponse, PostLibraryVirtualfoldersPathsUpdateData, PostLibraryVirtualfoldersPathsUpdateResponse, PostLibraryVirtualfoldersPathsDeleteData, PostLibraryVirtualfoldersPathsDeleteResponse, PostLivestreamsOpenData, PostLivestreamsOpenResponse, PostLivestreamsCloseData, PostLivestreamsCloseResponse, PostLivestreamsMediainfoData, PostLivestreamsMediainfoResponse, GetPlaybackBitratetestData, GetPlaybackBitratetestResponse, GetItemsByIdPlaybackinfoData, GetItemsByIdPlaybackinfoResponse, PostItemsByIdPlaybackinfoData, PostItemsByIdPlaybackinfoResponse, GetLivetvChanneltagsData, GetLivetvChanneltagsResponse, GetLivetvFolderResponse, GetLivetvChannelmappingsData, GetLivetvChannelmappingsResponse, HeadLivetvChannelmappingsData, HeadLivetvChannelmappingsResponse, PostLivetvChannelmappingsData, PostLivetvChannelmappingsResponse, PutLivetvChannelmappingsData, PutLivetvChannelmappingsResponse, DeleteLivetvChannelmappingsData, DeleteLivetvChannelmappingsResponse, GetLivetvChannelmappingoptionsData, GetLivetvChannelmappingoptionsResponse, HeadLivetvChannelmappingoptionsData, HeadLivetvChannelmappingoptionsResponse, PostLivetvChannelmappingoptionsData, PostLivetvChannelmappingoptionsResponse, PutLivetvChannelmappingoptionsData, PutLivetvChannelmappingoptionsResponse, DeleteLivetvChannelmappingoptionsData, DeleteLivetvChannelmappingoptionsResponse, PostLivetvListingprovidersData, PostLivetvListingprovidersResponse, DeleteLivetvListingprovidersData, DeleteLivetvListingprovidersResponse, GetLivetvListingprovidersData, GetLivetvListingprovidersResponse, GetLivetvTunerhostsResponse, PostLivetvTunerhostsData, PostLivetvTunerhostsResponse, DeleteLivetvTunerhostsData, DeleteLivetvTunerhostsResponse, GetLivetvInfoResponse, GetLivetvEpgData, GetLivetvEpgResponse, GetLivetvChannelsData, GetLivetvChannelsResponse, GetLivetvProgramsData, GetLivetvProgramsResponse, PostLivetvProgramsData, PostLivetvProgramsResponse, GetLivetvRecordingsData, GetLivetvRecordingsResponse, GetLivetvTimersData, GetLivetvTimersResponse, PostLivetvTimersData, PostLivetvTimersResponse, GetLivetvSeriestimersData, GetLivetvSeriestimersResponse, PostLivetvSeriestimersData, PostLivetvSeriestimersResponse, GetLivetvGuideinfoResponse, GetLivetvAvailablerecordingoptionsResponse, GetLivetvTunerhostsTypesResponse, GetLivetvManageChannelsData, GetLivetvManageChannelsResponse, GetLivetvChanneltagsPrefixesData, GetLivetvChanneltagsPrefixesResponse, GetLivetvRecordingsFoldersData, GetLivetvRecordingsFoldersResponse, GetLivetvTunersDiscvoverResponse, GetLivetvListingprovidersDefaultResponse, PostLivetvListingprovidersDeleteData, PostLivetvListingprovidersDeleteResponse, PostLivetvTunerhostsDeleteData, PostLivetvTunerhostsDeleteResponse, GetLivetvListingprovidersLineupsData, GetLivetvListingprovidersLineupsResponse, GetLivetvChannelsByIdData, GetLivetvChannelsByIdResponse, GetLivetvProgramsRecommendedData, GetLivetvProgramsRecommendedResponse, GetLivetvRecordingsSeriesResponse, GetLivetvRecordingsByIdData, GetLivetvRecordingsByIdResponse, DeleteLivetvRecordingsByIdData, DeleteLivetvRecordingsByIdResponse, GetLivetvTimersByIdData, GetLivetvTimersByIdResponse, DeleteLivetvTimersByIdData, DeleteLivetvTimersByIdResponse, PostLivetvTimersByIdData, PostLivetvTimersByIdResponse, GetLivetvSeriestimersByIdData, GetLivetvSeriestimersByIdResponse, DeleteLivetvSeriestimersByIdData, DeleteLivetvSeriestimersByIdResponse, PostLivetvSeriestimersByIdData, PostLivetvSeriestimersByIdResponse, GetLivetvTimersDefaultsData, GetLivetvTimersDefaultsResponse, GetLivetvRecordingsGroupsResponse, GetLivetvListingprovidersAvailableResponse, GetLivetvListingprovidersSchedulesdirectCountriesResponse, GetLivetvTunerhostsDefaultByTypeData, GetLivetvTunerhostsDefaultByTypeResponse, PostLivetvRecordingsByIdDeleteData, PostLivetvRecordingsByIdDeleteResponse, PostLivetvTimersByIdDeleteData, PostLivetvTimersByIdDeleteResponse, PostLivetvSeriestimersByIdDeleteData, PostLivetvSeriestimersByIdDeleteResponse, PostLivetvTunersByIdResetData, PostLivetvTunersByIdResetResponse, PostLivetvManageChannelsByIdDisabledData, PostLivetvManageChannelsByIdDisabledResponse, PostLivetvManageChannelsByIdSortindexData, PostLivetvManageChannelsByIdSortindexResponse, GetLocalizationParentalratingsResponse, GetLocalizationOptionsResponse, GetLocalizationCountriesResponse, GetLocalizationCulturesResponse, GetMoviesRecommendationsData, GetMoviesRecommendationsResponse, GetNotificationsTypesResponse, PostNotificationsAdminData, PostNotificationsAdminResponse, PostSessionsPlayingData, PostSessionsPlayingResponse, PostSessionsPlayingProgressData, PostSessionsPlayingProgressResponse, PostSessionsPlayingPingData, PostSessionsPlayingPingResponse, PostSessionsPlayingStoppedData, PostSessionsPlayingStoppedResponse, PostUsersByUseridPlayeditemsByIdData, PostUsersByUseridPlayeditemsByIdResponse, DeleteUsersByUseridPlayeditemsByIdData, DeleteUsersByUseridPlayeditemsByIdResponse, PostUsersByUseridPlayingitemsByIdData, PostUsersByUseridPlayingitemsByIdResponse, DeleteUsersByUseridPlayingitemsByIdData, DeleteUsersByUseridPlayingitemsByIdResponse, PostUsersByUseridItemsByItemidUserdataData, PostUsersByUseridItemsByItemidUserdataResponse, PostUsersByUseridPlayingitemsByIdProgressData, PostUsersByUseridPlayingitemsByIdProgressResponse, PostUsersByUseridPlayingitemsByIdDeleteData, PostUsersByUseridPlayingitemsByIdDeleteResponse, PostUsersByUseridPlayeditemsByIdDeleteData, PostUsersByUseridPlayeditemsByIdDeleteResponse, GetShowsMissingData, GetShowsMissingResponse, GetShowsUpcomingData, GetShowsUpcomingResponse, GetShowsNextupData, GetShowsNextupResponse, GetShowsByIdSeasonsData, GetShowsByIdSeasonsResponse, GetShowsByIdEpisodesData, GetShowsByIdEpisodesResponse, GetSyncTargetsData, GetSyncTargetsResponse, GetSyncJobsResponse, PostSyncJobsData, PostSyncJobsResponse, GetSyncJobitemsData, GetSyncJobitemsResponse, GetSyncOptionsData, GetSyncOptionsResponse, PostSyncOfflineactionsData, PostSyncOfflineactionsResponse, PostSyncDataData, PostSyncDataResponse, PostSyncByItemidStatusData, PostSyncByItemidStatusResponse, GetSyncJobsByIdData, GetSyncJobsByIdResponse, DeleteSyncJobsByIdData, DeleteSyncJobsByIdResponse, PostSyncJobsByIdData, PostSyncJobsByIdResponse, PostSyncItemsCancelData, PostSyncItemsCancelResponse, DeleteSyncByTargetidItemsData, DeleteSyncByTargetidItemsResponse, GetSyncItemsReadyData, GetSyncItemsReadyResponse, DeleteSyncJobitemsByIdData, DeleteSyncJobitemsByIdResponse, PostSyncJobsByIdDeleteData, PostSyncJobsByIdDeleteResponse, PostSyncByTargetidItemsDeleteData, PostSyncByTargetidItemsDeleteResponse, PostSyncJobitemsByIdTransferredData, PostSyncJobitemsByIdTransferredResponse, HeadSyncJobitemsByIdFileData, HeadSyncJobitemsByIdFileResponse, GetSyncJobitemsByIdFileData, GetSyncJobitemsByIdFileResponse, GetSyncJobitemsByIdAdditionalfilesData, GetSyncJobitemsByIdAdditionalfilesResponse, PostSyncJobitemsByIdEnableData, PostSyncJobitemsByIdEnableResponse, PostSyncJobitemsByIdDeleteData, PostSyncJobitemsByIdDeleteResponse, PostSyncJobitemsByIdMarkforremovalData, PostSyncJobitemsByIdMarkforremovalResponse, PostSyncJobitemsByIdUnmarkforremovalData, PostSyncJobitemsByIdUnmarkforremovalResponse, GetSystemConfigurationResponse, PostSystemConfigurationData, PostSystemConfigurationResponse, PostSystemConfigurationPartialData, PostSystemConfigurationPartialResponse, GetSystemConfigurationByKeyData, GetSystemConfigurationByKeyResponse, PostSystemConfigurationByKeyData, PostSystemConfigurationByKeyResponse, GetSystemReleasenotesResponse, PostSystemPingResponse, GetSystemPingResponse, GetSystemWakeonlaninfoResponse, GetSystemInfoResponse, PostSystemRestartResponse, PostSystemShutdownResponse, GetSystemEndpointResponse, GetSystemReleasenotesVersionsResponse, GetSystemLogsQueryData, GetSystemLogsQueryResponse, GetSystemLogsByNameData, GetSystemLogsByNameResponse, GetSystemInfoPublicResponse, GetSystemLogsByNameLinesData, GetSystemLogsByNameLinesResponse, GetUiViewData, GetUiViewResponse, PostUiCommandData, PostUiCommandResponse, GetUsersPublicResponse, GetUsersQueryData, GetUsersQueryResponse, GetUsersPrefixesData, GetUsersPrefixesResponse, GetUsersItemaccessData, GetUsersItemaccessResponse, GetUsersByIdData, GetUsersByIdResponse, DeleteUsersByIdData, DeleteUsersByIdResponse, PostUsersByIdData, PostUsersByIdResponse, PostUsersAuthenticatebynameData, PostUsersAuthenticatebynameResponse, PostUsersNewData, PostUsersNewResponse, PostUsersForgotpasswordData, PostUsersForgotpasswordResponse, PostUsersByIdDeleteData, PostUsersByIdDeleteResponse, PostUsersByIdAuthenticateData, PostUsersByIdAuthenticateResponse, PostUsersByIdPasswordData, PostUsersByIdPasswordResponse, PostUsersForgotpasswordPinData, PostUsersForgotpasswordPinResponse, PostUsersByIdConfigurationData, PostUsersByIdConfigurationResponse, PostUsersByIdPolicyData, PostUsersByIdPolicyResponse, DeleteUsersByIdTrackselectionsByTracktypeData, DeleteUsersByIdTrackselectionsByTracktypeResponse, PostUsersByIdConfigurationPartialData, PostUsersByIdConfigurationPartialResponse, GetUsersByUseridTypedsettingsByKeyData, GetUsersByUseridTypedsettingsByKeyResponse, PostUsersByUseridTypedsettingsByKeyData, PostUsersByUseridTypedsettingsByKeyResponse, PostUsersByIdTrackselectionsByTracktypeDeleteData, PostUsersByIdTrackselectionsByTracktypeDeleteResponse, GetUserUsageStatsGetItemPathData, GetUserUsageStatsGetItemPathResponse, GetUserUsageStatsGetItemStatsData, GetUserUsageStatsGetItemStatsResponse, GetUserUsageStatsGetItemsData, GetUserUsageStatsGetItemsResponse, GetUserUsageStatsTypeFilterListResponse, GetUserUsageStatsUserActivityData, GetUserUsageStatsUserActivityResponse, GetUserUsageStatsUserListResponse, PostUserUsageStatsImportBackupData, PostUserUsageStatsImportBackupResponse, GetUserUsageStatsLoadBackupData, GetUserUsageStatsLoadBackupResponse, GetUserUsageStatsSaveBackupResponse, GetUserUsageStatsPlayactivityData, GetUserUsageStatsPlayactivityResponse, GetUserUsageStatsHourlyreportData, GetUserUsageStatsHourlyreportResponse, GetUserUsageStatsTvshowsreportData, GetUserUsageStatsTvshowsreportResponse, GetUserUsageStatsMoviesreportData, GetUserUsageStatsMoviesreportResponse, PostUserUsageStatsSubmitCustomQueryData, PostUserUsageStatsSubmitCustomQueryResponse, GetUserUsageStatsUserplaylistData, GetUserUsageStatsUserplaylistResponse, GetUserUsageStatsSessionListResponse, GetUserUsageStatsByBreakdowntypeBreakdownreportData, GetUserUsageStatsByBreakdowntypeBreakdownreportResponse, GetUserUsageStatsUserManageByActionByIdData, GetUserUsageStatsUserManageByActionByIdResponse, GetUserUsageStatsByUseridByDateGetitemsData, GetUserUsageStatsByUseridByDateGetitemsResponse, PostVideosMergeversionsData, PostVideosMergeversionsResponse, DeleteVideosByIdAlternatesourcesData, DeleteVideosByIdAlternatesourcesResponse, PostVideosByIdAlternatesourcesDeleteData, PostVideosByIdAlternatesourcesDeleteResponse, DeleteVideosActiveencodingsData, DeleteVideosActiveencodingsResponse, PostVideosActiveencodingsDeleteData, PostVideosActiveencodingsDeleteResponse, GetVirtualtvChannelsM3UResponse, GetVirtualtvChannelsData, GetVirtualtvChannelsResponse, GetVirtualtvGuideXmlResponse, GetVirtualtvGuideData, GetVirtualtvGuideResponse, GetWebConfigurationpageResponse, GetWebConfigurationpagesResponse, GetWebStringsResponse, GetWebStringsetResponse, GetAudioByIdUniversalByContainerData, GetAudioByIdUniversalByContainerResponse, HeadAudioByIdUniversalByContainerData, HeadAudioByIdUniversalByContainerResponse, GetAudioByIdUniversalData, GetAudioByIdUniversalResponse, HeadAudioByIdUniversalData, HeadAudioByIdUniversalResponse, GetAudioByIdStreamByContainerData, GetAudioByIdStreamByContainerResponse, HeadAudioByIdStreamByContainerData, HeadAudioByIdStreamByContainerResponse, GetAudioByIdStreamData, GetAudioByIdStreamResponse, HeadAudioByIdStreamData, HeadAudioByIdStreamResponse, GetAudioByIdByStreamfilenameData, GetAudioByIdByStreamfilenameResponse, HeadAudioByIdByStreamfilenameData, HeadAudioByIdByStreamfilenameResponse, GetAudioByIdMasterM3U8Data, GetAudioByIdMasterM3U8Response, HeadAudioByIdMasterM3U8Data, HeadAudioByIdMasterM3U8Response, GetAudioByIdLiveM3U8Data, GetAudioByIdLiveM3U8Response, GetAudioByIdMainM3U8Data, GetAudioByIdMainM3U8Response, GetVideosByIdMasterM3U8Data, GetVideosByIdMasterM3U8Response, HeadVideosByIdMasterM3U8Data, HeadVideosByIdMasterM3U8Response, GetVideosByIdLiveM3U8Data, GetVideosByIdLiveM3U8Response, GetVideosByIdMainM3U8Data, GetVideosByIdMainM3U8Response, GetVideosByIdSubtitlesM3U8Data, GetVideosByIdSubtitlesM3U8Response, GetVideosByIdLiveSubtitlesM3U8Data, GetVideosByIdLiveSubtitlesM3U8Response, GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse, HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse, GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse, HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse, GetItemsByIdExternalidinfosData, GetItemsByIdExternalidinfosResponse, PostItemsRemotesearchTrailerData, PostItemsRemotesearchTrailerResponse, PostItemsRemotesearchBookData, PostItemsRemotesearchBookResponse, PostItemsRemotesearchMovieData, PostItemsRemotesearchMovieResponse, PostItemsRemotesearchSeriesData, PostItemsRemotesearchSeriesResponse, PostItemsRemotesearchGameData, PostItemsRemotesearchGameResponse, PostItemsRemotesearchBoxsetData, PostItemsRemotesearchBoxsetResponse, PostItemsRemotesearchMusicvideoData, PostItemsRemotesearchMusicvideoResponse, PostItemsRemotesearchPersonData, PostItemsRemotesearchPersonResponse, PostItemsRemotesearchMusicalbumData, PostItemsRemotesearchMusicalbumResponse, PostItemsRemotesearchMusicartistData, PostItemsRemotesearchMusicartistResponse, GetItemsRemotesearchImageData, GetItemsRemotesearchImageResponse, PostItemsMetadataResetData, PostItemsMetadataResetResponse, PostItemsRemotesearchApplyByIdData, PostItemsRemotesearchApplyByIdResponse, PostItemsByIdRefreshData, PostItemsByIdRefreshResponse, GetItemsByIdThumbnailsetData, GetItemsByIdThumbnailsetResponse, GetVideosByIdIndexBifData, GetVideosByIdIndexBifResponse, PostNotificationsServicesTestData, PostNotificationsServicesTestResponse, GetNotificationsServicesDefaultsResponse, GetSystemActivitylogEntriesData, GetSystemActivitylogEntriesResponse, GetUsersByUseridSuggestionsData, GetUsersByUseridSuggestionsResponse, GetUsersByUseridViewsData, GetUsersByUseridViewsResponse, GetVideosByIdStreamByContainerData, GetVideosByIdStreamByContainerResponse, HeadVideosByIdStreamByContainerData, HeadVideosByIdStreamByContainerResponse, GetVideosByIdStreamData, GetVideosByIdStreamResponse, HeadVideosByIdStreamData, HeadVideosByIdStreamResponse, GetVideosByIdByStreamfilenameData, GetVideosByIdByStreamfilenameResponse, HeadVideosByIdByStreamfilenameData, HeadVideosByIdByStreamfilenameResponse, DeleteItemsByIdSubtitlesByIndexData, DeleteItemsByIdSubtitlesByIndexResponse, GetProvidersSubtitlesSubtitlesByIdData, GetProvidersSubtitlesSubtitlesByIdResponse, DeleteVideosByIdSubtitlesByIndexData, DeleteVideosByIdSubtitlesByIndexResponse, GetItemsByIdRemotesearchSubtitlesByLanguageData, GetItemsByIdRemotesearchSubtitlesByLanguageResponse, PostItemsByIdSubtitlesByIndexDeleteData, PostItemsByIdSubtitlesByIndexDeleteResponse, PostItemsByIdRemotesearchSubtitlesBySubtitleidData, PostItemsByIdRemotesearchSubtitlesBySubtitleidResponse, PostVideosByIdSubtitlesByIndexDeleteData, PostVideosByIdSubtitlesByIndexDeleteResponse, GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData, GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponse, GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData, GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponse, GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData, GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponse, GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData, GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponse, GetLivetvLivestreamfilesByIdStreamByContainerData, GetLivetvLivestreamfilesByIdStreamByContainerResponse, GetLivetvLiverecordingsByIdStreamData, GetLivetvLiverecordingsByIdStreamResponse, GetLivetvLivestreamfilesByIdHlsMasterM3U8Data, GetLivetvLivestreamfilesByIdHlsMasterM3U8Response, HeadLivetvLivestreamfilesByIdHlsMasterM3U8Data, HeadLivetvLivestreamfilesByIdHlsMasterM3U8Response, GetLivetvLiverecordingsByIdHlsMasterM3U8Data, GetLivetvLiverecordingsByIdHlsMasterM3U8Response, HeadLivetvLiverecordingsByIdHlsMasterM3U8Data, HeadLivetvLiverecordingsByIdHlsMasterM3U8Response, GetLivetvLiverecordingsByIdHlsLiveM3U8Data, GetLivetvLiverecordingsByIdHlsLiveM3U8Response, HeadLivetvLiverecordingsByIdHlsLiveM3U8Data, HeadLivetvLiverecordingsByIdHlsLiveM3U8Response, GetLivetvLivestreamfilesByIdHlsLiveM3U8Data, GetLivetvLivestreamfilesByIdHlsLiveM3U8Response, HeadLivetvLivestreamfilesByIdHlsLiveM3U8Data, HeadLivetvLivestreamfilesByIdHlsLiveM3U8Response, GetLivetvLivestreamfilesByIdHlsBySegmentData, GetLivetvLivestreamfilesByIdHlsBySegmentResponse, HeadLivetvLivestreamfilesByIdHlsBySegmentData, HeadLivetvLivestreamfilesByIdHlsBySegmentResponse, GetLivetvLiverecordingsByIdHlsBySegmentData, GetLivetvLiverecordingsByIdHlsBySegmentResponse, HeadLivetvLiverecordingsByIdHlsBySegmentData, HeadLivetvLiverecordingsByIdHlsBySegmentResponse, GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerData, GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse, GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerData, GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse } from './types.gen';

export class ArtistsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all artists from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getArtists(data: GetArtistsData = {}): CancelablePromise<GetArtistsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an artist, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The artist name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getArtistsByName(data: GetArtistsByNameData): CancelablePromise<GetArtistsByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets all album artists from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getArtistsAlbumartists(data: GetArtistsAlbumartistsData = {}): CancelablePromise<GetArtistsAlbumartistsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/AlbumArtists',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class TagServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getAudiocodecs(data: GetAudiocodecsData = {}): CancelablePromise<GetAudiocodecsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/AudioCodecs',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getAudiolayouts(data: GetAudiolayoutsData = {}): CancelablePromise<GetAudiolayoutsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/AudioLayouts',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getContainers(data: GetContainersData = {}): CancelablePromise<GetContainersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Containers',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getExtendedvideotypes(data: GetExtendedvideotypesData = {}): CancelablePromise<GetExtendedvideotypesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/ExtendedVideoTypes',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getItemtypes(data: GetItemtypesData = {}): CancelablePromise<GetItemtypesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/ItemTypes',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getStreamlanguages(data: GetStreamlanguagesData = {}): CancelablePromise<GetStreamlanguagesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/StreamLanguages',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getSubtitlecodecs(data: GetSubtitlecodecsData = {}): CancelablePromise<GetSubtitlecodecsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/SubtitleCodecs',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getTags(data: GetTagsData = {}): CancelablePromise<GetTagsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Tags',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getVideocodecs(data: GetVideocodecsData = {}): CancelablePromise<GetVideocodecsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/VideoCodecs',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_TagItem Operation successful. Returning a QueryResult<TagItem> object.
     * @throws ApiError
     */
    public getYears(data: GetYearsData = {}): CancelablePromise<GetYearsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Years',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns NameValuePair Operation successful. Returning a NameValuePair[] object.
     * @throws ApiError
     */
    public getArtistsPrefixes(data: GetArtistsPrefixesData = {}): CancelablePromise<GetArtistsPrefixesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/Prefixes',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns NameValuePair Operation successful. Returning a NameValuePair[] object.
     * @throws ApiError
     */
    public getItemsPrefixes(data: GetItemsPrefixesData = {}): CancelablePromise<GetItemsPrefixesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/Prefixes',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Adds new tags to an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.requestBody AddTags
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdTagsAdd(data: PostItemsByIdTagsAddData): CancelablePromise<PostItemsByIdTagsAddResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Tags/Add',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes tags from an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.requestBody RemoveTags
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdTagsDelete(data: PostItemsByIdTagsDeleteData): CancelablePromise<PostItemsByIdTagsDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Tags/Delete',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ChannelServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets available channels
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.limit Optional. The maximum number of records to return
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getChannels(data: GetChannelsData = {}): CancelablePromise<GetChannelsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Channels',
            query: {
                UserId: data.userId,
                StartIndex: data.startIndex,
                Fields: data.fields,
                Limit: data.limit,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class CollectionServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Creates a new collection
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.isLocked Whether or not to lock the new collection.
     * @param data.name The name of the new collection.
     * @param data.parentId Optional - create the collection within a specific folder
     * @param data.ids Item Ids to add to the collection
     * @returns Collections_CollectionCreationResult Operation successful. Returning a CollectionCreationResult object.
     * @throws ApiError
     */
    public postCollections(data: PostCollectionsData = {}): CancelablePromise<PostCollectionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Collections',
            query: {
                IsLocked: data.isLocked,
                Name: data.name,
                ParentId: data.parentId,
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Adds items to a collection
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Item id, comma delimited
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postCollectionsByIdItems(data: PostCollectionsByIdItemsData): CancelablePromise<PostCollectionsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Collections/{Id}/Items',
            path: {
                Id: data.id
            },
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes items from a collection
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Item id, comma delimited
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteCollectionsByIdItems(data: DeleteCollectionsByIdItemsData): CancelablePromise<DeleteCollectionsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Collections/{Id}/Items',
            path: {
                Id: data.id
            },
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes items from a collection
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Item id, comma delimited
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postCollectionsByIdItemsDelete(data: PostCollectionsByIdItemsDeleteData): CancelablePromise<PostCollectionsByIdItemsDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Collections/{Id}/Items/Delete',
            path: {
                Id: data.id
            },
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class DeviceServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all devices
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @returns QueryResult_Devices_DeviceInfo Operation successful. Returning a QueryResult<DeviceInfo> object.
     * @throws ApiError
     */
    public getDevices(data: GetDevicesData = {}): CancelablePromise<GetDevicesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Devices',
            query: {
                SortOrder: data.sortOrder
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a device
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Device Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteDevices(data: DeleteDevicesData): CancelablePromise<DeleteDevicesResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Devices',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates device options
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Device Id
     * @param data.requestBody DeviceOptions:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postDevicesOptions(data: PostDevicesOptionsData): CancelablePromise<PostDevicesOptionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Devices/Options',
            query: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets options for a device
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Device Id
     * @returns Devices_DeviceOptions Operation successful. Returning a DeviceOptions object.
     * @throws ApiError
     */
    public getDevicesOptions(data: GetDevicesOptionsData): CancelablePromise<GetDevicesOptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Devices/Options',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets info for a device
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Device Id
     * @returns Devices_DeviceInfo Operation successful. Returning a DeviceInfo object.
     * @throws ApiError
     */
    public getDevicesInfo(data: GetDevicesInfoData): CancelablePromise<GetDevicesInfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Devices/Info',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets camera upload history for a device
     * Requires authentication as user
     * @returns Devices_ContentUploadHistory Operation successful. Returning a ContentUploadHistory object.
     * @throws ApiError
     */
    public getDevicesCamerauploads(): CancelablePromise<GetDevicesCamerauploadsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Devices/CameraUploads',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Uploads content
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.album Album
     * @param data.name Name
     * @param data.id Id
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postDevicesCamerauploads(data: PostDevicesCamerauploadsData): CancelablePromise<PostDevicesCamerauploadsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Devices/CameraUploads',
            query: {
                Album: data.album,
                Name: data.name,
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a device
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Device Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postDevicesDelete(data: PostDevicesDeleteData): CancelablePromise<PostDevicesDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Devices/Delete',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class FeatureServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of installed features
     * Requires authentication as administrator
     * @returns FeatureInfo Operation successful. Returning a FeatureInfo[] object.
     * @throws ApiError
     */
    public getFeatures(): CancelablePromise<GetFeaturesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Features',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class GameGenresServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all Game genres from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getGamegenres(data: GetGamegenresData = {}): CancelablePromise<GetGamegenresResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/GameGenres',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a Game genre, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The genre name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getGamegenresByName(data: GetGamegenresByNameData): CancelablePromise<GetGamegenresByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/GameGenres/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class GenresServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all genres from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getGenres(data: GetGenresData = {}): CancelablePromise<GetGenresResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Genres',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a genre, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The genre name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getGenresByName(data: GetGenresByNameData): CancelablePromise<GetGenresByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Genres/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ItemsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getItems(data: GetItemsData = {}): CancelablePromise<GetItemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getUsersByUseridItems(data: GetUsersByUseridItemsData): CancelablePromise<GetUsersByUseridItemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items',
            path: {
                UserId: data.userId
            },
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getUsersByUseridItemsResume(data: GetUsersByUseridItemsResumeData): CancelablePromise<GetUsersByUseridItemsResumeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/Resume',
            path: {
                UserId: data.userId
            },
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class LibraryServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Deletes an item from the library and file system
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Ids
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteItems(data: DeleteItemsData): CancelablePromise<DeleteItemsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Items',
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId Optional. Get counts from a specific user's library.
     * @param data.isFavorite Optional. Get counts of favorite items
     * @returns ItemCounts Operation successful. Returning a ItemCounts object.
     * @throws ApiError
     */
    public getItemsCounts(data: GetItemsCountsData = {}): CancelablePromise<GetItemsCountsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/Counts',
            query: {
                UserId: data.userId,
                IsFavorite: data.isFavorite
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets info to debug intros
     * Requires authentication as administrator
     * @returns Persistence_IntroDebugInfo Operation successful. Returning a List<IntroDebugInfo> object.
     * @throws ApiError
     */
    public getItemsIntros(): CancelablePromise<GetItemsIntrosResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/Intros',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes an item from the library and file system
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Ids
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsDelete(data: PostItemsDeleteData): CancelablePromise<PostItemsDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/Delete',
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes an item from the library and file system
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteItemsById(data: DeleteItemsByIdData): CancelablePromise<DeleteItemsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Items/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns Library_LibraryOptionsResult Operation successful. Returning a LibraryOptionsResult object.
     * @throws ApiError
     */
    public getLibrariesAvailableoptions(): CancelablePromise<GetLibrariesAvailableoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Libraries/AvailableOptions',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets all user media folders.
     * Requires authentication as user
     * @returns Library_MediaFolder Operation successful. Returning a MediaFolder[] object.
     * @throws ApiError
     */
    public getLibrarySelectablemediafolders(): CancelablePromise<GetLibrarySelectablemediafoldersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Library/SelectableMediaFolders',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets all user media folders.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.isHidden Optional. Filter by folders that are marked hidden, or not.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLibraryMediafolders(data: GetLibraryMediafoldersData = {}): CancelablePromise<GetLibraryMediafoldersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Library/MediaFolders',
            query: {
                IsHidden: data.isHidden
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of physical paths from virtual folders
     * Requires authentication as administrator
     * @returns string Operation successful. Returning a List<String> object.
     * @throws ApiError
     */
    public getLibraryPhysicalpaths(): CancelablePromise<GetLibraryPhysicalpathsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Library/PhysicalPaths',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Starts a library scan
     * Requires authentication as administrator
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryRefresh(): CancelablePromise<PostLibraryRefreshResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Refresh',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Finds albums similar to a given album.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getAlbumsByIdSimilar(data: GetAlbumsByIdSimilarData): CancelablePromise<GetAlbumsByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Albums/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Finds albums similar to a given album.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getArtistsByIdSimilar(data: GetArtistsByIdSimilarData): CancelablePromise<GetArtistsByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Finds games similar to a given game.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getGamesByIdSimilar(data: GetGamesByIdSimilarData): CancelablePromise<GetGamesByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Games/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets delete info for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns Library_DeleteInfo Operation successful. Returning a DeleteInfo object.
     * @throws ApiError
     */
    public getItemsByIdDeleteinfo(data: GetItemsByIdDeleteinfoData): CancelablePromise<GetItemsByIdDeleteinfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/DeleteInfo',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets similar items
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getItemsByIdSimilar(data: GetItemsByIdSimilarData): CancelablePromise<GetItemsByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Downloads item media
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdDownload(data: GetItemsByIdDownloadData): CancelablePromise<GetItemsByIdDownloadResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Download',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the original file of an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdFile(data: GetItemsByIdFileData): CancelablePromise<GetItemsByIdFileResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/File',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets all parents of an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getItemsByIdAncestors(data: GetItemsByIdAncestorsData): CancelablePromise<GetItemsByIdAncestorsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Ancestors',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets critic reviews for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getItemsByIdCriticreviews(data: GetItemsByIdCriticreviewsData): CancelablePromise<GetItemsByIdCriticreviewsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/CriticReviews',
            path: {
                Id: data.id
            },
            query: {
                StartIndex: data.startIndex,
                Limit: data.limit
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes an item from the library and file system
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdDelete(data: PostItemsByIdDeleteData): CancelablePromise<PostItemsByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets theme videos and songs for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.inheritFromParent Determines whether or not parent items should be searched for theme media.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns AllThemeMediaResult Operation successful. Returning a AllThemeMediaResult object.
     * @throws ApiError
     */
    public getItemsByIdThememedia(data: GetItemsByIdThememediaData): CancelablePromise<GetItemsByIdThememediaResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/ThemeMedia',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                InheritFromParent: data.inheritFromParent,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets theme songs for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.inheritFromParent Determines whether or not parent items should be searched for theme media.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns ThemeMediaResult Operation successful. Returning a ThemeMediaResult object.
     * @throws ApiError
     */
    public getItemsByIdThemesongs(data: GetItemsByIdThemesongsData): CancelablePromise<GetItemsByIdThemesongsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/ThemeSongs',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                InheritFromParent: data.inheritFromParent,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets theme videos for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.inheritFromParent Determines whether or not parent items should be searched for theme media.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns ThemeMediaResult Operation successful. Returning a ThemeMediaResult object.
     * @throws ApiError
     */
    public getItemsByIdThemevideos(data: GetItemsByIdThemevideosData): CancelablePromise<GetItemsByIdThemevideosResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/ThemeVideos',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                InheritFromParent: data.inheritFromParent,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deprecated. Use /Library/Media/Updated
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibrarySeriesAdded(): CancelablePromise<PostLibrarySeriesAddedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Series/Added',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deprecated. Use /Library/Media/Updated
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibrarySeriesUpdated(): CancelablePromise<PostLibrarySeriesUpdatedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Series/Updated',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Reports that new movies have been added by an external source
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody PostUpdatedMedia
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryMediaUpdated(data: PostLibraryMediaUpdatedData): CancelablePromise<PostLibraryMediaUpdatedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Media/Updated',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deprecated. Use /Library/Media/Updated
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryMoviesAdded(): CancelablePromise<PostLibraryMoviesAddedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Movies/Added',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deprecated. Use /Library/Media/Updated
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryMoviesUpdated(): CancelablePromise<PostLibraryMoviesUpdatedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/Movies/Updated',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Finds movies and trailers similar to a given movie.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getMoviesByIdSimilar(data: GetMoviesByIdSimilarData): CancelablePromise<GetMoviesByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Movies/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Finds tv shows similar to a given one.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getShowsByIdSimilar(data: GetShowsByIdSimilarData): CancelablePromise<GetShowsByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Finds movies and trailers similar to a given trailer.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getTrailersByIdSimilar(data: GetTrailersByIdSimilarData): CancelablePromise<GetTrailersByIdSimilarResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Trailers/{Id}/Similar',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class MusicGenresServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all music genres from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getMusicgenres(data: GetMusicgenresData = {}): CancelablePromise<GetMusicgenresResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a music genre, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The genre name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getMusicgenresByName(data: GetMusicgenresByNameData): CancelablePromise<GetMusicgenresByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class OfficialRatingServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_UserLibrary_OfficialRatingItem Operation successful. Returning a QueryResult<OfficialRatingItem> object.
     * @throws ApiError
     */
    public getOfficialratings(data: GetOfficialratingsData = {}): CancelablePromise<GetOfficialratingsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/OfficialRatings',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class OpenApiServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets the OpenAPI 3 specifications
     * No authentication required
     * @returns string Operation successful. Returning a String object.
     * @throws ApiError
     */
    public getOpenapi(): CancelablePromise<GetOpenapiResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/openapi',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets OpenAPI 3 specifications
     * No authentication required
     * @returns string Operation successful. Returning a String object.
     * @throws ApiError
     */
    public getOpenapiJson(): CancelablePromise<GetOpenapiJsonResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/openapi.json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the swagger specifications
     * No authentication required
     * @returns string Operation successful. Returning a String object.
     * @throws ApiError
     */
    public getSwagger(): CancelablePromise<GetSwaggerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/swagger',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the swagger specifications
     * No authentication required
     * @returns string Operation successful. Returning a String object.
     * @throws ApiError
     */
    public getSwaggerJson(): CancelablePromise<GetSwaggerJsonResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/swagger.json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class PackageServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets available packages
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.packageType Optional package type filter (System/UserInstalled)
     * @param data.targetSystems Optional. Filter by target system type. Allows multiple, comma delimited.
     * @param data.isPremium Optional. Filter by premium status
     * @param data.isAdult Optional. Filter by package that contain adult content.
     * @returns PackageInfo Operation successful. Returning a PackageInfo[] object.
     * @throws ApiError
     */
    public getPackages(data: GetPackagesData = {}): CancelablePromise<GetPackagesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Packages',
            query: {
                PackageType: data.packageType,
                TargetSystems: data.targetSystems,
                IsPremium: data.isPremium,
                IsAdult: data.isAdult
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available package updates for currently installed packages
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.packageType Package type filter (System/UserInstalled)
     * @returns PackageVersionInfo Operation successful. Returning a PackageVersionInfo[] object.
     * @throws ApiError
     */
    public getPackagesUpdates(data: GetPackagesUpdatesData): CancelablePromise<GetPackagesUpdatesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Packages/Updates',
            query: {
                PackageType: data.packageType
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a package, by name or assembly guid
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The name of the package
     * @param data.assemblyGuid The guid of the associated assembly
     * @returns PackageInfo Operation successful. Returning a PackageInfo object.
     * @throws ApiError
     */
    public getPackagesByName(data: GetPackagesByNameData): CancelablePromise<GetPackagesByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Packages/{Name}',
            path: {
                Name: data.name
            },
            query: {
                AssemblyGuid: data.assemblyGuid
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Installs a package
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.name Package name
     * @param data.assemblyGuid Guid of the associated assembly
     * @param data.version Optional version. Defaults to latest version.
     * @param data.updateClass Optional update class (Dev, Beta, Release). Defaults to Release.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postPackagesInstalledByName(data: PostPackagesInstalledByNameData): CancelablePromise<PostPackagesInstalledByNameResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Packages/Installed/{Name}',
            path: {
                Name: data.name
            },
            query: {
                AssemblyGuid: data.assemblyGuid,
                Version: data.version,
                UpdateClass: data.updateClass
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a package installation
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Installation Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deletePackagesInstallingById(data: DeletePackagesInstallingByIdData): CancelablePromise<DeletePackagesInstallingByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Packages/Installing/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a package installation
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Installation Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postPackagesInstallingByIdDelete(data: PostPackagesInstallingByIdDeleteData): CancelablePromise<PostPackagesInstallingByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Packages/Installing/{Id}/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class PersonsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all persons from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getPersons(data: GetPersonsData = {}): CancelablePromise<GetPersonsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Persons',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a person, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The person name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getPersonsByName(data: GetPersonsByNameData): CancelablePromise<GetPersonsByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Persons/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class PlaylistServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Creates a new playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The name of the new playlist.
     * @param data.ids Item Ids to add to the playlist
     * @param data.mediaType The playlist media type
     * @returns Playlists_PlaylistCreationResult Operation successful. Returning a PlaylistCreationResult object.
     * @throws ApiError
     */
    public postPlaylists(data: PostPlaylistsData = {}): CancelablePromise<PostPlaylistsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Playlists',
            query: {
                Name: data.name,
                Ids: data.ids,
                MediaType: data.mediaType
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets add to playlist info
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Item id, comma delimited
     * @param data.id
     * @param data.userId User Id
     * @returns unknown Operation successful. Returning a GetAddToPlaylistInfo object.
     * @throws ApiError
     */
    public getPlaylistsByIdAddtoplaylistinfo(data: GetPlaylistsByIdAddtoplaylistinfoData): CancelablePromise<GetPlaylistsByIdAddtoplaylistinfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Playlists/{Id}/AddToPlaylistInfo',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Adds items to a playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.ids Item id, comma delimited
     * @param data.id
     * @param data.userId User Id
     * @returns Playlists_AddToPlaylistResult Operation successful. Returning a AddToPlaylistResult object.
     * @throws ApiError
     */
    public postPlaylistsByIdItems(data: PostPlaylistsByIdItemsData): CancelablePromise<PostPlaylistsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Playlists/{Id}/Items',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes items from a playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.entryIds
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deletePlaylistsByIdItems(data: DeletePlaylistsByIdItemsData): CancelablePromise<DeletePlaylistsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Playlists/{Id}/Items',
            path: {
                Id: data.id
            },
            query: {
                EntryIds: data.entryIds
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the original items of a playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.userId User Id
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getPlaylistsByIdItems(data: GetPlaylistsByIdItemsData): CancelablePromise<GetPlaylistsByIdItemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Playlists/{Id}/Items',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Fields: data.fields,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes items from a playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.entryIds
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postPlaylistsByIdItemsDelete(data: PostPlaylistsByIdItemsDeleteData): CancelablePromise<PostPlaylistsByIdItemsDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Playlists/{Id}/Items/Delete',
            path: {
                Id: data.id
            },
            query: {
                EntryIds: data.entryIds
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Moves a playlist item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.itemId ItemId
     * @param data.id
     * @param data.newIndex NewIndex
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postPlaylistsByIdItemsByItemidMoveByNewindex(data: PostPlaylistsByIdItemsByItemidMoveByNewindexData): CancelablePromise<PostPlaylistsByIdItemsByItemidMoveByNewindexResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Playlists/{Id}/Items/{ItemId}/Move/{NewIndex}',
            path: {
                ItemId: data.itemId,
                Id: data.id,
                NewIndex: data.newIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class PluginServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of currently installed plugins
     * Requires authentication as administrator
     * @returns Plugins_PluginInfo Operation successful. Returning a PluginInfo[] object.
     * @throws ApiError
     */
    public getPlugins(): CancelablePromise<GetPluginsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Plugins',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Uninstalls a plugin
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Plugin Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deletePluginsById(data: DeletePluginsByIdData): CancelablePromise<DeletePluginsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Plugins/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a plugin thumb image
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Plugin Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getPluginsByIdThumb(data: GetPluginsByIdThumbData): CancelablePromise<GetPluginsByIdThumbResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Plugins/{Id}/Thumb',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a plugin's configuration
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Plugin Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getPluginsByIdConfiguration(data: GetPluginsByIdConfigurationData): CancelablePromise<GetPluginsByIdConfigurationResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Plugins/{Id}/Configuration',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a plugin's configuration
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Plugin Id
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postPluginsByIdConfiguration(data: PostPluginsByIdConfigurationData): CancelablePromise<PostPluginsByIdConfigurationResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Plugins/{Id}/Configuration',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Uninstalls a plugin
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Plugin Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postPluginsByIdDelete(data: PostPluginsByIdDeleteData): CancelablePromise<PostPluginsByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Plugins/{Id}/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ScheduledTaskServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets scheduled tasks
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.isHidden Optional filter tasks that are hidden, or not.
     * @param data.isEnabled Optional filter tasks that are enabled, or not.
     * @returns TaskInfo Operation successful. Returning a TaskInfo[] object.
     * @throws ApiError
     */
    public getScheduledtasks(data: GetScheduledtasksData = {}): CancelablePromise<GetScheduledtasksResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/ScheduledTasks',
            query: {
                IsHidden: data.isHidden,
                IsEnabled: data.isEnabled
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a scheduled task, by Id
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @returns TaskInfo Operation successful. Returning a TaskInfo object.
     * @throws ApiError
     */
    public getScheduledtasksById(data: GetScheduledtasksByIdData): CancelablePromise<GetScheduledtasksByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/ScheduledTasks/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Starts a scheduled task
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postScheduledtasksRunningById(data: PostScheduledtasksRunningByIdData): CancelablePromise<PostScheduledtasksRunningByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/ScheduledTasks/Running/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Stops a scheduled task
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteScheduledtasksRunningById(data: DeleteScheduledtasksRunningByIdData): CancelablePromise<DeleteScheduledtasksRunningByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/ScheduledTasks/Running/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates the triggers for a scheduled task
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody List`1:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postScheduledtasksByIdTriggers(data: PostScheduledtasksByIdTriggersData): CancelablePromise<PostScheduledtasksByIdTriggersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/ScheduledTasks/{Id}/Triggers',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Stops a scheduled task
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postScheduledtasksRunningByIdDelete(data: PostScheduledtasksRunningByIdDeleteData): CancelablePromise<PostScheduledtasksRunningByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/ScheduledTasks/Running/{Id}/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class SessionsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of sessions
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.controllableByUserId Optional. Filter by sessions that a given user is allowed to remote control.
     * @param data.deviceId Optional. Filter by device id.
     * @param data.id Optional. Filter by session id.
     * @returns Session_SessionInfo Operation successful. Returning a SessionInfo[] object.
     * @throws ApiError
     */
    public getSessions(data: GetSessionsData = {}): CancelablePromise<GetSessionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sessions',
            query: {
                ControllableByUserId: data.controllableByUserId,
                DeviceId: data.deviceId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @returns NameIdPair Operation successful. Returning a NameIdPair[] object.
     * @throws ApiError
     */
    public getAuthProviders(): CancelablePromise<GetAuthProvidersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Auth/Providers',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.app App
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postAuthKeys(data: PostAuthKeysData): CancelablePromise<PostAuthKeysResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Auth/Keys',
            query: {
                App: data.app
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAuthKeys(data: GetAuthKeysData = {}): CancelablePromise<GetAuthKeysResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Auth/Keys',
            query: {
                StartIndex: data.startIndex,
                Limit: data.limit
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a the current play queue from a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Optional. Filter by session id.
     * @param data.deviceId Optional. Filter by device id.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getSessionsPlayqueue(data: GetSessionsPlayqueueData = {}): CancelablePromise<GetSessionsPlayqueueResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sessions/PlayQueue',
            query: {
                Id: data.id,
                DeviceId: data.deviceId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Reports that a session has ended
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsLogout(): CancelablePromise<PostSessionsLogoutResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Logout',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates capabilities for a device
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.playableMediaTypes A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
     * @param data.supportedCommands A list of supported remote control commands, comma delimited
     * @param data.supportsMediaControl Determines whether media can be played remotely.
     * @param data.supportsSync Determines whether sync is supported.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsCapabilities(data: PostSessionsCapabilitiesData): CancelablePromise<PostSessionsCapabilitiesResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Capabilities',
            query: {
                Id: data.id,
                PlayableMediaTypes: data.playableMediaTypes,
                SupportedCommands: data.supportedCommands,
                SupportsMediaControl: data.supportsMediaControl,
                SupportsSync: data.supportsSync
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.key Auth Key
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteAuthKeysByKey(data: DeleteAuthKeysByKeyData): CancelablePromise<DeleteAuthKeysByKeyResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Auth/Keys/{Key}',
            path: {
                Key: data.key
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Instructs a session to browse to an item or view
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.itemType The type of item to browse to.
     * @param data.itemId The Id of the item.
     * @param data.itemName The name of the item.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdViewing(data: PostSessionsByIdViewingData): CancelablePromise<PostSessionsByIdViewingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Viewing',
            path: {
                Id: data.id
            },
            query: {
                ItemType: data.itemType,
                ItemId: data.itemId,
                ItemName: data.itemName
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Issues a command to a client to display a message to the user
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.text The message text.
     * @param data.header The message header.
     * @param data.timeoutMs The message timeout. If omitted the user will have to confirm viewing the message.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdMessage(data: PostSessionsByIdMessageData): CancelablePromise<PostSessionsByIdMessageResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Message',
            path: {
                Id: data.id
            },
            query: {
                Text: data.text,
                Header: data.header,
                TimeoutMs: data.timeoutMs
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Instructs a session to play an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.itemIds The ids of the items to play, comma delimited
     * @param data.playCommand The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
     * @param data.requestBody PlayRequest:
     * @param data.startPositionTicks The starting position of the first item.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postSessionsByIdPlaying(data: PostSessionsByIdPlayingData): CancelablePromise<PostSessionsByIdPlayingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Playing',
            path: {
                Id: data.id
            },
            query: {
                ItemIds: data.itemIds,
                StartPositionTicks: data.startPositionTicks,
                PlayCommand: data.playCommand
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Issues a system command to a client
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.requestBody GeneralCommand:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdCommand(data: PostSessionsByIdCommandData): CancelablePromise<PostSessionsByIdCommandResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Command',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates capabilities for a device
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.requestBody ClientCapabilities:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsCapabilitiesFull(data: PostSessionsCapabilitiesFullData): CancelablePromise<PostSessionsCapabilitiesFullResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Capabilities/Full',
            query: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.key Auth Key
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postAuthKeysByKeyDelete(data: PostAuthKeysByKeyDeleteData): CancelablePromise<PostAuthKeysByKeyDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Auth/Keys/{Key}/Delete',
            path: {
                Key: data.key
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Issues a playstate command to a client
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.command
     * @param data.requestBody PlaystateRequest:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdPlayingByCommand(data: PostSessionsByIdPlayingByCommandData): CancelablePromise<PostSessionsByIdPlayingByCommandResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Playing/{Command}',
            path: {
                Id: data.id,
                Command: data.command
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Issues a system command to a client
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.command The command to send.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdSystemByCommand(data: PostSessionsByIdSystemByCommandData): CancelablePromise<PostSessionsByIdSystemByCommandResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/System/{Command}',
            path: {
                Id: data.id,
                Command: data.command
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Issues a system command to a client
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.command The command to send.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdCommandByCommand(data: PostSessionsByIdCommandByCommandData): CancelablePromise<PostSessionsByIdCommandByCommandResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Command/{Command}',
            path: {
                Id: data.id,
                Command: data.command
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Adds an additional user to a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.userId UserId Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdUsersByUserid(data: PostSessionsByIdUsersByUseridData): CancelablePromise<PostSessionsByIdUsersByUseridResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Users/{UserId}',
            path: {
                Id: data.id,
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes an additional user from a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.userId UserId Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteSessionsByIdUsersByUserid(data: DeleteSessionsByIdUsersByUseridData): CancelablePromise<DeleteSessionsByIdUsersByUseridResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Sessions/{Id}/Users/{UserId}',
            path: {
                Id: data.id,
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes an additional user from a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Session Id
     * @param data.userId UserId Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsByIdUsersByUseridDelete(data: PostSessionsByIdUsersByUseridDeleteData): CancelablePromise<PostSessionsByIdUsersByUseridDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/{Id}/Users/{UserId}/Delete',
            path: {
                Id: data.id,
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class StudiosServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets all studios from a given item, folder, or the entire library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getStudios(data: GetStudiosData = {}): CancelablePromise<GetStudiosResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Studios',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a studio, by name
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The studio name
     * @param data.userId Optional. Filter by user id, and attach user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getStudiosByName(data: GetStudiosByNameData): CancelablePromise<GetStudiosByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Studios/{Name}',
            path: {
                Name: data.name
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class TrailersServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Finds movies and trailers similar to a given trailer.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getTrailers(data: GetTrailersData = {}): CancelablePromise<GetTrailersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Trailers',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ImageServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.percentPlayed
     * @param data.unPlayedCount
     * @param data.id Item Id
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(data: GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData): CancelablePromise<GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnPlayedCount}',
            path: {
                PercentPlayed: data.percentPlayed,
                UnPlayedCount: data.unPlayedCount,
                Id: data.id,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Tag: data.tag,
                Format: data.format,
                Type: data.type,
                Index: data.index
            },
            query: {
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.percentPlayed
     * @param data.unPlayedCount
     * @param data.id Item Id
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount(data: HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData): CancelablePromise<HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnPlayedCount}',
            path: {
                PercentPlayed: data.percentPlayed,
                UnPlayedCount: data.unPlayedCount,
                Id: data.id,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Tag: data.tag,
                Format: data.format,
                Type: data.type,
                Index: data.index
            },
            query: {
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets information about an item's images
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns ImageInfo Operation successful. Returning a List<ImageInfo> object.
     * @throws ApiError
     */
    public getItemsByIdImages(data: GetItemsByIdImagesData): CancelablePromise<GetItemsByIdImagesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Images',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getArtistsByNameImagesByType(data: GetArtistsByNameImagesByTypeData): CancelablePromise<GetArtistsByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headArtistsByNameImagesByType(data: HeadArtistsByNameImagesByTypeData): CancelablePromise<HeadArtistsByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Artists/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getGamegenresByNameImagesByType(data: GetGamegenresByNameImagesByTypeData): CancelablePromise<GetGamegenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/GameGenres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headGamegenresByNameImagesByType(data: HeadGamegenresByNameImagesByTypeData): CancelablePromise<HeadGamegenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/GameGenres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getGenresByNameImagesByType(data: GetGenresByNameImagesByTypeData): CancelablePromise<GetGenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Genres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headGenresByNameImagesByType(data: HeadGenresByNameImagesByTypeData): CancelablePromise<HeadGenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Genres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdImagesByType(data: GetItemsByIdImagesByTypeData): CancelablePromise<GetItemsByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headItemsByIdImagesByType(data: HeadItemsByIdImagesByTypeData): CancelablePromise<HeadItemsByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Items/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Uploads an image for an item, must be base64 encoded.
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.requestBody Binary stream
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdImagesByType(data: PostItemsByIdImagesByTypeData): CancelablePromise<PostItemsByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                Index: data.index
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteItemsByIdImagesByType(data: DeleteItemsByIdImagesByTypeData): CancelablePromise<DeleteItemsByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Items/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getMusicgenresByNameImagesByType(data: GetMusicgenresByNameImagesByTypeData): CancelablePromise<GetMusicgenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headMusicgenresByNameImagesByType(data: HeadMusicgenresByNameImagesByTypeData): CancelablePromise<HeadMusicgenresByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/MusicGenres/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getPersonsByNameImagesByType(data: GetPersonsByNameImagesByTypeData): CancelablePromise<GetPersonsByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Persons/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headPersonsByNameImagesByType(data: HeadPersonsByNameImagesByTypeData): CancelablePromise<HeadPersonsByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Persons/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getStudiosByNameImagesByType(data: GetStudiosByNameImagesByTypeData): CancelablePromise<GetStudiosByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Studios/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headStudiosByNameImagesByType(data: HeadStudiosByNameImagesByTypeData): CancelablePromise<HeadStudiosByNameImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Studios/{Name}/Images/{Type}',
            path: {
                Name: data.name,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getUsersByIdImagesByType(data: GetUsersByIdImagesByTypeData): CancelablePromise<GetUsersByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @param data.index Image Index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headUsersByIdImagesByType(data: HeadUsersByIdImagesByTypeData): CancelablePromise<HeadUsersByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Users/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Uploads an image for an item, must be base64 encoded.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.requestBody Binary stream
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdImagesByType(data: PostUsersByIdImagesByTypeData): CancelablePromise<PostUsersByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                Index: data.index
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersByIdImagesByType(data: DeleteUsersByIdImagesByTypeData): CancelablePromise<DeleteUsersByIdImagesByTypeResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{Id}/Images/{Type}',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getArtistsByNameImagesByTypeByIndex(data: GetArtistsByNameImagesByTypeByIndexData): CancelablePromise<GetArtistsByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headArtistsByNameImagesByTypeByIndex(data: HeadArtistsByNameImagesByTypeByIndexData): CancelablePromise<HeadArtistsByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Artists/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getGamegenresByNameImagesByTypeByIndex(data: GetGamegenresByNameImagesByTypeByIndexData): CancelablePromise<GetGamegenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/GameGenres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headGamegenresByNameImagesByTypeByIndex(data: HeadGamegenresByNameImagesByTypeByIndexData): CancelablePromise<HeadGamegenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/GameGenres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getGenresByNameImagesByTypeByIndex(data: GetGenresByNameImagesByTypeByIndexData): CancelablePromise<GetGenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Genres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headGenresByNameImagesByTypeByIndex(data: HeadGenresByNameImagesByTypeByIndexData): CancelablePromise<HeadGenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Genres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdImagesByTypeByIndex(data: GetItemsByIdImagesByTypeByIndexData): CancelablePromise<GetItemsByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headItemsByIdImagesByTypeByIndex(data: HeadItemsByIdImagesByTypeByIndexData): CancelablePromise<HeadItemsByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Items/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Uploads an image for an item, must be base64 encoded.
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdImagesByTypeByIndex(data: PostItemsByIdImagesByTypeByIndexData): CancelablePromise<PostItemsByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteItemsByIdImagesByTypeByIndex(data: DeleteItemsByIdImagesByTypeByIndexData): CancelablePromise<DeleteItemsByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Items/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdImagesByTypeDelete(data: PostItemsByIdImagesByTypeDeleteData): CancelablePromise<PostItemsByIdImagesByTypeDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Images/{Type}/Delete',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getMusicgenresByNameImagesByTypeByIndex(data: GetMusicgenresByNameImagesByTypeByIndexData): CancelablePromise<GetMusicgenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headMusicgenresByNameImagesByTypeByIndex(data: HeadMusicgenresByNameImagesByTypeByIndexData): CancelablePromise<HeadMusicgenresByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/MusicGenres/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getPersonsByNameImagesByTypeByIndex(data: GetPersonsByNameImagesByTypeByIndexData): CancelablePromise<GetPersonsByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Persons/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headPersonsByNameImagesByTypeByIndex(data: HeadPersonsByNameImagesByTypeByIndexData): CancelablePromise<HeadPersonsByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Persons/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getStudiosByNameImagesByTypeByIndex(data: GetStudiosByNameImagesByTypeByIndexData): CancelablePromise<GetStudiosByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Studios/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name Item name
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headStudiosByNameImagesByTypeByIndex(data: HeadStudiosByNameImagesByTypeByIndexData): CancelablePromise<HeadStudiosByNameImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Studios/{Name}/Images/{Type}/{Index}',
            path: {
                Name: data.name,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getUsersByIdImagesByTypeByIndex(data: GetUsersByIdImagesByTypeByIndexData): CancelablePromise<GetUsersByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.maxWidth The maximum image width to return.
     * @param data.maxHeight The maximum image height to return.
     * @param data.width The fixed image width to return.
     * @param data.height The fixed image height to return.
     * @param data.quality Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
     * @param data.tag Optional. Supply the cache tag from the item object to receive strong caching headers.
     * @param data.cropWhitespace Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
     * @param data.enableImageEnhancers Enable or disable image enhancers such as cover art.
     * @param data.format Determines the output foramt of the image - original,gif,jpg,png
     * @param data.backgroundColor Optional. Apply a background color for transparent images.
     * @param data.foregroundLayer Optional. Apply a foreground layer on top of the image.
     * @param data.autoOrient Set to true to force normalization of orientation in the event the renderer does not support it.
     * @param data.keepAnimation Set to true to retain image animation (when supported).
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headUsersByIdImagesByTypeByIndex(data: HeadUsersByIdImagesByTypeByIndexData): CancelablePromise<HeadUsersByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Users/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                Width: data.width,
                Height: data.height,
                Quality: data.quality,
                Tag: data.tag,
                CropWhitespace: data.cropWhitespace,
                EnableImageEnhancers: data.enableImageEnhancers,
                Format: data.format,
                BackgroundColor: data.backgroundColor,
                ForegroundLayer: data.foregroundLayer,
                AutoOrient: data.autoOrient,
                KeepAnimation: data.keepAnimation
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Uploads an image for an item, must be base64 encoded.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdImagesByTypeByIndex(data: PostUsersByIdImagesByTypeByIndexData): CancelablePromise<PostUsersByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersByIdImagesByTypeByIndex(data: DeleteUsersByIdImagesByTypeByIndexData): CancelablePromise<DeleteUsersByIdImagesByTypeByIndexResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{Id}/Images/{Type}/{Index}',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdImagesByTypeDelete(data: PostUsersByIdImagesByTypeDeleteData): CancelablePromise<PostUsersByIdImagesByTypeDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Images/{Type}/Delete',
            path: {
                Id: data.id,
                Type: data.type
            },
            query: {
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdImagesByTypeByIndexDelete(data: PostItemsByIdImagesByTypeByIndexDeleteData): CancelablePromise<PostItemsByIdImagesByTypeByIndexDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Images/{Type}/{Index}/Delete',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates the index for an item image
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.newIndex The new image index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdImagesByTypeByIndexIndex(data: PostItemsByIdImagesByTypeByIndexIndexData): CancelablePromise<PostItemsByIdImagesByTypeByIndexIndexResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Images/{Type}/{Index}/Index',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                NewIndex: data.newIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates the index for an item image
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @param data.url The url for the new image
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdImagesByTypeByIndexUrl(data: PostItemsByIdImagesByTypeByIndexUrlData): CancelablePromise<PostItemsByIdImagesByTypeByIndexUrlResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Images/{Type}/{Index}/Url',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            query: {
                Url: data.url
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.type Image Type
     * @param data.index Image Index
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdImagesByTypeByIndexDelete(data: PostUsersByIdImagesByTypeByIndexDeleteData): CancelablePromise<PostUsersByIdImagesByTypeByIndexDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Images/{Type}/{Index}/Delete',
            path: {
                Id: data.id,
                Type: data.type,
                Index: data.index
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class InstantMixServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Creates an instant playlist based on a given artist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getArtistsInstantmix(data: GetArtistsInstantmixData = {}): CancelablePromise<GetArtistsInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Artists/InstantMix',
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of next up episodes
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.albumId Optional. Filter by series id
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getAudiobooksNextup(data: GetAudiobooksNextupData): CancelablePromise<GetAudiobooksNextupResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/AudioBooks/NextUp',
            query: {
                UserId: data.userId,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Fields: data.fields,
                AlbumId: data.albumId,
                ParentId: data.parentId,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a music genre
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getMusicgenresInstantmix(data: GetMusicgenresInstantmixData = {}): CancelablePromise<GetMusicgenresInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres/InstantMix',
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a given album
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getAlbumsByIdInstantmix(data: GetAlbumsByIdInstantmixData): CancelablePromise<GetAlbumsByIdInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Albums/{Id}/InstantMix',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a given item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getItemsByIdInstantmix(data: GetItemsByIdInstantmixData): CancelablePromise<GetItemsByIdInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/InstantMix',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a music genre
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The genre name
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getMusicgenresByNameInstantmix(data: GetMusicgenresByNameInstantmixData): CancelablePromise<GetMusicgenresByNameInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/MusicGenres/{Name}/InstantMix',
            path: {
                Name: data.name
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a given playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getPlaylistsByIdInstantmix(data: GetPlaylistsByIdInstantmixData): CancelablePromise<GetPlaylistsByIdInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Playlists/{Id}/InstantMix',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Creates an instant playlist based on a given song
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getSongsByIdInstantmix(data: GetSongsByIdInstantmixData): CancelablePromise<GetSongsByIdInstantmixResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Songs/{Id}/InstantMix',
            path: {
                Id: data.id
            },
            query: {
                IncludeItemTypes: data.includeItemTypes,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                UserId: data.userId,
                Limit: data.limit,
                Fields: data.fields
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class BackupApiService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody RestoreOptions:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postBackuprestoreRestore(data: PostBackuprestoreRestoreData): CancelablePromise<PostBackuprestoreRestoreResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/BackupRestore/Restore',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody DataRestoreOptions:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postBackuprestoreRestoredata(data: PostBackuprestoreRestoredataData): CancelablePromise<PostBackuprestoreRestoredataResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/BackupRestore/RestoreData',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @returns MBBackup_Api_AllBackupsInfo Operation successful. Returning a AllBackupsInfo object.
     * @throws ApiError
     */
    public getBackuprestoreBackupinfo(): CancelablePromise<GetBackuprestoreBackupinfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/BackupRestore/BackupInfo',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class BrandingServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets branding configuration
     * Requires authentication as user
     * @returns Branding_BrandingOptions Operation successful. Returning a BrandingOptions object.
     * @throws ApiError
     */
    public getBrandingConfiguration(): CancelablePromise<GetBrandingConfigurationResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Branding/Configuration',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets custom css
     * Requires authentication as user
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getBrandingCss(): CancelablePromise<GetBrandingCssResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Branding/Css',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets custom css
     * Requires authentication as user
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getBrandingCssCss(): CancelablePromise<GetBrandingCssCssResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Branding/Css.css',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ConnectServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Creates a Connect link for a user
     * Requires authentication as administrator
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getConnectPending(): CancelablePromise<GetConnectPendingResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Connect/Pending',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the corresponding local user from a connect user id
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.connectUserId ConnectUserId
     * @returns Connect_ConnectAuthenticationExchangeResult Operation successful. Returning a ConnectAuthenticationExchangeResult object.
     * @throws ApiError
     */
    public getConnectExchange(data: GetConnectExchangeData): CancelablePromise<GetConnectExchangeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Connect/Exchange',
            query: {
                ConnectUserId: data.connectUserId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Creates a Connect link for a user
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id User Id
     * @param data.connectUsername Connect username
     * @returns Connect_UserLinkResult Operation successful. Returning a UserLinkResult object.
     * @throws ApiError
     */
    public postUsersByIdConnectLink(data: PostUsersByIdConnectLinkData): CancelablePromise<PostUsersByIdConnectLinkResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Connect/Link',
            path: {
                Id: data.id
            },
            query: {
                ConnectUsername: data.connectUsername
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes a Connect link for a user
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id User Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersByIdConnectLink(data: DeleteUsersByIdConnectLinkData): CancelablePromise<DeleteUsersByIdConnectLinkResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{Id}/Connect/Link',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes a Connect link for a user
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id User Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdConnectLinkDelete(data: PostUsersByIdConnectLinkDeleteData): CancelablePromise<PostUsersByIdConnectLinkDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Connect/Link/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class DisplayPreferencesServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a user's display preferences for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId User Id
     * @param data.client Client
     * @returns DisplayPreferences Operation successful. Returning a DisplayPreferences object.
     * @throws ApiError
     */
    public getDisplaypreferencesById(data: GetDisplaypreferencesByIdData): CancelablePromise<GetDisplaypreferencesByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/DisplayPreferences/{Id}',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                Client: data.client
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user's display preferences for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.displayPreferencesId DisplayPreferences Id
     * @param data.userId User Id
     * @param data.requestBody DisplayPreferences:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postDisplaypreferencesByDisplaypreferencesid(data: PostDisplaypreferencesByDisplaypreferencesidData): CancelablePromise<PostDisplaypreferencesByDisplaypreferencesidResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/DisplayPreferences/{DisplayPreferencesId}',
            path: {
                DisplayPreferencesId: data.displayPreferencesId
            },
            query: {
                UserId: data.userId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class EncodingInfoServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets available tone mapping options
     * Requires authentication as administrator
     * @returns Configuration_ToneMapping_ToneMapOptionsVisibility Operation successful. Returning a ToneMapOptionsVisibility object.
     * @throws ApiError
     */
    public getEncodingTonemapoptions(): CancelablePromise<GetEncodingTonemapoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Encoding/ToneMapOptions',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets details about available video encoders and decoders
     * Requires authentication as administrator
     * @returns VideoCodecBase Operation successful. Returning a VideoCodecBase[] object.
     * @throws ApiError
     */
    public getEncodingCodecinformationVideo(): CancelablePromise<GetEncodingCodecinformationVideoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Encoding/CodecInformation/Video',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets default codec configurations
     * Requires authentication as administrator
     * @returns CodecConfiguration Operation successful. Returning a CodecConfiguration[] object.
     * @throws ApiError
     */
    public getEncodingCodecconfigurationDefaults(): CancelablePromise<GetEncodingCodecconfigurationDefaultsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Encoding/CodecConfiguration/Defaults',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ToneMapOptionsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets the tone mapping options
     * Requires authentication as user
     * @returns EditObjectContainer Operation successful. Returning a EditObjectContainer object.
     * @throws ApiError
     */
    public getEncodingFulltonemapoptions(): CancelablePromise<GetEncodingFulltonemapoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Encoding/FullToneMapOptions',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates the tone mapping options
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postEncodingFulltonemapoptions(data: PostEncodingFulltonemapoptionsData): CancelablePromise<PostEncodingFulltonemapoptionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Encoding/FullToneMapOptions',
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the tone mapping options
     * Requires authentication as user
     * @returns EditObjectContainer Operation successful. Returning a EditObjectContainer object.
     * @throws ApiError
     */
    public getEncodingPublictonemapoptions(): CancelablePromise<GetEncodingPublictonemapoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Encoding/PublicToneMapOptions',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates the tone mapping options
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postEncodingPublictonemapoptions(data: PostEncodingPublictonemapoptionsData): CancelablePromise<PostEncodingPublictonemapoptionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Encoding/PublicToneMapOptions',
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class SubtitleOptionsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets the subtitle options
     * Requires authentication as user
     * @returns EditObjectContainer Operation successful. Returning a EditObjectContainer object.
     * @throws ApiError
     */
    public getEncodingSubtitleoptions(): CancelablePromise<GetEncodingSubtitleoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Encoding/SubtitleOptions',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates the subtitle options
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postEncodingSubtitleoptions(data: PostEncodingSubtitleoptionsData): CancelablePromise<PostEncodingSubtitleoptionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Encoding/SubtitleOptions',
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class FfmpegOptionsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets the ffmpeg options
     * Requires authentication as user
     * @returns EditObjectContainer Operation successful. Returning a EditObjectContainer object.
     * @throws ApiError
     */
    public getEncodingFfmpegoptions(): CancelablePromise<GetEncodingFfmpegoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Encoding/FfmpegOptions',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates the ffmpeg options
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postEncodingFfmpegoptions(data: PostEncodingFfmpegoptionsData): CancelablePromise<PostEncodingFfmpegoptionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Encoding/FfmpegOptions',
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class CodecParameterServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets the parameters for a specified codec.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.codecId Codec Id
     * @param data.parameterContext Parameter Context
     * @returns EditObjectContainer Operation successful. Returning a EditObjectContainer object.
     * @throws ApiError
     */
    public getEncodingCodecparameters(data: GetEncodingCodecparametersData): CancelablePromise<GetEncodingCodecparametersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Encoding/CodecParameters',
            query: {
                CodecId: data.codecId,
                ParameterContext: data.parameterContext
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates the parameters for a specified codec.
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.codecId Codec Id
     * @param data.parameterContext Parameter Context
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postEncodingCodecparameters(data: PostEncodingCodecparametersData): CancelablePromise<PostEncodingCodecparametersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Encoding/CodecParameters',
            query: {
                CodecId: data.codecId,
                ParameterContext: data.parameterContext
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class EnvironmentServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets the contents of a given directory in the file system
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.path
     * @param data.requestBody ValidatePath
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postEnvironmentValidatepath(data: PostEnvironmentValidatepathData): CancelablePromise<PostEnvironmentValidatepathResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Environment/ValidatePath',
            query: {
                Path: data.path
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the parent path of a given path
     * Requires authentication as administrator
     * @returns DefaultDirectoryBrowserInfo Operation successful. Returning a DefaultDirectoryBrowserInfo object.
     * @throws ApiError
     */
    public getEnvironmentDefaultdirectorybrowser(): CancelablePromise<GetEnvironmentDefaultdirectorybrowserResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/DefaultDirectoryBrowser',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the contents of a given directory in the file system
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.path
     * @param data.includeFiles An optional filter to include or exclude files from the results. true/false
     * @param data.includeDirectories An optional filter to include or exclude folders from the results. true/false
     * @returns IO_FileSystemEntryInfo Operation successful. Returning a List<FileSystemEntryInfo> object.
     * @throws ApiError
     */
    public getEnvironmentDirectorycontents(data: GetEnvironmentDirectorycontentsData): CancelablePromise<GetEnvironmentDirectorycontentsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/DirectoryContents',
            query: {
                Path: data.path,
                IncludeFiles: data.includeFiles,
                IncludeDirectories: data.includeDirectories
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the contents of a given directory in the file system
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.path
     * @param data.requestBody GetDirectoryContents
     * @param data.includeFiles An optional filter to include or exclude files from the results. true/false
     * @param data.includeDirectories An optional filter to include or exclude folders from the results. true/false
     * @returns IO_FileSystemEntryInfo Operation successful. Returning a List<FileSystemEntryInfo> object.
     * @throws ApiError
     */
    public postEnvironmentDirectorycontents(data: PostEnvironmentDirectorycontentsData): CancelablePromise<PostEnvironmentDirectorycontentsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Environment/DirectoryContents',
            query: {
                Path: data.path,
                IncludeFiles: data.includeFiles,
                IncludeDirectories: data.includeDirectories
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets shares from a network device
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.path
     * @returns IO_FileSystemEntryInfo Operation successful. Returning a List<FileSystemEntryInfo> object.
     * @throws ApiError
     */
    public getEnvironmentNetworkshares(data: GetEnvironmentNetworksharesData): CancelablePromise<GetEnvironmentNetworksharesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/NetworkShares',
            query: {
                Path: data.path
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available drives from the server's file system
     * Requires authentication as administrator
     * @returns IO_FileSystemEntryInfo Operation successful. Returning a List<FileSystemEntryInfo> object.
     * @throws ApiError
     */
    public getEnvironmentDrives(): CancelablePromise<GetEnvironmentDrivesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/Drives',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of devices on the network
     * Requires authentication as administrator
     * @returns IO_FileSystemEntryInfo Operation successful. Returning a List<FileSystemEntryInfo> object.
     * @throws ApiError
     */
    public getEnvironmentNetworkdevices(): CancelablePromise<GetEnvironmentNetworkdevicesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/NetworkDevices',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the parent path of a given path
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.path
     * @returns string Operation successful. Returning a String object.
     * @throws ApiError
     */
    public getEnvironmentParentpath(data: GetEnvironmentParentpathData): CancelablePromise<GetEnvironmentParentpathResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Environment/ParentPath',
            query: {
                Path: data.path
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class RemoteImageServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a remote image
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.imageUrl The image url
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getImagesRemote(data: GetImagesRemoteData): CancelablePromise<GetImagesRemoteResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Images/Remote',
            query: {
                ImageUrl: data.imageUrl
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available remote images for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type The image type
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.providerName Optional. The image provider to use
     * @param data.includeAllLanguages Optional.
     * @returns RemoteImageResult Operation successful. Returning a RemoteImageResult object.
     * @throws ApiError
     */
    public getItemsByIdRemoteimages(data: GetItemsByIdRemoteimagesData): CancelablePromise<GetItemsByIdRemoteimagesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/RemoteImages',
            path: {
                Id: data.id
            },
            query: {
                Type: data.type,
                StartIndex: data.startIndex,
                Limit: data.limit,
                ProviderName: data.providerName,
                IncludeAllLanguages: data.includeAllLanguages
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available remote image providers for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns ImageProviderInfo Operation successful. Returning a List<ImageProviderInfo> object.
     * @throws ApiError
     */
    public getItemsByIdRemoteimagesProviders(data: GetItemsByIdRemoteimagesProvidersData): CancelablePromise<GetItemsByIdRemoteimagesProvidersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/RemoteImages/Providers',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Downloads a remote image for an item
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.type The image type
     * @param data.providerName The image provider
     * @param data.imageUrl The image url
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdRemoteimagesDownload(data: PostItemsByIdRemoteimagesDownloadData): CancelablePromise<PostItemsByIdRemoteimagesDownloadResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/RemoteImages/Download',
            path: {
                Id: data.id
            },
            query: {
                Type: data.type,
                ProviderName: data.providerName,
                ImageUrl: data.imageUrl
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ItemUpdateServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Updates an item
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.itemId The id of the item
     * @param data.requestBody BaseItemDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByItemid(data: PostItemsByItemidData): CancelablePromise<PostItemsByItemidResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{ItemId}',
            path: {
                ItemId: data.itemId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets metadata editor info for an item
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.itemId The id of the item
     * @returns MetadataEditorInfo Operation successful. Returning a MetadataEditorInfo object.
     * @throws ApiError
     */
    public getItemsByItemidMetadataeditor(data: GetItemsByItemidMetadataeditorData): CancelablePromise<GetItemsByItemidMetadataeditorResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{ItemId}/MetadataEditor',
            path: {
                ItemId: data.itemId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class UserLibraryServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Updates user item access
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody UpdateUserItemAccess
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsAccess(data: PostItemsAccessData): CancelablePromise<PostItemsAccessResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/Access',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Makes an item public to all users
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdMakepublic(data: PostItemsByIdMakepublicData): CancelablePromise<PostItemsByIdMakepublicResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/MakePublic',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Makes an item private
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdMakeprivate(data: PostItemsByIdMakeprivateData): CancelablePromise<PostItemsByIdMakeprivateResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/MakePrivate',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Leaves a shared item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody LeaveSharedItems
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsSharedLeave(data: PostItemsSharedLeaveData): CancelablePromise<PostItemsSharedLeaveResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/Shared/Leave',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv program
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getLivetvProgramsById(data: GetLivetvProgramsByIdData): CancelablePromise<GetLivetvProgramsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Programs/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets additional parts for a video.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getVideosByIdAdditionalparts(data: GetVideosByIdAdditionalpartsData): CancelablePromise<GetVideosByIdAdditionalpartsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/AdditionalParts',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                Fields: data.fields,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets latest media
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.limit Limit
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, SortName, Studios, Taglines
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.isFolder Filter by items that are folders, or not.
     * @param data.isPlayed Filter by items that are played, or not.
     * @param data.groupItems Whether or not to group items into a parent container.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getUsersByUseridItemsLatest(data: GetUsersByUseridItemsLatestData): CancelablePromise<GetUsersByUseridItemsLatestResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/Latest',
            path: {
                UserId: data.userId
            },
            query: {
                Limit: data.limit,
                ParentId: data.parentId,
                Fields: data.fields,
                IncludeItemTypes: data.includeItemTypes,
                MediaTypes: data.mediaTypes,
                IsFolder: data.isFolder,
                IsPlayed: data.isPlayed,
                GroupItems: data.groupItems,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an item from a user's library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getUsersByUseridItemsById(data: GetUsersByUseridItemsByIdData): CancelablePromise<GetUsersByUseridItemsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the root folder from a user's library
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getUsersByUseridItemsRoot(data: GetUsersByUseridItemsRootData): CancelablePromise<GetUsersByUseridItemsRootResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/Root',
            path: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Marks an item as a favorite
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public postUsersByUseridFavoriteitemsById(data: PostUsersByUseridFavoriteitemsByIdData): CancelablePromise<PostUsersByUseridFavoriteitemsByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/FavoriteItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Unmarks an item as a favorite
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public deleteUsersByUseridFavoriteitemsById(data: DeleteUsersByUseridFavoriteitemsByIdData): CancelablePromise<DeleteUsersByUseridFavoriteitemsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{UserId}/FavoriteItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets special features for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Movie Id
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getUsersByUseridItemsByIdSpecialfeatures(data: GetUsersByUseridItemsByIdSpecialfeaturesData): CancelablePromise<GetUsersByUseridItemsByIdSpecialfeaturesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/{Id}/SpecialFeatures',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                Fields: data.fields,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets local trailers for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getUsersByUseridItemsByIdLocaltrailers(data: GetUsersByUseridItemsByIdLocaltrailersData): CancelablePromise<GetUsersByUseridItemsByIdLocaltrailersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/{Id}/LocalTrailers',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                Fields: data.fields,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets intros to play before the main media item plays
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getUsersByUseridItemsByIdIntros(data: GetUsersByUseridItemsByIdIntrosData): CancelablePromise<GetUsersByUseridItemsByIdIntrosResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Items/{Id}/Intros',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                Fields: data.fields,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Unmarks an item as a favorite
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public postUsersByUseridFavoriteitemsByIdDelete(data: PostUsersByUseridFavoriteitemsByIdDeleteData): CancelablePromise<PostUsersByUseridFavoriteitemsByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/FavoriteItems/{Id}/Delete',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a user's saved personal rating for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public deleteUsersByUseridItemsByIdRating(data: DeleteUsersByUseridItemsByIdRatingData): CancelablePromise<DeleteUsersByUseridItemsByIdRatingResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{UserId}/Items/{Id}/Rating',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user's rating for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.likes Whether the user likes the item or not. true/false
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public postUsersByUseridItemsByIdRating(data: PostUsersByUseridItemsByIdRatingData): CancelablePromise<PostUsersByUseridItemsByIdRatingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/Items/{Id}/Rating',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                Likes: data.likes
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user's hide from resume for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.hide Whether the item should be hidden from reusme or not. true/false
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public postUsersByUseridItemsByIdHidefromresume(data: PostUsersByUseridItemsByIdHidefromresumeData): CancelablePromise<PostUsersByUseridItemsByIdHidefromresumeResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/Items/{Id}/HideFromResume',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                Hide: data.hide
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a user's saved personal rating for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public postUsersByUseridItemsByIdRatingDelete(data: PostUsersByUseridItemsByIdRatingDeleteData): CancelablePromise<PostUsersByUseridItemsByIdRatingDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/Items/{Id}/Rating/Delete',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class LibraryStructureServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody AddVirtualFolder
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfolders(data: PostLibraryVirtualfoldersData): CancelablePromise<PostLibraryVirtualfoldersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLibraryVirtualfolders(): CancelablePromise<DeleteLibraryVirtualfoldersResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Library/VirtualFolders',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @returns QueryResult_VirtualFolderInfo Operation successful. Returning a QueryResult<VirtualFolderInfo> object.
     * @throws ApiError
     */
    public getLibraryVirtualfoldersQuery(data: GetLibraryVirtualfoldersQueryData = {}): CancelablePromise<GetLibraryVirtualfoldersQueryResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Library/VirtualFolders/Query',
            query: {
                StartIndex: data.startIndex,
                Limit: data.limit
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody UpdateLibraryOptions
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfoldersLibraryoptions(data: PostLibraryVirtualfoldersLibraryoptionsData): CancelablePromise<PostLibraryVirtualfoldersLibraryoptionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders/LibraryOptions',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody RenameVirtualFolder
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfoldersName(data: PostLibraryVirtualfoldersNameData): CancelablePromise<PostLibraryVirtualfoldersNameResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders/Name',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody RemoveVirtualFolder
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfoldersDelete(data: PostLibraryVirtualfoldersDeleteData): CancelablePromise<PostLibraryVirtualfoldersDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders/Delete',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody AddMediaPath
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfoldersPaths(data: PostLibraryVirtualfoldersPathsData): CancelablePromise<PostLibraryVirtualfoldersPathsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders/Paths',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLibraryVirtualfoldersPaths(): CancelablePromise<DeleteLibraryVirtualfoldersPathsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Library/VirtualFolders/Paths',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody UpdateMediaPath
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfoldersPathsUpdate(data: PostLibraryVirtualfoldersPathsUpdateData): CancelablePromise<PostLibraryVirtualfoldersPathsUpdateResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders/Paths/Update',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody RemoveMediaPath
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLibraryVirtualfoldersPathsDelete(data: PostLibraryVirtualfoldersPathsDeleteData): CancelablePromise<PostLibraryVirtualfoldersPathsDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Library/VirtualFolders/Paths/Delete',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class MediaInfoServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Opens a media source
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody LiveStreamRequest:
     * @returns LiveStreamResponse Operation successful. Returning a LiveStreamResponse object.
     * @throws ApiError
     */
    public postLivestreamsOpen(data: PostLivestreamsOpenData): CancelablePromise<PostLivestreamsOpenResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveStreams/Open',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Closes a media source
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.liveStreamId LiveStreamId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivestreamsClose(data: PostLivestreamsCloseData): CancelablePromise<PostLivestreamsCloseResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveStreams/Close',
            query: {
                LiveStreamId: data.liveStreamId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Closes a media source
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.liveStreamId LiveStreamId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postLivestreamsMediainfo(data: PostLivestreamsMediainfoData): CancelablePromise<PostLivestreamsMediainfoResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveStreams/MediaInfo',
            query: {
                LiveStreamId: data.liveStreamId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.size Size
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getPlaybackBitratetest(data: GetPlaybackBitratetestData): CancelablePromise<GetPlaybackBitratetestResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Playback/BitrateTest',
            query: {
                Size: data.size
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets live playback media info for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.userId User Id
     * @returns PlaybackInfoResponse Operation successful. Returning a PlaybackInfoResponse object.
     * @throws ApiError
     */
    public getItemsByIdPlaybackinfo(data: GetItemsByIdPlaybackinfoData): CancelablePromise<GetItemsByIdPlaybackinfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/PlaybackInfo',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets live playback media info for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody PlaybackInfoRequest:
     * @returns PlaybackInfoResponse Operation successful. Returning a PlaybackInfoResponse object.
     * @throws ApiError
     */
    public postItemsByIdPlaybackinfo(data: PostItemsByIdPlaybackinfoData): CancelablePromise<PostItemsByIdPlaybackinfoResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/PlaybackInfo',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class LiveTvServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets live tv channel tags
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLivetvChanneltags(data: GetLivetvChanneltagsData = {}): CancelablePromise<GetLivetvChanneltagsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ChannelTags',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the top level live tv folder
     * Requires authentication as user
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getLivetvFolder(): CancelablePromise<GetLivetvFolderResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Folder',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvChannelmappings(data: GetLivetvChannelmappingsData): CancelablePromise<GetLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headLivetvChannelmappings(data: HeadLivetvChannelmappingsData): CancelablePromise<HeadLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @param data.requestBody SetChannelMapping
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postLivetvChannelmappings(data: PostLivetvChannelmappingsData): CancelablePromise<PostLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @param data.requestBody SetChannelMapping
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public putLivetvChannelmappings(data: PutLivetvChannelmappingsData): CancelablePromise<PutLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'PUT',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteLivetvChannelmappings(data: DeleteLivetvChannelmappingsData): CancelablePromise<DeleteLivetvChannelmappingsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/ChannelMappings',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvChannelmappingoptions(data: GetLivetvChannelmappingoptionsData): CancelablePromise<GetLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headLivetvChannelmappingoptions(data: HeadLivetvChannelmappingoptionsData): CancelablePromise<HeadLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postLivetvChannelmappingoptions(data: PostLivetvChannelmappingoptionsData): CancelablePromise<PostLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public putLivetvChannelmappingoptions(data: PutLivetvChannelmappingoptionsData): CancelablePromise<PutLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'PUT',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.providerId Provider id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteLivetvChannelmappingoptions(data: DeleteLivetvChannelmappingoptionsData): CancelablePromise<DeleteLivetvChannelmappingoptionsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/ChannelMappingOptions',
            query: {
                ProviderId: data.providerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Adds a listing provider
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody ListingsProviderInfo:
     * @returns LiveTv_ListingsProviderInfo Operation successful. Returning a ListingsProviderInfo object.
     * @throws ApiError
     */
    public postLivetvListingproviders(data: PostLivetvListingprovidersData): CancelablePromise<PostLivetvListingprovidersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/ListingProviders',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a listing provider
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Provider id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLivetvListingproviders(data: DeleteLivetvListingprovidersData = {}): CancelablePromise<DeleteLivetvListingprovidersResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/ListingProviders',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets current listing providers
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.channelId Channel id
     * @returns LiveTv_ListingsProviderInfo Operation successful. Returning a ListingsProviderInfo[] object.
     * @throws ApiError
     */
    public getLivetvListingproviders(data: GetLivetvListingprovidersData): CancelablePromise<GetLivetvListingprovidersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ListingProviders',
            query: {
                ChannelId: data.channelId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets tuner hosts
     * Requires authentication as administrator
     * @returns LiveTv_TunerHostInfo Operation successful. Returning a TunerHostInfo[] object.
     * @throws ApiError
     */
    public getLivetvTunerhosts(): CancelablePromise<GetLivetvTunerhostsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/TunerHosts',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Adds a tuner host
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody TunerHostInfo:
     * @returns LiveTv_TunerHostInfo Operation successful. Returning a TunerHostInfo object.
     * @throws ApiError
     */
    public postLivetvTunerhosts(data: PostLivetvTunerhostsData): CancelablePromise<PostLivetvTunerhostsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/TunerHosts',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a tuner host
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Tuner host id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLivetvTunerhosts(data: DeleteLivetvTunerhostsData = {}): CancelablePromise<DeleteLivetvTunerhostsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/TunerHosts',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available live tv services.
     * Requires authentication as user
     * @returns LiveTv_LiveTvInfo Operation successful. Returning a LiveTvInfo object.
     * @throws ApiError
     */
    public getLivetvInfo(): CancelablePromise<GetLivetvInfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Info',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the epg.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.type Optional filter by channel type.
     * @param data.isLiked Filter by channels that are liked, or not.
     * @param data.isDisliked Filter by channels that are disliked, or not.
     * @param data.enableFavoriteSorting Incorporate favorite and like status into channel sorting.
     * @param data.addCurrentProgram Optional. Adds current program info to each channel
     * @param data.channelIds The channels to return guide information for.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_Api_EpgRow Operation successful. Returning a QueryResult<EpgRow> object.
     * @throws ApiError
     */
    public getLivetvEpg(data: GetLivetvEpgData = {}): CancelablePromise<GetLivetvEpgResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/EPG',
            query: {
                Type: data.type,
                IsLiked: data.isLiked,
                IsDisliked: data.isDisliked,
                EnableFavoriteSorting: data.enableFavoriteSorting,
                AddCurrentProgram: data.addCurrentProgram,
                ChannelIds: data.channelIds,
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available live tv channels.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.type Optional filter by channel type.
     * @param data.isLiked Filter by channels that are liked, or not.
     * @param data.isDisliked Filter by channels that are disliked, or not.
     * @param data.enableFavoriteSorting Incorporate favorite and like status into channel sorting.
     * @param data.addCurrentProgram Optional. Adds current program info to each channel
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLivetvChannels(data: GetLivetvChannelsData = {}): CancelablePromise<GetLivetvChannelsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Channels',
            query: {
                Type: data.type,
                IsLiked: data.isLiked,
                IsDisliked: data.isDisliked,
                EnableFavoriteSorting: data.enableFavoriteSorting,
                AddCurrentProgram: data.addCurrentProgram,
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available live tv epgs..
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.channelIds The channels to return guide information for.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvPrograms(data: GetLivetvProgramsData = {}): CancelablePromise<GetLivetvProgramsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Programs',
            query: {
                ChannelIds: data.channelIds,
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available live tv epgs..
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody BaseItemsRequest:
     * @param data.channelIds The channels to return guide information for.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postLivetvPrograms(data: PostLivetvProgramsData): CancelablePromise<PostLivetvProgramsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Programs',
            query: {
                ChannelIds: data.channelIds,
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv recordings
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.channelId Optional filter by channel id.
     * @param data.status Optional filter by recording status.
     * @param data.isInProgress Optional filter by recordings that are in progress, or not.
     * @param data.seriesTimerId Optional filter by recordings belonging to a series timer
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvRecordings(data: GetLivetvRecordingsData = {}): CancelablePromise<GetLivetvRecordingsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings',
            query: {
                ChannelId: data.channelId,
                Status: data.status,
                IsInProgress: data.isInProgress,
                SeriesTimerId: data.seriesTimerId,
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv timers
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.channelId Optional filter by channel id.
     * @param data.seriesTimerId Optional filter by timers belonging to a series timer
     * @returns QueryResult_LiveTv_TimerInfoDto Operation successful. Returning a QueryResult<TimerInfoDto> object.
     * @throws ApiError
     */
    public getLivetvTimers(data: GetLivetvTimersData = {}): CancelablePromise<GetLivetvTimersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Timers',
            query: {
                ChannelId: data.channelId,
                SeriesTimerId: data.seriesTimerId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Creates a live tv timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody TimerInfoDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvTimers(data: PostLivetvTimersData): CancelablePromise<PostLivetvTimersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Timers',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv series timers
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.sortBy Optional. Sort by SortName or Priority
     * @param data.sortOrder Optional. Sort in Ascending or Descending order
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @returns QueryResult_LiveTv_SeriesTimerInfoDto Operation successful. Returning a QueryResult<SeriesTimerInfoDto> object.
     * @throws ApiError
     */
    public getLivetvSeriestimers(data: GetLivetvSeriestimersData = {}): CancelablePromise<GetLivetvSeriestimersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/SeriesTimers',
            query: {
                SortBy: data.sortBy,
                SortOrder: data.sortOrder,
                StartIndex: data.startIndex,
                Limit: data.limit
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Creates a live tv series timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody SeriesTimerInfo:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvSeriestimers(data: PostLivetvSeriestimersData): CancelablePromise<PostLivetvSeriestimersResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/SeriesTimers',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets guide info
     * Requires authentication as user
     * @returns LiveTv_GuideInfo Operation successful. Returning a GuideInfo object.
     * @throws ApiError
     */
    public getLivetvGuideinfo(): CancelablePromise<GetLivetvGuideinfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/GuideInfo',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available recording options
     * Requires authentication as user
     * @returns Api_AvailableRecordingOptions Operation successful. Returning a AvailableRecordingOptions object.
     * @throws ApiError
     */
    public getLivetvAvailablerecordingoptions(): CancelablePromise<GetLivetvAvailablerecordingoptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/AvailableRecordingOptions',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns NameIdPair Operation successful. Returning a List<NameIdPair> object.
     * @throws ApiError
     */
    public getLivetvTunerhostsTypes(): CancelablePromise<GetLivetvTunerhostsTypesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/TunerHosts/Types',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets the channel management list
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @returns QueryResult_ChannelManagementInfo Operation successful. Returning a QueryResult<ChannelManagementInfo> object.
     * @throws ApiError
     */
    public getLivetvManageChannels(data: GetLivetvManageChannelsData = {}): CancelablePromise<GetLivetvManageChannelsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Manage/Channels',
            query: {
                StartIndex: data.startIndex,
                Limit: data.limit,
                SortBy: data.sortBy,
                SortOrder: data.sortOrder
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv channel tag prefixes
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns Api_TagItem Operation successful. Returning a TagItem[] object.
     * @throws ApiError
     */
    public getLivetvChanneltagsPrefixes(data: GetLivetvChanneltagsPrefixesData = {}): CancelablePromise<GetLivetvChanneltagsPrefixesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ChannelTags/Prefixes',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets recording folders
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId Optional filter by user and attach user data.
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto[] object.
     * @throws ApiError
     */
    public getLivetvRecordingsFolders(data: GetLivetvRecordingsFoldersData = {}): CancelablePromise<GetLivetvRecordingsFoldersResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings/Folders',
            query: {
                UserId: data.userId,
                Fields: data.fields,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns LiveTv_TunerHostInfo Operation successful. Returning a List<TunerHostInfo> object.
     * @throws ApiError
     */
    public getLivetvTunersDiscvover(): CancelablePromise<GetLivetvTunersDiscvoverResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Tuners/Discvover',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns LiveTv_ListingsProviderInfo Operation successful. Returning a ListingsProviderInfo object.
     * @throws ApiError
     */
    public getLivetvListingprovidersDefault(): CancelablePromise<GetLivetvListingprovidersDefaultResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ListingProviders/Default',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a listing provider
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Provider id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvListingprovidersDelete(data: PostLivetvListingprovidersDeleteData = {}): CancelablePromise<PostLivetvListingprovidersDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/ListingProviders/Delete',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a tuner host
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Tuner host id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvTunerhostsDelete(data: PostLivetvTunerhostsDeleteData = {}): CancelablePromise<PostLivetvTunerhostsDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/TunerHosts/Delete',
            query: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available lineups
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Provider id
     * @param data.type Provider Type
     * @param data.location Location
     * @param data.country Country
     * @returns NameIdPair Operation successful. Returning a List<NameIdPair> object.
     * @throws ApiError
     */
    public getLivetvListingprovidersLineups(data: GetLivetvListingprovidersLineupsData = {}): CancelablePromise<GetLivetvListingprovidersLineupsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ListingProviders/Lineups',
            query: {
                Id: data.id,
                Type: data.type,
                Location: data.location,
                Country: data.country
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Channel Id
     * @param data.userId Optional attach user data.
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getLivetvChannelsById(data: GetLivetvChannelsByIdData): CancelablePromise<GetLivetvChannelsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Channels/{Id}',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available live tv epgs..
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId Optional filter by user id.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.isAiring Optional. Filter by programs that are currently airing, or not.
     * @param data.hasAired Optional. Filter by programs that have completed airing, or not.
     * @param data.isSeries Optional filter for series.
     * @param data.isMovie Optional filter for movies.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.genreIds The genres to return guide information for.
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLivetvProgramsRecommended(data: GetLivetvProgramsRecommendedData = {}): CancelablePromise<GetLivetvProgramsRecommendedResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Programs/Recommended',
            query: {
                UserId: data.userId,
                Limit: data.limit,
                IsAiring: data.isAiring,
                HasAired: data.hasAired,
                IsSeries: data.isSeries,
                IsMovie: data.isMovie,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                GenreIds: data.genreIds,
                Fields: data.fields,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv recordings
     * Requires authentication as user
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLivetvRecordingsSeries(): CancelablePromise<GetLivetvRecordingsSeriesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings/Series',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Recording Id
     * @param data.userId Optional attach user data.
     * @returns BaseItemDto Operation successful. Returning a BaseItemDto object.
     * @throws ApiError
     */
    public getLivetvRecordingsById(data: GetLivetvRecordingsByIdData): CancelablePromise<GetLivetvRecordingsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings/{Id}',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a live tv recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Recording Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLivetvRecordingsById(data: DeleteLivetvRecordingsByIdData): CancelablePromise<DeleteLivetvRecordingsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/Recordings/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Timer Id
     * @returns LiveTv_TimerInfoDto Operation successful. Returning a TimerInfoDto object.
     * @throws ApiError
     */
    public getLivetvTimersById(data: GetLivetvTimersByIdData): CancelablePromise<GetLivetvTimersByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Timers/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a live tv timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Timer Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLivetvTimersById(data: DeleteLivetvTimersByIdData): CancelablePromise<DeleteLivetvTimersByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/Timers/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a live tv timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody TimerInfoDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvTimersById(data: PostLivetvTimersByIdData): CancelablePromise<PostLivetvTimersByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Timers/{Id}',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv series timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Timer Id
     * @returns LiveTv_TimerInfoDto Operation successful. Returning a TimerInfoDto object.
     * @throws ApiError
     */
    public getLivetvSeriestimersById(data: GetLivetvSeriestimersByIdData): CancelablePromise<GetLivetvSeriestimersByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/SeriesTimers/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a live tv series timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Timer Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteLivetvSeriestimersById(data: DeleteLivetvSeriestimersByIdData): CancelablePromise<DeleteLivetvSeriestimersByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/LiveTv/SeriesTimers/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a live tv series timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody SeriesTimerInfo:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvSeriestimersById(data: PostLivetvSeriestimersByIdData): CancelablePromise<PostLivetvSeriestimersByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/SeriesTimers/{Id}',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets default values for a new timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.programId Optional, to attach default values based on a program.
     * @returns LiveTv_SeriesTimerInfoDto Operation successful. Returning a SeriesTimerInfoDto object.
     * @throws ApiError
     */
    public getLivetvTimersDefaults(data: GetLivetvTimersDefaultsData = {}): CancelablePromise<GetLivetvTimersDefaultsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Timers/Defaults',
            query: {
                ProgramId: data.programId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets live tv recording groups
     * Requires authentication as user
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getLivetvRecordingsGroups(): CancelablePromise<GetLivetvRecordingsGroupsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/Recordings/Groups',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets listing provider
     * Requires authentication as administrator
     * @returns Api_ListingProviderTypeInfo Operation successful. Returning a ListingProviderTypeInfo[] object.
     * @throws ApiError
     */
    public getLivetvListingprovidersAvailable(): CancelablePromise<GetLivetvListingprovidersAvailableResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ListingProviders/Available',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets available lineups
     * Requires authentication as administrator
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvListingprovidersSchedulesdirectCountries(): CancelablePromise<GetLivetvListingprovidersSchedulesdirectCountriesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/ListingProviders/SchedulesDirect/Countries',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets tuner hosts
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.type Type
     * @returns LiveTv_TunerHostInfo Operation successful. Returning a TunerHostInfo object.
     * @throws ApiError
     */
    public getLivetvTunerhostsDefaultByType(data: GetLivetvTunerhostsDefaultByTypeData): CancelablePromise<GetLivetvTunerhostsDefaultByTypeResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/TunerHosts/Default/{Type}',
            path: {
                Type: data.type
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a live tv recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Recording Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvRecordingsByIdDelete(data: PostLivetvRecordingsByIdDeleteData): CancelablePromise<PostLivetvRecordingsByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Recordings/{Id}/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a live tv timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Timer Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvTimersByIdDelete(data: PostLivetvTimersByIdDeleteData): CancelablePromise<PostLivetvTimersByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Timers/{Id}/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a live tv series timer
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Timer Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvSeriestimersByIdDelete(data: PostLivetvSeriestimersByIdDeleteData): CancelablePromise<PostLivetvSeriestimersByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/SeriesTimers/{Id}/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Resets a tv tuner
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Tuner Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postLivetvTunersByIdReset(data: PostLivetvTunersByIdResetData): CancelablePromise<PostLivetvTunersByIdResetResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Tuners/{Id}/Reset',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Sets a channel disabled or not
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody SetChannelDisabled
     * @returns QueryResult_ChannelManagementInfo Operation successful. Returning a QueryResult<ChannelManagementInfo> object.
     * @throws ApiError
     */
    public postLivetvManageChannelsByIdDisabled(data: PostLivetvManageChannelsByIdDisabledData): CancelablePromise<PostLivetvManageChannelsByIdDisabledResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Manage/Channels/{Id}/Disabled',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Sets a channel sort index
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody SetChannelSortIndex
     * @returns QueryResult_ChannelManagementInfo Operation successful. Returning a QueryResult<ChannelManagementInfo> object.
     * @throws ApiError
     */
    public postLivetvManageChannelsByIdSortindex(data: PostLivetvManageChannelsByIdSortindexData): CancelablePromise<PostLivetvManageChannelsByIdSortindexResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/LiveTv/Manage/Channels/{Id}/SortIndex',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class LocalizationServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets known parental ratings
     * Requires authentication as user
     * @returns ParentalRating Operation successful. Returning a ParentalRating[] object.
     * @throws ApiError
     */
    public getLocalizationParentalratings(): CancelablePromise<GetLocalizationParentalratingsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Localization/ParentalRatings',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets localization options
     * Requires authentication as user
     * @returns Globalization_LocalizatonOption Operation successful. Returning a LocalizatonOption[] object.
     * @throws ApiError
     */
    public getLocalizationOptions(): CancelablePromise<GetLocalizationOptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Localization/Options',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets known countries
     * Requires authentication as user
     * @returns Globalization_CountryInfo Operation successful. Returning a CountryInfo[] object.
     * @throws ApiError
     */
    public getLocalizationCountries(): CancelablePromise<GetLocalizationCountriesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Localization/Countries',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets known cultures
     * Requires authentication as user
     * @returns Globalization_CultureDto Operation successful. Returning a CultureDto[] object.
     * @throws ApiError
     */
    public getLocalizationCultures(): CancelablePromise<GetLocalizationCulturesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Localization/Cultures',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class MoviesServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets movie recommendations
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.categoryLimit The max number of categories to return
     * @param data.itemLimit The max number of items to return per category
     * @param data.userId Optional. Filter by user id, and attach user data
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @returns RecommendationDto Operation successful. Returning a RecommendationDto[] object.
     * @throws ApiError
     */
    public getMoviesRecommendations(data: GetMoviesRecommendationsData = {}): CancelablePromise<GetMoviesRecommendationsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Movies/Recommendations',
            query: {
                CategoryLimit: data.categoryLimit,
                ItemLimit: data.itemLimit,
                UserId: data.userId,
                ParentId: data.parentId,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class NotificationsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets notification types
     * Requires authentication as user
     * @returns NotificationCategoryInfo Operation successful. Returning a NotificationCategoryInfo[] object.
     * @throws ApiError
     */
    public getNotificationsTypes(): CancelablePromise<GetNotificationsTypesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Notifications/Types',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Sends a notification to all admin users
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.name The notification's name
     * @param data.description The notification's description
     * @param data.imageUrl The notification's image url
     * @param data.url The notification's info url
     * @param data.level The notification level
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postNotificationsAdmin(data: PostNotificationsAdminData): CancelablePromise<PostNotificationsAdminResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Notifications/Admin',
            query: {
                Name: data.name,
                Description: data.description,
                ImageUrl: data.imageUrl,
                Url: data.url,
                Level: data.level
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class PlaystateServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Reports playback has started within a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody PlaybackStartInfo:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsPlaying(data: PostSessionsPlayingData): CancelablePromise<PostSessionsPlayingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Playing',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Reports playback progress within a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody PlaybackProgressInfo:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsPlayingProgress(data: PostSessionsPlayingProgressData): CancelablePromise<PostSessionsPlayingProgressResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Playing/Progress',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Pings a playback session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.playSessionId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsPlayingPing(data: PostSessionsPlayingPingData = {}): CancelablePromise<PostSessionsPlayingPingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Playing/Ping',
            query: {
                PlaySessionId: data.playSessionId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Reports playback has stopped within a session
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody PlaybackStopInfo:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSessionsPlayingStopped(data: PostSessionsPlayingStoppedData): CancelablePromise<PostSessionsPlayingStoppedResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sessions/Playing/Stopped',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Marks an item as played
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.datePlayed The date the item was played (if any). Format = yyyyMMddHHmmss
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public postUsersByUseridPlayeditemsById(data: PostUsersByUseridPlayeditemsByIdData): CancelablePromise<PostUsersByUseridPlayeditemsByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/PlayedItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                DatePlayed: data.datePlayed
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Marks an item as unplayed
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public deleteUsersByUseridPlayeditemsById(data: DeleteUsersByUseridPlayeditemsByIdData): CancelablePromise<DeleteUsersByUseridPlayeditemsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{UserId}/PlayedItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Reports that a user has begun playing an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.mediaSourceId The id of the MediaSource
     * @param data.canSeek Indicates if the client can seek
     * @param data.audioStreamIndex
     * @param data.subtitleStreamIndex
     * @param data.playMethod
     * @param data.liveStreamId
     * @param data.playSessionId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByUseridPlayingitemsById(data: PostUsersByUseridPlayingitemsByIdData): CancelablePromise<PostUsersByUseridPlayingitemsByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/PlayingItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                MediaSourceId: data.mediaSourceId,
                CanSeek: data.canSeek,
                AudioStreamIndex: data.audioStreamIndex,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                PlayMethod: data.playMethod,
                LiveStreamId: data.liveStreamId,
                PlaySessionId: data.playSessionId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Reports that a user has stopped playing an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.mediaSourceId The id of the MediaSource
     * @param data.nextMediaType The next media type that will play
     * @param data.positionTicks Optional. The position, in ticks, where playback stopped. 1ms = 10000 ticks.
     * @param data.liveStreamId
     * @param data.playSessionId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersByUseridPlayingitemsById(data: DeleteUsersByUseridPlayingitemsByIdData): CancelablePromise<DeleteUsersByUseridPlayingitemsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{UserId}/PlayingItems/{Id}',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                MediaSourceId: data.mediaSourceId,
                NextMediaType: data.nextMediaType,
                PositionTicks: data.positionTicks,
                LiveStreamId: data.liveStreamId,
                PlaySessionId: data.playSessionId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates userdata for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.itemId
     * @param data.requestBody UserItemDataDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByUseridItemsByItemidUserdata(data: PostUsersByUseridItemsByItemidUserdataData): CancelablePromise<PostUsersByUseridItemsByItemidUserdataResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/Items/{ItemId}/UserData',
            path: {
                UserId: data.userId,
                ItemId: data.itemId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Reports a user's playback progress
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.mediaSourceId The id of the MediaSource
     * @param data.requestBody OnPlaybackProgress
     * @param data.positionTicks Optional. The current position, in ticks. 1ms = 10000 ticks.
     * @param data.isPaused Indicates if the player is paused.
     * @param data.isMuted Indicates if the player is muted.
     * @param data.audioStreamIndex
     * @param data.subtitleStreamIndex
     * @param data.volumeLevel Scale of 0-100
     * @param data.playMethod
     * @param data.liveStreamId
     * @param data.playSessionId
     * @param data.repeatMode
     * @param data.subtitleOffset
     * @param data.playbackRate
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByUseridPlayingitemsByIdProgress(data: PostUsersByUseridPlayingitemsByIdProgressData): CancelablePromise<PostUsersByUseridPlayingitemsByIdProgressResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/PlayingItems/{Id}/Progress',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                MediaSourceId: data.mediaSourceId,
                PositionTicks: data.positionTicks,
                IsPaused: data.isPaused,
                IsMuted: data.isMuted,
                AudioStreamIndex: data.audioStreamIndex,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                VolumeLevel: data.volumeLevel,
                PlayMethod: data.playMethod,
                LiveStreamId: data.liveStreamId,
                PlaySessionId: data.playSessionId,
                RepeatMode: data.repeatMode,
                SubtitleOffset: data.subtitleOffset,
                PlaybackRate: data.playbackRate
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Reports that a user has stopped playing an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @param data.mediaSourceId The id of the MediaSource
     * @param data.nextMediaType The next media type that will play
     * @param data.positionTicks Optional. The position, in ticks, where playback stopped. 1ms = 10000 ticks.
     * @param data.liveStreamId
     * @param data.playSessionId
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByUseridPlayingitemsByIdDelete(data: PostUsersByUseridPlayingitemsByIdDeleteData): CancelablePromise<PostUsersByUseridPlayingitemsByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/PlayingItems/{Id}/Delete',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            query: {
                MediaSourceId: data.mediaSourceId,
                NextMediaType: data.nextMediaType,
                PositionTicks: data.positionTicks,
                LiveStreamId: data.liveStreamId,
                PlaySessionId: data.playSessionId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Marks an item as unplayed
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id Item Id
     * @returns UserItemDataDto Operation successful. Returning a UserItemDataDto object.
     * @throws ApiError
     */
    public postUsersByUseridPlayeditemsByIdDelete(data: PostUsersByUseridPlayeditemsByIdDeleteData): CancelablePromise<PostUsersByUseridPlayeditemsByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/PlayedItems/{Id}/Delete',
            path: {
                UserId: data.userId,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class TvShowsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of missing episodes
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getShowsMissing(data: GetShowsMissingData = {}): CancelablePromise<GetShowsMissingResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/Missing',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of upcoming episodes
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getShowsUpcoming(data: GetShowsUpcomingData = {}): CancelablePromise<GetShowsUpcomingResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/Upcoming',
            query: {
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of next up episodes
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.seriesId Optional. Filter by series id
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getShowsNextup(data: GetShowsNextupData): CancelablePromise<GetShowsNextupResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/NextUp',
            query: {
                UserId: data.userId,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Fields: data.fields,
                SeriesId: data.seriesId,
                ParentId: data.parentId,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets seasons for a tv series
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.id The series id
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.isSpecialSeason Optional. Filter by special season.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getShowsByIdSeasons(data: GetShowsByIdSeasonsData): CancelablePromise<GetShowsByIdSeasonsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/{Id}/Seasons',
            path: {
                Id: data.id
            },
            query: {
                UserId: data.userId,
                Fields: data.fields,
                IsSpecialSeason: data.isSpecialSeason,
                AdjacentTo: data.adjacentTo,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets episodes for a tv season
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id The series id
     * @param data.season Optional filter by season number.
     * @param data.seasonId Optional. Filter by season id
     * @param data.startItemId Optional. Skip through the list until a given item is found.
     * @param data.artistType Artist or AlbumArtist
     * @param data.maxOfficialRating Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
     * @param data.hasThemeSong Optional filter by items with theme songs.
     * @param data.hasThemeVideo Optional filter by items with theme videos.
     * @param data.hasSubtitles Optional filter by items with subtitles.
     * @param data.hasSpecialFeature Optional filter by items with special features.
     * @param data.hasTrailer Optional filter by items with trailers.
     * @param data.adjacentTo Optional. Return items that are siblings of a supplied item.
     * @param data.minIndexNumber Optional filter by minimum index number.
     * @param data.minStartDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxStartDate Optional. The maximum premiere date. Format = ISO
     * @param data.minEndDate Optional. The minimum premiere date. Format = ISO
     * @param data.maxEndDate Optional. The maximum premiere date. Format = ISO
     * @param data.minPlayers Optional filter by minimum number of game players.
     * @param data.maxPlayers Optional filter by maximum number of game players.
     * @param data.parentIndexNumber Optional filter by parent index number.
     * @param data.hasParentalRating Optional filter by items that have or do not have a parental rating
     * @param data.isHd Optional filter by items that are HD or not.
     * @param data.isUnaired Optional filter by items that are unaired episodes or not.
     * @param data.minCommunityRating Optional filter by minimum community rating.
     * @param data.minCriticRating Optional filter by minimum critic rating.
     * @param data.airedDuringSeason Gets all episodes that aired during a season, including specials.
     * @param data.minPremiereDate Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSaved Optional. The minimum premiere date. Format = ISO
     * @param data.minDateLastSavedForUser Optional. The minimum premiere date. Format = ISO
     * @param data.maxPremiereDate Optional. The maximum premiere date. Format = ISO
     * @param data.hasOverview Optional filter by items that have an overview or not.
     * @param data.hasImdbId Optional filter by items that have an imdb id or not.
     * @param data.hasTmdbId Optional filter by items that have a tmdb id or not.
     * @param data.hasTvdbId Optional filter by items that have a tvdb id or not.
     * @param data.excludeItemIds Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.recursive When searching within folders, this determines whether or not the search will be recursive. true/false
     * @param data.searchTerm Enter a search term to perform a search request
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @param data.parentId Specify this to localize the search to a specific item or folder. Omit to use the root
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
     * @param data.excludeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.includeItemTypes Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
     * @param data.anyProviderIdEquals Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
     * @param data.filters Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
     * @param data.isFavorite Optional filter by items that are marked as favorite, or not.
     * @param data.isMovie Optional filter for movies.
     * @param data.isSeries Optional filter for series.
     * @param data.isFolder Optional filter for folders.
     * @param data.isNews Optional filter for news.
     * @param data.isKids Optional filter for kids.
     * @param data.isSports Optional filter for sports.
     * @param data.isNew Optional filter for IsNew.
     * @param data.isPremiere Optional filter for IsPremiere.
     * @param data.isNewOrPremiere Optional filter for IsNewOrPremiere.
     * @param data.isRepeat Optional filter for IsRepeat.
     * @param data.projectToMedia ProjectToMedia
     * @param data.mediaTypes Optional filter by MediaType. Allows multiple, comma delimited.
     * @param data.imageTypes Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
     * @param data.sortBy Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
     * @param data.isPlayed Optional filter by items that are played, or not.
     * @param data.genres Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
     * @param data.officialRatings Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
     * @param data.tags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.excludeTags Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
     * @param data.years Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
     * @param data.enableImages Optional, include image information in output
     * @param data.enableUserData Optional, include user data
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.person Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personIds Optional. If specified, results will be filtered to include only those containing the specified person.
     * @param data.personTypes Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
     * @param data.studios Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.studioIds Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
     * @param data.artists Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.artistIds Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
     * @param data.albums Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
     * @param data.ids Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
     * @param data.videoTypes Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
     * @param data.containers Optional filter by Container. Allows multiple, comma delimeted.
     * @param data.audioCodecs Optional filter by AudioCodec. Allows multiple, comma delimeted.
     * @param data.audioLayouts Optional filter by AudioLayout. Allows multiple, comma delimeted.
     * @param data.videoCodecs Optional filter by VideoCodec. Allows multiple, comma delimeted.
     * @param data.extendedVideoTypes Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
     * @param data.subtitleCodecs Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
     * @param data.path Optional filter by Path.
     * @param data.userId User Id
     * @param data.minOfficialRating Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
     * @param data.isLocked Optional filter by items that are locked.
     * @param data.isPlaceHolder Optional filter by items that are placeholders
     * @param data.hasOfficialRating Optional filter by items that have official ratings
     * @param data.groupItemsIntoCollections Whether or not to hide items behind their boxsets.
     * @param data.is3D Optional filter by items that are 3D, or not.
     * @param data.seriesStatus Optional filter by Series Status. Allows multiple, comma delimeted.
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.artistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.albumArtistStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.nameStartsWith Optional filter by items whose name is sorted equally than a given input string.
     * @param data.nameLessThan Optional filter by items whose name is equally or lesser than a given input string.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getShowsByIdEpisodes(data: GetShowsByIdEpisodesData): CancelablePromise<GetShowsByIdEpisodesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Shows/{Id}/Episodes',
            path: {
                Id: data.id
            },
            query: {
                Season: data.season,
                SeasonId: data.seasonId,
                StartItemId: data.startItemId,
                ArtistType: data.artistType,
                MaxOfficialRating: data.maxOfficialRating,
                HasThemeSong: data.hasThemeSong,
                HasThemeVideo: data.hasThemeVideo,
                HasSubtitles: data.hasSubtitles,
                HasSpecialFeature: data.hasSpecialFeature,
                HasTrailer: data.hasTrailer,
                AdjacentTo: data.adjacentTo,
                MinIndexNumber: data.minIndexNumber,
                MinStartDate: data.minStartDate,
                MaxStartDate: data.maxStartDate,
                MinEndDate: data.minEndDate,
                MaxEndDate: data.maxEndDate,
                MinPlayers: data.minPlayers,
                MaxPlayers: data.maxPlayers,
                ParentIndexNumber: data.parentIndexNumber,
                HasParentalRating: data.hasParentalRating,
                IsHD: data.isHd,
                IsUnaired: data.isUnaired,
                MinCommunityRating: data.minCommunityRating,
                MinCriticRating: data.minCriticRating,
                AiredDuringSeason: data.airedDuringSeason,
                MinPremiereDate: data.minPremiereDate,
                MinDateLastSaved: data.minDateLastSaved,
                MinDateLastSavedForUser: data.minDateLastSavedForUser,
                MaxPremiereDate: data.maxPremiereDate,
                HasOverview: data.hasOverview,
                HasImdbId: data.hasImdbId,
                HasTmdbId: data.hasTmdbId,
                HasTvdbId: data.hasTvdbId,
                ExcludeItemIds: data.excludeItemIds,
                StartIndex: data.startIndex,
                Limit: data.limit,
                Recursive: data.recursive,
                SearchTerm: data.searchTerm,
                SortOrder: data.sortOrder,
                ParentId: data.parentId,
                Fields: data.fields,
                ExcludeItemTypes: data.excludeItemTypes,
                IncludeItemTypes: data.includeItemTypes,
                AnyProviderIdEquals: data.anyProviderIdEquals,
                Filters: data.filters,
                IsFavorite: data.isFavorite,
                IsMovie: data.isMovie,
                IsSeries: data.isSeries,
                IsFolder: data.isFolder,
                IsNews: data.isNews,
                IsKids: data.isKids,
                IsSports: data.isSports,
                IsNew: data.isNew,
                IsPremiere: data.isPremiere,
                IsNewOrPremiere: data.isNewOrPremiere,
                IsRepeat: data.isRepeat,
                ProjectToMedia: data.projectToMedia,
                MediaTypes: data.mediaTypes,
                ImageTypes: data.imageTypes,
                SortBy: data.sortBy,
                IsPlayed: data.isPlayed,
                Genres: data.genres,
                OfficialRatings: data.officialRatings,
                Tags: data.tags,
                ExcludeTags: data.excludeTags,
                Years: data.years,
                EnableImages: data.enableImages,
                EnableUserData: data.enableUserData,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                Person: data.person,
                PersonIds: data.personIds,
                PersonTypes: data.personTypes,
                Studios: data.studios,
                StudioIds: data.studioIds,
                Artists: data.artists,
                ArtistIds: data.artistIds,
                Albums: data.albums,
                Ids: data.ids,
                VideoTypes: data.videoTypes,
                Containers: data.containers,
                AudioCodecs: data.audioCodecs,
                AudioLayouts: data.audioLayouts,
                VideoCodecs: data.videoCodecs,
                ExtendedVideoTypes: data.extendedVideoTypes,
                SubtitleCodecs: data.subtitleCodecs,
                Path: data.path,
                UserId: data.userId,
                MinOfficialRating: data.minOfficialRating,
                IsLocked: data.isLocked,
                IsPlaceHolder: data.isPlaceHolder,
                HasOfficialRating: data.hasOfficialRating,
                GroupItemsIntoCollections: data.groupItemsIntoCollections,
                Is3D: data.is3D,
                SeriesStatus: data.seriesStatus,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                ArtistStartsWithOrGreater: data.artistStartsWithOrGreater,
                AlbumArtistStartsWithOrGreater: data.albumArtistStartsWithOrGreater,
                NameStartsWith: data.nameStartsWith,
                NameLessThan: data.nameLessThan
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class SyncServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of available sync targets.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId UserId
     * @returns SyncTarget Operation successful. Returning a List<SyncTarget> object.
     * @throws ApiError
     */
    public getSyncTargets(data: GetSyncTargetsData): CancelablePromise<GetSyncTargetsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/Targets',
            query: {
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets sync jobs.
     * Requires authentication as user
     * @returns QueryResult_SyncJob Operation successful. Returning a QueryResult<SyncJob> object.
     * @throws ApiError
     */
    public getSyncJobs(): CancelablePromise<GetSyncJobsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/Jobs',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets sync jobs.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody SyncJobRequest:
     * @returns SyncJobCreationResult Operation successful. Returning a SyncJobCreationResult object.
     * @throws ApiError
     */
    public postSyncJobs(data: PostSyncJobsData): CancelablePromise<PostSyncJobsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/Jobs',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets sync job items.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.targetId TargetId
     * @returns QueryResult_SyncJobItem Operation successful. Returning a QueryResult<SyncJobItem> object.
     * @throws ApiError
     */
    public getSyncJobitems(data: GetSyncJobitemsData): CancelablePromise<GetSyncJobitemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/JobItems',
            query: {
                TargetId: data.targetId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of available sync targets.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId UserId
     * @param data.itemIds ItemIds
     * @param data.parentId ParentId
     * @param data.targetId TargetId
     * @param data.category Category
     * @returns SyncDialogOptions Operation successful. Returning a SyncDialogOptions object.
     * @throws ApiError
     */
    public getSyncOptions(data: GetSyncOptionsData): CancelablePromise<GetSyncOptionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/Options',
            query: {
                UserId: data.userId,
                ItemIds: data.itemIds,
                ParentId: data.parentId,
                TargetId: data.targetId,
                Category: data.category
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Reports an action that occurred while offline.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody List`1:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncOfflineactions(data: PostSyncOfflineactionsData): CancelablePromise<PostSyncOfflineactionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/OfflineActions',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Syncs data between device and server
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.targetId TargetId
     * @param data.requestBody SyncDataRequest:
     * @returns SyncDataResponse Operation successful. Returning a SyncDataResponse object.
     * @throws ApiError
     */
    public postSyncData(data: PostSyncDataData): CancelablePromise<PostSyncDataResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/Data',
            query: {
                TargetId: data.targetId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets sync status for an item.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.itemId
     * @param data.requestBody SyncedItemProgress:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncByItemidStatus(data: PostSyncByItemidStatusData): CancelablePromise<PostSyncByItemidStatusResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/{ItemId}/Status',
            path: {
                ItemId: data.itemId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a sync job.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns SyncJob Operation successful. Returning a SyncJob object.
     * @throws ApiError
     */
    public getSyncJobsById(data: GetSyncJobsByIdData): CancelablePromise<GetSyncJobsByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/Jobs/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a sync job.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteSyncJobsById(data: DeleteSyncJobsByIdData): CancelablePromise<DeleteSyncJobsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Sync/Jobs/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a sync job.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody SyncJob:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobsById(data: PostSyncJobsByIdData): CancelablePromise<PostSyncJobsByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/Jobs/{Id}',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels items from a sync target
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.itemIds ItemIds
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncItemsCancel(data: PostSyncItemsCancelData = {}): CancelablePromise<PostSyncItemsCancelResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/Items/Cancel',
            query: {
                ItemIds: data.itemIds
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels items from a sync target
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.targetId TargetId
     * @param data.itemIds ItemIds
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteSyncByTargetidItems(data: DeleteSyncByTargetidItemsData): CancelablePromise<DeleteSyncByTargetidItemsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Sync/{TargetId}/Items',
            path: {
                TargetId: data.targetId
            },
            query: {
                ItemIds: data.itemIds
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets ready to download sync items.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.targetId TargetId
     * @returns SyncedItem Operation successful. Returning a List<SyncedItem> object.
     * @throws ApiError
     */
    public getSyncItemsReady(data: GetSyncItemsReadyData): CancelablePromise<GetSyncItemsReadyResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/Items/Ready',
            query: {
                TargetId: data.targetId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a sync job item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteSyncJobitemsById(data: DeleteSyncJobitemsByIdData): CancelablePromise<DeleteSyncJobitemsByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Sync/JobItems/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a sync job.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobsByIdDelete(data: PostSyncJobsByIdDeleteData): CancelablePromise<PostSyncJobsByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/Jobs/{Id}/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels items from a sync target
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.targetId TargetId
     * @param data.itemIds ItemIds
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncByTargetidItemsDelete(data: PostSyncByTargetidItemsDeleteData): CancelablePromise<PostSyncByTargetidItemsDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/{TargetId}/Items/Delete',
            path: {
                TargetId: data.targetId
            },
            query: {
                ItemIds: data.itemIds
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Reports that a sync job item has successfully been transferred.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobitemsByIdTransferred(data: PostSyncJobitemsByIdTransferredData): CancelablePromise<PostSyncJobitemsByIdTransferredResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/JobItems/{Id}/Transferred',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a sync job item file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headSyncJobitemsByIdFile(data: HeadSyncJobitemsByIdFileData): CancelablePromise<HeadSyncJobitemsByIdFileResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Sync/JobItems/{Id}/File',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a sync job item file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getSyncJobitemsByIdFile(data: GetSyncJobitemsByIdFileData): CancelablePromise<GetSyncJobitemsByIdFileResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/JobItems/{Id}/File',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a sync job item file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @param data.name Name
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getSyncJobitemsByIdAdditionalfiles(data: GetSyncJobitemsByIdAdditionalfilesData): CancelablePromise<GetSyncJobitemsByIdAdditionalfilesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Sync/JobItems/{Id}/AdditionalFiles',
            path: {
                Id: data.id
            },
            query: {
                Name: data.name
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Enables a cancelled or queued sync job item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobitemsByIdEnable(data: PostSyncJobitemsByIdEnableData): CancelablePromise<PostSyncJobitemsByIdEnableResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/JobItems/{Id}/Enable',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Cancels a sync job item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobitemsByIdDelete(data: PostSyncJobitemsByIdDeleteData): CancelablePromise<PostSyncJobitemsByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/JobItems/{Id}/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Marks a job item for removal
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobitemsByIdMarkforremoval(data: PostSyncJobitemsByIdMarkforremovalData): CancelablePromise<PostSyncJobitemsByIdMarkforremovalResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/JobItems/{Id}/MarkForRemoval',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Unmarks a job item for removal
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSyncJobitemsByIdUnmarkforremoval(data: PostSyncJobitemsByIdUnmarkforremovalData): CancelablePromise<PostSyncJobitemsByIdUnmarkforremovalResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Sync/JobItems/{Id}/UnmarkForRemoval',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ConfigurationServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets application configuration
     * Requires authentication as user
     * @returns ServerConfiguration Operation successful. Returning a ServerConfiguration object.
     * @throws ApiError
     */
    public getSystemConfiguration(): CancelablePromise<GetSystemConfigurationResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Configuration',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates application configuration
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody ServerConfiguration:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSystemConfiguration(data: PostSystemConfigurationData): CancelablePromise<PostSystemConfigurationResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Configuration',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates application configuration
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSystemConfigurationPartial(data: PostSystemConfigurationPartialData): CancelablePromise<PostSystemConfigurationPartialResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Configuration/Partial',
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a named configuration
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.key Key
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getSystemConfigurationByKey(data: GetSystemConfigurationByKeyData): CancelablePromise<GetSystemConfigurationByKeyResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Configuration/{Key}',
            path: {
                Key: data.key
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates named configuration
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.key Key
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSystemConfigurationByKey(data: PostSystemConfigurationByKeyData): CancelablePromise<PostSystemConfigurationByKeyResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Configuration/{Key}',
            path: {
                Key: data.key
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class SystemServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets release notes
     * Requires authentication as user
     * @returns PackageVersionInfo Operation successful. Returning a PackageVersionInfo object.
     * @throws ApiError
     */
    public getSystemReleasenotes(): CancelablePromise<GetSystemReleasenotesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/ReleaseNotes',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postSystemPing(): CancelablePromise<PostSystemPingResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Ping',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public getSystemPing(): CancelablePromise<GetSystemPingResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Ping',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets wake on lan information
     * Requires authentication as user
     * @returns WakeOnLanInfo Operation successful. Returning a WakeOnLanInfo[] object.
     * @throws ApiError
     */
    public getSystemWakeonlaninfo(): CancelablePromise<GetSystemWakeonlaninfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/WakeOnLanInfo',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets information about the server
     * Requires authentication as user
     * @returns SystemInfo Operation successful. Returning a SystemInfo object.
     * @throws ApiError
     */
    public getSystemInfo(): CancelablePromise<GetSystemInfoResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Info',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Restarts the application, if needed
     * Requires authentication as administrator
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postSystemRestart(): CancelablePromise<PostSystemRestartResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Restart',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Shuts down the application
     * Requires authentication as administrator
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postSystemShutdown(): CancelablePromise<PostSystemShutdownResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/System/Shutdown',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets information about the request endpoint
     * Requires authentication as user
     * @returns Net_EndPointInfo Operation successful. Returning a EndPointInfo object.
     * @throws ApiError
     */
    public getSystemEndpoint(): CancelablePromise<GetSystemEndpointResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Endpoint',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets release notes
     * Requires authentication as user
     * @returns PackageVersionInfo Operation successful. Returning a PackageVersionInfo[] object.
     * @throws ApiError
     */
    public getSystemReleasenotesVersions(): CancelablePromise<GetSystemReleasenotesVersionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/ReleaseNotes/Versions',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of available server log files
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @returns QueryResult_LogFile Operation successful. Returning a QueryResult<LogFile> object.
     * @throws ApiError
     */
    public getSystemLogsQuery(data: GetSystemLogsQueryData = {}): CancelablePromise<GetSystemLogsQueryResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Logs/Query',
            query: {
                StartIndex: data.startIndex,
                Limit: data.limit
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a log file
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.name The log file name.
     * @param data.sanitize Return sanitized log
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getSystemLogsByName(data: GetSystemLogsByNameData): CancelablePromise<GetSystemLogsByNameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Logs/{Name}',
            path: {
                Name: data.name
            },
            query: {
                Sanitize: data.sanitize
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets public information about the server
     * Requires authentication as user
     * @returns PublicSystemInfo Operation successful. Returning a PublicSystemInfo object.
     * @throws ApiError
     */
    public getSystemInfoPublic(): CancelablePromise<GetSystemInfoPublicResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Info/Public',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a log file
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.name The log file name.
     * @returns QueryResult_String Operation successful. Returning a QueryResult<String> object.
     * @throws ApiError
     */
    public getSystemLogsByNameLines(data: GetSystemLogsByNameLinesData): CancelablePromise<GetSystemLogsByNameLinesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/Logs/{Name}/Lines',
            path: {
                Name: data.name
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class GenericUiApiServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets UI view data
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.pageId Id of the page controller
     * @param data.clientLocale Locale identifier of the client
     * @returns UIViewInfo Operation successful. Returning a UIViewInfo object.
     * @throws ApiError
     */
    public getUiView(data: GetUiViewData): CancelablePromise<GetUiViewResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/UI/View',
            query: {
                PageId: data.pageId,
                ClientLocale: data.clientLocale
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Execute a command in the context of tv setup
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RunUICommand
     * @returns UIViewInfo Operation successful. Returning a UIViewInfo object.
     * @throws ApiError
     */
    public postUiCommand(data: PostUiCommandData): CancelablePromise<PostUiCommandResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/UI/Command',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class UserServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a list of publicly visible users for display on a login screen.
     * Requires authentication as user
     * @returns UserDto Operation successful. Returning a UserDto[] object.
     * @throws ApiError
     */
    public getUsersPublic(): CancelablePromise<GetUsersPublicResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/Public',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of users
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.isHidden Optional filter by IsHidden=true or false
     * @param data.isDisabled Optional filter by IsDisabled=true or false
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @returns QueryResult_UserDto Operation successful. Returning a QueryResult<UserDto> object.
     * @throws ApiError
     */
    public getUsersQuery(data: GetUsersQueryData = {}): CancelablePromise<GetUsersQueryResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/Query',
            query: {
                IsHidden: data.isHidden,
                IsDisabled: data.isDisabled,
                StartIndex: data.startIndex,
                Limit: data.limit,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                SortOrder: data.sortOrder
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of users
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.isHidden Optional filter by IsHidden=true or false
     * @param data.isDisabled Optional filter by IsDisabled=true or false
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @returns NameIdPair Operation successful. Returning a NameIdPair[] object.
     * @throws ApiError
     */
    public getUsersPrefixes(data: GetUsersPrefixesData = {}): CancelablePromise<GetUsersPrefixesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/Prefixes',
            query: {
                IsHidden: data.isHidden,
                IsDisabled: data.isDisabled,
                StartIndex: data.startIndex,
                Limit: data.limit,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                SortOrder: data.sortOrder
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a list of users
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.isHidden Optional filter by IsHidden=true or false
     * @param data.isDisabled Optional filter by IsDisabled=true or false
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.nameStartsWithOrGreater Optional filter by items whose name is sorted equally or greater than a given input string.
     * @param data.sortOrder Sort Order - Ascending,Descending
     * @returns QueryResult_UserDto Operation successful. Returning a QueryResult<UserDto> object.
     * @throws ApiError
     */
    public getUsersItemaccess(data: GetUsersItemaccessData = {}): CancelablePromise<GetUsersItemaccessResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/ItemAccess',
            query: {
                IsHidden: data.isHidden,
                IsDisabled: data.isDisabled,
                StartIndex: data.startIndex,
                Limit: data.limit,
                NameStartsWithOrGreater: data.nameStartsWithOrGreater,
                SortOrder: data.sortOrder
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a user by Id
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns UserDto Operation successful. Returning a UserDto object.
     * @throws ApiError
     */
    public getUsersById(data: GetUsersByIdData): CancelablePromise<GetUsersByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a user
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersById(data: DeleteUsersByIdData): CancelablePromise<DeleteUsersByIdResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody UserDto:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersById(data: PostUsersByIdData): CancelablePromise<PostUsersByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Authenticates a user
     * Authenticate a user by nane and password. A 200 status code indicates success, while anything in the 400 or 500 range indicates failure
     * ---
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.xEmbyAuthorization The authorization header can be either named 'Authorization' or 'X-Emby-Authorization'.
     * It must be of the following schema:
     * Emby UserId="(guid)", Client="(string)", Device="(string)", DeviceId="(string)", Version="string", Token="(string)"
     * Please consult the documentation for further details.
     * @param data.requestBody AuthenticateUserByName
     * @returns Authentication_AuthenticationResult Operation successful. Returning a AuthenticationResult object.
     * @throws ApiError
     */
    public postUsersAuthenticatebyname(data: PostUsersAuthenticatebynameData): CancelablePromise<PostUsersAuthenticatebynameResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/AuthenticateByName',
            headers: {
                'X-Emby-Authorization': data.xEmbyAuthorization
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Creates a user
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody CreateUserByName
     * @returns UserDto Operation successful. Returning a UserDto object.
     * @throws ApiError
     */
    public postUsersNew(data: PostUsersNewData): CancelablePromise<PostUsersNewResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/New',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Initiates the forgot password process for a local user
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody ForgotPassword
     * @returns ForgotPasswordResult Operation successful. Returning a ForgotPasswordResult object.
     * @throws ApiError
     */
    public postUsersForgotpassword(data: PostUsersForgotpasswordData): CancelablePromise<PostUsersForgotpasswordResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/ForgotPassword',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes a user
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdDelete(data: PostUsersByIdDeleteData): CancelablePromise<PostUsersByIdDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Authenticates a user
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody AuthenticateUser
     * @returns Authentication_AuthenticationResult Operation successful. Returning a AuthenticationResult object.
     * @throws ApiError
     */
    public postUsersByIdAuthenticate(data: PostUsersByIdAuthenticateData): CancelablePromise<PostUsersByIdAuthenticateResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Authenticate',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user's password
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody UpdateUserPassword
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdPassword(data: PostUsersByIdPasswordData): CancelablePromise<PostUsersByIdPasswordResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Password',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Redeems a forgot password pin
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody ForgotPasswordPin
     * @returns PinRedeemResult Operation successful. Returning a PinRedeemResult object.
     * @throws ApiError
     */
    public postUsersForgotpasswordPin(data: PostUsersForgotpasswordPinData): CancelablePromise<PostUsersForgotpasswordPinResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/ForgotPassword/Pin',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user configuration
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody UserConfiguration:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdConfiguration(data: PostUsersByIdConfigurationData): CancelablePromise<PostUsersByIdConfigurationResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Configuration',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user policy
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody UserPolicy:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdPolicy(data: PostUsersByIdPolicyData): CancelablePromise<PostUsersByIdPolicyResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Policy',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Clears audio or subtitle track selections for a user
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.trackType
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteUsersByIdTrackselectionsByTracktype(data: DeleteUsersByIdTrackselectionsByTracktypeData): CancelablePromise<DeleteUsersByIdTrackselectionsByTracktypeResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Users/{Id}/TrackSelections/{TrackType}',
            path: {
                Id: data.id,
                TrackType: data.trackType
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a user configuration
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdConfigurationPartial(data: PostUsersByIdConfigurationPartialData): CancelablePromise<PostUsersByIdConfigurationPartialResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/Configuration/Partial',
            path: {
                Id: data.id
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a typed user setting
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.key Key
     * @param data.userId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getUsersByUseridTypedsettingsByKey(data: GetUsersByUseridTypedsettingsByKeyData): CancelablePromise<GetUsersByUseridTypedsettingsByKeyResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/TypedSettings/{Key}',
            path: {
                Key: data.key,
                UserId: data.userId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Updates a typed user setting
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId
     * @param data.key Key
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByUseridTypedsettingsByKey(data: PostUsersByUseridTypedsettingsByKeyData): CancelablePromise<PostUsersByUseridTypedsettingsByKeyResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{UserId}/TypedSettings/{Key}',
            path: {
                UserId: data.userId,
                Key: data.key
            },
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Clears audio or subtitle track selections for a user
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.trackType
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUsersByIdTrackselectionsByTracktypeDelete(data: PostUsersByIdTrackselectionsByTracktypeDeleteData): CancelablePromise<PostUsersByIdTrackselectionsByTracktypeDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Users/{Id}/TrackSelections/{TrackType}/Delete',
            path: {
                Id: data.id,
                TrackType: data.trackType
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class UserActivityApiService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Get a list of items for type and filtered
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id item id
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsGetItemPath(data: GetUserUsageStatsGetItemPathData): CancelablePromise<GetUserUsageStatsGetItemPathResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/get_item_path',
            query: {
                id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Get a list of items for type and filtered
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id item id
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsGetItemStats(data: GetUserUsageStatsGetItemStatsData): CancelablePromise<GetUserUsageStatsGetItemStatsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/get_item_stats',
            query: {
                id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Get a list of items for type and filtered
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.filter filter string
     * @param data.itemType type of items to return
     * @param data.parent parentid
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsGetItems(data: GetUserUsageStatsGetItemsData = {}): CancelablePromise<GetUserUsageStatsGetItemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/get_items',
            query: {
                filter: data.filter,
                item_type: data.itemType,
                parent: data.parent
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets types filter list items
     * Requires authentication as administrator
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsTypeFilterList(): CancelablePromise<GetUserUsageStatsTypeFilterListResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/type_filter_list',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a report of the available activity per hour
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsUserActivity(data: GetUserUsageStatsUserActivityData = {}): CancelablePromise<GetUserUsageStatsUserActivityResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/user_activity',
            query: {
                days: data.days,
                end_date: data.endDate
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Get users
     * Requires authentication as administrator
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsUserList(): CancelablePromise<GetUserUsageStatsUserListResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/user_list',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Post a backup for importing
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody Binary stream
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postUserUsageStatsImportBackup(data: PostUserUsageStatsImportBackupData): CancelablePromise<PostUserUsageStatsImportBackupResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/user_usage_stats/import_backup',
            body: data.requestBody,
            mediaType: 'application/octet-stream',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Loads a backup from a file
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.backupfile File name of file to load
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsLoadBackup(data: GetUserUsageStatsLoadBackupData): CancelablePromise<GetUserUsageStatsLoadBackupResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/load_backup',
            query: {
                backupfile: data.backupfile
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Saves a backup of the playback report data to the backup path
     * Requires authentication as administrator
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsSaveBackup(): CancelablePromise<GetUserUsageStatsSaveBackupResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/save_backup',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets play activity for number of days
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @param data.filter Comma separated list of media types to filter (movies,series)
     * @param data.dataType Data type to return (count,time)
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsPlayactivity(data: GetUserUsageStatsPlayactivityData = {}): CancelablePromise<GetUserUsageStatsPlayactivityResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/PlayActivity',
            query: {
                days: data.days,
                end_date: data.endDate,
                filter: data.filter,
                data_type: data.dataType
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a report of the available activity per hour
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @param data.filter Comma separated list of media types to filter (movies,series)
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsHourlyreport(data: GetUserUsageStatsHourlyreportData = {}): CancelablePromise<GetUserUsageStatsHourlyreportResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/HourlyReport',
            query: {
                user_id: data.userId,
                days: data.days,
                end_date: data.endDate,
                filter: data.filter
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets TV Shows counts
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsTvshowsreport(data: GetUserUsageStatsTvshowsreportData = {}): CancelablePromise<GetUserUsageStatsTvshowsreportResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/TvShowsReport',
            query: {
                user_id: data.userId,
                days: data.days,
                end_date: data.endDate
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets Movies counts
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsMoviesreport(data: GetUserUsageStatsMoviesreportData = {}): CancelablePromise<GetUserUsageStatsMoviesreportResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/MoviesReport',
            query: {
                user_id: data.userId,
                days: data.days,
                end_date: data.endDate
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Submit an SQL query
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody CustomQuery
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public postUserUsageStatsSubmitCustomQuery(data: PostUserUsageStatsSubmitCustomQueryData): CancelablePromise<PostUserUsageStatsSubmitCustomQueryResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/user_usage_stats/submit_custom_query',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a report of all played items for a user in a date period
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.aggregateData Aggregate the data to total duration per user per item
     * @param data.filterName Name Filter
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @param data.filter Comma separated list of media types to filter (movies,series)
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsUserplaylist(data: GetUserUsageStatsUserplaylistData): CancelablePromise<GetUserUsageStatsUserplaylistResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/UserPlaylist',
            query: {
                user_id: data.userId,
                aggregate_data: data.aggregateData,
                filter_name: data.filterName,
                days: data.days,
                end_date: data.endDate,
                filter: data.filter
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets Session Info
     * Requires authentication as administrator
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsSessionList(): CancelablePromise<GetUserUsageStatsSessionListResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/session_list',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a breakdown of a usage metric
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.breakdownType Breakdown type
     * @param data.userId User Id
     * @param data.days Number of Days
     * @param data.endDate End date of the report in yyyy-MM-dd format
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsByBreakdowntypeBreakdownreport(data: GetUserUsageStatsByBreakdowntypeBreakdownreportData): CancelablePromise<GetUserUsageStatsByBreakdowntypeBreakdownreportResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/{BreakdownType}/BreakdownReport',
            path: {
                BreakdownType: data.breakdownType
            },
            query: {
                user_id: data.userId,
                days: data.days,
                end_date: data.endDate
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Get users
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.action action to perform
     * @param data.id user Id to perform the action on
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsUserManageByActionById(data: GetUserUsageStatsUserManageByActionByIdData): CancelablePromise<GetUserUsageStatsUserManageByActionByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/user_manage/{Action}/{Id}',
            path: {
                Action: data.action,
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets activity for {USER} for {Date} formatted as yyyy-MM-dd
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.date UTC DateTime, Format yyyy-MM-dd
     * @param data.filter Comma separated list of media types to filter (movies,series)
     * @returns unknown Operation successful. Returning a Object object.
     * @throws ApiError
     */
    public getUserUsageStatsByUseridByDateGetitems(data: GetUserUsageStatsByUseridByDateGetitemsData): CancelablePromise<GetUserUsageStatsByUseridByDateGetitemsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/user_usage_stats/{UserID}/{Date}/GetItems',
            path: {
                UserID: data.userId,
                Date: data.date
            },
            query: {
                Filter: data.filter
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class VideosServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Merges videos into a single record
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.ids Item id list. This allows multiple, comma delimited.
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postVideosMergeversions(data: PostVideosMergeversionsData = {}): CancelablePromise<PostVideosMergeversionsResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Videos/MergeVersions',
            query: {
                Ids: data.ids
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes alternate video sources.
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public deleteVideosByIdAlternatesources(data: DeleteVideosByIdAlternatesourcesData): CancelablePromise<DeleteVideosByIdAlternatesourcesResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Videos/{Id}/AlternateSources',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Removes alternate video sources.
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postVideosByIdAlternatesourcesDelete(data: PostVideosByIdAlternatesourcesDeleteData): CancelablePromise<PostVideosByIdAlternatesourcesDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Videos/{Id}/AlternateSources/Delete',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class HlsSegmentServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.playSessionId The play session id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteVideosActiveencodings(data: DeleteVideosActiveencodingsData): CancelablePromise<DeleteVideosActiveencodingsResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Videos/ActiveEncodings',
            query: {
                DeviceId: data.deviceId,
                PlaySessionId: data.playSessionId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.playSessionId The play session id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postVideosActiveencodingsDelete(data: PostVideosActiveencodingsDeleteData): CancelablePromise<PostVideosActiveencodingsDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Videos/ActiveEncodings/Delete',
            query: {
                DeviceId: data.deviceId,
                PlaySessionId: data.playSessionId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class VirtualTvExportServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Downloads the local channels.m3u file. Only allowed within local network!
     * Requires authentication as user
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVirtualtvChannelsM3U(): CancelablePromise<GetVirtualtvChannelsM3UResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/VirtualTV/channels.m3u',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Downloads a live tv channels m3u playlist
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.streamType Type of channel playlist streaming urls: Universal, EmbyCon or EmbyNextGen (Mandatory)
     * @param data.token Token
     * @param data.catchupType StreamType Universal only: vod, flussonic, shift or append (Defaults to vod)
     * @param data.catchupContainer StreamType Universal only: original, mpegts or hls (Container of the catchup stream. Defaults to original)
     * @param data.realLiveTv Returns real live tv channels (Optional)
     * @param data.maxBitrate StreamType Universal only: Max. video bitrate in Kbps (Optional)
     * @param data.timeout StreamType Universal only: Time in seconds after streaming is stopped if client has disconnected (Defaults to 10 sec)
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVirtualtvChannels(data: GetVirtualtvChannelsData): CancelablePromise<GetVirtualtvChannelsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/VirtualTV/Channels',
            query: {
                StreamType: data.streamType,
                CatchupType: data.catchupType,
                CatchupContainer: data.catchupContainer,
                RealLiveTv: data.realLiveTv,
                MaxBitrate: data.maxBitrate,
                Timeout: data.timeout,
                Token: data.token
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Downloads the local guide.xml xmltv file. Only allowed within local network!
     * Requires authentication as user
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVirtualtvGuideXml(): CancelablePromise<GetVirtualtvGuideXmlResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/VirtualTV/guide.xml',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Downloads a live tv program guide as xmltv file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.streamType Type of channel playlist catchup urls: Universal, EmbyCon or EmbyNextGen (Mandatory)
     * @param data.token Token
     * @param data.imageType Aspect ratio of program images: Thumb or Poster (Defaults to Thumb)
     * @param data.realLiveTv Returns program for real live tv channels (Optional)
     * @param data.matchProgramToLibrary Matches programs to library items to enable catchup streams (Only for real live tv. Optional)
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVirtualtvGuide(data: GetVirtualtvGuideData): CancelablePromise<GetVirtualtvGuideResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/VirtualTV/Guide',
            query: {
                StreamType: data.streamType,
                ImageType: data.imageType,
                RealLiveTv: data.realLiveTv,
                MatchProgramToLibrary: data.matchProgramToLibrary,
                Token: data.token
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class WebAppServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as user
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getWebConfigurationpage(): CancelablePromise<GetWebConfigurationpageResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/web/ConfigurationPage',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns Api_ConfigurationPageInfo Operation successful. Returning a List<ConfigurationPageInfo> object.
     * @throws ApiError
     */
    public getWebConfigurationpages(): CancelablePromise<GetWebConfigurationpagesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/web/ConfigurationPages',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getWebStrings(): CancelablePromise<GetWebStringsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/web/strings',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @returns string Operation successful. Returning a String[] object.
     * @throws ApiError
     */
    public getWebStringset(): CancelablePromise<GetWebStringsetResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/web/stringset',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class UniversalAudioServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdUniversalByContainer(data: GetAudioByIdUniversalByContainerData): CancelablePromise<GetAudioByIdUniversalByContainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/universal.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceId: data.deviceId,
                StartTimeTicks: data.startTimeTicks
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdUniversalByContainer(data: HeadAudioByIdUniversalByContainerData): CancelablePromise<HeadAudioByIdUniversalByContainerResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/universal.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceId: data.deviceId,
                StartTimeTicks: data.startTimeTicks
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdUniversal(data: GetAudioByIdUniversalData): CancelablePromise<GetAudioByIdUniversalResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/universal',
            path: {
                Id: data.id
            },
            query: {
                DeviceId: data.deviceId,
                StartTimeTicks: data.startTimeTicks
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdUniversal(data: HeadAudioByIdUniversalData): CancelablePromise<HeadAudioByIdUniversalResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/universal',
            path: {
                Id: data.id
            },
            query: {
                DeviceId: data.deviceId,
                StartTimeTicks: data.startTimeTicks
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class AudioServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdStreamByContainer(data: GetAudioByIdStreamByContainerData): CancelablePromise<GetAudioByIdStreamByContainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/stream.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdStreamByContainer(data: HeadAudioByIdStreamByContainerData): CancelablePromise<HeadAudioByIdStreamByContainerResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/stream.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdStream(data: GetAudioByIdStreamData): CancelablePromise<GetAudioByIdStreamResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/stream',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdStream(data: HeadAudioByIdStreamData): CancelablePromise<HeadAudioByIdStreamResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/stream',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.streamFileName
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdByStreamfilename(data: GetAudioByIdByStreamfilenameData): CancelablePromise<GetAudioByIdByStreamfilenameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/{StreamFileName}',
            path: {
                StreamFileName: data.streamFileName,
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.streamFileName
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdByStreamfilename(data: HeadAudioByIdByStreamfilenameData): CancelablePromise<HeadAudioByIdByStreamfilenameResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/{StreamFileName}',
            path: {
                StreamFileName: data.streamFileName,
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class DynamicHlsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets an audio stream using HTTP live streaming.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdMasterM3U8(data: GetAudioByIdMasterM3U8Data): CancelablePromise<GetAudioByIdMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/master.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream using HTTP live streaming.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdMasterM3U8(data: HeadAudioByIdMasterM3U8Data): CancelablePromise<HeadAudioByIdMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/master.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdLiveM3U8(data: GetAudioByIdLiveM3U8Data): CancelablePromise<GetAudioByIdLiveM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/live.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an audio stream using HTTP live streaming.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdMainM3U8(data: GetAudioByIdMainM3U8Data): CancelablePromise<GetAudioByIdMainM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/main.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream using HTTP live streaming.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdMasterM3U8(data: GetVideosByIdMasterM3U8Data): CancelablePromise<GetVideosByIdMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/master.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream using HTTP live streaming.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headVideosByIdMasterM3U8(data: HeadVideosByIdMasterM3U8Data): CancelablePromise<HeadVideosByIdMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Videos/{Id}/master.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdLiveM3U8(data: GetVideosByIdLiveM3U8Data): CancelablePromise<GetVideosByIdLiveM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/live.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream using HTTP live streaming.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdMainM3U8(data: GetVideosByIdMainM3U8Data): CancelablePromise<GetVideosByIdMainM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/main.m3u8',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an HLS subtitle playlist.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.subtitleSegmentLength The subtitle segment length
     * @param data.manifestSubtitles The subtitle segment format
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdSubtitlesM3U8(data: GetVideosByIdSubtitlesM3U8Data): CancelablePromise<GetVideosByIdSubtitlesM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/subtitles.m3u8',
            path: {
                Id: data.id
            },
            query: {
                SubtitleSegmentLength: data.subtitleSegmentLength,
                ManifestSubtitles: data.manifestSubtitles
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets an HLS subtitle playlist.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.subtitleSegmentLength The subtitle segment length
     * @param data.manifestSubtitles The subtitle segment format
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdLiveSubtitlesM3U8(data: GetVideosByIdLiveSubtitlesM3U8Data): CancelablePromise<GetVideosByIdLiveSubtitlesM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/live_subtitles.m3u8',
            path: {
                Id: data.id
            },
            query: {
                SubtitleSegmentLength: data.subtitleSegmentLength,
                ManifestSubtitles: data.manifestSubtitles
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.segmentContainer
     * @param data.segmentId
     * @param data.id
     * @param data.playlistId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(data: GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                SegmentContainer: data.segmentContainer,
                SegmentId: data.segmentId,
                Id: data.id,
                PlaylistId: data.playlistId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.segmentContainer
     * @param data.segmentId
     * @param data.id
     * @param data.playlistId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(data: HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                SegmentContainer: data.segmentContainer,
                SegmentId: data.segmentId,
                Id: data.id,
                PlaylistId: data.playlistId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.segmentContainer
     * @param data.segmentId
     * @param data.id
     * @param data.playlistId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(data: GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                SegmentContainer: data.segmentContainer,
                SegmentId: data.segmentId,
                Id: data.id,
                PlaylistId: data.playlistId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.segmentContainer
     * @param data.segmentId
     * @param data.id
     * @param data.playlistId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer(data: HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                SegmentContainer: data.segmentContainer,
                SegmentId: data.segmentId,
                Id: data.id,
                PlaylistId: data.playlistId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ItemLookupServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets external id infos for an item
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns ExternalIdInfo Operation successful. Returning a List<ExternalIdInfo> object.
     * @throws ApiError
     */
    public getItemsByIdExternalidinfos(data: GetItemsByIdExternalidinfosData): CancelablePromise<GetItemsByIdExternalidinfosResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/ExternalIdInfos',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchTrailer(data: PostItemsRemotesearchTrailerData): CancelablePromise<PostItemsRemotesearchTrailerResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Trailer',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchBook(data: PostItemsRemotesearchBookData): CancelablePromise<PostItemsRemotesearchBookResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Book',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchMovie(data: PostItemsRemotesearchMovieData): CancelablePromise<PostItemsRemotesearchMovieResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Movie',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchSeries(data: PostItemsRemotesearchSeriesData): CancelablePromise<PostItemsRemotesearchSeriesResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Series',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchGame(data: PostItemsRemotesearchGameData): CancelablePromise<PostItemsRemotesearchGameResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Game',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchBoxset(data: PostItemsRemotesearchBoxsetData): CancelablePromise<PostItemsRemotesearchBoxsetResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/BoxSet',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchMusicvideo(data: PostItemsRemotesearchMusicvideoData): CancelablePromise<PostItemsRemotesearchMusicvideoResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/MusicVideo',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchPerson(data: PostItemsRemotesearchPersonData): CancelablePromise<PostItemsRemotesearchPersonResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Person',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchMusicalbum(data: PostItemsRemotesearchMusicalbumData): CancelablePromise<PostItemsRemotesearchMusicalbumResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/MusicAlbum',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody RemoteSearchQuery`1:
     * @returns RemoteSearchResult Operation successful. Returning a List<RemoteSearchResult> object.
     * @throws ApiError
     */
    public postItemsRemotesearchMusicartist(data: PostItemsRemotesearchMusicartistData): CancelablePromise<PostItemsRemotesearchMusicartistResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/MusicArtist',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a remote image
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.imageUrl The image url
     * @param data.providerName
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsRemotesearchImage(data: GetItemsRemotesearchImageData): CancelablePromise<GetItemsRemotesearchImageResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/RemoteSearch/Image',
            query: {
                ImageUrl: data.imageUrl,
                ProviderName: data.providerName
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Resets metadata for one or more items
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.itemIds The item ids
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsMetadataReset(data: PostItemsMetadataResetData): CancelablePromise<PostItemsMetadataResetResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/Metadata/Reset',
            query: {
                ItemIds: data.itemIds
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Applies search criteria to an item and refreshes metadata
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.id The item id
     * @param data.requestBody RemoteSearchResult:
     * @param data.replaceAllImages Whether or not to replace all images
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsRemotesearchApplyById(data: PostItemsRemotesearchApplyByIdData): CancelablePromise<PostItemsRemotesearchApplyByIdResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/RemoteSearch/Apply/{Id}',
            path: {
                Id: data.id
            },
            query: {
                ReplaceAllImages: data.replaceAllImages
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ItemRefreshServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Refreshes metadata for an item
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.recursive Indicates if the refresh should occur recursively.
     * @param data.metadataRefreshMode Specifies the metadata refresh mode
     * @param data.imageRefreshMode Specifies the image refresh mode
     * @param data.replaceAllMetadata Determines if metadata should be replaced. Only applicable if mode is FullRefresh
     * @param data.replaceAllImages Determines if images should be replaced. Only applicable if mode is FullRefresh
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postItemsByIdRefresh(data: PostItemsByIdRefreshData): CancelablePromise<PostItemsByIdRefreshResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Refresh',
            path: {
                Id: data.id
            },
            query: {
                Recursive: data.recursive,
                MetadataRefreshMode: data.metadataRefreshMode,
                ImageRefreshMode: data.imageRefreshMode,
                ReplaceAllMetadata: data.replaceAllMetadata,
                ReplaceAllImages: data.replaceAllImages
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class BifServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.width
     * @param data.id Item Id
     * @returns RokuMetadata_Api_ThumbnailSetInfo Operation successful. Returning a ThumbnailSetInfo object.
     * @throws ApiError
     */
    public getItemsByIdThumbnailset(data: GetItemsByIdThumbnailsetData): CancelablePromise<GetItemsByIdThumbnailsetResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/ThumbnailSet',
            path: {
                Id: data.id
            },
            query: {
                Width: data.width
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.width
     * @param data.id Item Id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdIndexBif(data: GetVideosByIdIndexBifData): CancelablePromise<GetVideosByIdIndexBifResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/index.bif',
            path: {
                Id: data.id
            },
            query: {
                Width: data.width
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class UserNotificationsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Sends a test notification
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.requestBody UserNotificationInfo:
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public postNotificationsServicesTest(data: PostNotificationsServicesTestData): CancelablePromise<PostNotificationsServicesTestResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Notifications/Services/Test',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets default notification info
     * Requires authentication as user
     * @returns UserNotificationInfo Operation successful. Returning a UserNotificationInfo object.
     * @throws ApiError
     */
    public getNotificationsServicesDefaults(): CancelablePromise<GetNotificationsServicesDefaultsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Notifications/Services/Defaults',
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class ActivityLogServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets activity log entries
     * Requires authentication as administrator
     * @param data The data for the request.
     * @param data.startIndex Optional. The record index to start at. All items with a lower index will be dropped from the results.
     * @param data.limit Optional. The maximum number of records to return
     * @param data.minDate Optional. The minimum date. Format = ISO
     * @returns QueryResult_ActivityLogEntry Operation successful. Returning a QueryResult<ActivityLogEntry> object.
     * @throws ApiError
     */
    public getSystemActivitylogEntries(data: GetSystemActivitylogEntriesData = {}): CancelablePromise<GetSystemActivitylogEntriesResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/System/ActivityLog/Entries',
            query: {
                StartIndex: data.startIndex,
                Limit: data.limit,
                MinDate: data.minDate
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class SuggestionsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets items based on a query.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId
     * @param data.fields Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
     * @param data.enableImages Optional, include image information in output
     * @param data.imageTypeLimit Optional, the max number of images to return, per image type
     * @param data.enableImageTypes Optional. The image types to include in the output.
     * @param data.enableUserData Optional, include user data
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getUsersByUseridSuggestions(data: GetUsersByUseridSuggestionsData): CancelablePromise<GetUsersByUseridSuggestionsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Suggestions',
            path: {
                UserId: data.userId
            },
            query: {
                Fields: data.fields,
                EnableImages: data.enableImages,
                ImageTypeLimit: data.imageTypeLimit,
                EnableImageTypes: data.enableImageTypes,
                EnableUserData: data.enableUserData
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class UserViewsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.userId User Id
     * @param data.includeExternalContent Whether or not to include external views such as channels or live tv
     * @returns QueryResult_BaseItemDto Operation successful. Returning a QueryResult<BaseItemDto> object.
     * @throws ApiError
     */
    public getUsersByUseridViews(data: GetUsersByUseridViewsData): CancelablePromise<GetUsersByUseridViewsResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Users/{UserId}/Views',
            path: {
                UserId: data.userId
            },
            query: {
                IncludeExternalContent: data.includeExternalContent
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class VideoServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a video stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdStreamByContainer(data: GetVideosByIdStreamByContainerData): CancelablePromise<GetVideosByIdStreamByContainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/stream.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headVideosByIdStreamByContainer(data: HeadVideosByIdStreamByContainerData): CancelablePromise<HeadVideosByIdStreamByContainerResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Videos/{Id}/stream.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdStream(data: GetVideosByIdStreamData): CancelablePromise<GetVideosByIdStreamResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/stream',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headVideosByIdStream(data: HeadVideosByIdStreamData): CancelablePromise<HeadVideosByIdStreamResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Videos/{Id}/stream',
            path: {
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.streamFileName
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdByStreamfilename(data: GetVideosByIdByStreamfilenameData): CancelablePromise<GetVideosByIdByStreamfilenameResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/{StreamFileName}',
            path: {
                StreamFileName: data.streamFileName,
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a video stream
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.streamFileName
     * @param data.id Item Id
     * @param data.container Container
     * @param data.deviceProfileId Optional. The dlna device profile id to utilize.
     * @param data.deviceId The device id of the client requesting. Used to stop encoding processes when needed.
     * @param data.audioCodec Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
     * @param data.enableAutoStreamCopy Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
     * @param data.audioSampleRate Optional. Specify a specific audio sample rate, e.g. 44100
     * @param data.audioBitRate Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
     * @param data.audioChannels Optional. Specify a specific number of audio channels to encode to, e.g. 2
     * @param data.maxAudioChannels Optional. Specify a maximum number of audio channels to encode to, e.g. 2
     * @param data._static Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
     * @param data.copyTimestamps Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
     * @param data.startTimeTicks Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
     * @param data.width Optional. The fixed horizontal resolution of the encoded video.
     * @param data.height Optional. The fixed vertical resolution of the encoded video.
     * @param data.maxWidth Optional. The maximum horizontal resolution of the encoded video.
     * @param data.maxHeight Optional. The maximum vertical resolution of the encoded video.
     * @param data.videoBitRate Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
     * @param data.subtitleStreamIndex Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
     * @param data.subtitleMethod Optional. Specify the subtitle delivery method.
     * @param data.maxVideoBitDepth Optional.
     * @param data.videoCodec Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
     * @param data.audioStreamIndex Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
     * @param data.videoStreamIndex Optional. The index of the video stream to use. If omitted the first video stream will be used.
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headVideosByIdByStreamfilename(data: HeadVideosByIdByStreamfilenameData): CancelablePromise<HeadVideosByIdByStreamfilenameResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/Videos/{Id}/{StreamFileName}',
            path: {
                StreamFileName: data.streamFileName,
                Id: data.id
            },
            query: {
                DeviceProfileId: data.deviceProfileId,
                DeviceId: data.deviceId,
                Container: data.container,
                AudioCodec: data.audioCodec,
                EnableAutoStreamCopy: data.enableAutoStreamCopy,
                AudioSampleRate: data.audioSampleRate,
                AudioBitRate: data.audioBitRate,
                AudioChannels: data.audioChannels,
                MaxAudioChannels: data.maxAudioChannels,
                Static: data._static,
                CopyTimestamps: data.copyTimestamps,
                StartTimeTicks: data.startTimeTicks,
                Width: data.width,
                Height: data.height,
                MaxWidth: data.maxWidth,
                MaxHeight: data.maxHeight,
                VideoBitRate: data.videoBitRate,
                SubtitleStreamIndex: data.subtitleStreamIndex,
                SubtitleMethod: data.subtitleMethod,
                MaxVideoBitDepth: data.maxVideoBitDepth,
                VideoCodec: data.videoCodec,
                AudioStreamIndex: data.audioStreamIndex,
                VideoStreamIndex: data.videoStreamIndex
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class SubtitleServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Deletes an external subtitle file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.index The subtitle stream index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteItemsByIdSubtitlesByIndex(data: DeleteItemsByIdSubtitlesByIndexData): CancelablePromise<DeleteItemsByIdSubtitlesByIndexResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Items/{Id}/Subtitles/{Index}',
            path: {
                Id: data.id,
                Index: data.index
            },
            query: {
                MediaSourceId: data.mediaSourceId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @returns unknown Operation successful. Empty response.
     * @throws ApiError
     */
    public getProvidersSubtitlesSubtitlesById(data: GetProvidersSubtitlesSubtitlesByIdData): CancelablePromise<GetProvidersSubtitlesSubtitlesByIdResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Providers/Subtitles/Subtitles/{Id}',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes an external subtitle file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.index The subtitle stream index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public deleteVideosByIdSubtitlesByIndex(data: DeleteVideosByIdSubtitlesByIndexData): CancelablePromise<DeleteVideosByIdSubtitlesByIndexResponse> {
        return this.httpRequest.request({
            method: 'DELETE',
            url: '/Videos/{Id}/Subtitles/{Index}',
            path: {
                Id: data.id,
                Index: data.index
            },
            query: {
                MediaSourceId: data.mediaSourceId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.language Language
     * @param data.isPerfectMatch IsPerfectMatch
     * @param data.isForced IsForced
     * @param data.isHearingImpaired IsHearingImpaired
     * @returns RemoteSubtitleInfo Operation successful. Returning a RemoteSubtitleInfo[] object.
     * @throws ApiError
     */
    public getItemsByIdRemotesearchSubtitlesByLanguage(data: GetItemsByIdRemotesearchSubtitlesByLanguageData): CancelablePromise<GetItemsByIdRemotesearchSubtitlesByLanguageResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/RemoteSearch/Subtitles/{Language}',
            path: {
                Id: data.id,
                Language: data.language
            },
            query: {
                MediaSourceId: data.mediaSourceId,
                IsPerfectMatch: data.isPerfectMatch,
                IsForced: data.isForced,
                IsHearingImpaired: data.isHearingImpaired
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes an external subtitle file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.index The subtitle stream index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postItemsByIdSubtitlesByIndexDelete(data: PostItemsByIdSubtitlesByIndexDeleteData): CancelablePromise<PostItemsByIdSubtitlesByIndexDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/Subtitles/{Index}/Delete',
            path: {
                Id: data.id,
                Index: data.index
            },
            query: {
                MediaSourceId: data.mediaSourceId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.subtitleId SubtitleId
     * @returns Subtitles_SubtitleDownloadResult Operation successful. Returning a SubtitleDownloadResult object.
     * @throws ApiError
     */
    public postItemsByIdRemotesearchSubtitlesBySubtitleid(data: PostItemsByIdRemotesearchSubtitlesBySubtitleidData): CancelablePromise<PostItemsByIdRemotesearchSubtitlesBySubtitleidResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Items/{Id}/RemoteSearch/Subtitles/{SubtitleId}',
            path: {
                Id: data.id,
                SubtitleId: data.subtitleId
            },
            query: {
                MediaSourceId: data.mediaSourceId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Deletes an external subtitle file
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.index The subtitle stream index
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public postVideosByIdSubtitlesByIndexDelete(data: PostVideosByIdSubtitlesByIndexDeleteData): CancelablePromise<PostVideosByIdSubtitlesByIndexDeleteResponse> {
        return this.httpRequest.request({
            method: 'POST',
            url: '/Videos/{Id}/Subtitles/{Index}/Delete',
            path: {
                Id: data.id,
                Index: data.index
            },
            query: {
                MediaSourceId: data.mediaSourceId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets subtitles in a specified format.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.index The subtitle stream index
     * @param data.format Format
     * @param data.startPositionTicks StartPositionTicks
     * @param data.endPositionTicks EndPositionTicks
     * @param data.copyTimestamps CopyTimestamps
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat(data: GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData): CancelablePromise<GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}',
            path: {
                Id: data.id,
                MediaSourceId: data.mediaSourceId,
                Index: data.index,
                Format: data.format
            },
            query: {
                StartPositionTicks: data.startPositionTicks,
                EndPositionTicks: data.endPositionTicks,
                CopyTimestamps: data.copyTimestamps
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets subtitles in a specified format.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.index The subtitle stream index
     * @param data.format Format
     * @param data.startPositionTicks StartPositionTicks
     * @param data.endPositionTicks EndPositionTicks
     * @param data.copyTimestamps CopyTimestamps
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat(data: GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData): CancelablePromise<GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}',
            path: {
                Id: data.id,
                MediaSourceId: data.mediaSourceId,
                Index: data.index,
                Format: data.format
            },
            query: {
                StartPositionTicks: data.startPositionTicks,
                EndPositionTicks: data.endPositionTicks,
                CopyTimestamps: data.copyTimestamps
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets subtitles in a specified format.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.index The subtitle stream index
     * @param data.format Format
     * @param data.startPositionTicks StartPositionTicks
     * @param data.endPositionTicks EndPositionTicks
     * @param data.copyTimestamps CopyTimestamps
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat(data: GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData): CancelablePromise<GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Items/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}',
            path: {
                Id: data.id,
                MediaSourceId: data.mediaSourceId,
                Index: data.index,
                Format: data.format,
                StartPositionTicks: data.startPositionTicks
            },
            query: {
                EndPositionTicks: data.endPositionTicks,
                CopyTimestamps: data.copyTimestamps
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets subtitles in a specified format.
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id Item Id
     * @param data.mediaSourceId MediaSourceId
     * @param data.index The subtitle stream index
     * @param data.format Format
     * @param data.startPositionTicks StartPositionTicks
     * @param data.endPositionTicks EndPositionTicks
     * @param data.copyTimestamps CopyTimestamps
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat(data: GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData): CancelablePromise<GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}',
            path: {
                Id: data.id,
                MediaSourceId: data.mediaSourceId,
                Index: data.index,
                Format: data.format,
                StartPositionTicks: data.startPositionTicks
            },
            query: {
                EndPositionTicks: data.endPositionTicks,
                CopyTimestamps: data.copyTimestamps
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class LiveStreamServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Gets a live tv channel
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.container
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvLivestreamfilesByIdStreamByContainer(data: GetLivetvLivestreamfilesByIdStreamByContainerData): CancelablePromise<GetLivetvLivestreamfilesByIdStreamByContainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/LiveStreamFiles/{Id}/stream.{Container}',
            path: {
                Id: data.id,
                Container: data.container
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvLiverecordingsByIdStream(data: GetLivetvLiverecordingsByIdStreamData): CancelablePromise<GetLivetvLiverecordingsByIdStreamResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/LiveRecordings/{Id}/stream',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvLivestreamfilesByIdHlsMasterM3U8(data: GetLivetvLivestreamfilesByIdHlsMasterM3U8Data): CancelablePromise<GetLivetvLivestreamfilesByIdHlsMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/LiveStreamFiles/{Id}/hls/master.m3u8',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headLivetvLivestreamfilesByIdHlsMasterM3U8(data: HeadLivetvLivestreamfilesByIdHlsMasterM3U8Data): CancelablePromise<HeadLivetvLivestreamfilesByIdHlsMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/LiveTv/LiveStreamFiles/{Id}/hls/master.m3u8',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvLiverecordingsByIdHlsMasterM3U8(data: GetLivetvLiverecordingsByIdHlsMasterM3U8Data): CancelablePromise<GetLivetvLiverecordingsByIdHlsMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/LiveRecordings/{Id}/hls/master.m3u8',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headLivetvLiverecordingsByIdHlsMasterM3U8(data: HeadLivetvLiverecordingsByIdHlsMasterM3U8Data): CancelablePromise<HeadLivetvLiverecordingsByIdHlsMasterM3U8Response> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/LiveTv/LiveRecordings/{Id}/hls/master.m3u8',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvLiverecordingsByIdHlsLiveM3U8(data: GetLivetvLiverecordingsByIdHlsLiveM3U8Data): CancelablePromise<GetLivetvLiverecordingsByIdHlsLiveM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/LiveRecordings/{Id}/hls/live.m3u8',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headLivetvLiverecordingsByIdHlsLiveM3U8(data: HeadLivetvLiverecordingsByIdHlsLiveM3U8Data): CancelablePromise<HeadLivetvLiverecordingsByIdHlsLiveM3U8Response> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/LiveTv/LiveRecordings/{Id}/hls/live.m3u8',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvLivestreamfilesByIdHlsLiveM3U8(data: GetLivetvLivestreamfilesByIdHlsLiveM3U8Data): CancelablePromise<GetLivetvLivestreamfilesByIdHlsLiveM3U8Response> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/LiveStreamFiles/{Id}/hls/live.m3u8',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headLivetvLivestreamfilesByIdHlsLiveM3U8(data: HeadLivetvLivestreamfilesByIdHlsLiveM3U8Data): CancelablePromise<HeadLivetvLivestreamfilesByIdHlsLiveM3U8Response> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/LiveTv/LiveStreamFiles/{Id}/hls/live.m3u8',
            path: {
                Id: data.id
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.segment
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvLivestreamfilesByIdHlsBySegment(data: GetLivetvLivestreamfilesByIdHlsBySegmentData): CancelablePromise<GetLivetvLivestreamfilesByIdHlsBySegmentResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/LiveStreamFiles/{Id}/hls/{Segment}',
            path: {
                Id: data.id,
                Segment: data.segment
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live tv channel
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.segment
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headLivetvLivestreamfilesByIdHlsBySegment(data: HeadLivetvLivestreamfilesByIdHlsBySegmentData): CancelablePromise<HeadLivetvLivestreamfilesByIdHlsBySegmentResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/LiveTv/LiveStreamFiles/{Id}/hls/{Segment}',
            path: {
                Id: data.id,
                Segment: data.segment
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.segment
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getLivetvLiverecordingsByIdHlsBySegment(data: GetLivetvLiverecordingsByIdHlsBySegmentData): CancelablePromise<GetLivetvLiverecordingsByIdHlsBySegmentResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/LiveTv/LiveRecordings/{Id}/hls/{Segment}',
            path: {
                Id: data.id,
                Segment: data.segment
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Gets a live recording
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.id
     * @param data.segment
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public headLivetvLiverecordingsByIdHlsBySegment(data: HeadLivetvLiverecordingsByIdHlsBySegmentData): CancelablePromise<HeadLivetvLiverecordingsByIdHlsBySegmentResponse> {
        return this.httpRequest.request({
            method: 'HEAD',
            url: '/LiveTv/LiveRecordings/{Id}/hls/{Segment}',
            path: {
                Id: data.id,
                Segment: data.segment
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}

export class VideoHlsServiceService {
    constructor(public readonly httpRequest: BaseHttpRequest) { }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.segmentContainer
     * @param data.segmentId
     * @param data.id
     * @param data.playlistId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainer(data: GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Audio/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                SegmentContainer: data.segmentContainer,
                SegmentId: data.segmentId,
                Id: data.id,
                PlaylistId: data.playlistId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
    /**
     * Requires authentication as user
     * @param data The data for the request.
     * @param data.segmentContainer
     * @param data.segmentId
     * @param data.id
     * @param data.playlistId
     * @returns unknown Operation successful. Response content unknown.
     * @throws ApiError
     */
    public getVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainer(data: GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerData): CancelablePromise<GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponse> {
        return this.httpRequest.request({
            method: 'GET',
            url: '/Videos/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}',
            path: {
                SegmentContainer: data.segmentContainer,
                SegmentId: data.segmentId,
                Id: data.id,
                PlaylistId: data.playlistId
            },
            errors: {
                400: 'Bad Request. Server cannot process request.',
                401: 'Unauthorized. Client needs to authenticate.',
                403: 'Forbidden. No permission for the reqested operation.',
                404: 'Resource not found or unavailable.',
                500: 'Server error.'
            }
        });
    }
    
}