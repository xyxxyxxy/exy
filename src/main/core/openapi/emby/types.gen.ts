// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseURL: 'http://emby.media/emby' | (string & {});
};

export type QueryResultBaseItemDto = {
    Items?: Array<BaseItemDto>;
    TotalRecordCount?: number;
};

/**
 * This is strictly used as a data transfer object from the api layer. This holds information about a BaseItem in a format that is convenient for the client.
 *
 */
export type BaseItemDto = {
    /**
     * The name.
     */
    Name?: string;
    OriginalTitle?: string;
    /**
     * The server identifier.
     */
    ServerId?: string;
    /**
     * The id.
     */
    Id?: string;
    Guid?: string;
    /**
     * The etag.
     */
    Etag?: string;
    /**
     * The Prefix.
     */
    Prefix?: string;
    TunerName?: string;
    /**
     * The playlist item identifier.
     */
    PlaylistItemId?: string;
    /**
     * The date created.
     */
    DateCreated?: string | null;
    DateModified?: string | null;
    VideoCodec?: string;
    AudioCodec?: string;
    AverageFrameRate?: number | null;
    RealFrameRate?: number | null;
    ExtraType?: string;
    SortIndexNumber?: number | null;
    SortParentIndexNumber?: number | null;
    CanDelete?: boolean | null;
    CanDownload?: boolean | null;
    CanEditItems?: boolean | null;
    SupportsResume?: boolean | null;
    PresentationUniqueKey?: string;
    PreferredMetadataLanguage?: string;
    PreferredMetadataCountryCode?: string;
    /**
     * A value indicating whether \[supports synchronize\].
     */
    SupportsSync?: boolean | null;
    SyncStatus?: SyncJobItemStatus;
    CanManageAccess?: boolean | null;
    CanLeaveContent?: boolean | null;
    CanMakePublic?: boolean | null;
    Container?: string;
    /**
     * The name of the sort.
     */
    SortName?: string;
    ForcedSortName?: string;
    Video3DFormat?: Video3dFormat;
    /**
     * The premiere date.
     */
    PremiereDate?: string | null;
    /**
     * The external urls.
     */
    ExternalUrls?: Array<ExternalUrl>;
    /**
     * The media versions.
     */
    MediaSources?: Array<MediaSourceInfo>;
    /**
     * The critic rating.
     */
    CriticRating?: number | null;
    GameSystemId?: number | null;
    AsSeries?: boolean | null;
    /**
     * The game system.
     */
    GameSystem?: string;
    ProductionLocations?: Array<string>;
    /**
     * The path.
     */
    Path?: string;
    /**
     * The official rating.
     */
    OfficialRating?: string;
    /**
     * The custom rating.
     */
    CustomRating?: string;
    /**
     * The channel identifier.
     */
    ChannelId?: string;
    ChannelName?: string;
    /**
     * The overview.
     */
    Overview?: string;
    /**
     * The taglines.
     */
    Taglines?: Array<string>;
    /**
     * The genres.
     */
    Genres?: Array<string>;
    /**
     * The community rating.
     */
    CommunityRating?: number | null;
    /**
     * The run time ticks.
     */
    RunTimeTicks?: number | null;
    Size?: number | null;
    FileName?: string;
    Bitrate?: number | null;
    /**
     * The production year.
     */
    ProductionYear?: number | null;
    /**
     * The number.
     */
    Number?: string;
    ChannelNumber?: string;
    /**
     * The index number.
     */
    IndexNumber?: number | null;
    /**
     * The index number end.
     */
    IndexNumberEnd?: number | null;
    /**
     * The parent index number.
     */
    ParentIndexNumber?: number | null;
    /**
     * The trailer urls.
     */
    RemoteTrailers?: Array<MediaUrl>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * A value indicating whether this instance is folder.
     */
    IsFolder?: boolean | null;
    /**
     * The parent id.
     */
    ParentId?: string;
    /**
     * The type.
     */
    Type?: string;
    /**
     * The people.
     */
    People?: Array<BaseItemPerson>;
    /**
     * The studios.
     */
    Studios?: Array<NameLongIdPair>;
    GenreItems?: Array<NameLongIdPair>;
    TagItems?: Array<NameLongIdPair>;
    /**
     * If the item does not have a logo, this will hold the Id of the Parent that has one.
     */
    ParentLogoItemId?: string;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     */
    ParentBackdropItemId?: string;
    /**
     * The parent backdrop image tags.
     */
    ParentBackdropImageTags?: Array<string>;
    /**
     * The local trailer count.
     */
    LocalTrailerCount?: number | null;
    UserData?: UserItemDataDto;
    /**
     * The recursive item count.
     */
    RecursiveItemCount?: number | null;
    /**
     * The child count.
     */
    ChildCount?: number | null;
    SeasonCount?: number | null;
    /**
     * The name of the series.
     */
    SeriesName?: string;
    /**
     * The series id.
     */
    SeriesId?: string;
    /**
     * The season identifier.
     */
    SeasonId?: string;
    /**
     * The special feature count.
     */
    SpecialFeatureCount?: number | null;
    /**
     * The display preferences id.
     */
    DisplayPreferencesId?: string;
    /**
     * The status.
     */
    Status?: string;
    /**
     * The air days.
     */
    AirDays?: Array<DayOfWeek>;
    /**
     * The tags.
     */
    Tags?: Array<string>;
    /**
     * The primary image aspect ratio, after image enhancements.
     */
    PrimaryImageAspectRatio?: number | null;
    /**
     * The artists.
     */
    Artists?: Array<string>;
    /**
     * The artist items.
     */
    ArtistItems?: Array<NameIdPair>;
    Composers?: Array<NameIdPair>;
    /**
     * The album.
     */
    Album?: string;
    /**
     * The type of the collection.
     */
    CollectionType?: string;
    /**
     * The display order.
     */
    DisplayOrder?: string;
    /**
     * The album id.
     */
    AlbumId?: string;
    /**
     * The album image tag.
     */
    AlbumPrimaryImageTag?: string;
    /**
     * The series primary image tag.
     */
    SeriesPrimaryImageTag?: string;
    /**
     * The album artist.
     */
    AlbumArtist?: string;
    /**
     * The album artists.
     */
    AlbumArtists?: Array<NameIdPair>;
    /**
     * The name of the season.
     */
    SeasonName?: string;
    /**
     * The media streams.
     */
    MediaStreams?: Array<MediaStream>;
    /**
     * The part count.
     */
    PartCount?: number | null;
    /**
     * The image tags.
     */
    ImageTags?: {
        [key: string]: string;
    };
    /**
     * The backdrop image tags.
     */
    BackdropImageTags?: Array<string>;
    /**
     * The parent logo image tag.
     */
    ParentLogoImageTag?: string;
    /**
     * The series studio.
     */
    SeriesStudio?: string;
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
    /**
     * The parent thumb item id.
     */
    ParentThumbItemId?: string;
    /**
     * The parent thumb image tag.
     */
    ParentThumbImageTag?: string;
    /**
     * The chapters.
     */
    Chapters?: Array<ChapterInfo>;
    LocationType?: LocationType;
    /**
     * The type of the media.
     */
    MediaType?: string;
    /**
     * The end date.
     */
    EndDate?: string | null;
    /**
     * The locked fields.
     */
    LockedFields?: Array<MetadataFields>;
    /**
     * A value indicating whether \[enable internet providers\].
     */
    LockData?: boolean | null;
    Width?: number | null;
    Height?: number | null;
    CameraMake?: string;
    CameraModel?: string;
    Software?: string;
    ExposureTime?: number | null;
    FocalLength?: number | null;
    ImageOrientation?: DrawingImageOrientation;
    Aperture?: number | null;
    ShutterSpeed?: number | null;
    Latitude?: number | null;
    Longitude?: number | null;
    Altitude?: number | null;
    IsoSpeedRating?: number | null;
    /**
     * The series timer identifier.
     */
    SeriesTimerId?: string;
    /**
     * The channel primary image tag.
     */
    ChannelPrimaryImageTag?: string;
    /**
     * The start date of the recording, in UTC.
     */
    StartDate?: string | null;
    /**
     * The completion percentage.
     */
    CompletionPercentage?: number | null;
    /**
     * A value indicating whether this instance is repeat.
     */
    IsRepeat?: boolean | null;
    IsNew?: boolean | null;
    /**
     * The episode title.
     */
    EpisodeTitle?: string;
    /**
     * A value indicating whether this instance is movie.
     */
    IsMovie?: boolean | null;
    /**
     * A value indicating whether this instance is sports.
     */
    IsSports?: boolean | null;
    /**
     * A value indicating whether this instance is series.
     */
    IsSeries?: boolean | null;
    /**
     * A value indicating whether this instance is live.
     */
    IsLive?: boolean | null;
    /**
     * A value indicating whether this instance is news.
     */
    IsNews?: boolean | null;
    /**
     * A value indicating whether this instance is kids.
     */
    IsKids?: boolean | null;
    /**
     * A value indicating whether this instance is premiere.
     */
    IsPremiere?: boolean | null;
    TimerType?: LiveTvTimerType;
    Disabled?: boolean | null;
    ManagementId?: string;
    /**
     * The timer identifier.
     */
    TimerId?: string;
    CurrentProgram?: BaseItemDto;
    MovieCount?: number | null;
    SeriesCount?: number | null;
    AlbumCount?: number | null;
    SongCount?: number | null;
    MusicVideoCount?: number | null;
    Subviews?: Array<string>;
    ListingsProviderId?: string;
    ListingsChannelId?: string;
    ListingsPath?: string;
    ListingsId?: string;
    ListingsChannelName?: string;
    ListingsChannelNumber?: string;
    AffiliateCallSign?: string;
};

export type SyncJobItemStatus = 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Synced' | 'Failed';

export type Video3dFormat = 'HalfSideBySide' | 'FullSideBySide' | 'FullTopAndBottom' | 'HalfTopAndBottom' | 'MVC';

export type ExternalUrl = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The type of the item.
     */
    Url?: string;
};

export type MediaSourceInfo = {
    Chapters?: Array<ChapterInfo>;
    Protocol?: MediaProtocol;
    Id?: string;
    Path?: string;
    EncoderPath?: string;
    EncoderProtocol?: MediaProtocol;
    Type?: MediaSourceType;
    ProbePath?: string;
    ProbeProtocol?: MediaProtocol;
    Container?: string;
    Size?: number | null;
    Name?: string;
    SortName?: string;
    /**
     * Differentiate internet url vs local network
     */
    IsRemote?: boolean;
    HasMixedProtocols?: boolean;
    RunTimeTicks?: number | null;
    ContainerStartTimeTicks?: number | null;
    SupportsTranscoding?: boolean;
    TrancodeLiveStartIndex?: number | null;
    WallClockStart?: string | null;
    SupportsDirectStream?: boolean;
    SupportsDirectPlay?: boolean;
    IsInfiniteStream?: boolean;
    RequiresOpening?: boolean;
    OpenToken?: string;
    RequiresClosing?: boolean;
    LiveStreamId?: string;
    /**
     * @deprecated
     */
    BufferMs?: number | null;
    RequiresLooping?: boolean;
    /**
     * @deprecated
     */
    SupportsProbing?: boolean;
    Video3DFormat?: Video3dFormat;
    MediaStreams?: Array<MediaStream>;
    Formats?: Array<string>;
    Bitrate?: number | null;
    Timestamp?: TransportStreamTimestamp;
    RequiredHttpHeaders?: {
        [key: string]: string;
    };
    DirectStreamUrl?: string;
    AddApiKeyToDirectStreamUrl?: boolean;
    TranscodingUrl?: string;
    TranscodingSubProtocol?: string;
    TranscodingContainer?: string;
    /**
     * @deprecated
     */
    AnalyzeDurationMs?: number | null;
    /**
     * @deprecated
     */
    ReadAtNativeFramerate?: boolean;
    DefaultAudioStreamIndex?: number | null;
    DefaultSubtitleStreamIndex?: number | null;
    /**
     * Used only by our Windows app. Not used by Emby Server. The id of the item that this mediasource belongs to, if there is one Also used by Emby for Kodi
     */
    ItemId?: string;
    /**
     * Used only by our Windows app. Not used by Emby Server.
     */
    ServerId?: string;
};

/**
 * Class ChapterInfo
 *
 */
export type ChapterInfo = {
    /**
     * The start position ticks.
     */
    StartPositionTicks?: number;
    /**
     * The name.
     */
    Name?: string;
    ImageTag?: string;
    MarkerType?: MarkerType;
    ChapterIndex?: number;
};

export type MarkerType = 'Chapter' | 'IntroStart' | 'IntroEnd' | 'CreditsStart';

export type MediaProtocol = 'File' | 'Http' | 'Rtmp' | 'Rtsp' | 'Udp' | 'Rtp' | 'Ftp' | 'Mms';

export type MediaSourceType = 'Default' | 'Grouping' | 'Placeholder';

/**
 * MediaStream information.
 *
 *
 * MediaStream itens are typically included in a `MediaBrowser.Model.Dto.MediaSourceInfo` object.
 *
 *
 * `MediaBrowser.Model.Dto.MediaSourceInfo.MediaStreams`
 *
 */
export type MediaStream = {
    /**
     * The codec.
     *
     * Probe Field: `codec_name`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`
     * Related Enums: `T:Emby.Media.Model.Enums.VideoMediaTypes`, `Emby.Media.Model.Enums.AudioMediaTypes`, `Emby.Media.Model.Enums.SubtitleMediaTypes`.
     */
    Codec?: string;
    /**
     * The codec tag.
     *
     * Probe Field: `codec_tag`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    CodecTag?: string;
    /**
     * The language.
     *
     * Probe Field: `tags["language"]`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    Language?: string;
    /**
     * The color transfer characteristics.
     *
     * Probe Field: `color_transfer`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`
     * Related Enum: `Emby.Media.Model.Enums.ColorTransfers`.
     */
    ColorTransfer?: string;
    /**
     * The chromaticity coordinates of the source primaries.
     *
     * Probe Field: `color_primaries`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`
     * Related Enum: `Emby.Media.Model.Enums.ColorPrimaries`.
     */
    ColorPrimaries?: string;
    /**
     * The YUV colorspace type.
     *
     * Probe Field: `color_space`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`
     * Related Enum: `Emby.Media.Model.Enums.ColorSpaces`.
     */
    ColorSpace?: string;
    /**
     * The comment.
     *
     * Probe Field: `tags["comment"]`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    Comment?: string;
    /**
     * The start time of the stream.
     *
     * Probe Field: `start_time`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     * Actual type: `System.TimeSpan`.
     */
    StreamStartTimeTicks?: number | null;
    /**
     * The time\-base.
     *
     * Probe Field: `time_base`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     * Actual type: `Emby.Media.Model.Types.Rational`.
     */
    TimeBase?: string;
    /**
     * The title.
     *
     * Probe Field: `tags["title"]`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    Title?: string;
    /**
     * The extradata.
     *
     * Probe Field: `extradata`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     *
     * Currently, this value is only parsed for subtitle streams with codec `Emby.Media.Model.Enums.SubtitleMediaTypes.dvb_teletext`.
     */
    Extradata?: string;
    VideoRange?: string;
    /**
     * The display title.
     *
     * Custom property set by the application.
     */
    DisplayTitle?: string;
    /**
     * The display language.
     *
     * Custom property set by the application.
     */
    DisplayLanguage?: string;
    /**
     * The nal length size.
     *
     * Probe Field: `nal_length_size`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video` of type `Emby.Media.Model.Enums.VideoMediaTypes.h264`.
     * Actual type: `System.Int32`.
     */
    NalLengthSize?: string;
    /**
     * A value indicating whether this instance is interlaced.
     *
     * Probe Field: `field_order` \!\= `progressive`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     */
    IsInterlaced?: boolean;
    /**
     * @deprecated
     */
    IsAVC?: boolean | null;
    /**
     * The channel layout.
     *
     * Probe Field: `channel_layout`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Audio`
     * Related Enum: `MediaBrowser.Model.Entities.MediaStream.ChannelLayout`.
     */
    ChannelLayout?: string;
    /**
     * The bit rate.
     *
     * Probe Field: `bit_rate`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`.
     *
     * THIS VALUE IS PROCESSED BY CUSTOM LOGIC AND DOES NOT NECESSARILY MATCH FFPROBE RESULTS\!
     */
    BitRate?: number | null;
    /**
     * The bit depth.
     *
     * Probe Field: `bits_per_sample` or `bits_per_raw_sample`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`.
     */
    BitDepth?: number | null;
    /**
     * The reference frames.
     *
     * Probe Field: `refs`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     */
    RefFrames?: number | null;
    Rotation?: number | null;
    /**
     * The audio channel count.
     *
     * Probe Field: `channels`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Audio`.
     */
    Channels?: number | null;
    /**
     * The sample rate.
     *
     * Probe Field: `sample_rate`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Audio`
     * Related Enum: `Emby.Media.Model.Enums.SampleRates`.
     */
    SampleRate?: number | null;
    /**
     * A value indicating whether this instance is default.
     *
     * Probe Field: `disposition["default"]`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    IsDefault?: boolean;
    /**
     * A value indicating whether this instance is forced.
     *
     * Probe Field: `disposition["forced"]`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    IsForced?: boolean;
    IsHearingImpaired?: boolean;
    /**
     * The height.
     *
     * Probe Field: `height`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     */
    Height?: number | null;
    /**
     * The width.
     *
     * Probe Field: `width`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     */
    Width?: number | null;
    /**
     * The average frame rate..
     *
     * Probe Field: `avg_frame_rate`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     * Actual type: `Emby.Media.Model.Types.Rational`.
     */
    AverageFrameRate?: number | null;
    /**
     * The real frame rate..
     *
     * Probe Field: `r_frame_rate`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     * Actual type: `Emby.Media.Model.Types.Rational`.
     */
    RealFrameRate?: number | null;
    /**
     * The profile.
     *
     * Probe Field: `profile`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`
     * Related Enums: `Emby.Media.Model.Enums.AacProfiles`, `Emby.Media.Model.Enums.AvcProfiles`, `Emby.Media.Model.Enums.H263Profiles`, `Emby.Media.Model.Enums.HevcProfiles`, `Emby.Media.Model.Enums.Mpeg2Profiles`,`Emby.Media.Model.Enums.Vc1Profiles`, `Emby.Media.Model.Enums.Mpeg4Profiles`, `Emby.Media.Model.Enums.Vp8Profiles`, `Emby.Media.Model.Enums.Vp9Profiles`.
     */
    Profile?: string;
    Type?: MediaStreamType;
    /**
     * The aspect ratio.
     *
     * Probe Field: `display_aspect_ratio`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     * Actual type: `Emby.Media.Model.Types.Rational`.
     */
    AspectRatio?: string;
    /**
     * The index of the stream inside its container.
     *
     * Probe Field: `index`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`, `MediaBrowser.Model.Entities.MediaStreamType.Audio`, `MediaBrowser.Model.Entities.MediaStreamType.Subtitle`.
     */
    Index?: number;
    /**
     * A value indicating whether this instance is external.
     *
     * Custom property set by the application.
     */
    IsExternal?: boolean;
    DeliveryMethod?: SubtitleDeliveryMethod;
    /**
     * The delivery URL.
     *
     * Custom property set by the application.
     */
    DeliveryUrl?: string;
    /**
     * A value indicating whether this instance is external URL.
     *
     * Custom property set by the application.
     */
    IsExternalUrl?: boolean | null;
    IsTextSubtitleStream?: boolean;
    /**
     * A value indicating whether \[supports external stream\].
     */
    SupportsExternalStream?: boolean;
    /**
     * The filename.
     */
    Path?: string;
    Protocol?: MediaProtocol;
    /**
     * The pixel format.
     *
     * Probe Field: `pix_fmt`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`.
     * Actual type: `MediaBrowser.Model.Entities.MediaStream.PixelFormat`.
     */
    PixelFormat?: string;
    /**
     * The codec level.
     *
     * Probe Field: `level`
     * Applies to: `MediaBrowser.Model.Entities.MediaStreamType.Video`
     * Related Enums: `Emby.Media.Model.Enums.AvcLevels`, `Emby.Media.Model.Enums.H263Levels`, `Emby.Media.Model.Enums.HevcLevels`, `Emby.Media.Model.Enums.Mpeg2Levels`,`Emby.Media.Model.Enums.Vc1Levels`, `Emby.Media.Model.Enums.Mpeg4Levels`, `Emby.Media.Model.Enums.Vp8Levels`, `Emby.Media.Model.Enums.Vp9Levels`.
     */
    Level?: number | null;
    /**
     * A value indicating whether this instance is anamorphic.
     */
    IsAnamorphic?: boolean | null;
    ExtendedVideoType?: ExtendedVideoTypes;
    ExtendedVideoSubType?: ExtendedVideoSubTypes;
    /**
     * The extended video sub\-type description.
     */
    ExtendedVideoSubTypeDescription?: string;
    /**
     * Used only by our Windows app. Not used by Emby Server.
     */
    ItemId?: string;
    /**
     * Used only by our Windows app. Not used by Emby Server.
     */
    ServerId?: string;
    /**
     * The size of the attachment.
     */
    AttachmentSize?: number | null;
    /**
     * The type of the MIME.
     */
    MimeType?: string;
    SubtitleLocationType?: SubtitleLocationType;
};

/**
 * Enum MediaStreamType
 *
 */
export type MediaStreamType = 'Unknown' | 'Audio' | 'Video' | 'Subtitle' | 'EmbeddedImage' | 'Attachment' | 'Data';

export type SubtitleDeliveryMethod = 'Encode' | 'Embed' | 'External' | 'Hls' | 'VideoSideData';

export type ExtendedVideoTypes = 'None' | 'Hdr10' | 'Hdr10Plus' | 'HyperLogGamma' | 'DolbyVision';

export type ExtendedVideoSubTypes = 'None' | 'Hdr10' | 'HyperLogGamma' | 'Hdr10Plus0' | 'DoviProfile02' | 'DoviProfile10' | 'DoviProfile22' | 'DoviProfile30' | 'DoviProfile42' | 'DoviProfile50' | 'DoviProfile61' | 'DoviProfile76' | 'DoviProfile81' | 'DoviProfile82' | 'DoviProfile83' | 'DoviProfile84' | 'DoviProfile85' | 'DoviProfile92';

export type SubtitleLocationType = 'InternalStream' | 'VideoSideData';

export type TransportStreamTimestamp = 'None' | 'Zero' | 'Valid';

export type MediaUrl = {
    Url?: string;
    Name?: string;
};

export type ProviderIdDictionary = {
    [key: string]: string;
};

/**
 * This is used by the api to get information about a Person within a BaseItem
 *
 */
export type BaseItemPerson = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The identifier.
     */
    Id?: string;
    /**
     * The role.
     */
    Role?: string;
    Type?: PersonType;
    /**
     * The primary image tag.
     */
    PrimaryImageTag?: string;
};

export type PersonType = 'Actor' | 'Director' | 'Writer' | 'Producer' | 'GuestStar' | 'Composer' | 'Conductor' | 'Lyricist';

export type NameLongIdPair = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The identifier.
     */
    Id?: number;
};

/**
 * Class UserItemDataDto
 *
 */
export type UserItemDataDto = {
    /**
     * The rating.
     */
    Rating?: number | null;
    /**
     * The played percentage.
     */
    PlayedPercentage?: number | null;
    /**
     * The unplayed item count.
     */
    UnplayedItemCount?: number | null;
    /**
     * The playback position ticks.
     */
    PlaybackPositionTicks?: number;
    /**
     * The play count.
     */
    PlayCount?: number | null;
    /**
     * A value indicating whether this instance is favorite.
     */
    IsFavorite?: boolean;
    /**
     * The last played date.
     */
    LastPlayedDate?: string | null;
    /**
     * A value indicating whether this `MediaBrowser.Model.Dto.UserItemDataDto` is played.
     */
    Played?: boolean;
    /**
     * The key.
     */
    Key?: string;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * Used only by our Windows app. Not used by Emby Server.
     */
    ServerId?: string;
};

export type DayOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday';

export type NameIdPair = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The identifier.
     */
    Id?: string;
};

/**
 * Enum LocationType
 *
 */
export type LocationType = 'FileSystem' | 'Virtual';

/**
 * Enum MetadataFields
 *
 */
export type MetadataFields = 'Cast' | 'Genres' | 'ProductionLocations' | 'Studios' | 'Tags' | 'Name' | 'Overview' | 'Runtime' | 'OfficialRating' | 'Collections' | 'ChannelNumber' | 'SortName' | 'OriginalTitle' | 'SortIndexNumber' | 'SortParentIndexNumber' | 'CommunityRating' | 'CriticRating' | 'Tagline' | 'Composers' | 'Artists' | 'AlbumArtists';

export type DrawingImageOrientation = 'TopLeft' | 'TopRight' | 'BottomRight' | 'BottomLeft' | 'LeftTop' | 'RightTop' | 'RightBottom' | 'LeftBottom';

export type LiveTvTimerType = 'Program' | 'DateTime' | 'Keyword';

export type QueryResultUserLibraryTagItem = {
    Items?: Array<UserLibraryTagItem>;
    TotalRecordCount?: number;
};

export type UserLibraryTagItem = {
    Name?: string;
    Id?: string;
};

export type CollectionsCollectionCreationResult = {
    Id?: string;
    Name?: string;
};

export type QueryResultDevicesDeviceInfo = {
    Items?: Array<DevicesDeviceInfo>;
    TotalRecordCount?: number;
};

export type DevicesDeviceInfo = {
    Name?: string;
    /**
     * The identifier.
     */
    Id?: string;
    InternalId?: number;
    ReportedDeviceId?: string;
    /**
     * The last name of the user.
     */
    LastUserName?: string;
    /**
     * The name of the application.
     */
    AppName?: string;
    /**
     * The application version.
     */
    AppVersion?: string;
    /**
     * The last user identifier.
     */
    LastUserId?: string;
    DateLastActivity?: string;
    IconUrl?: string;
    IpAddress?: string;
};

export type FeatureInfo = {
    Name?: string;
    Id?: string;
    FeatureType?: FeatureType;
};

export type FeatureType = 'System' | 'User';

export type QueryResultUserLibraryOfficialRatingItem = {
    Items?: Array<UserLibraryOfficialRatingItem>;
    TotalRecordCount?: number;
};

export type UserLibraryOfficialRatingItem = {
    Name?: string;
};

/**
 * Class PackageInfo
 *
 */
export type PackageInfo = {
    /**
     * The internal id of this package.
     */
    id?: string;
    /**
     * The name.
     */
    name?: string;
    /**
     * The short description.
     */
    shortDescription?: string;
    /**
     * The overview.
     */
    overview?: string;
    /**
     * A value indicating whether this instance is premium.
     */
    isPremium?: boolean;
    /**
     * A value indicating whether this instance is adult only content.
     */
    adult?: boolean;
    /**
     * The rich desc URL.
     */
    richDescUrl?: string;
    /**
     * The thumb image.
     */
    thumbImage?: string;
    /**
     * The preview image.
     */
    previewImage?: string;
    /**
     * The type.
     */
    type?: string;
    /**
     * The target filename.
     */
    targetFilename?: string;
    /**
     * The owner.
     */
    owner?: string;
    /**
     * The category.
     */
    category?: string;
    /**
     * The catalog tile color.
     */
    tileColor?: string;
    /**
     * The feature id of this package (if premium).
     */
    featureId?: string;
    /**
     * The price for this package (if premium).
     */
    price?: number | null;
    targetSystem?: PackageTargetSystem;
    /**
     * The guid of the assembly associated with this package (if a plug\-in). This is used to identify the proper item for automatic updates.
     */
    guid?: string;
    /**
     * Whether or not this package is registered.
     */
    isRegistered?: boolean;
    /**
     * The expiration date for this package.
     */
    expDate?: string;
    /**
     * The versions.
     */
    versions?: Array<PackageVersionInfo>;
    /**
     * A value indicating whether \[enable in application store\].
     */
    enableInAppStore?: boolean;
    /**
     * The installs.
     */
    installs?: number;
};

/**
 * Enum PackageType
 *
 */
export type PackageTargetSystem = 'Server' | 'MBTheater' | 'MBClassic' | 'Other';

/**
 * Class PackageVersionInfo
 *
 */
export type PackageVersionInfo = {
    /**
     * The name.
     */
    name?: string;
    /**
     * The guid.
     */
    guid?: string;
    /**
     * The version STR.
     */
    versionStr?: string;
    classification?: PackageVersionClass;
    /**
     * The description.
     */
    description?: string;
    /**
     * The required version STR.
     */
    requiredVersionStr?: string;
    /**
     * The source URL.
     */
    sourceUrl?: string;
    /**
     * The source URL.
     */
    checksum?: string;
    /**
     * The target filename.
     */
    targetFilename?: string;
    infoUrl?: string;
    runtimes?: string;
    timestamp?: string | null;
};

/**
 * Enum PackageVersionClass
 *
 */
export type PackageVersionClass = 'Release' | 'Beta' | 'Dev';

export type PlaylistsPlaylistCreationResult = {
    Id?: string;
    Name?: string;
    ItemAddedCount?: number;
};

/**
 * This is a serializable stub class that is used by the api to provide information about installed plugins.
 *
 */
export type PluginsPluginInfo = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The version.
     */
    Version?: string;
    /**
     * The name of the configuration file.
     */
    ConfigurationFileName?: string;
    /**
     * The description.
     */
    Description?: string;
    /**
     * The unique id.
     */
    Id?: string;
    /**
     * The image URL.
     */
    ImageTag?: string;
};

/**
 * Class TaskInfo
 *
 */
export type TaskInfo = {
    /**
     * The name.
     */
    Name?: string;
    State?: TaskState;
    /**
     * The progress.
     */
    CurrentProgressPercentage?: number | null;
    /**
     * The id.
     */
    Id?: string;
    LastExecutionResult?: TaskResult;
    /**
     * The triggers.
     */
    Triggers?: Array<TaskTriggerInfo>;
    /**
     * The description.
     */
    Description?: string;
    /**
     * The category.
     */
    Category?: string;
    /**
     * A value indicating whether this instance is hidden.
     */
    IsHidden?: boolean;
    /**
     * The key.
     */
    Key?: string;
};

/**
 * Enum TaskState
 *
 */
export type TaskState = 'Idle' | 'Cancelling' | 'Running';

/**
 * Class TaskExecutionInfo
 *
 */
export type TaskResult = {
    /**
     * The start time UTC.
     */
    StartTimeUtc?: string;
    /**
     * The end time UTC.
     */
    EndTimeUtc?: string;
    Status?: TaskCompletionStatus;
    /**
     * The name.
     */
    Name?: string;
    /**
     * The key.
     */
    Key?: string;
    /**
     * The id.
     */
    Id?: string;
    /**
     * The error message.
     */
    ErrorMessage?: string;
    /**
     * The long error message.
     */
    LongErrorMessage?: string;
};

/**
 * Enum TaskCompletionStatus
 *
 */
export type TaskCompletionStatus = 'Completed' | 'Failed' | 'Cancelled' | 'Aborted';

/**
 * Class TaskTriggerInfo
 *
 */
export type TaskTriggerInfo = {
    /**
     * The type.
     */
    Type?: string;
    /**
     * The time of day.
     */
    TimeOfDayTicks?: number | null;
    /**
     * The interval.
     */
    IntervalTicks?: number | null;
    SystemEvent?: SystemEvent;
    DayOfWeek?: DayOfWeek;
    /**
     * The maximum runtime ticks.
     */
    MaxRuntimeTicks?: number | null;
};

/**
 * Enum SystemEvent
 *
 */
export type SystemEvent = 'WakeFromSleep' | 'DisplayConfigurationChange' | 'NetworkChange';

/**
 * Class SessionInfo
 *
 */
export type SessionSessionInfo = {
    PlayState?: PlayerStateInfo;
    AdditionalUsers?: Array<SessionUserInfo>;
    /**
     * The remote end point.
     */
    RemoteEndPoint?: string;
    Protocol?: string;
    /**
     * The playable media types.
     */
    PlayableMediaTypes?: Array<string>;
    PlaylistItemId?: string;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    /**
     * The id.
     */
    Id?: string;
    ServerId?: string;
    /**
     * The user id.
     */
    UserId?: string;
    PartyId?: string;
    /**
     * The username.
     */
    UserName?: string;
    UserPrimaryImageTag?: string;
    /**
     * The type of the client.
     */
    Client?: string;
    /**
     * The last activity date.
     */
    LastActivityDate?: string;
    /**
     * The name of the device.
     */
    DeviceName?: string;
    DeviceType?: string;
    NowPlayingItem?: BaseItemDto;
    InternalDeviceId?: number;
    /**
     * The device id.
     */
    DeviceId?: string;
    /**
     * The application version.
     */
    ApplicationVersion?: string;
    /**
     * The application icon URL.
     */
    AppIconUrl?: string;
    /**
     * The supported commands.
     */
    SupportedCommands?: Array<string>;
    TranscodingInfo?: TranscodingInfo;
    SupportsRemoteControl?: boolean;
};

export type PlayerStateInfo = {
    /**
     * The now playing position ticks.
     */
    PositionTicks?: number | null;
    /**
     * A value indicating whether this instance can seek.
     */
    CanSeek?: boolean;
    /**
     * A value indicating whether this instance is paused.
     */
    IsPaused?: boolean;
    /**
     * A value indicating whether this instance is muted.
     */
    IsMuted?: boolean;
    /**
     * The volume level.
     */
    VolumeLevel?: number | null;
    /**
     * The index of the now playing audio stream.
     */
    AudioStreamIndex?: number | null;
    /**
     * The index of the now playing subtitle stream.
     */
    SubtitleStreamIndex?: number | null;
    /**
     * The now playing media version identifier.
     */
    MediaSourceId?: string;
    MediaSource?: MediaSourceInfo;
    PlayMethod?: PlayMethod;
    RepeatMode?: RepeatMode;
    SleepTimerMode?: SleepTimerMode;
    SleepTimerEndTime?: string | null;
    SubtitleOffset?: number;
    Shuffle?: boolean;
    PlaybackRate?: number;
};

export type PlayMethod = 'Transcode' | 'DirectStream' | 'DirectPlay';

export type RepeatMode = 'RepeatNone' | 'RepeatAll' | 'RepeatOne';

export type SleepTimerMode = 'None' | 'AfterItem' | 'AtTime';

/**
 * Class SessionUserInfo.
 *
 */
export type SessionUserInfo = {
    /**
     * The user identifier.
     */
    UserId?: string;
    /**
     * The name of the user.
     */
    UserName?: string;
    UserInternalId?: number;
};

export type TranscodingInfo = {
    AudioCodec?: string;
    VideoCodec?: string;
    SubProtocol?: string;
    Container?: string;
    IsVideoDirect?: boolean;
    IsAudioDirect?: boolean;
    Bitrate?: number | null;
    AudioBitrate?: number | null;
    VideoBitrate?: number | null;
    Framerate?: number | null;
    CompletionPercentage?: number | null;
    TranscodingPositionTicks?: number | null;
    TranscodingStartPositionTicks?: number | null;
    Width?: number | null;
    Height?: number | null;
    AudioChannels?: number | null;
    TranscodeReasons?: Array<TranscodeReason>;
    /**
     * Deprecated, please use ProcessStatistics instead
     *
     * @deprecated
     */
    CurrentCpuUsage?: number | null;
    /**
     * Deprecated, please use ProcessStatistics instead
     *
     * @deprecated
     */
    AverageCpuUsage?: number | null;
    /**
     * Deprecated, please use ProcessStatistics instead
     *
     * @deprecated
     */
    CpuHistory?: Array<TupleDoubleDouble>;
    ProcessStatistics?: ProcessRunMetricsProcessStatistics;
    CurrentThrottle?: number | null;
    VideoDecoder?: string;
    VideoDecoderIsHardware?: boolean;
    VideoDecoderMediaType?: string;
    VideoDecoderHwAccel?: string;
    VideoEncoder?: string;
    VideoEncoderIsHardware?: boolean;
    VideoEncoderMediaType?: string;
    VideoEncoderHwAccel?: string;
    VideoPipelineInfo?: Array<TranscodingVpStepInfo>;
    SubtitlePipelineInfos?: Array<Array<TranscodingVpStepInfo>>;
};

export type TranscodeReason = 'ContainerNotSupported' | 'VideoCodecNotSupported' | 'AudioCodecNotSupported' | 'ContainerBitrateExceedsLimit' | 'AudioBitrateNotSupported' | 'AudioChannelsNotSupported' | 'VideoResolutionNotSupported' | 'UnknownVideoStreamInfo' | 'UnknownAudioStreamInfo' | 'AudioProfileNotSupported' | 'AudioSampleRateNotSupported' | 'AnamorphicVideoNotSupported' | 'InterlacedVideoNotSupported' | 'SecondaryAudioNotSupported' | 'RefFramesNotSupported' | 'VideoBitDepthNotSupported' | 'VideoBitrateNotSupported' | 'VideoFramerateNotSupported' | 'VideoLevelNotSupported' | 'VideoProfileNotSupported' | 'AudioBitDepthNotSupported' | 'SubtitleCodecNotSupported' | 'DirectPlayError' | 'VideoRangeNotSupported' | 'SubtitleContentOptionsEnabled' | 'ExternalAudioNotSupported' | 'AudioDelayNotSupported';

export type TupleDoubleDouble = {
    Item1?: number;
    Item2?: number;
};

export type ProcessRunMetricsProcessStatistics = {
    /**
     * The current cpu.
     */
    CurrentCpu?: number;
    /**
     * The average cpu.
     */
    AverageCpu?: number;
    /**
     * The currently allocated virtual memory.
     */
    CurrentVirtualMemory?: number;
    /**
     * The currently allocated working set.
     */
    CurrentWorkingSet?: number;
    /**
     * The metrics.
     */
    Metrics?: Array<ProcessRunMetricsProcessMetricPoint>;
};

export type ProcessRunMetricsProcessMetricPoint = {
    /**
     * The time.
     */
    Time?: string;
    /**
     * The cpu percent.
     */
    CpuPercent?: number;
    /**
     * The virtual memory.
     */
    VirtualMemory?: number;
    /**
     * The working set.
     */
    WorkingSet?: number;
};

export type TranscodingVpStepInfo = {
    StepType?: TranscodingVpStepTypes;
    StepTypeName?: string;
    HardwareContextName?: string;
    IsHardwareContext?: boolean;
    Name?: string;
    Short?: string;
    FfmpegName?: string;
    FfmpegDescription?: string;
    FfmpegOptions?: string;
    Param?: string;
    ParamShort?: string;
};

/**
 * Video Processing Step Type enum.
 *
 */
export type TranscodingVpStepTypes = 'Decoder' | 'Encoder' | 'Scaling' | 'Deinterlace' | 'SubtitleOverlay' | 'ToneMapping' | 'ColorConversion' | 'SplitCaptions' | 'TextSub2Video' | 'GraphicSub2Video' | 'GraphicSub2Text' | 'BurnInTextSubs' | 'BurnInGraphicSubs' | 'ScaleSubs' | 'TextMod' | 'Censor' | 'ShowSpeaker' | 'StripStyles' | 'ConnectTo' | 'Rotate';

/**
 * Enum ImageType
 *
 */
export type ImageType = 'Primary' | 'Art' | 'Backdrop' | 'Banner' | 'Logo' | 'Thumb' | 'Disc' | 'Box' | 'Screenshot' | 'Menu' | 'Chapter' | 'BoxRear' | 'Thumbnail' | 'LogoLight' | 'LogoLightColor';

export type NameValuePair = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The value.
     */
    Value?: string;
};

export type MbBackupApiRestoreOptions = {
    RestoreServerId?: boolean;
    UseFiles?: string;
};

export type MbBackupApiDataRestoreOptions = {
    Users?: Array<MbBackupApiUserRestoreInfo>;
};

export type MbBackupApiUserRestoreInfo = {
    SourceUserId?: string;
    TargetUserId?: string;
};

export type MbBackupApiAllBackupsInfo = {
    FullBackupInfo?: MbBackupBackupInfo;
    LightBackups?: Array<MbBackupBackupInfo>;
};

export type MbBackupBackupInfo = {
    ServerVersion?: string;
    PluginVersion?: string;
    Name?: string;
    CanRestore?: boolean;
    IsFullBackup?: boolean;
    DateCreated?: string;
    Users?: Array<NameIdPair>;
};

export type BrandingBrandingOptions = {
    /**
     * The login disclaimer.
     */
    LoginDisclaimer?: string;
    /**
     * The custom CSS.
     */
    CustomCss?: string;
};

export type ConnectConnectAuthenticationExchangeResult = {
    LocalUserId?: string;
    AccessToken?: string;
};

export type DevicesDeviceOptions = {
    CustomName?: string;
};

export type DevicesContentUploadHistory = {
    DeviceId?: string;
    FilesUploaded?: Array<DevicesLocalFileInfo>;
};

export type DevicesLocalFileInfo = {
    Name?: string;
    Id?: string;
    Album?: string;
    MimeType?: string;
    DateCreated?: string | null;
};

export type DisplayPreferences = {
    Id?: string;
    SortBy?: string;
    CustomPrefs?: {
        [key: string]: string;
    };
    SortOrder?: SortOrder;
    Client?: string;
};

/**
 * Enum SortOrder
 *
 */
export type SortOrder = 'Ascending' | 'Descending';

export type DlnaProfilesDlnaProfile = {
    Type?: DlnaProfilesDeviceProfileType;
    Path?: string;
    UserId?: string;
    AlbumArtPn?: string;
    MaxAlbumArtWidth?: number;
    MaxAlbumArtHeight?: number;
    MaxIconWidth?: number | null;
    MaxIconHeight?: number | null;
    FriendlyName?: string;
    Manufacturer?: string;
    ManufacturerUrl?: string;
    ModelName?: string;
    ModelDescription?: string;
    ModelNumber?: string;
    ModelUrl?: string;
    SerialNumber?: string;
    EnableAlbumArtInDidl?: boolean;
    EnableSingleAlbumArtLimit?: boolean;
    EnableSingleSubtitleLimit?: boolean;
    ProtocolInfo?: string;
    TimelineOffsetSeconds?: number;
    RequiresPlainVideoItems?: boolean;
    RequiresPlainFolders?: boolean;
    IgnoreTranscodeByteRangeRequests?: boolean;
    SupportsSamsungBookmark?: boolean;
    Identification?: DlnaProfilesDeviceIdentification;
    ProtocolInfoDetection?: DlnaProfilesProtocolInfoDetection;
    /**
     * The name.
     */
    Name?: string;
    Id?: string;
    SupportedMediaTypes?: string;
    MaxStreamingBitrate?: number | null;
    MusicStreamingTranscodingBitrate?: number | null;
    MaxStaticMusicBitrate?: number | null;
    DeclaredFeatures?: Array<string>;
    /**
     * The direct play profiles.
     */
    DirectPlayProfiles?: Array<DirectPlayProfile>;
    /**
     * The transcoding profiles.
     */
    TranscodingProfiles?: Array<TranscodingProfile>;
    ContainerProfiles?: Array<ContainerProfile>;
    CodecProfiles?: Array<CodecProfile>;
    ResponseProfiles?: Array<ResponseProfile>;
    SubtitleProfiles?: Array<SubtitleProfile>;
};

export type DlnaProfilesDeviceProfileType = 'System' | 'User';

export type DlnaProfilesDeviceIdentification = {
    FriendlyName?: string;
    ModelNumber?: string;
    SerialNumber?: string;
    ModelName?: string;
    ModelDescription?: string;
    DeviceDescription?: string;
    ModelUrl?: string;
    Manufacturer?: string;
    ManufacturerUrl?: string;
    Headers?: Array<DlnaProfilesHttpHeaderInfo>;
};

export type DlnaProfilesHttpHeaderInfo = {
    Name?: string;
    Value?: string;
    Match?: DlnaProfilesHeaderMatchType;
};

export type DlnaProfilesHeaderMatchType = 'Equals' | 'Regex' | 'Substring';

export type DlnaProfilesProtocolInfoDetection = {
    EnabledForVideo?: boolean;
    EnabledForAudio?: boolean;
    EnabledForPhotos?: boolean;
};

export type DirectPlayProfile = {
    Container?: string;
    AudioCodec?: string;
    VideoCodec?: string;
    Type?: DlnaProfileType;
};

export type DlnaProfileType = 'Audio' | 'Video' | 'Photo';

export type TranscodingProfile = {
    Container?: string;
    Type?: DlnaProfileType;
    VideoCodec?: string;
    AudioCodec?: string;
    Protocol?: string;
    EstimateContentLength?: boolean;
    EnableMpegtsM2TsMode?: boolean;
    TranscodeSeekInfo?: TranscodeSeekInfo;
    CopyTimestamps?: boolean;
    Context?: EncodingContext;
    MaxAudioChannels?: string;
    MinSegments?: number;
    SegmentLength?: number;
    BreakOnNonKeyFrames?: boolean;
    AllowInterlacedVideoStreamCopy?: boolean;
    ManifestSubtitles?: string;
    MaxManifestSubtitles?: number;
    MaxWidth?: number;
    MaxHeight?: number;
    FillEmptySubtitleSegments?: boolean;
};

export type TranscodeSeekInfo = 'Auto' | 'Bytes';

export type EncodingContext = 'Streaming' | 'Static';

export type ContainerProfile = {
    Type?: DlnaProfileType;
    Conditions?: Array<ProfileCondition>;
    Container?: string;
};

export type ProfileCondition = {
    Condition?: ProfileConditionType;
    Property?: ProfileConditionValue;
    Value?: string;
    IsRequired?: boolean;
};

export type ProfileConditionType = 'Equals' | 'NotEquals' | 'LessThanEqual' | 'GreaterThanEqual' | 'EqualsAny';

export type ProfileConditionValue = 'AudioChannels' | 'AudioBitrate' | 'AudioProfile' | 'Width' | 'Height' | 'Has64BitOffsets' | 'PacketLength' | 'VideoBitDepth' | 'VideoBitrate' | 'VideoFramerate' | 'VideoLevel' | 'VideoProfile' | 'VideoTimestamp' | 'IsAnamorphic' | 'RefFrames' | 'NumAudioStreams' | 'NumVideoStreams' | 'IsSecondaryAudio' | 'VideoCodecTag' | 'IsAvc' | 'IsInterlaced' | 'AudioSampleRate' | 'AudioBitDepth' | 'VideoRange' | 'VideoRotation' | 'IsExternalAudio';

export type CodecProfile = {
    Type?: CodecType;
    Conditions?: Array<ProfileCondition>;
    ApplyConditions?: Array<ProfileCondition>;
    Codec?: string;
    Container?: string;
};

export type CodecType = 'Video' | 'VideoAudio' | 'Audio';

export type ResponseProfile = {
    Container?: string;
    AudioCodec?: string;
    VideoCodec?: string;
    Type?: DlnaProfileType;
    OrgPn?: string;
    MimeType?: string;
    Conditions?: Array<ProfileCondition>;
};

export type SubtitleProfile = {
    Format?: string;
    Method?: SubtitleDeliveryMethod;
    DidlMode?: string;
    Language?: string;
    Container?: string;
    Protocol?: string;
};

export type ConfigurationToneMappingToneMapOptionsVisibility = {
    ShowAdvanced?: boolean;
    IsSoftwareToneMappingAvailable?: boolean;
    IsAnyHardwareToneMappingAvailable?: boolean;
    ShowNvidiaOptions?: boolean;
    ShowQuickSyncOptions?: boolean;
    ShowVaapiOptions?: boolean;
    IsOpenClAvailable?: boolean;
    IsOpenClSuperTAvailable?: boolean;
    IsVaapiNativeAvailable?: boolean;
    IsQuickSyncNativeAvailable?: boolean;
    OperatingSystem?: OperatingSystem;
};

export type OperatingSystem = 'Windows' | 'Linux' | 'OSX' | 'BSD' | 'Android';

export type EditObjectContainer = {
    Object?: {
        [key: string]: unknown;
    };
    DefaultObject?: {
        [key: string]: unknown;
    };
    TypeName?: string;
    EditorRoot?: EditorsEditorRoot;
};

export type EditorsEditorRoot = {
    PropertyConditions?: Array<ConditionsPropertyCondition>;
    PostbackActions?: Array<ActionsPostbackAction>;
    TitleButton?: EditorsEditorButtonItem;
    EditorItems?: Array<EditorsEditorBase>;
    EditorType?: CommonEditorTypes;
    Name?: string;
    Id?: string;
    AllowEmpty?: boolean;
    IsReadOnly?: boolean;
    IsAdvanced?: boolean;
    DisplayName?: string;
    Description?: string;
    FeatureRequiresPremiere?: boolean;
    ParentId?: string;
};

export type ConditionsPropertyCondition = {
    AffectedPropertyId?: string;
    ConditionType?: ConditionsPropertyConditionType;
    /**
     * The target property name or path.
     */
    TargetPropertyId?: string;
    SimpleCondition?: AttributesSimpleCondition;
    ValueCondition?: AttributesValueCondition;
    /**
     * The value.
     */
    Value?: {
        [key: string]: unknown;
    };
};

export type ConditionsPropertyConditionType = 'Visible' | 'Enabled';

/**
 * Conditions on the source value.
 *
 */
export type AttributesSimpleCondition = 'IsTrue' | 'IsFalse' | 'IsNull' | 'IsNotNullOrEmpty';

/**
 * Conditions for comparing with a target value.
 *
 */
export type AttributesValueCondition = 'IsEqual' | 'IsNotEqual' | 'IsGreater' | 'IsGreaterOrEqual' | 'IsLess' | 'IsLessOrEqual';

export type ActionsPostbackAction = {
    TargetEditorId?: string;
    PostbackCommandId?: string;
    CommandParameterPropertyId?: string;
};

export type EditorsEditorButtonItem = {
    EditorType?: CommonEditorTypes;
    Name?: string;
    Id?: string;
    AllowEmpty?: boolean;
    IsReadOnly?: boolean;
    IsAdvanced?: boolean;
    DisplayName?: string;
    Description?: string;
    FeatureRequiresPremiere?: boolean;
    ParentId?: string;
};

export type CommonEditorTypes = 'Group' | 'Text' | 'Numeric' | 'Boolean' | 'SelectSingle' | 'SelectMultiple' | 'Date' | 'FilePath' | 'FolderPath' | 'StatusItem' | 'ProgressItem' | 'ButtonItem' | 'ButtonGroup' | 'CaptionItem' | 'LabelItem' | 'ItemList' | 'RadioGroup' | 'DxDataGrid' | 'DxPivotGrid' | 'SpacerItem';

export type EditorsEditorBase = {
    EditorType?: CommonEditorTypes;
    Name?: string;
    Id?: string;
    AllowEmpty?: boolean;
    IsReadOnly?: boolean;
    IsAdvanced?: boolean;
    DisplayName?: string;
    Description?: string;
    FeatureRequiresPremiere?: boolean;
    ParentId?: string;
};

export type MediaEncodingCodecParameterContext = 'Playback' | 'Conversion';

export type ValidatePath = {
    ValidateWriteable?: boolean;
    IsFile?: boolean | null;
    Username?: string;
    Password?: string;
};

export type DefaultDirectoryBrowserInfo = {
    Path?: string;
};

/**
 * Class FileSystemEntryInfo
 *
 */
export type IoFileSystemEntryInfo = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The path.
     */
    Path?: string;
    Type?: IoFileSystemEntryType;
};

/**
 * Enum FileSystemEntryType
 *
 */
export type IoFileSystemEntryType = 'File' | 'Directory' | 'NetworkComputer' | 'NetworkShare';

export type GetDirectoryContents = {
    Username?: string;
    Password?: string;
};

export type UserLibraryUpdateUserItemAccess = {
    ItemIds?: Array<string>;
    UserIds?: Array<string>;
    ItemAccess?: UserItemShareLevel;
};

export type UserItemShareLevel = 'None' | 'Read' | 'Write' | 'Manage' | 'ManageDelete';

/**
 * Class LibrarySummary
 *
 */
export type ItemCounts = {
    /**
     * The movie count.
     */
    MovieCount?: number;
    /**
     * The series count.
     */
    SeriesCount?: number;
    /**
     * The episode count.
     */
    EpisodeCount?: number;
    /**
     * The game count.
     */
    GameCount?: number;
    ArtistCount?: number;
    ProgramCount?: number;
    /**
     * The game system count.
     */
    GameSystemCount?: number;
    /**
     * The trailer count.
     */
    TrailerCount?: number;
    /**
     * The song count.
     */
    SongCount?: number;
    /**
     * The album count.
     */
    AlbumCount?: number;
    /**
     * The music video count.
     */
    MusicVideoCount?: number;
    /**
     * The box set count.
     */
    BoxSetCount?: number;
    /**
     * The book count.
     */
    BookCount?: number;
    ItemCount?: number;
};

export type PersistenceIntroDebugInfo = {
    Id?: number;
    Path?: string;
    Start?: number;
    End?: number;
};

export type LibraryOptionsResult = {
    MetadataSavers?: Array<LibraryOptionInfo>;
    MetadataReaders?: Array<LibraryOptionInfo>;
    SubtitleFetchers?: Array<LibraryOptionInfo>;
    LyricsFetchers?: Array<LibraryOptionInfo>;
    TypeOptions?: Array<LibraryTypeOptions>;
    DefaultLibraryOptions?: LibraryOptions;
};

export type LibraryOptionInfo = {
    Name?: string;
    SetupUrl?: string;
    DefaultEnabled?: boolean;
    Features?: Array<MetadataFeatures>;
};

export type MetadataFeatures = 'Collections' | 'Adult' | 'RequiredSetup';

export type LibraryTypeOptions = {
    Type?: string;
    MetadataFetchers?: Array<LibraryOptionInfo>;
    ImageFetchers?: Array<LibraryOptionInfo>;
    SupportedImageTypes?: Array<ImageType>;
    DefaultImageOptions?: Array<ImageOption>;
};

export type ImageOption = {
    Type?: ImageType;
    /**
     * The limit.
     */
    Limit?: number;
    /**
     * The minimum width.
     */
    MinWidth?: number;
};

export type LibraryOptions = {
    EnableArchiveMediaFiles?: boolean;
    EnablePhotos?: boolean;
    EnableRealtimeMonitor?: boolean;
    EnableMarkerDetection?: boolean;
    EnableMarkerDetectionDuringLibraryScan?: boolean;
    IntroDetectionFingerprintLength?: number;
    EnableChapterImageExtraction?: boolean;
    ExtractChapterImagesDuringLibraryScan?: boolean;
    DownloadImagesInAdvance?: boolean;
    CacheImages?: boolean;
    ExcludeFromSearch?: boolean;
    EnablePlexIgnore?: boolean;
    PathInfos?: Array<MediaPathInfo>;
    IgnoreHiddenFiles?: boolean;
    IgnoreFileExtensions?: Array<string>;
    SaveLocalMetadata?: boolean;
    SaveMetadataHidden?: boolean;
    SaveLocalThumbnailSets?: boolean;
    ImportPlaylists?: boolean;
    EnableAutomaticSeriesGrouping?: boolean;
    ShareEmbeddedMusicAlbumImages?: boolean;
    EnableEmbeddedTitles?: boolean;
    EnableAudioResume?: boolean;
    AutoGenerateChapters?: boolean;
    MergeTopLevelFolders?: boolean;
    AutoGenerateChapterIntervalMinutes?: number;
    AutomaticRefreshIntervalDays?: number;
    PlaceholderMetadataRefreshIntervalDays?: number;
    /**
     * The preferred metadata language.
     */
    PreferredMetadataLanguage?: string;
    PreferredImageLanguage?: string;
    ContentType?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataSavers?: Array<string>;
    DisabledLocalMetadataReaders?: Array<string>;
    LocalMetadataReaderOrder?: Array<string>;
    DisabledLyricsFetchers?: Array<string>;
    SaveLyricsWithMedia?: boolean;
    LyricsDownloadMaxAgeDays?: number;
    LyricsFetcherOrder?: Array<string>;
    LyricsDownloadLanguages?: Array<string>;
    DisabledSubtitleFetchers?: Array<string>;
    SubtitleFetcherOrder?: Array<string>;
    SkipSubtitlesIfEmbeddedSubtitlesPresent?: boolean;
    SkipSubtitlesIfAudioTrackMatches?: boolean;
    SubtitleDownloadLanguages?: Array<string>;
    SubtitleDownloadMaxAgeDays?: number;
    RequirePerfectSubtitleMatch?: boolean;
    SaveSubtitlesWithMedia?: boolean;
    ForcedSubtitlesOnly?: boolean;
    HearingImpairedSubtitlesOnly?: boolean;
    TypeOptions?: Array<TypeOptions>;
    CollapseSingleItemFolders?: boolean;
    EnableAdultMetadata?: boolean;
    ImportCollections?: boolean;
    EnableMultiVersionByFiles?: boolean;
    EnableMultiVersionByMetadata?: boolean;
    EnableMultiPartItems?: boolean;
    MinCollectionItems?: number;
    MusicFolderStructure?: string;
    /**
     * The minimum percentage of an item that must be played in order for playstate to be updated.
     */
    MinResumePct?: number;
    /**
     * The maximum percentage of an item that can be played while still saving playstate. If this percentage is crossed playstate will be reset to the beginning and the item will be marked watched.
     */
    MaxResumePct?: number;
    /**
     * The minimum duration that an item must have in order to be eligible for playstate updates..
     */
    MinResumeDurationSeconds?: number;
    ThumbnailImagesIntervalSeconds?: number;
    SampleIgnoreSize?: number;
};

export type MediaPathInfo = {
    Path?: string;
    NetworkPath?: string;
    Username?: string;
    Password?: string;
};

export type TypeOptions = {
    Type?: string;
    MetadataFetchers?: Array<string>;
    MetadataFetcherOrder?: Array<string>;
    ImageFetchers?: Array<string>;
    ImageFetcherOrder?: Array<string>;
    ImageOptions?: Array<ImageOption>;
};

export type LibraryMediaFolder = {
    Name?: string;
    Id?: string;
    Guid?: string;
    SubFolders?: Array<LibrarySubFolder>;
    IsUserAccessConfigurable?: boolean;
};

export type LibrarySubFolder = {
    Name?: string;
    Id?: string;
    Path?: string;
    IsUserAccessConfigurable?: boolean;
};

export type LibraryAddVirtualFolder = {
    Name?: string;
    CollectionType?: string;
    RefreshLibrary?: boolean;
    Paths?: Array<string>;
    LibraryOptions?: LibraryOptions;
};

export type LiveStreamRequest = {
    OpenToken?: string;
    UserId?: string;
    PlaySessionId?: string;
    MaxStreamingBitrate?: number | null;
    StartTimeTicks?: number | null;
    AudioStreamIndex?: number | null;
    SubtitleStreamIndex?: number | null;
    MaxAudioChannels?: number | null;
    ItemId?: number;
    DeviceProfile?: DeviceProfile;
    EnableDirectPlay?: boolean;
    EnableDirectStream?: boolean;
    EnableTranscoding?: boolean;
    AllowVideoStreamCopy?: boolean;
    AllowInterlacedVideoStreamCopy?: boolean;
    AllowAudioStreamCopy?: boolean;
};

export type DeviceProfile = {
    /**
     * The name.
     */
    Name?: string;
    Id?: string;
    SupportedMediaTypes?: string;
    MaxStreamingBitrate?: number | null;
    MusicStreamingTranscodingBitrate?: number | null;
    MaxStaticMusicBitrate?: number | null;
    DeclaredFeatures?: Array<string>;
    /**
     * The direct play profiles.
     */
    DirectPlayProfiles?: Array<DirectPlayProfile>;
    /**
     * The transcoding profiles.
     */
    TranscodingProfiles?: Array<TranscodingProfile>;
    ContainerProfiles?: Array<ContainerProfile>;
    CodecProfiles?: Array<CodecProfile>;
    ResponseProfiles?: Array<ResponseProfile>;
    SubtitleProfiles?: Array<SubtitleProfile>;
};

export type LiveStreamResponse = {
    MediaSource?: MediaSourceInfo;
};

export type ApiSetChannelMapping = {
    TunerChannelId?: string;
    ProviderChannelId?: string;
};

export type LiveTvListingsProviderInfo = {
    Name?: string;
    SetupUrl?: string;
    Id?: string;
    Type?: string;
    Username?: string;
    Password?: string;
    ListingsId?: string;
    ZipCode?: string;
    Country?: string;
    Path?: string;
    EnabledTuners?: Array<string>;
    EnableAllTuners?: boolean;
    NewsCategories?: Array<string>;
    SportsCategories?: Array<string>;
    KidsCategories?: Array<string>;
    MovieCategories?: Array<string>;
    ChannelMappings?: Array<NameValuePair>;
    TvgShiftTicks?: number;
    MoviePrefix?: string;
    PreferredLanguage?: string;
    UserAgent?: string;
    DataVersion?: string;
};

export type LiveTvTunerHostInfo = {
    Id?: string;
    Url?: string;
    Type?: string;
    DeviceId?: string;
    FriendlyName?: string;
    SetupUrl?: string;
    ImportFavoritesOnly?: boolean;
    PreferEpgChannelImages?: boolean;
    PreferEpgChannelNumbers?: boolean;
    AllowHWTranscoding?: boolean;
    AllowMappingByNumber?: boolean;
    ImportGuideData?: boolean;
    Source?: string;
    TunerCount?: number;
    UserAgent?: string;
    Referrer?: string;
    ProviderOptions?: string;
    DataVersion?: number;
};

export type LiveTvLiveTvInfo = {
    /**
     * A value indicating whether this instance is enabled.
     */
    IsEnabled?: boolean;
    /**
     * The enabled users.
     */
    EnabledUsers?: Array<string>;
};

/**
 * Enum ChannelType
 *
 */
export type LiveTvChannelType = 'TV' | 'Radio';

export type QueryResultApiEpgRow = {
    Items?: Array<ApiEpgRow>;
    TotalRecordCount?: number;
};

export type ApiEpgRow = {
    Channel?: BaseItemDto;
    Programs?: Array<BaseItemDto>;
};

export type ApiBaseItemsRequest = {
    IsSpecialEpisode?: boolean | null;
    Is4K?: boolean | null;
    MinDateCreated?: string | null;
    MaxDateCreated?: string | null;
    EnableTotalRecordCount?: boolean;
    MatchAnyWord?: boolean;
    IsDuplicate?: boolean | null;
    Name?: string;
    RecordingKeyword?: string;
    RecordingKeywordType?: LiveTvKeywordType;
    RandomSeed?: number;
    GenreIds?: string;
    CollectionIds?: string;
    TagIds?: string;
    ExcludeTagIds?: string;
    ItemPersonTypes?: Array<PersonType>;
    ExcludeArtistIds?: string;
    AlbumArtistIds?: string;
    ComposerArtistIds?: string;
    ContributingArtistIds?: string;
    AlbumIds?: string;
    OuterIds?: string;
    ListItemIds?: string;
    AudioLanguages?: string;
    SubtitleLanguages?: string;
    CanEditItems?: boolean | null;
    GroupItemsInto?: LibraryItemLinkType;
    IsStandaloneSpecial?: boolean | null;
    MinWidth?: number | null;
    MinHeight?: number | null;
    MaxWidth?: number | null;
    MaxHeight?: number | null;
    GroupProgramsBySeries?: boolean;
    AirDays?: Array<DayOfWeek>;
    IsAiring?: boolean | null;
    HasAired?: boolean | null;
    CollectionTypes?: string;
    ExcludeSources?: Array<string>;
};

export type LiveTvKeywordType = 'Name' | 'EpisodeTitle' | 'Overview' | 'Actor' | 'Director';

export type LibraryItemLinkType = 'Artists' | 'AlbumArtists' | 'Genres' | 'Studios' | 'Tags' | 'Composers' | 'Collections' | 'Albums' | 'CollectionFolders' | 'LiveTVSeries' | 'GameSystems';

export type LiveTvRecordingStatus = 'New' | 'InProgress' | 'Completed' | 'Cancelled' | 'ConflictedOk' | 'ConflictedNotOk' | 'Error';

export type QueryResultLiveTvTimerInfoDto = {
    Items?: Array<LiveTvTimerInfoDto>;
    TotalRecordCount?: number;
};

export type LiveTvTimerInfoDto = {
    Status?: LiveTvRecordingStatus;
    /**
     * The series timer identifier.
     */
    SeriesTimerId?: string;
    /**
     * The run time ticks.
     */
    RunTimeTicks?: number | null;
    ProgramInfo?: BaseItemDto;
    TimerType?: LiveTvTimerType;
    /**
     * Id of the recording.
     */
    Id?: string;
    Type?: string;
    /**
     * The server identifier.
     */
    ServerId?: string;
    /**
     * ChannelId of the recording.
     */
    ChannelId?: string;
    /**
     * ChannelName of the recording.
     */
    ChannelName?: string;
    ChannelNumber?: string;
    ChannelPrimaryImageTag?: string;
    /**
     * The program identifier.
     */
    ProgramId?: string;
    /**
     * Name of the recording.
     */
    Name?: string;
    /**
     * Description of the recording.
     */
    Overview?: string;
    ParentFolderId?: string;
    /**
     * The start date of the recording, in UTC.
     */
    StartDate?: string;
    /**
     * The end date of the recording, in UTC.
     */
    EndDate?: string;
    /**
     * The priority.
     */
    Priority?: number;
    /**
     * The pre padding seconds.
     */
    PrePaddingSeconds?: number;
    /**
     * The post padding seconds.
     */
    PostPaddingSeconds?: number;
    /**
     * A value indicating whether this instance is pre padding required.
     */
    IsPrePaddingRequired?: boolean;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     */
    ParentBackdropItemId?: string;
    /**
     * The parent backdrop image tags.
     */
    ParentBackdropImageTags?: Array<string>;
    /**
     * A value indicating whether this instance is post padding required.
     */
    IsPostPaddingRequired?: boolean;
    KeepUntil?: LiveTvKeepUntil;
};

export type LiveTvKeepUntil = 'UntilDeleted' | 'UntilSpaceNeeded' | 'UntilWatched' | 'UntilDate';

export type QueryResultLiveTvSeriesTimerInfoDto = {
    Items?: Array<LiveTvSeriesTimerInfoDto>;
    TotalRecordCount?: number;
};

/**
 * Class SeriesTimerInfoDto.
 *
 */
export type LiveTvSeriesTimerInfoDto = {
    /**
     * A value indicating whether \[record any time\].
     */
    RecordAnyTime?: boolean;
    SkipEpisodesInLibrary?: boolean;
    MatchExistingItemsWithAnyLibrary?: boolean;
    /**
     * A value indicating whether \[record any channel\].
     */
    RecordAnyChannel?: boolean;
    KeepUpTo?: number;
    MaxRecordingSeconds?: number;
    /**
     * A value indicating whether \[record new only\].
     */
    RecordNewOnly?: boolean;
    ChannelIds?: Array<string>;
    /**
     * The days.
     */
    Days?: Array<DayOfWeek>;
    /**
     * The image tags.
     */
    ImageTags?: {
        [key: string]: string;
    };
    /**
     * The parent thumb item id.
     */
    ParentThumbItemId?: string;
    /**
     * The parent thumb image tag.
     */
    ParentThumbImageTag?: string;
    /**
     * The parent primary image item identifier.
     */
    ParentPrimaryImageItemId?: string;
    /**
     * The parent primary image tag.
     */
    ParentPrimaryImageTag?: string;
    SeriesId?: string;
    Keywords?: Array<LiveTvKeywordInfo>;
    TimerType?: LiveTvTimerType;
    /**
     * Id of the recording.
     */
    Id?: string;
    Type?: string;
    /**
     * The server identifier.
     */
    ServerId?: string;
    /**
     * ChannelId of the recording.
     */
    ChannelId?: string;
    /**
     * ChannelName of the recording.
     */
    ChannelName?: string;
    ChannelNumber?: string;
    ChannelPrimaryImageTag?: string;
    /**
     * The program identifier.
     */
    ProgramId?: string;
    /**
     * Name of the recording.
     */
    Name?: string;
    /**
     * Description of the recording.
     */
    Overview?: string;
    ParentFolderId?: string;
    /**
     * The start date of the recording, in UTC.
     */
    StartDate?: string;
    /**
     * The end date of the recording, in UTC.
     */
    EndDate?: string;
    /**
     * The priority.
     */
    Priority?: number;
    /**
     * The pre padding seconds.
     */
    PrePaddingSeconds?: number;
    /**
     * The post padding seconds.
     */
    PostPaddingSeconds?: number;
    /**
     * A value indicating whether this instance is pre padding required.
     */
    IsPrePaddingRequired?: boolean;
    /**
     * If the item does not have any backdrops, this will hold the Id of the Parent that has one.
     */
    ParentBackdropItemId?: string;
    /**
     * The parent backdrop image tags.
     */
    ParentBackdropImageTags?: Array<string>;
    /**
     * A value indicating whether this instance is post padding required.
     */
    IsPostPaddingRequired?: boolean;
    KeepUntil?: LiveTvKeepUntil;
};

export type LiveTvKeywordInfo = {
    KeywordType?: LiveTvKeywordType;
    Keyword?: string;
};

export type LiveTvSeriesTimerInfo = {
    /**
     * Id of the recording.
     */
    Id?: string;
    /**
     * ChannelId of the recording.
     */
    ChannelId?: string;
    ChannelIds?: Array<string>;
    ParentFolderId?: number;
    /**
     * The program identifier.
     */
    ProgramId?: string;
    /**
     * Name of the recording.
     */
    Name?: string;
    ServiceName?: string;
    /**
     * Description of the recording.
     */
    Overview?: string;
    /**
     * The start date of the recording, in UTC.
     */
    StartDate?: string;
    /**
     * The end date of the recording, in UTC.
     */
    EndDate?: string;
    /**
     * A value indicating whether \[record any time\].
     */
    RecordAnyTime?: boolean;
    KeepUpTo?: number;
    KeepUntil?: LiveTvKeepUntil;
    SkipEpisodesInLibrary?: boolean;
    MatchExistingItemsWithAnyLibrary?: boolean;
    /**
     * A value indicating whether \[record new only\].
     */
    RecordNewOnly?: boolean;
    /**
     * The days.
     */
    Days?: Array<DayOfWeek>;
    /**
     * The priority.
     */
    Priority?: number;
    /**
     * The pre padding seconds.
     */
    PrePaddingSeconds?: number;
    /**
     * The post padding seconds.
     */
    PostPaddingSeconds?: number;
    /**
     * A value indicating whether this instance is pre padding required.
     */
    IsPrePaddingRequired?: boolean;
    /**
     * A value indicating whether this instance is post padding required.
     */
    IsPostPaddingRequired?: boolean;
    /**
     * The series identifier.
     */
    SeriesId?: string;
    ProviderIds?: ProviderIdDictionary;
    MaxRecordingSeconds?: number;
    Keywords?: Array<LiveTvKeywordInfo>;
    TimerType?: LiveTvTimerType;
};

export type LiveTvGuideInfo = {
    /**
     * The start date.
     */
    StartDate?: string;
    /**
     * The end date.
     */
    EndDate?: string;
};

export type ApiAvailableRecordingOptions = {
    RecordingFolders?: Array<ApiNameIdDescriptionPair>;
    MovieRecordingFolders?: Array<ApiNameIdDescriptionPair>;
    SeriesRecordingFolders?: Array<ApiNameIdDescriptionPair>;
};

export type ApiNameIdDescriptionPair = {
    ShortOverview?: string;
    /**
     * The name.
     */
    Name?: string;
    /**
     * The identifier.
     */
    Id?: string;
};

/**
 * Class ParentalRating
 *
 */
export type ParentalRating = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The value.
     */
    Value?: number;
};

export type GlobalizationLocalizatonOption = {
    Name?: string;
    Value?: string;
};

/**
 * Class CountryInfo
 *
 */
export type GlobalizationCountryInfo = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The display name.
     */
    DisplayName?: string;
    /**
     * The English name.
     */
    EnglishName?: string;
    /**
     * The name of the two letter ISO region.
     */
    TwoLetterISORegionName?: string;
    /**
     * The name of the three letter ISO region.
     */
    ThreeLetterISORegionName?: string;
};

/**
 * Class CultureDto
 *
 */
export type GlobalizationCultureDto = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The display name.
     */
    DisplayName?: string;
    /**
     * The name of the two letter ISO language.
     */
    TwoLetterISOLanguageName?: string;
    /**
     * The name of the three letter ISO language.
     */
    ThreeLetterISOLanguageName?: string;
    ThreeLetterISOLanguageNames?: Array<string>;
    TwoLetterISOLanguageNames?: Array<string>;
};

export type RecommendationDto = {
    Items?: Array<BaseItemDto>;
    RecommendationType?: RecommendationType;
    BaselineItemName?: string;
    CategoryId?: number;
};

export type RecommendationType = 'SimilarToRecentlyPlayed' | 'SimilarToLikedItem' | 'HasDirectorFromRecentlyPlayed' | 'HasActorFromRecentlyPlayed' | 'HasLikedDirector' | 'HasLikedActor';

export type NotificationCategoryInfo = {
    Name?: string;
    Id?: string;
    Events?: Array<NotificationTypeInfo>;
};

export type NotificationTypeInfo = {
    Name?: string;
    Id?: string;
    CategoryName?: string;
    CategoryId?: string;
};

export type ApiAddAdminNotification = {
    DisplayDateTime?: boolean;
};

/**
 * Class PlaybackStartInfo.
 *
 */
export type PlaybackStartInfo = {
    /**
     * A value indicating whether this instance can seek.
     */
    CanSeek?: boolean;
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    /**
     * The session id.
     */
    SessionId?: string;
    /**
     * The index of the audio stream.
     */
    AudioStreamIndex?: number | null;
    /**
     * The index of the subtitle stream.
     */
    SubtitleStreamIndex?: number | null;
    /**
     * A value indicating whether this instance is paused.
     */
    IsPaused?: boolean;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    /**
     * A value indicating whether this instance is muted.
     */
    IsMuted?: boolean;
    RunTimeTicks?: number | null;
    PlaybackStartTimeTicks?: number | null;
    /**
     * The volume level.
     */
    VolumeLevel?: number | null;
    Brightness?: number | null;
    AspectRatio?: string;
    EventName?: ProgressEvent;
    PlayMethod?: PlayMethod;
    RepeatMode?: RepeatMode;
    SleepTimerMode?: SleepTimerMode;
    SleepTimerEndTime?: string | null;
    Shuffle?: boolean;
    SubtitleOffset?: number;
    PlaybackRate?: number;
    PlaylistItemIds?: Array<string>;
    /**
     * The play session identifier.
     */
    PlaySessionId?: string;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * The live stream identifier.
     */
    LiveStreamId?: string;
    /**
     * The media version identifier.
     */
    MediaSourceId?: string;
    Item?: BaseItemDto;
    /**
     * The position ticks.
     */
    PositionTicks?: number | null;
};

export type QueueItem = {
    Id?: number;
    PlaylistItemId?: string;
};

export type ProgressEvent = 'TimeUpdate' | 'Pause' | 'Unpause' | 'VolumeChange' | 'RepeatModeChange' | 'AudioTrackChange' | 'SubtitleTrackChange' | 'PlaylistItemMove' | 'PlaylistItemRemove' | 'PlaylistItemAdd' | 'QualityChange' | 'StateChange' | 'SubtitleOffsetChange' | 'PlaybackRateChange' | 'ShuffleChange' | 'SleepTimerChange';

export type SyncTarget = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The identifier.
     */
    Id?: string;
};

export type QueryResultSyncJob = {
    Items?: Array<SyncJob>;
    TotalRecordCount?: number;
};

export type SyncJob = {
    /**
     * The identifier.
     */
    Id?: number;
    /**
     * The device identifier.
     */
    TargetId?: string;
    InternalTargetId?: number;
    /**
     * The name of the target.
     */
    TargetName?: string;
    /**
     * The quality.
     */
    Quality?: string;
    /**
     * The bitrate.
     */
    Bitrate?: number | null;
    Container?: string;
    VideoCodec?: string;
    AudioCodec?: string;
    /**
     * The profile.
     */
    Profile?: string;
    Category?: SyncCategory;
    /**
     * The parent identifier.
     */
    ParentId?: number;
    /**
     * The current progress.
     */
    Progress?: number;
    /**
     * The name.
     */
    Name?: string;
    Status?: SyncJobStatus;
    /**
     * The user identifier.
     */
    UserId?: number;
    /**
     * A value indicating whether \[unwatched only\].
     */
    UnwatchedOnly?: boolean;
    /**
     * A value indicating whether \[synchronize new content\].
     */
    SyncNewContent?: boolean;
    /**
     * The item limit.
     */
    ItemLimit?: number | null;
    /**
     * The requested item ids.
     */
    RequestedItemIds?: Array<number>;
    ItemId?: number;
    /**
     * The date created.
     */
    DateCreated?: string;
    /**
     * The date last modified.
     */
    DateLastModified?: string;
    /**
     * The item count.
     */
    ItemCount?: number;
    ParentName?: string;
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
};

export type SyncCategory = 'Latest' | 'NextUp' | 'Resume';

export type SyncJobStatus = 'Queued' | 'Converting' | 'ReadyToTransfer' | 'Transferring' | 'Completed' | 'CompletedWithError' | 'Failed';

export type QueryResultSyncJobItem = {
    Items?: Array<SyncJobItem>;
    TotalRecordCount?: number;
};

export type SyncJobItem = {
    Id?: number;
    JobId?: number;
    ItemId?: number;
    ItemName?: string;
    MediaSourceId?: string;
    MediaSource?: MediaSourceInfo;
    TargetId?: string;
    InternalTargetId?: number;
    OutputPath?: string;
    Status?: SyncJobItemStatus;
    Progress?: number | null;
    DateCreated?: string;
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
    TemporaryPath?: string;
    AdditionalFiles?: Array<ItemFileInfo>;
};

export type ItemFileInfo = {
    Type?: ItemFileType;
    Name?: string;
    Path?: string;
    ImageType?: ImageType;
    Index?: number;
};

export type ItemFileType = 'Media' | 'Image' | 'Subtitles';

export type SyncJobRequest = {
    TargetId?: string;
    ItemIds?: Array<string>;
    Category?: SyncCategory;
    ParentId?: string;
    Quality?: string;
    Profile?: string;
    Container?: string;
    VideoCodec?: string;
    AudioCodec?: string;
    Name?: string;
    UserId?: string;
    UnwatchedOnly?: boolean;
    SyncNewContent?: boolean;
    ItemLimit?: number | null;
    Bitrate?: number | null;
    Downloaded?: boolean;
};

export type SyncJobCreationResult = {
    Job?: SyncJob;
    JobItems?: Array<SyncJobItem>;
};

export type SyncDialogOptions = {
    Targets?: Array<SyncTarget>;
    Options?: Array<SyncJobOption>;
    QualityOptions?: Array<SyncQualityOption>;
    ProfileOptions?: Array<SyncProfileOption>;
};

export type SyncJobOption = 'Name' | 'Quality' | 'UnwatchedOnly' | 'SyncNewContent' | 'ItemLimit' | 'Profile';

export type SyncQualityOption = {
    Name?: string;
    Description?: string;
    Id?: string;
    IsDefault?: boolean;
    IsOriginalQuality?: boolean;
};

export type SyncProfileOption = {
    Name?: string;
    Description?: string;
    Id?: string;
    IsDefault?: boolean;
    EnableQualityOptions?: boolean;
};

export type UserAction = {
    Id?: string;
    ServerId?: string;
    UserId?: string;
    ItemId?: string;
    Type?: UserActionType;
    Date?: string;
    PositionTicks?: number | null;
    Played?: boolean | null;
    IsFavorite?: boolean | null;
};

export type UserActionType = 'PlayedItem' | 'MarkPlayed' | 'MarkFavorite';

export type SyncDataRequest = {
    LocalItemIds?: Array<string>;
    InternalTargetIds?: Array<number>;
};

export type SyncDataResponse = {
    ItemIdsToRemove?: Array<string>;
};

/**
 * Represents the server configuration.
 *
 */
export type ServerConfiguration = {
    /**
     * A value indicating whether \[enable u pn p\].
     */
    EnableUPnP?: boolean;
    /**
     * The public mapped port.
     */
    PublicPort?: number;
    /**
     * The public HTTPS port.
     */
    PublicHttpsPort?: number;
    /**
     * The HTTP server port number.
     */
    HttpServerPortNumber?: number;
    /**
     * The HTTPS server port number.
     */
    HttpsPortNumber?: number;
    /**
     * A value indicating whether \[use HTTPS\].
     */
    EnableHttps?: boolean;
    /**
     * The value pointing to the file system where the ssl certiifcate is located..
     */
    CertificatePath?: string;
    CertificatePassword?: string;
    /**
     * A value indicating whether this instance is port authorized.
     */
    IsPortAuthorized?: boolean;
    AutoRunWebApp?: boolean;
    EnableRemoteAccess?: boolean;
    LogAllQueryTimes?: boolean;
    DisableOutgoingIPv6?: boolean;
    /**
     * A value indicating whether \[enable case sensitive item ids\].
     */
    EnableCaseSensitiveItemIds?: boolean;
    /**
     * The metadata path.
     */
    MetadataPath?: string;
    MetadataNetworkPath?: string;
    /**
     * The preferred metadata language.
     */
    PreferredMetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    /**
     * Words to be removed from strings to create a sort name
     */
    SortRemoveWords?: Array<string>;
    /**
     * The delay in seconds that we will wait after a file system change to try and discover what has been added\/removed Some delay is necessary with some items because their creation is not atomic.  It involves the creation of several different directories and files.
     */
    LibraryMonitorDelaySeconds?: number;
    /**
     * A value indicating whether \[enable dashboard response caching\]. Allows potential contributors without visual studio to modify production dashboard code and test changes.
     */
    EnableDashboardResponseCaching?: boolean;
    /**
     * Allows the dashboard to be served from a custom path.
     */
    DashboardSourcePath?: string;
    ImageSavingConvention?: ImageSavingConvention;
    EnableAutomaticRestart?: boolean;
    ServerName?: string;
    PreferredDetectedRemoteAddressFamily?: NetSocketsAddressFamily;
    WanDdns?: string;
    UICulture?: string;
    RemoteClientBitrateLimit?: number;
    LocalNetworkSubnets?: Array<string>;
    LocalNetworkAddresses?: Array<string>;
    EnableExternalContentInSuggestions?: boolean;
    RequireHttps?: boolean;
    IsBehindProxy?: boolean;
    RemoteIPFilter?: Array<string>;
    IsRemoteIPFilterBlacklist?: boolean;
    ImageExtractionTimeoutMs?: number;
    PathSubstitutions?: Array<PathSubstitution>;
    UninstalledPlugins?: Array<string>;
    CollapseVideoFolders?: boolean;
    EnableOriginalTrackTitles?: boolean;
    VacuumDatabaseOnStartup?: boolean;
    SimultaneousStreamLimit?: number;
    DatabaseCacheSizeMB?: number;
    EnableSqLiteMmio?: boolean;
    PlaylistsUpgradedToM3U?: boolean;
    ImageExtractorUpgraded1?: boolean;
    EnablePeopleLetterSubFolders?: boolean;
    OptimizeDatabaseOnShutdown?: boolean;
    DatabaseAnalysisLimit?: number;
    MaxLibraryDbConnections?: number;
    MaxAuthDbConnections?: number;
    MaxOtherDbConnections?: number;
    DisableAsyncIO?: boolean;
    MigratedToUserItemShares8?: boolean;
    MigratedLibraryOptionsToDb?: boolean;
    AllowLegacyLocalNetworkPassword?: boolean;
    EnableSavedMetadataForPeople?: boolean;
    TvChannelsRefreshed?: boolean;
    ProxyHeaderMode?: ProxyHeaderMode;
    IsInMaintenanceMode?: boolean;
    MaintenanceModeMessage?: string;
    /**
     * A value indicating whether \[enable debug level logging\].
     */
    EnableDebugLevelLogging?: boolean;
    RevertDebugLogging?: string;
    /**
     * Enable automatically and silently updating of the application
     */
    EnableAutoUpdate?: boolean;
    /**
     * The number of days we should retain log files
     */
    LogFileRetentionDays?: number;
    /**
     * A value indicating whether \[run at startup\].
     */
    RunAtStartup?: boolean;
    /**
     * A value indicating whether this instance is first run.
     */
    IsStartupWizardCompleted?: boolean;
    /**
     * The cache path.
     */
    CachePath?: string;
};

export type ImageSavingConvention = 'Legacy' | 'Compatible';

export type NetSocketsAddressFamily = 'Unspecified' | 'Unix' | 'InterNetwork' | 'ImpLink' | 'Pup' | 'Chaos' | 'NS' | 'Ipx' | 'Iso' | 'Osi' | 'Ecma' | 'DataKit' | 'Ccitt' | 'Sna' | 'DecNet' | 'DataLink' | 'Lat' | 'HyperChannel' | 'AppleTalk' | 'NetBios' | 'VoiceView' | 'FireFox' | 'Banyan' | 'Atm' | 'InterNetworkV6' | 'Cluster' | 'Ieee12844' | 'Irda' | 'NetworkDesigners' | 'Max' | 'Packet' | 'ControllerAreaNetwork' | 'Unknown';

export type PathSubstitution = {
    From?: string;
    To?: string;
};

export type ProxyHeaderMode = 'None' | 'LanAddressesOnly' | 'RemoteAddressesOnly' | 'AllAddresses';

export type WakeOnLanInfo = {
    MacAddress?: string;
    BroadcastAddress?: string;
    Port?: number;
};

/**
 * Class SystemInfo
 *
 */
export type SystemInfo = {
    SystemUpdateLevel?: PackageVersionClass;
    /**
     * The display name of the operating system.
     */
    OperatingSystemDisplayName?: string;
    PackageName?: string;
    /**
     * A value indicating whether this instance has pending restart.
     */
    HasPendingRestart?: boolean;
    IsShuttingDown?: boolean;
    HasImageEnhancers?: boolean;
    /**
     * The operating sytem.
     */
    OperatingSystem?: string;
    /**
     * A value indicating whether \[supports library monitor\].
     */
    SupportsLibraryMonitor?: boolean;
    SupportsLocalPortConfiguration?: boolean;
    SupportsWakeServer?: boolean;
    /**
     * The web socket port number.
     */
    WebSocketPortNumber?: number;
    /**
     * The completed installations.
     */
    CompletedInstallations?: Array<InstallationInfo>;
    /**
     * A value indicating whether this instance can self restart.
     */
    CanSelfRestart?: boolean;
    /**
     * A value indicating whether this instance can self update.
     */
    CanSelfUpdate?: boolean;
    CanLaunchWebBrowser?: boolean;
    /**
     * The program data path.
     */
    ProgramDataPath?: string;
    /**
     * The items by name path.
     */
    ItemsByNamePath?: string;
    /**
     * The cache path.
     */
    CachePath?: string;
    /**
     * The log path.
     */
    LogPath?: string;
    /**
     * The internal metadata path.
     */
    InternalMetadataPath?: string;
    /**
     * The transcoding temporary path.
     */
    TranscodingTempPath?: string;
    /**
     * The HTTP server port number.
     */
    HttpServerPortNumber?: number;
    /**
     * A value indicating whether \[enable HTTPS\].
     */
    SupportsHttps?: boolean;
    /**
     * The HTTPS server port number.
     */
    HttpsPortNumber?: number;
    /**
     * A value indicating whether this instance has update available.
     */
    HasUpdateAvailable?: boolean;
    /**
     * A value indicating whether \[supports automatic run at startup\].
     */
    SupportsAutoRunAtStartup?: boolean;
    HardwareAccelerationRequiresPremiere?: boolean;
    WakeOnLanInfo?: Array<WakeOnLanInfo>;
    IsInMaintenanceMode?: boolean;
    /**
     * The local address.
     */
    LocalAddress?: string;
    LocalAddresses?: Array<string>;
    /**
     * The wan address.
     */
    WanAddress?: string;
    RemoteAddresses?: Array<string>;
    /**
     * The name of the server.
     */
    ServerName?: string;
    /**
     * The version.
     */
    Version?: string;
    /**
     * The id.
     */
    Id?: string;
};

/**
 * Class InstallationInfo
 *
 */
export type InstallationInfo = {
    /**
     * The id.
     */
    Id?: string;
    /**
     * The name.
     */
    Name?: string;
    /**
     * The assembly guid.
     */
    AssemblyGuid?: string;
    /**
     * The version.
     */
    Version?: string;
    UpdateClass?: PackageVersionClass;
    /**
     * The percent complete.
     */
    PercentComplete?: number | null;
};

export type NetEndPointInfo = {
    IsLocal?: boolean;
    IsInNetwork?: boolean;
};

export type UiViewInfo = {
    ViewId?: string;
    PageId?: string;
    Caption?: string;
    SubCaption?: string;
    PluginId?: string;
    ViewType?: EnumsUiViewType;
    ShowDialogFullScreen?: boolean;
    IsInSequence?: boolean;
    RedirectViewUrl?: string;
    EditObjectContainer?: GenericEditIEditObjectContainer;
    Commands?: Array<UiCommand>;
    TabPageInfos?: Array<UiTabPageInfo>;
    IsPageChangeInfo?: boolean;
};

export type EnumsUiViewType = 'RegularPage' | 'Dialog' | 'Wizard';

export type GenericEditIEditObjectContainer = {
    Object?: {
        [key: string]: unknown;
    };
    DefaultObject?: {
        [key: string]: unknown;
    };
    TypeName?: string;
};

export type UiCommand = {
    CommandType?: EnumsUiCommandType;
    CommandId?: string;
    IsVisible?: boolean;
    IsEnabled?: boolean;
    Caption?: string;
    SetFocus?: boolean;
    ConfirmationPrompt?: string;
};

export type EnumsUiCommandType = 'Custom' | 'WizardCancel' | 'WizardBack' | 'WizardNext' | 'WizardFinish' | 'DialogCancel' | 'DialogOk' | 'PageSave' | 'PageBack' | 'WizardButton1' | 'WizardButton2' | 'WizardButton3';

export type UiTabPageInfo = {
    PageId?: string;
    DisplayName?: string;
    PluginId?: string;
    Href?: string;
    NavKey?: string;
    Index?: number;
};

export type RunUiCommand = {
    PageId?: string;
    CommandId?: string;
    Data?: string;
    ItemId?: string;
    ClientLocale?: string;
};

/**
 * Class UserDto
 *
 */
export type UserDto = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The server identifier.
     */
    ServerId?: string;
    /**
     * The name of the server. This is not used by the server and is for client\-side usage only.
     */
    ServerName?: string;
    Prefix?: string;
    /**
     * The name of the connect user.
     */
    ConnectUserName?: string;
    DateCreated?: string | null;
    ConnectLinkType?: ConnectUserLinkType;
    /**
     * The id.
     */
    Id?: string;
    /**
     * The primary image tag.
     */
    PrimaryImageTag?: string;
    /**
     * A value indicating whether this instance has password.
     */
    HasPassword?: boolean;
    /**
     * A value indicating whether this instance has configured password.
     */
    HasConfiguredPassword?: boolean;
    EnableAutoLogin?: boolean | null;
    /**
     * The last login date.
     */
    LastLoginDate?: string | null;
    /**
     * The last activity date.
     */
    LastActivityDate?: string | null;
    Configuration?: UserConfiguration;
    Policy?: UserPolicy;
    /**
     * The primary image aspect ratio.
     */
    PrimaryImageAspectRatio?: number | null;
    /**
     * @deprecated
     */
    HasConfiguredEasyPassword?: boolean;
    UserItemShareLevel?: UserItemShareLevel;
};

export type ConnectUserLinkType = 'LinkedUser' | 'Guest';

/**
 * Class UserConfiguration
 *
 */
export type UserConfiguration = {
    /**
     * The audio language preference.
     */
    AudioLanguagePreference?: string;
    /**
     * A value indicating whether \[play default audio track\].
     */
    PlayDefaultAudioTrack?: boolean;
    /**
     * The subtitle language preference.
     */
    SubtitleLanguagePreference?: string;
    ProfilePin?: string;
    DisplayMissingEpisodes?: boolean;
    SubtitleMode?: SubtitlePlaybackMode;
    OrderedViews?: Array<string>;
    LatestItemsExcludes?: Array<string>;
    MyMediaExcludes?: Array<string>;
    HidePlayedInLatest?: boolean;
    HidePlayedInMoreLikeThis?: boolean;
    HidePlayedInSuggestions?: boolean;
    RememberAudioSelections?: boolean;
    RememberSubtitleSelections?: boolean;
    EnableNextEpisodeAutoPlay?: boolean;
    ResumeRewindSeconds?: number;
    IntroSkipMode?: SegmentSkipMode;
    /**
     * @deprecated
     */
    EnableLocalPassword?: boolean;
};

export type SubtitlePlaybackMode = 'Default' | 'Always' | 'OnlyForced' | 'None' | 'Smart' | 'HearingImpaired';

export type SegmentSkipMode = 'ShowButton' | 'AutoSkip' | 'None';

export type UserPolicy = {
    /**
     * A value indicating whether this instance is administrator.
     */
    IsAdministrator?: boolean;
    /**
     * A value indicating whether this instance is hidden.
     */
    IsHidden?: boolean;
    IsHiddenRemotely?: boolean;
    IsHiddenFromUnusedDevices?: boolean;
    /**
     * A value indicating whether this instance is disabled.
     */
    IsDisabled?: boolean;
    LockedOutDate?: number;
    /**
     * The max parental rating.
     */
    MaxParentalRating?: number | null;
    AllowTagOrRating?: boolean;
    BlockedTags?: Array<string>;
    IsTagBlockingModeInclusive?: boolean;
    IncludeTags?: Array<string>;
    EnableUserPreferenceAccess?: boolean;
    AccessSchedules?: Array<AccessSchedule>;
    BlockUnratedItems?: Array<UnratedItem>;
    EnableRemoteControlOfOtherUsers?: boolean;
    EnableSharedDeviceControl?: boolean;
    EnableRemoteAccess?: boolean;
    EnableLiveTvManagement?: boolean;
    EnableLiveTvAccess?: boolean;
    EnableMediaPlayback?: boolean;
    EnableAudioPlaybackTranscoding?: boolean;
    EnableVideoPlaybackTranscoding?: boolean;
    EnablePlaybackRemuxing?: boolean;
    EnableContentDeletion?: boolean;
    RestrictedFeatures?: Array<string>;
    EnableContentDeletionFromFolders?: Array<string>;
    EnableContentDownloading?: boolean;
    EnableSubtitleDownloading?: boolean;
    EnableSubtitleManagement?: boolean;
    /**
     * A value indicating whether \[enable synchronize\].
     */
    EnableSyncTranscoding?: boolean;
    EnableMediaConversion?: boolean;
    EnabledChannels?: Array<string>;
    EnableAllChannels?: boolean;
    EnabledFolders?: Array<string>;
    EnableAllFolders?: boolean;
    InvalidLoginAttemptCount?: number;
    EnablePublicSharing?: boolean;
    RemoteClientBitrateLimit?: number;
    AuthenticationProviderId?: string;
    ExcludedSubFolders?: Array<string>;
    SimultaneousStreamLimit?: number;
    EnabledDevices?: Array<string>;
    EnableAllDevices?: boolean;
    AllowCameraUpload?: boolean;
    AllowSharingPersonalItems?: boolean;
};

export type AccessSchedule = {
    DayOfWeek?: DynamicDayOfWeek;
    /**
     * The start hour.
     */
    StartHour?: number;
    /**
     * The end hour.
     */
    EndHour?: number;
};

export type DynamicDayOfWeek = 'Sunday' | 'Monday' | 'Tuesday' | 'Wednesday' | 'Thursday' | 'Friday' | 'Saturday' | 'Everyday' | 'Weekday' | 'Weekend';

export type UnratedItem = 'Movie' | 'Trailer' | 'Series' | 'Music' | 'Game' | 'Book' | 'LiveTvChannel' | 'LiveTvProgram' | 'ChannelContent' | 'Other';

export type QueryResultUserDto = {
    Items?: Array<UserDto>;
    TotalRecordCount?: number;
};

export type AuthenticateUserByName = {
    Username?: string;
    Pw?: string;
};

export type AuthenticationAuthenticationResult = {
    User?: UserDto;
    SessionInfo?: SessionSessionInfo;
    /**
     * The authentication token.
     */
    AccessToken?: string;
    /**
     * The server identifier.
     */
    ServerId?: string;
};

export type CreateUserByName = {
    Name?: string;
    CopyFromUserId?: string;
    UserCopyOptions?: Array<LibraryUserCopyOptions>;
};

export type LibraryUserCopyOptions = 'UserPolicy' | 'UserConfiguration' | 'UserData';

export type ForgotPassword = {
    EnteredUsername?: string;
};

export type ForgotPasswordResult = {
    Action?: ForgotPasswordAction;
    /**
     * The pin file.
     */
    PinFile?: string;
    /**
     * The pin expiration date.
     */
    PinExpirationDate?: string | null;
};

export type ForgotPasswordAction = 'ContactAdmin' | 'PinCode';

export type ApiConfigurationPageInfo = {
    Name?: string;
    EnableInMainMenu?: boolean;
    EnableInUserMenu?: boolean;
    FeatureId?: string;
    MenuSection?: string;
    MenuIcon?: string;
    DisplayName?: string;
    ConfigurationPageType?: PluginsConfigurationPageType;
    PluginId?: string;
    Href?: string;
    NavMenuId?: string;
    Plugin?: CommonPluginsIPlugin;
    Translations?: Array<string>;
};

/**
 * Enum ConfigurationPageType
 *
 */
export type PluginsConfigurationPageType = 'PluginConfiguration' | 'None';

/**
 * Interface IPlugin
 *
 */
export type CommonPluginsIPlugin = {
    /**
     * The name of the plugin
     */
    Name?: string;
    /**
     * The description.
     */
    Description?: string;
    /**
     * The unique id.
     */
    Id?: string;
    Version?: Version;
    /**
     * The path to the assembly file
     */
    AssemblyFilePath?: string;
    /**
     * The full path to the data folder, where the plugin can store any miscellaneous files needed
     */
    DataFolderPath?: string;
};

export type Version = {
    Major?: number;
    Minor?: number;
    Build?: number;
    Revision?: number;
    MajorRevision?: number;
    MinorRevision?: number;
};

export type VideoCodecBase = {
    CodecDeviceInfo?: CommonInterfacesICodecDeviceInfo;
    CodecKind?: CodecKinds;
    MediaTypeName?: string;
    VideoMediaType?: VideoMediaTypes;
    MinWidth?: number | null;
    MaxWidth?: number | null;
    MinHeight?: number | null;
    MaxHeight?: number | null;
    WidthAlignment?: number | null;
    HeightAlignment?: number | null;
    MaxBitRate?: BitRate;
    SupportedColorFormats?: Array<ColorFormats>;
    SupportedColorFormatStrings?: Array<string>;
    ProfileAndLevelInformation?: Array<ProfileLevelInformation>;
    Id?: string;
    Direction?: CodecDirections;
    Name?: string;
    Description?: string;
    FrameworkCodec?: string;
    IsHardwareCodec?: boolean;
    SecondaryFramework?: SecondaryFrameworks;
    SecondaryFrameworkCodec?: string;
    MaxInstanceCount?: number | null;
    IsEnabledByDefault?: boolean;
    DefaultPriority?: number;
};

export type CommonInterfacesICodecDeviceInfo = {
    Capabilities?: CommonInterfacesICodecDeviceCapabilities;
    Adapter?: number;
    Name?: string;
    Desription?: string;
    Driver?: string;
    DriverVersion?: Version;
    ApiVersion?: Version;
    VendorId?: number;
    DeviceId?: number;
    DeviceIdentifier?: string;
    HardwareContextFramework?: SecondaryFrameworks;
    DevPath?: string;
    DrmNode?: string;
    VendorName?: string;
    DeviceName?: string;
};

export type CommonInterfacesICodecDeviceCapabilities = {
    SupportsHwUpload?: boolean;
    SupportsHwDownload?: boolean;
    SupportsStandaloneDeviceInit?: boolean;
    Supports10BitProcessing?: boolean;
    SupportsNativeToneMapping?: boolean;
};

/**
 * Enum defining secondary frameworks for encoding and decoding.
 *
 *
 * While most of these are hardware acceleration frameworks, this is not a necessity             (e.g. Android MediaCodec offers software codecs as well).
 *
 */
export type SecondaryFrameworks = 'Unknown' | 'None' | 'AmdAmf' | 'MediaCodec' | 'NvEncDec' | 'OpenMax' | 'QuickSync' | 'VaApi' | 'V4L2' | 'DxVa' | 'D3d11va' | 'VideoToolbox' | 'Mmal';

/**
 * Enum defining the kind of media a codec is processing.
 *
 */
export type CodecKinds = 'Audio' | 'Video' | 'SubTitles';

/**
 * Enum listing video media types.
 *
 *
 * The enum member names are matching exactly those that are used by ffmpeg. Exception: Items that are starting with a number are prefixed with an underscore here.
 *
 */
export type VideoMediaTypes = 'Unknown' | 'copy' | 'flv1' | 'h263' | 'h263p' | 'h264' | 'hevc' | 'mjpeg' | 'mpeg1video' | 'mpeg2video' | 'mpeg4' | 'msvideo1' | 'theora' | 'vc1image' | 'vc1' | 'vp8' | 'vp9' | 'wmv1' | 'wmv2' | 'wmv3' | '_012v' | '_4xm' | '_8bps' | 'a64_multi' | 'a64_multi5' | 'aasc' | 'aic' | 'alias_pix' | 'amv' | 'anm' | 'ansi' | 'apng' | 'asv1' | 'asv2' | 'aura' | 'aura2' | 'av1' | 'avrn' | 'avrp' | 'avs' | 'avui' | 'ayuv' | 'bethsoftvid' | 'bfi' | 'binkvideo' | 'bintext' | 'bitpacked' | 'bmp' | 'bmv_video' | 'brender_pix' | 'c93' | 'cavs' | 'cdgraphics' | 'cdxl' | 'cfhd' | 'cinepak' | 'clearvideo' | 'cljr' | 'cllc' | 'cmv' | 'cpia' | 'cscd' | 'cyuv' | 'daala' | 'dds' | 'dfa' | 'dirac' | 'dnxhd' | 'dpx' | 'dsicinvideo' | 'dvvideo' | 'dxa' | 'dxtory' | 'dxv' | 'escape124' | 'escape130' | 'exr' | 'ffv1' | 'ffvhuff' | 'fic' | 'fits' | 'flashsv' | 'flashsv2' | 'flic' | 'fmvc' | 'fraps' | 'frwu' | 'g2m' | 'gdv' | 'gif' | 'h261' | 'h263i' | 'hap' | 'hnm4video' | 'hq_hqa' | 'hqx' | 'huffyuv' | 'idcin' | 'idf' | 'iff_ilbm' | 'indeo2' | 'indeo3' | 'indeo4' | 'indeo5' | 'interplayvideo' | 'jpeg2000' | 'jpegls' | 'jv' | 'kgv1' | 'kmvc' | 'lagarith' | 'ljpeg' | 'loco' | 'm101' | 'mad' | 'magicyuv' | 'mdec' | 'mimic' | 'mjpegb' | 'mmvideo' | 'motionpixels' | 'msa1' | 'mscc' | 'msmpeg4v1' | 'msmpeg4v2' | 'msmpeg4v3' | 'msrle' | 'mss1' | 'mss2' | 'mszh' | 'mts2' | 'mvc1' | 'mvc2' | 'mxpeg' | 'nuv' | 'paf_video' | 'pam' | 'pbm' | 'pcx' | 'pgm' | 'pgmyuv' | 'pictor' | 'pixlet' | 'png' | 'ppm' | 'prores' | 'psd' | 'ptx' | 'qdraw' | 'qpeg' | 'qtrle' | 'r10k' | 'r210' | 'rawvideo' | 'rl2' | 'roq' | 'rpza' | 'rscc' | 'rv10' | 'rv20' | 'rv30' | 'rv40' | 'sanm' | 'scpr' | 'screenpresso' | 'sgi' | 'sgirle' | 'sheervideo' | 'smackvideo' | 'smc' | 'smvjpeg' | 'snow' | 'sp5x' | 'speedhq' | 'srgc' | 'sunrast' | 'svg' | 'svq1' | 'svq3' | 'targa' | 'targa_y216' | 'tdsc' | 'tgq' | 'tgv' | 'thp' | 'tiertexseqvideo' | 'tiff' | 'tmv' | 'tqi' | 'truemotion1' | 'truemotion2' | 'truemotion2rt' | 'tscc' | 'tscc2' | 'txd' | 'ulti' | 'utvideo' | 'v210' | 'v210x' | 'v308' | 'v408' | 'v410' | 'vb' | 'vble' | 'vcr1' | 'vixl' | 'vmdvideo' | 'vmnc' | 'vp3' | 'vp5' | 'vp6' | 'vp6a' | 'vp6f' | 'vp7' | 'webp' | 'wmv3image' | 'wnv1' | 'wrapped_avframe' | 'ws_vqa' | 'xan_wc3' | 'xan_wc4' | 'xbin' | 'xbm' | 'xface' | 'xpm' | 'xwd' | 'y41p' | 'ylc' | 'yop' | 'yuv4' | 'zerocodec' | 'zlib' | 'zmbv';

/**
 * A type for handling bit rates.
 *
 *
 * The purpose of this type is to avoid manual calculations and conversions in code,             unified handling and conversion as well as presentation through its various To\*\*\*String methods.
 *
 *
 * `System.IComparable`
 *
 *
 * `System.IEquatable`1`
 *
 */
export type BitRate = {
    bps?: number;
    kbps?: number;
    Mbps?: number;
};

/**
 * Enum listing color formats.
 *
 *
 * The enum member names are matching those that are used by ffmpeg. (execute 'ffmpeg \-pix\_fmts' to list them) Exception: Items that are starting with a number are prefixed with an underscore here. In ffmpeg code these are prefixed with 'AV\_PIX\_FMT\_' and all\-caps.
 *
 */
export type ColorFormats = 'Unknown' | 'yuv420p' | 'yuyv422' | 'rgb24' | 'bgr24' | 'yuv422p' | 'yuv444p' | 'yuv410p' | 'yuv411p' | 'gray' | 'monow' | 'monob' | 'pal8' | 'yuvj420p' | 'yuvj422p' | 'yuvj444p' | 'uyvy422' | 'uyyvyy411' | 'bgr8' | 'bgr4' | 'bgr4_byte' | 'rgb8' | 'rgb4' | 'rgb4_byte' | 'nv12' | 'nv21' | 'argb' | 'rgba' | 'abgr' | 'bgra' | 'gray16' | 'yuv440p' | 'yuvj440p' | 'yuva420p' | 'rgb48' | 'rgb565' | 'rgb555' | 'bgr565' | 'bgr555' | 'vaapi_moco' | 'vaapi_idct' | 'vaapi_vld' | 'yuv420p16' | 'yuv422p16' | 'yuv444p16' | 'dxva2_vld' | 'rgb444' | 'bgr444' | 'ya8' | 'bgr48' | 'yuv420p9' | 'yuv420p10' | 'yuv422p10' | 'yuv444p9' | 'yuv444p10' | 'yuv422p9' | 'gbrp' | 'gbrp9' | 'gbrp10' | 'gbrp16' | 'yuva422p' | 'yuva444p' | 'yuva420p9' | 'yuva422p9' | 'yuva444p9' | 'yuva420p10' | 'yuva422p10' | 'yuva444p10' | 'yuva420p16' | 'yuva422p16' | 'yuva444p16' | 'vdpau' | 'xyz12' | 'nv16' | 'nv20' | 'rgba64' | 'bgra64' | 'yvyu422' | 'ya16' | 'gbrap' | 'gbrap16' | 'qsv' | 'mmal' | 'd3d11va_vld' | 'cuda' | '_0rgb' | 'rgb0' | '_0bgr' | 'bgr0' | 'yuv420p12' | 'yuv420p14' | 'yuv422p12' | 'yuv422p14' | 'yuv444p12' | 'yuv444p14' | 'gbrp12' | 'gbrp14' | 'yuvj411p' | 'bayer_bggr8' | 'bayer_rggb8' | 'bayer_gbrg8' | 'bayer_grbg8' | 'bayer_bggr16' | 'bayer_rggb16' | 'bayer_gbrg16' | 'bayer_grbg16' | 'xvmc' | 'yuv440p10' | 'yuv440p12' | 'ayuv64' | 'videotoolbox_vld' | 'p010' | 'gbrap12' | 'gbrap10' | 'mediacodec' | 'gray12' | 'gray10' | 'gray14' | 'p016' | 'd3d11' | 'gray9' | 'gbrpf32' | 'gbrapf32' | 'drm_prime' | 'opencl' | 'grayf32' | 'yuva422p12' | 'yuva444p12' | 'nv24' | 'nv42';

/**
 * A class combining both `Emby.Media.Model.Types.ProfileInformation` and `Emby.Media.Model.Types.LevelInformation`.
 *
 */
export type ProfileLevelInformation = {
    Profile?: ProfileInformation;
    Level?: LevelInformation;
};

/**
 * Class for unified presentation of all information associated with a specific codec profile.
 *
 */
export type ProfileInformation = {
    /**
     * The enum member name of the profile.
     */
    ShortName?: string;
    /**
     * The common name of the profile.
     */
    Description?: string;
    /**
     * Detail information about the profile.
     */
    Details?: string;
    /**
     * A unique identifier.
     */
    Id?: string;
    /**
     * The bit depths.
     */
    BitDepths?: Array<number>;
};

/**
 * Class for unified presentation of all information associated with a specific codec level.
 *
 */
export type LevelInformation = {
    /**
     * The enum member name of the level.
     */
    ShortName?: string;
    /**
     * The common name of the level.
     */
    Description?: string;
    /**
     * A value indicating the level's ranking relative to other levels.
     */
    Ordinal?: number | null;
    MaxBitRate?: BitRate;
    /**
     * A display value of the `Emby.Media.Model.Types.LevelInformation.MaxBitRate` property.
     */
    MaxBitRateDisplay?: string;
    /**
     * A unique identifier.
     */
    Id?: string;
    /**
     * Examples for the maximum supported combinations of resolution and rate for this level.
     */
    ResolutionRates?: Array<ResolutionWithRate>;
    /**
     * Examples for the maximum supported combinations of resolution and rate for this level as string values.
     */
    ResolutionRateStrings?: Array<string>;
    /**
     * A single string from the `Emby.Media.Model.Types.LevelInformation.ResolutionRateStrings` list.
     */
    ResolutionRatesDisplay?: string;
};

/**
 * Struct representing a combination of video resolution and frame rate.
 *
 *
 * `System.IEquatable`1`
 *
 */
export type ResolutionWithRate = {
    /**
     * The resolution width.
     */
    Width?: number;
    /**
     * The resolution height.
     */
    Height?: number;
    /**
     * The frame rate in frames\/second (fps).
     */
    FrameRate?: number;
    Resolution?: Resolution;
};

/**
 * Struct representing a video resolution specified in X and Y dimension.
 *
 *
 * `System.IComparable`
 *
 *
 * `System.IEquatable`1`
 *
 */
export type Resolution = {
    /**
     * The resolution width.
     */
    Width?: number;
    /**
     * The resolution height.
     */
    Height?: number;
};

/**
 * Enum for indicating the processing direction of a codec.
 *
 */
export type CodecDirections = 'Encoder' | 'Decoder';

export type CodecConfiguration = {
    /**
     * A value indicating whether the codec is enabled.
     */
    IsEnabled?: boolean;
    /**
     * The selection priority for the codec.
     *
     * Higher values mean higher priority.
     */
    Priority?: number;
    /**
     * The codec identifier.
     */
    CodecId?: string;
};

export type ExternalIdInfo = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The key.
     */
    Key?: string;
    Website?: string;
    /**
     * The URL format string.
     */
    UrlFormatString?: string;
    IsSupportedAsIdentifier?: boolean;
};

export type RemoteSearchQueryTrailerInfo = {
    SearchInfo?: TrailerInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<string>;
    IncludeDisabledProviders?: boolean;
};

export type TrailerInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchResult = {
    /**
     * The name.
     */
    Name?: string;
    OriginalTitle?: string;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    ProductionYear?: number | null;
    IndexNumber?: number | null;
    IndexNumberEnd?: number | null;
    ParentIndexNumber?: number | null;
    SortIndexNumber?: number | null;
    SortParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    StartDate?: string | null;
    EndDate?: string | null;
    ImageUrl?: string;
    SearchProviderName?: string;
    GameSystem?: string;
    Overview?: string;
    DisambiguationComment?: string;
    AlbumArtist?: RemoteSearchResult;
    Artists?: Array<RemoteSearchResult>;
};

export type RemoteSearchQueryBookInfo = {
    SearchInfo?: BookInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<string>;
    IncludeDisabledProviders?: boolean;
};

export type BookInfo = {
    SeriesName?: string;
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQueryMovieInfo = {
    SearchInfo?: MovieInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<string>;
    IncludeDisabledProviders?: boolean;
};

export type MovieInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQuerySeriesInfo = {
    SearchInfo?: SeriesInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<string>;
    IncludeDisabledProviders?: boolean;
};

export type SeriesInfo = {
    EpisodeAirDate?: string | null;
    DisplayOrder?: SeriesDisplayOrder;
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type SeriesDisplayOrder = 'Aired' | 'Dvd' | 'Absolute';

export type RemoteSearchQueryGameInfo = {
    SearchInfo?: GameInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<string>;
    IncludeDisabledProviders?: boolean;
};

export type GameInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQueryItemLookupInfo = {
    SearchInfo?: ItemLookupInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<string>;
    IncludeDisabledProviders?: boolean;
};

export type ItemLookupInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQueryMusicVideoInfo = {
    SearchInfo?: MusicVideoInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<string>;
    IncludeDisabledProviders?: boolean;
};

export type MusicVideoInfo = {
    Artists?: Array<string>;
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQueryPersonLookupInfo = {
    SearchInfo?: PersonLookupInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<string>;
    IncludeDisabledProviders?: boolean;
};

export type PersonLookupInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQueryAlbumInfo = {
    SearchInfo?: AlbumInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<string>;
    IncludeDisabledProviders?: boolean;
};

export type AlbumInfo = {
    /**
     * The album artist.
     */
    AlbumArtists?: Array<string>;
    SongInfos?: Array<SongInfo>;
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type SongInfo = {
    AlbumArtists?: Array<string>;
    Album?: string;
    Artists?: Array<string>;
    Composers?: Array<string>;
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type RemoteSearchQueryArtistInfo = {
    SearchInfo?: ArtistInfo;
    ItemId?: number;
    SearchProviderName?: string;
    Providers?: Array<string>;
    IncludeDisabledProviders?: boolean;
};

export type ArtistInfo = {
    /**
     * The name.
     */
    Name?: string;
    Path?: string;
    /**
     * The metadata language.
     */
    MetadataLanguage?: string;
    /**
     * The metadata country code.
     */
    MetadataCountryCode?: string;
    MetadataLanguages?: Array<GlobalizationCultureDto>;
    ProviderIds?: ProviderIdDictionary;
    /**
     * The year.
     */
    Year?: number | null;
    IndexNumber?: number | null;
    ParentIndexNumber?: number | null;
    PremiereDate?: string | null;
    IsAutomated?: boolean;
    EnableAdultMetadata?: boolean;
};

export type MetadataRefreshMode = 'ValidationOnly' | 'Default' | 'FullRefresh';

export type BaseRefreshRequest = {
    ReplaceThumbnailImages?: boolean;
};

export type MetadataEditorInfo = {
    ParentalRatingOptions?: Array<ParentalRating>;
    Countries?: Array<GlobalizationCountryInfo>;
    Cultures?: Array<GlobalizationCultureDto>;
    ExternalIdInfos?: Array<ExternalIdInfo>;
    PersonExternalIdInfos?: Array<ExternalIdInfo>;
};

export type UserLibraryLeaveSharedItems = {
    ItemIds?: Array<string>;
    UserId?: string;
};

export type LibraryDeleteInfo = {
    Paths?: Array<string>;
};

export type AllThemeMediaResult = {
    ThemeVideosResult?: ThemeMediaResult;
    ThemeSongsResult?: ThemeMediaResult;
    SoundtrackSongsResult?: ThemeMediaResult;
};

/**
 * Class ThemeMediaResult
 *
 */
export type ThemeMediaResult = {
    /**
     * The owner id.
     */
    OwnerId?: number;
    Items?: Array<BaseItemDto>;
    TotalRecordCount?: number;
};

/**
 * Class ImageInfo
 *
 */
export type ImageInfo = {
    ImageType?: ImageType;
    /**
     * The index of the image.
     */
    ImageIndex?: number | null;
    /**
     * The path.
     */
    Path?: string;
    Filename?: string;
    /**
     * The height.
     */
    Height?: number | null;
    /**
     * The width.
     */
    Width?: number | null;
    /**
     * The size.
     */
    Size?: number;
};

/**
 * Class RemoteImageResult.
 *
 */
export type RemoteImageResult = {
    /**
     * The images.
     */
    Images?: Array<RemoteImageInfo>;
    /**
     * The total record count.
     */
    TotalRecordCount?: number;
    /**
     * The providers.
     */
    Providers?: Array<string>;
};

/**
 * Class RemoteImageInfo
 *
 */
export type RemoteImageInfo = {
    /**
     * The name of the provider.
     */
    ProviderName?: string;
    /**
     * The URL.
     */
    Url?: string;
    /**
     * A url used for previewing a smaller version
     */
    ThumbnailUrl?: string;
    /**
     * The height.
     */
    Height?: number | null;
    /**
     * The width.
     */
    Width?: number | null;
    /**
     * The community rating.
     */
    CommunityRating?: number | null;
    /**
     * The vote count.
     */
    VoteCount?: number | null;
    /**
     * The language.
     */
    Language?: string;
    DisplayLanguage?: string;
    Type?: ImageType;
    RatingType?: RatingType;
};

export type RatingType = 'Score' | 'Likes';

export type RokuMetadataApiThumbnailSetInfo = {
    AspectRatio?: number | null;
    Thumbnails?: Array<RokuMetadataApiThumbnailInfo>;
};

export type RokuMetadataApiThumbnailInfo = {
    PositionTicks?: number;
    ImageTag?: string;
};

export type PlaybackInfoResponse = {
    /**
     * The media sources.
     */
    MediaSources?: Array<MediaSourceInfo>;
    /**
     * The play session identifier.
     */
    PlaySessionId?: string;
    ErrorCode?: PlaybackErrorCode;
};

export type PlaybackErrorCode = 'NotAllowed' | 'NoCompatibleStream' | 'RateLimitExceeded';

export type PlaybackInfoRequest = {
    Id?: string;
    UserId?: string;
    MaxStreamingBitrate?: number | null;
    StartTimeTicks?: number | null;
    AudioStreamIndex?: number | null;
    SubtitleStreamIndex?: number | null;
    MaxAudioChannels?: number | null;
    MediaSourceId?: string;
    LiveStreamId?: string;
    DeviceProfile?: DeviceProfile;
    EnableDirectPlay?: boolean;
    EnableDirectStream?: boolean;
    EnableTranscoding?: boolean;
    AllowInterlacedVideoStreamCopy?: boolean;
    AllowVideoStreamCopy?: boolean;
    AllowAudioStreamCopy?: boolean;
    IsPlayback?: boolean;
    AutoOpenLiveStream?: boolean;
    CurrentPlaySessionId?: string;
};

export type LibraryPostUpdatedMedia = {
    Updates?: Array<LibraryMediaUpdateInfo>;
};

export type LibraryMediaUpdateInfo = {
    Path?: string;
    UpdateType?: string;
};

export type QueryResultVirtualFolderInfo = {
    Items?: Array<VirtualFolderInfo>;
    TotalRecordCount?: number;
};

/**
 * Used to hold information about a user's list of configured virtual folders
 *
 */
export type VirtualFolderInfo = {
    /**
     * The name.
     */
    Name?: string;
    /**
     * The locations.
     */
    Locations?: Array<string>;
    /**
     * The type of the collection.
     */
    CollectionType?: string;
    LibraryOptions?: LibraryOptions;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * ItemId came first, so that is left for compatability purposes
     */
    Id?: string;
    Guid?: string;
    /**
     * The primary image item identifier.
     */
    PrimaryImageItemId?: string;
    PrimaryImageTag?: string;
    RefreshProgress?: number | null;
    RefreshStatus?: string;
};

export type LibraryUpdateLibraryOptions = {
    Id?: string;
    LibraryOptions?: LibraryOptions;
};

export type LibraryRenameVirtualFolder = {
    Id?: string;
    NewName?: string;
};

export type LibraryRemoveVirtualFolder = {
    Id?: string;
    RefreshLibrary?: boolean;
};

export type LibraryAddMediaPath = {
    Id?: string;
    Path?: string;
    PathInfo?: MediaPathInfo;
    RefreshLibrary?: boolean;
};

export type ApiTagItem = {
    Name?: string;
    Id?: string;
};

export type ApiListingProviderTypeInfo = {
    Name?: string;
    Id?: string;
    SetupUrl?: string;
};

export type UserNotificationInfo = {
    NotifierKey?: string;
    SetupModuleUrl?: string;
    ServiceName?: string;
    PluginId?: string;
    FriendlyName?: string;
    Id?: string;
    Enabled?: boolean;
    /**
     * Limit events based on user ids, for admin notifications
     */
    UserIds?: Array<string>;
    DeviceIds?: Array<string>;
    LibraryIds?: Array<string>;
    EventIds?: Array<string>;
    /**
     * Notification intended for a specific user
     */
    UserId?: string;
    IsSelfNotification?: boolean;
    GroupItems?: boolean;
    /**
     * This is for webhooks since this will cause xml serialization to fail
     */
    Options?: {
        [key: string]: string;
    };
};

export type PlaylistsAddToPlaylistInfo = {
    ItemCount?: number;
    ContainsDuplicates?: boolean;
};

export type PlaylistsAddToPlaylistResult = {
    Id?: string;
    ItemAddedCount?: number;
};

/**
 * Enum PlayCommand
 *
 */
export type PlayCommand = 'PlayNow' | 'PlayNext' | 'PlayLast' | 'PlayInstantMix' | 'PlayShuffle';

/**
 * Class PlayRequest
 *
 */
export type PlayRequest = {
    /**
     * The controlling user identifier.
     */
    ControllingUserId?: string;
    SubtitleStreamIndex?: number | null;
    AudioStreamIndex?: number | null;
    MediaSourceId?: string;
    StartIndex?: number | null;
};

export type GeneralCommand = {
    Name?: string;
    ControllingUserId?: string;
    Arguments?: {
        [key: string]: string;
    };
};

export type ClientCapabilities = {
    PlayableMediaTypes?: Array<string>;
    SupportedCommands?: Array<string>;
    SupportsMediaControl?: boolean;
    PushToken?: string;
    PushTokenType?: string;
    SupportsSync?: boolean;
    DeviceProfile?: DeviceProfile;
    IconUrl?: string;
    AppId?: string;
};

/**
 * Class PlaybackProgressInfo.
 *
 */
export type PlaybackProgressInfo = {
    /**
     * A value indicating whether this instance can seek.
     */
    CanSeek?: boolean;
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    /**
     * The session id.
     */
    SessionId?: string;
    /**
     * The index of the audio stream.
     */
    AudioStreamIndex?: number | null;
    /**
     * The index of the subtitle stream.
     */
    SubtitleStreamIndex?: number | null;
    /**
     * A value indicating whether this instance is paused.
     */
    IsPaused?: boolean;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    /**
     * A value indicating whether this instance is muted.
     */
    IsMuted?: boolean;
    RunTimeTicks?: number | null;
    PlaybackStartTimeTicks?: number | null;
    /**
     * The volume level.
     */
    VolumeLevel?: number | null;
    Brightness?: number | null;
    AspectRatio?: string;
    EventName?: ProgressEvent;
    PlayMethod?: PlayMethod;
    RepeatMode?: RepeatMode;
    SleepTimerMode?: SleepTimerMode;
    SleepTimerEndTime?: string | null;
    Shuffle?: boolean;
    SubtitleOffset?: number;
    PlaybackRate?: number;
    PlaylistItemIds?: Array<string>;
    /**
     * The play session identifier.
     */
    PlaySessionId?: string;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * The live stream identifier.
     */
    LiveStreamId?: string;
    /**
     * The media version identifier.
     */
    MediaSourceId?: string;
    Item?: BaseItemDto;
    /**
     * The position ticks.
     */
    PositionTicks?: number | null;
};

/**
 * Class PlaybackStopInfo.
 *
 */
export type PlaybackStopInfo = {
    NowPlayingQueue?: Array<QueueItem>;
    PlaylistItemId?: string;
    PlaylistIndex?: number;
    PlaylistLength?: number;
    /**
     * The session id.
     */
    SessionId?: string;
    IsAutomated?: boolean;
    /**
     * A value indicating whether this `MediaBrowser.Model.Session.PlaybackStopInfo` is failed.
     */
    Failed?: boolean;
    NextMediaType?: string;
    /**
     * The play session identifier.
     */
    PlaySessionId?: string;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * The live stream identifier.
     */
    LiveStreamId?: string;
    /**
     * The media version identifier.
     */
    MediaSourceId?: string;
    Item?: BaseItemDto;
    /**
     * The position ticks.
     */
    PositionTicks?: number | null;
};

export type SyncedItemProgress = {
    Progress?: number | null;
    Status?: SyncJobItemStatus;
};

export type SyncedItem = {
    ServerId?: string;
    SyncJobId?: number;
    SyncJobName?: string;
    SyncJobDateCreated?: string;
    SyncJobItemId?: number;
    OriginalFileName?: string;
    Item?: BaseItemDto;
    UserId?: string;
    AdditionalFiles?: Array<ItemFileInfo>;
};

export type QueryResultLogFile = {
    Items?: Array<LogFile>;
    TotalRecordCount?: number;
};

export type LogFile = {
    /**
     * The date created.
     */
    DateCreated?: string;
    /**
     * The date modified.
     */
    DateModified?: string;
    /**
     * The size.
     */
    Size?: number;
    /**
     * The name.
     */
    Name?: string;
};

export type PublicSystemInfo = {
    /**
     * The local address.
     */
    LocalAddress?: string;
    LocalAddresses?: Array<string>;
    /**
     * The wan address.
     */
    WanAddress?: string;
    RemoteAddresses?: Array<string>;
    /**
     * The name of the server.
     */
    ServerName?: string;
    /**
     * The version.
     */
    Version?: string;
    /**
     * The id.
     */
    Id?: string;
};

export type QueryResultActivityLogEntry = {
    Items?: Array<ActivityLogEntry>;
    TotalRecordCount?: number;
};

export type ActivityLogEntry = {
    /**
     * The identifier.
     */
    Id?: number;
    /**
     * The name.
     */
    Name?: string;
    /**
     * The overview.
     */
    Overview?: string;
    /**
     * The short overview.
     */
    ShortOverview?: string;
    /**
     * The type.
     */
    Type?: string;
    /**
     * The item identifier.
     */
    ItemId?: string;
    /**
     * The date.
     */
    Date?: string;
    /**
     * The user identifier.
     */
    UserId?: string;
    /**
     * The user primary image tag.
     */
    UserPrimaryImageTag?: string;
    Severity?: LoggingLogSeverity;
};

/**
 * Enum LogSeverity
 *
 */
export type LoggingLogSeverity = 'Info' | 'Debug' | 'Warn' | 'Error' | 'Fatal';

export type AuthenticateUser = {
    Pw?: string;
};

export type UpdateUserPassword = {
    Id?: string;
    NewPw?: string;
    ResetPassword?: boolean;
};

export type ForgotPasswordPin = {
    Pin?: string;
};

export type PinRedeemResult = {
    /**
     * A value indicating whether this `MediaBrowser.Model.Users.PinRedeemResult` is success.
     */
    Success?: boolean;
    /**
     * The users reset.
     */
    UsersReset?: Array<string>;
};

export type ContentSection = {
    Name?: string;
    Subtitle?: string;
    Id?: string;
    SectionType?: string;
    CollectionType?: string;
    ViewType?: string;
    Monitor?: Array<string>;
    CardSizeOffset?: number;
    ScrollDirection?: ScrollDirection;
    ParentItem?: BaseItemDto;
    TextInfo?: TextSectionInfo;
    PremiumFeature?: string;
    PremiumMessage?: string;
    RefreshInterval?: number | null;
};

export type ScrollDirection = 'Horizontal' | 'Vertical';

export type TextSectionInfo = {
    Text?: string;
    Name?: string;
    Id?: string;
    Level?: NotificationsNotificationLevel;
};

export type NotificationsNotificationLevel = 'Normal' | 'Warning' | 'Error';

export type UserLibraryAddTags = {
    Tags?: Array<NameIdPair>;
};

export type UserLibraryRemoveTags = {
    Tags?: Array<NameIdPair>;
};

/**
 * Class ImageProviderInfo.
 *
 */
export type ImageProviderInfo = {
    /**
     * The name.
     */
    Name?: string;
    SupportedImages?: Array<ImageType>;
};

export type ImagesBaseDownloadRemoteImage = {
    ImageIndex?: number | null;
};

export type LibraryUpdateMediaPath = {
    Id?: string;
    PathInfo?: MediaPathInfo;
};

export type LibraryRemoveMediaPath = {
    Id?: string;
    Path?: string;
    RefreshLibrary?: boolean;
};

/**
 * Enum PlaystateCommand
 *
 */
export type PlaystateCommand = 'Stop' | 'Pause' | 'Unpause' | 'NextTrack' | 'PreviousTrack' | 'Seek' | 'Rewind' | 'FastForward' | 'PlayPause' | 'SeekRelative';

export type PlaystateRequest = {
    Command?: PlaystateCommand;
    SeekPositionTicks?: number | null;
    /**
     * The controlling user identifier.
     */
    ControllingUserId?: string;
};

export type QueryResultString = {
    Items?: Array<string>;
    TotalRecordCount?: number;
};

export type ConnectUserLinkResult = {
    IsPending?: boolean;
    IsNewUserInvitation?: boolean;
    GuestDisplayName?: string;
};

export type RemoteSubtitleInfo = {
    /**
     * Use language instead to return the language specified by the subtitle provider
     *
     * @deprecated
     */
    ThreeLetterISOLanguageName?: string;
    Id?: string;
    ProviderName?: string;
    Name?: string;
    Format?: string;
    Author?: string;
    Comment?: string;
    DateCreated?: string | null;
    CommunityRating?: number | null;
    DownloadCount?: number | null;
    IsHashMatch?: boolean | null;
    IsForced?: boolean | null;
    IsHearingImpaired?: boolean | null;
    Language?: string;
};

export type SubtitlesSubtitleDownloadResult = {
    NewIndex?: number | null;
};

export type ApiSetChannelDisabled = {
    Id?: string;
    ManagementId?: string;
    Disabled?: boolean;
};

export type QueryResultChannelManagementInfo = {
    Items?: Array<ChannelManagementInfo>;
    TotalRecordCount?: number;
};

export type ChannelManagementInfo = {
    Id?: string;
    Name?: string;
};

export type ApiSetChannelSortIndex = {
    Id?: string;
    ManagementId?: string;
    NewIndex?: number;
};

export type ApiOnPlaybackProgress = {
    PlaylistIndex?: number;
    PlaylistLength?: number;
    Shuffle?: boolean;
    SleepTimerMode?: SleepTimerMode;
    SleepTimerEndTime?: string | null;
    EventName?: ProgressEvent;
};

export type GetArtistsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Artists';
};

export type GetArtistsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetArtistsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetArtistsResponse = GetArtistsResponses[keyof GetArtistsResponses];

export type GetAudiocodecsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/AudioCodecs';
};

export type GetAudiocodecsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudiocodecsResponses = {
    /**
     * Operation successful. Returning a QueryResult<TagItem> object.
     */
    200: QueryResultUserLibraryTagItem;
};

export type GetAudiocodecsResponse = GetAudiocodecsResponses[keyof GetAudiocodecsResponses];

export type GetAudiolayoutsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/AudioLayouts';
};

export type GetAudiolayoutsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudiolayoutsResponses = {
    /**
     * Operation successful. Returning a QueryResult<TagItem> object.
     */
    200: QueryResultUserLibraryTagItem;
};

export type GetAudiolayoutsResponse = GetAudiolayoutsResponses[keyof GetAudiolayoutsResponses];

export type GetChannelsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Channels';
};

export type GetChannelsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetChannelsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetChannelsResponse = GetChannelsResponses[keyof GetChannelsResponses];

export type PostCollectionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Whether or not to lock the new collection.
         */
        IsLocked?: boolean;
        /**
         * The name of the new collection.
         */
        Name?: string;
        /**
         * Optional - create the collection within a specific folder
         */
        ParentId?: string;
        /**
         * Item Ids to add to the collection
         */
        Ids?: string;
    };
    url: '/Collections';
};

export type PostCollectionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostCollectionsResponses = {
    /**
     * Operation successful. Returning a CollectionCreationResult object.
     */
    200: CollectionsCollectionCreationResult;
};

export type PostCollectionsResponse = PostCollectionsResponses[keyof PostCollectionsResponses];

export type GetContainersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Containers';
};

export type GetContainersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetContainersResponses = {
    /**
     * Operation successful. Returning a QueryResult<TagItem> object.
     */
    200: QueryResultUserLibraryTagItem;
};

export type GetContainersResponse = GetContainersResponses[keyof GetContainersResponses];

export type DeleteDevicesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Device Id
         */
        Id: string;
    };
    url: '/Devices';
};

export type DeleteDevicesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteDevicesResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetDevicesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
    };
    url: '/Devices';
};

export type GetDevicesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDevicesResponses = {
    /**
     * Operation successful. Returning a QueryResult<DeviceInfo> object.
     */
    200: QueryResultDevicesDeviceInfo;
};

export type GetDevicesResponse = GetDevicesResponses[keyof GetDevicesResponses];

export type GetExtendedvideotypesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/ExtendedVideoTypes';
};

export type GetExtendedvideotypesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetExtendedvideotypesResponses = {
    /**
     * Operation successful. Returning a QueryResult<TagItem> object.
     */
    200: QueryResultUserLibraryTagItem;
};

export type GetExtendedvideotypesResponse = GetExtendedvideotypesResponses[keyof GetExtendedvideotypesResponses];

export type GetFeaturesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Features';
};

export type GetFeaturesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetFeaturesResponses = {
    /**
     * Operation successful. Returning a FeatureInfo[] object.
     */
    200: Array<FeatureInfo>;
};

export type GetFeaturesResponse = GetFeaturesResponses[keyof GetFeaturesResponses];

export type GetGamegenresData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/GameGenres';
};

export type GetGamegenresErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetGamegenresResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetGamegenresResponse = GetGamegenresResponses[keyof GetGamegenresResponses];

export type GetGenresData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Genres';
};

export type GetGenresErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetGenresResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetGenresResponse = GetGenresResponses[keyof GetGenresResponses];

export type DeleteItemsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Ids
         */
        Ids: string;
    };
    url: '/Items';
};

export type DeleteItemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteItemsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetItemsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Items';
};

export type GetItemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetItemsResponse = GetItemsResponses[keyof GetItemsResponses];

export type GetItemtypesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/ItemTypes';
};

export type GetItemtypesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemtypesResponses = {
    /**
     * Operation successful. Returning a QueryResult<TagItem> object.
     */
    200: QueryResultUserLibraryTagItem;
};

export type GetItemtypesResponse = GetItemtypesResponses[keyof GetItemtypesResponses];

export type GetMusicgenresData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/MusicGenres';
};

export type GetMusicgenresErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetMusicgenresResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetMusicgenresResponse = GetMusicgenresResponses[keyof GetMusicgenresResponses];

export type GetOfficialratingsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/OfficialRatings';
};

export type GetOfficialratingsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetOfficialratingsResponses = {
    /**
     * Operation successful. Returning a QueryResult<OfficialRatingItem> object.
     */
    200: QueryResultUserLibraryOfficialRatingItem;
};

export type GetOfficialratingsResponse = GetOfficialratingsResponses[keyof GetOfficialratingsResponses];

export type GetOpenapiData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/openapi';
};

export type GetOpenapiErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetOpenapiResponses = {
    /**
     * Operation successful. Returning a String object.
     */
    200: string;
};

export type GetOpenapiResponse = GetOpenapiResponses[keyof GetOpenapiResponses];

export type GetOpenapiJsonData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/openapi.json';
};

export type GetOpenapiJsonErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetOpenapiJsonResponses = {
    /**
     * Operation successful. Returning a String object.
     */
    200: string;
};

export type GetOpenapiJsonResponse = GetOpenapiJsonResponses[keyof GetOpenapiJsonResponses];

export type GetPackagesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional package type filter (System/UserInstalled)
         */
        PackageType?: string;
        /**
         * Optional. Filter by target system type. Allows multiple, comma delimited.
         */
        TargetSystems?: string;
        /**
         * Optional. Filter by premium status
         */
        IsPremium?: boolean | null;
        /**
         * Optional. Filter by package that contain adult content.
         */
        IsAdult?: boolean | null;
    };
    url: '/Packages';
};

export type GetPackagesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPackagesResponses = {
    /**
     * Operation successful. Returning a PackageInfo[] object.
     */
    200: Array<PackageInfo>;
};

export type GetPackagesResponse = GetPackagesResponses[keyof GetPackagesResponses];

export type GetPersonsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Persons';
};

export type GetPersonsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPersonsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetPersonsResponse = GetPersonsResponses[keyof GetPersonsResponses];

export type PostPlaylistsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The name of the new playlist.
         */
        Name?: string;
        /**
         * Item Ids to add to the playlist
         */
        Ids?: string;
        /**
         * The playlist media type
         */
        MediaType?: string;
    };
    url: '/Playlists';
};

export type PostPlaylistsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostPlaylistsResponses = {
    /**
     * Operation successful. Returning a PlaylistCreationResult object.
     */
    200: PlaylistsPlaylistCreationResult;
};

export type PostPlaylistsResponse = PostPlaylistsResponses[keyof PostPlaylistsResponses];

export type GetPluginsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Plugins';
};

export type GetPluginsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPluginsResponses = {
    /**
     * Operation successful. Returning a PluginInfo[] object.
     */
    200: Array<PluginsPluginInfo>;
};

export type GetPluginsResponse = GetPluginsResponses[keyof GetPluginsResponses];

export type GetScheduledtasksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter tasks that are hidden, or not.
         */
        IsHidden?: boolean | null;
        /**
         * Optional filter tasks that are enabled, or not.
         */
        IsEnabled?: boolean | null;
    };
    url: '/ScheduledTasks';
};

export type GetScheduledtasksErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetScheduledtasksResponses = {
    /**
     * Operation successful. Returning a TaskInfo[] object.
     */
    200: Array<TaskInfo>;
};

export type GetScheduledtasksResponse = GetScheduledtasksResponses[keyof GetScheduledtasksResponses];

export type GetSessionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by sessions that a given user is allowed to remote control.
         */
        ControllableByUserId?: string;
        /**
         * Optional. Filter by device id.
         */
        DeviceId?: string;
        /**
         * Optional. Filter by session id.
         */
        Id?: string;
    };
    url: '/Sessions';
};

export type GetSessionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSessionsResponses = {
    /**
     * Operation successful. Returning a SessionInfo[] object.
     */
    200: Array<SessionSessionInfo>;
};

export type GetSessionsResponse = GetSessionsResponses[keyof GetSessionsResponses];

export type GetStreamlanguagesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/StreamLanguages';
};

export type GetStreamlanguagesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetStreamlanguagesResponses = {
    /**
     * Operation successful. Returning a QueryResult<TagItem> object.
     */
    200: QueryResultUserLibraryTagItem;
};

export type GetStreamlanguagesResponse = GetStreamlanguagesResponses[keyof GetStreamlanguagesResponses];

export type GetStudiosData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Studios';
};

export type GetStudiosErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetStudiosResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetStudiosResponse = GetStudiosResponses[keyof GetStudiosResponses];

export type GetSubtitlecodecsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/SubtitleCodecs';
};

export type GetSubtitlecodecsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSubtitlecodecsResponses = {
    /**
     * Operation successful. Returning a QueryResult<TagItem> object.
     */
    200: QueryResultUserLibraryTagItem;
};

export type GetSubtitlecodecsResponse = GetSubtitlecodecsResponses[keyof GetSubtitlecodecsResponses];

export type GetSwaggerData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/swagger';
};

export type GetSwaggerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSwaggerResponses = {
    /**
     * Operation successful. Returning a String object.
     */
    200: string;
};

export type GetSwaggerResponse = GetSwaggerResponses[keyof GetSwaggerResponses];

export type GetSwaggerJsonData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/swagger.json';
};

export type GetSwaggerJsonErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSwaggerJsonResponses = {
    /**
     * Operation successful. Returning a String object.
     */
    200: string;
};

export type GetSwaggerJsonResponse = GetSwaggerJsonResponses[keyof GetSwaggerJsonResponses];

export type GetTagsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Tags';
};

export type GetTagsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetTagsResponses = {
    /**
     * Operation successful. Returning a QueryResult<TagItem> object.
     */
    200: QueryResultUserLibraryTagItem;
};

export type GetTagsResponse = GetTagsResponses[keyof GetTagsResponses];

export type GetTrailersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Trailers';
};

export type GetTrailersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetTrailersResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetTrailersResponse = GetTrailersResponses[keyof GetTrailersResponses];

export type GetVideocodecsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/VideoCodecs';
};

export type GetVideocodecsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideocodecsResponses = {
    /**
     * Operation successful. Returning a QueryResult<TagItem> object.
     */
    200: QueryResultUserLibraryTagItem;
};

export type GetVideocodecsResponse = GetVideocodecsResponses[keyof GetVideocodecsResponses];

export type GetYearsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Years';
};

export type GetYearsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetYearsResponses = {
    /**
     * Operation successful. Returning a QueryResult<TagItem> object.
     */
    200: QueryResultUserLibraryTagItem;
};

export type GetYearsResponse = GetYearsResponses[keyof GetYearsResponses];

export type GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData = {
    body?: never;
    path: {
        PercentPlayed: number | null;
        UnPlayedCount: number | null;
        /**
         * Item Id
         */
        Id: string;
        /**
         * The maximum image width to return.
         */
        MaxWidth: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag: string;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnPlayedCount}';
};

export type GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData = {
    body?: never;
    path: {
        PercentPlayed: number | null;
        UnPlayedCount: number | null;
        /**
         * Item Id
         */
        Id: string;
        /**
         * The maximum image width to return.
         */
        MaxWidth: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag: string;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnPlayedCount}';
};

export type HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetArtistsByNameData = {
    body?: never;
    path: {
        /**
         * The artist name
         */
        Name: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data
         */
        UserId?: string;
    };
    url: '/Artists/{Name}';
};

export type GetArtistsByNameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetArtistsByNameResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetArtistsByNameResponse = GetArtistsByNameResponses[keyof GetArtistsByNameResponses];

export type GetArtistsAlbumartistsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Artists/AlbumArtists';
};

export type GetArtistsAlbumartistsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetArtistsAlbumartistsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetArtistsAlbumartistsResponse = GetArtistsAlbumartistsResponses[keyof GetArtistsAlbumartistsResponses];

export type GetArtistsPrefixesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Artists/Prefixes';
};

export type GetArtistsPrefixesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetArtistsPrefixesResponses = {
    /**
     * Operation successful. Returning a NameValuePair[] object.
     */
    200: Array<NameValuePair>;
};

export type GetArtistsPrefixesResponse = GetArtistsPrefixesResponses[keyof GetArtistsPrefixesResponses];

export type GetArtistsInstantmixData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Artists/InstantMix';
};

export type GetArtistsInstantmixErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetArtistsInstantmixResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetArtistsInstantmixResponse = GetArtistsInstantmixResponses[keyof GetArtistsInstantmixResponses];

export type GetAudiobooksNextupData = {
    body?: never;
    path?: never;
    query: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         */
        Fields?: string;
        /**
         * Optional. Filter by series id
         */
        AlbumId?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
    };
    url: '/AudioBooks/NextUp';
};

export type GetAudiobooksNextupErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudiobooksNextupResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetAudiobooksNextupResponse = GetAudiobooksNextupResponses[keyof GetAudiobooksNextupResponses];

export type GetAuthProvidersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Auth/Providers';
};

export type GetAuthProvidersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAuthProvidersResponses = {
    /**
     * Operation successful. Returning a NameIdPair[] object.
     */
    200: Array<NameIdPair>;
};

export type GetAuthProvidersResponse = GetAuthProvidersResponses[keyof GetAuthProvidersResponses];

export type GetAuthKeysData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
    };
    url: '/Auth/Keys';
};

export type GetAuthKeysErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAuthKeysResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostAuthKeysData = {
    body?: never;
    path?: never;
    query: {
        /**
         * App
         */
        App: string;
    };
    url: '/Auth/Keys';
};

export type PostAuthKeysErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostAuthKeysResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostBackuprestoreRestoreData = {
    /**
     * RestoreOptions:
     */
    body: MbBackupApiRestoreOptions;
    path?: never;
    query?: never;
    url: '/BackupRestore/Restore';
};

export type PostBackuprestoreRestoreErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostBackuprestoreRestoreResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostBackuprestoreRestoredataData = {
    /**
     * DataRestoreOptions:
     */
    body: MbBackupApiDataRestoreOptions;
    path?: never;
    query?: never;
    url: '/BackupRestore/RestoreData';
};

export type PostBackuprestoreRestoredataErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostBackuprestoreRestoredataResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetBackuprestoreBackupinfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/BackupRestore/BackupInfo';
};

export type GetBackuprestoreBackupinfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetBackuprestoreBackupinfoResponses = {
    /**
     * Operation successful. Returning a AllBackupsInfo object.
     */
    200: MbBackupApiAllBackupsInfo;
};

export type GetBackuprestoreBackupinfoResponse = GetBackuprestoreBackupinfoResponses[keyof GetBackuprestoreBackupinfoResponses];

export type GetBrandingConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Branding/Configuration';
};

export type GetBrandingConfigurationErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetBrandingConfigurationResponses = {
    /**
     * Operation successful. Returning a BrandingOptions object.
     */
    200: BrandingBrandingOptions;
};

export type GetBrandingConfigurationResponse = GetBrandingConfigurationResponses[keyof GetBrandingConfigurationResponses];

export type GetBrandingCssData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Branding/Css';
};

export type GetBrandingCssErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetBrandingCssResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetBrandingCssCssData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Branding/Css.css';
};

export type GetBrandingCssCssErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetBrandingCssCssResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetConnectPendingData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Connect/Pending';
};

export type GetConnectPendingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetConnectPendingResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetConnectExchangeData = {
    body?: never;
    path?: never;
    query: {
        /**
         * ConnectUserId
         */
        ConnectUserId: string;
    };
    url: '/Connect/Exchange';
};

export type GetConnectExchangeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetConnectExchangeResponses = {
    /**
     * Operation successful. Returning a ConnectAuthenticationExchangeResult object.
     */
    200: ConnectConnectAuthenticationExchangeResult;
};

export type GetConnectExchangeResponse = GetConnectExchangeResponses[keyof GetConnectExchangeResponses];

export type GetDevicesOptionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Device Id
         */
        Id: string;
    };
    url: '/Devices/Options';
};

export type GetDevicesOptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDevicesOptionsResponses = {
    /**
     * Operation successful. Returning a DeviceOptions object.
     */
    200: DevicesDeviceOptions;
};

export type GetDevicesOptionsResponse = GetDevicesOptionsResponses[keyof GetDevicesOptionsResponses];

export type PostDevicesOptionsData = {
    /**
     * DeviceOptions:
     */
    body: DevicesDeviceOptions;
    path?: never;
    query: {
        /**
         * Device Id
         */
        Id: string;
    };
    url: '/Devices/Options';
};

export type PostDevicesOptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostDevicesOptionsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetDevicesInfoData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Device Id
         */
        Id: string;
    };
    url: '/Devices/Info';
};

export type GetDevicesInfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDevicesInfoResponses = {
    /**
     * Operation successful. Returning a DeviceInfo object.
     */
    200: DevicesDeviceInfo;
};

export type GetDevicesInfoResponse = GetDevicesInfoResponses[keyof GetDevicesInfoResponses];

export type GetDevicesCamerauploadsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Devices/CameraUploads';
};

export type GetDevicesCamerauploadsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDevicesCamerauploadsResponses = {
    /**
     * Operation successful. Returning a ContentUploadHistory object.
     */
    200: DevicesContentUploadHistory;
};

export type GetDevicesCamerauploadsResponse = GetDevicesCamerauploadsResponses[keyof GetDevicesCamerauploadsResponses];

export type PostDevicesCamerauploadsData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path?: never;
    query: {
        /**
         * Album
         */
        Album: string;
        /**
         * Name
         */
        Name: string;
        /**
         * Id
         */
        Id: string;
    };
    url: '/Devices/CameraUploads';
};

export type PostDevicesCamerauploadsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostDevicesCamerauploadsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostDevicesDeleteData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Device Id
         */
        Id: string;
    };
    url: '/Devices/Delete';
};

export type PostDevicesDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostDevicesDeleteResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetDisplaypreferencesByIdData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Client
         */
        Client: string;
    };
    url: '/DisplayPreferences/{Id}';
};

export type GetDisplaypreferencesByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDisplaypreferencesByIdResponses = {
    /**
     * Operation successful. Returning a DisplayPreferences object.
     */
    200: DisplayPreferences;
};

export type GetDisplaypreferencesByIdResponse = GetDisplaypreferencesByIdResponses[keyof GetDisplaypreferencesByIdResponses];

export type PostDisplaypreferencesByDisplaypreferencesidData = {
    /**
     * DisplayPreferences:
     */
    body: DisplayPreferences;
    path: {
        /**
         * DisplayPreferences Id
         */
        DisplayPreferencesId: string;
    };
    query: {
        /**
         * User Id
         */
        UserId: string;
    };
    url: '/DisplayPreferences/{DisplayPreferencesId}';
};

export type PostDisplaypreferencesByDisplaypreferencesidErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostDisplaypreferencesByDisplaypreferencesidResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetDlnaProfileinfosData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Dlna/ProfileInfos';
};

export type GetDlnaProfileinfosErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaProfileinfosResponses = {
    /**
     * Operation successful. Returning a DlnaProfile[] object.
     */
    200: Array<DlnaProfilesDlnaProfile>;
};

export type GetDlnaProfileinfosResponse = GetDlnaProfileinfosResponses[keyof GetDlnaProfileinfosResponses];

export type PostDlnaProfilesData = {
    /**
     * DlnaProfile:
     */
    body: DlnaProfilesDlnaProfile;
    path?: never;
    query?: never;
    url: '/Dlna/Profiles';
};

export type PostDlnaProfilesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostDlnaProfilesResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetEncodingTonemapoptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Encoding/ToneMapOptions';
};

export type GetEncodingTonemapoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEncodingTonemapoptionsResponses = {
    /**
     * Operation successful. Returning a ToneMapOptionsVisibility object.
     */
    200: ConfigurationToneMappingToneMapOptionsVisibility;
};

export type GetEncodingTonemapoptionsResponse = GetEncodingTonemapoptionsResponses[keyof GetEncodingTonemapoptionsResponses];

export type GetEncodingFulltonemapoptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Encoding/FullToneMapOptions';
};

export type GetEncodingFulltonemapoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEncodingFulltonemapoptionsResponses = {
    /**
     * Operation successful. Returning a EditObjectContainer object.
     */
    200: EditObjectContainer;
};

export type GetEncodingFulltonemapoptionsResponse = GetEncodingFulltonemapoptionsResponses[keyof GetEncodingFulltonemapoptionsResponses];

export type PostEncodingFulltonemapoptionsData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path?: never;
    query?: never;
    url: '/Encoding/FullToneMapOptions';
};

export type PostEncodingFulltonemapoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostEncodingFulltonemapoptionsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetEncodingPublictonemapoptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Encoding/PublicToneMapOptions';
};

export type GetEncodingPublictonemapoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEncodingPublictonemapoptionsResponses = {
    /**
     * Operation successful. Returning a EditObjectContainer object.
     */
    200: EditObjectContainer;
};

export type GetEncodingPublictonemapoptionsResponse = GetEncodingPublictonemapoptionsResponses[keyof GetEncodingPublictonemapoptionsResponses];

export type PostEncodingPublictonemapoptionsData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path?: never;
    query?: never;
    url: '/Encoding/PublicToneMapOptions';
};

export type PostEncodingPublictonemapoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostEncodingPublictonemapoptionsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetEncodingSubtitleoptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Encoding/SubtitleOptions';
};

export type GetEncodingSubtitleoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEncodingSubtitleoptionsResponses = {
    /**
     * Operation successful. Returning a EditObjectContainer object.
     */
    200: EditObjectContainer;
};

export type GetEncodingSubtitleoptionsResponse = GetEncodingSubtitleoptionsResponses[keyof GetEncodingSubtitleoptionsResponses];

export type PostEncodingSubtitleoptionsData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path?: never;
    query?: never;
    url: '/Encoding/SubtitleOptions';
};

export type PostEncodingSubtitleoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostEncodingSubtitleoptionsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetEncodingFfmpegoptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Encoding/FfmpegOptions';
};

export type GetEncodingFfmpegoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEncodingFfmpegoptionsResponses = {
    /**
     * Operation successful. Returning a EditObjectContainer object.
     */
    200: EditObjectContainer;
};

export type GetEncodingFfmpegoptionsResponse = GetEncodingFfmpegoptionsResponses[keyof GetEncodingFfmpegoptionsResponses];

export type PostEncodingFfmpegoptionsData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path?: never;
    query?: never;
    url: '/Encoding/FfmpegOptions';
};

export type PostEncodingFfmpegoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostEncodingFfmpegoptionsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetEncodingCodecparametersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Codec Id
         */
        CodecId: string;
        /**
         * Parameter Context
         */
        ParameterContext: MediaEncodingCodecParameterContext;
    };
    url: '/Encoding/CodecParameters';
};

export type GetEncodingCodecparametersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEncodingCodecparametersResponses = {
    /**
     * Operation successful. Returning a EditObjectContainer object.
     */
    200: EditObjectContainer;
};

export type GetEncodingCodecparametersResponse = GetEncodingCodecparametersResponses[keyof GetEncodingCodecparametersResponses];

export type PostEncodingCodecparametersData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path?: never;
    query: {
        /**
         * Codec Id
         */
        CodecId: string;
        /**
         * Parameter Context
         */
        ParameterContext: MediaEncodingCodecParameterContext;
    };
    url: '/Encoding/CodecParameters';
};

export type PostEncodingCodecparametersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostEncodingCodecparametersResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostEnvironmentValidatepathData = {
    /**
     * ValidatePath
     */
    body: ValidatePath;
    path?: never;
    query: {
        Path: string;
    };
    url: '/Environment/ValidatePath';
};

export type PostEnvironmentValidatepathErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostEnvironmentValidatepathResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetEnvironmentDefaultdirectorybrowserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Environment/DefaultDirectoryBrowser';
};

export type GetEnvironmentDefaultdirectorybrowserErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEnvironmentDefaultdirectorybrowserResponses = {
    /**
     * Operation successful. Returning a DefaultDirectoryBrowserInfo object.
     */
    200: DefaultDirectoryBrowserInfo;
};

export type GetEnvironmentDefaultdirectorybrowserResponse = GetEnvironmentDefaultdirectorybrowserResponses[keyof GetEnvironmentDefaultdirectorybrowserResponses];

export type GetEnvironmentDirectorycontentsData = {
    body?: never;
    path?: never;
    query: {
        Path: string;
        /**
         * An optional filter to include or exclude files from the results. true/false
         */
        IncludeFiles?: boolean;
        /**
         * An optional filter to include or exclude folders from the results. true/false
         */
        IncludeDirectories?: boolean;
    };
    url: '/Environment/DirectoryContents';
};

export type GetEnvironmentDirectorycontentsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEnvironmentDirectorycontentsResponses = {
    /**
     * Operation successful. Returning a List<FileSystemEntryInfo> object.
     */
    200: Array<IoFileSystemEntryInfo>;
};

export type GetEnvironmentDirectorycontentsResponse = GetEnvironmentDirectorycontentsResponses[keyof GetEnvironmentDirectorycontentsResponses];

export type PostEnvironmentDirectorycontentsData = {
    /**
     * GetDirectoryContents
     */
    body: GetDirectoryContents;
    path?: never;
    query: {
        Path: string;
        /**
         * An optional filter to include or exclude files from the results. true/false
         */
        IncludeFiles?: boolean;
        /**
         * An optional filter to include or exclude folders from the results. true/false
         */
        IncludeDirectories?: boolean;
    };
    url: '/Environment/DirectoryContents';
};

export type PostEnvironmentDirectorycontentsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostEnvironmentDirectorycontentsResponses = {
    /**
     * Operation successful. Returning a List<FileSystemEntryInfo> object.
     */
    200: Array<IoFileSystemEntryInfo>;
};

export type PostEnvironmentDirectorycontentsResponse = PostEnvironmentDirectorycontentsResponses[keyof PostEnvironmentDirectorycontentsResponses];

export type GetEnvironmentNetworksharesData = {
    body?: never;
    path?: never;
    query: {
        Path: string;
    };
    url: '/Environment/NetworkShares';
};

export type GetEnvironmentNetworksharesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEnvironmentNetworksharesResponses = {
    /**
     * Operation successful. Returning a List<FileSystemEntryInfo> object.
     */
    200: Array<IoFileSystemEntryInfo>;
};

export type GetEnvironmentNetworksharesResponse = GetEnvironmentNetworksharesResponses[keyof GetEnvironmentNetworksharesResponses];

export type GetEnvironmentDrivesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Environment/Drives';
};

export type GetEnvironmentDrivesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEnvironmentDrivesResponses = {
    /**
     * Operation successful. Returning a List<FileSystemEntryInfo> object.
     */
    200: Array<IoFileSystemEntryInfo>;
};

export type GetEnvironmentDrivesResponse = GetEnvironmentDrivesResponses[keyof GetEnvironmentDrivesResponses];

export type GetEnvironmentNetworkdevicesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Environment/NetworkDevices';
};

export type GetEnvironmentNetworkdevicesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEnvironmentNetworkdevicesResponses = {
    /**
     * Operation successful. Returning a List<FileSystemEntryInfo> object.
     */
    200: Array<IoFileSystemEntryInfo>;
};

export type GetEnvironmentNetworkdevicesResponse = GetEnvironmentNetworkdevicesResponses[keyof GetEnvironmentNetworkdevicesResponses];

export type GetEnvironmentParentpathData = {
    body?: never;
    path?: never;
    query: {
        Path: string;
    };
    url: '/Environment/ParentPath';
};

export type GetEnvironmentParentpathErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEnvironmentParentpathResponses = {
    /**
     * Operation successful. Returning a String object.
     */
    200: string;
};

export type GetEnvironmentParentpathResponse = GetEnvironmentParentpathResponses[keyof GetEnvironmentParentpathResponses];

export type GetGamegenresByNameData = {
    body?: never;
    path: {
        /**
         * The genre name
         */
        Name: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data
         */
        UserId?: string;
    };
    url: '/GameGenres/{Name}';
};

export type GetGamegenresByNameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetGamegenresByNameResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetGamegenresByNameResponse = GetGamegenresByNameResponses[keyof GetGamegenresByNameResponses];

export type GetGenresByNameData = {
    body?: never;
    path: {
        /**
         * The genre name
         */
        Name: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data
         */
        UserId?: string;
    };
    url: '/Genres/{Name}';
};

export type GetGenresByNameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetGenresByNameResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetGenresByNameResponse = GetGenresByNameResponses[keyof GetGenresByNameResponses];

export type GetImagesRemoteData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The image url
         */
        ImageUrl: string;
    };
    url: '/Images/Remote';
};

export type GetImagesRemoteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetImagesRemoteResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostItemsByItemidData = {
    /**
     * BaseItemDto:
     */
    body: BaseItemDto;
    path: {
        /**
         * The id of the item
         */
        ItemId: string;
    };
    query?: never;
    url: '/Items/{ItemId}';
};

export type PostItemsByItemidErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByItemidResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetItemsPrefixesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Items/Prefixes';
};

export type GetItemsPrefixesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsPrefixesResponses = {
    /**
     * Operation successful. Returning a NameValuePair[] object.
     */
    200: Array<NameValuePair>;
};

export type GetItemsPrefixesResponse = GetItemsPrefixesResponses[keyof GetItemsPrefixesResponses];

export type PostItemsAccessData = {
    /**
     * UpdateUserItemAccess
     */
    body: UserLibraryUpdateUserItemAccess;
    path?: never;
    query?: never;
    url: '/Items/Access';
};

export type PostItemsAccessErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsAccessResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetItemsCountsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Get counts from a specific user's library.
         */
        UserId?: string;
        /**
         * Optional. Get counts of favorite items
         */
        IsFavorite?: boolean | null;
    };
    url: '/Items/Counts';
};

export type GetItemsCountsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsCountsResponses = {
    /**
     * Operation successful. Returning a ItemCounts object.
     */
    200: ItemCounts;
};

export type GetItemsCountsResponse = GetItemsCountsResponses[keyof GetItemsCountsResponses];

export type GetItemsIntrosData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Items/Intros';
};

export type GetItemsIntrosErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsIntrosResponses = {
    /**
     * Operation successful. Returning a List<IntroDebugInfo> object.
     */
    200: Array<PersistenceIntroDebugInfo>;
};

export type GetItemsIntrosResponse = GetItemsIntrosResponses[keyof GetItemsIntrosResponses];

export type PostItemsDeleteData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Ids
         */
        Ids: string;
    };
    url: '/Items/Delete';
};

export type PostItemsDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteItemsByIdData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}';
};

export type DeleteItemsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteItemsByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLibrariesAvailableoptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Libraries/AvailableOptions';
};

export type GetLibrariesAvailableoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLibrariesAvailableoptionsResponses = {
    /**
     * Operation successful. Returning a LibraryOptionsResult object.
     */
    200: LibraryOptionsResult;
};

export type GetLibrariesAvailableoptionsResponse = GetLibrariesAvailableoptionsResponses[keyof GetLibrariesAvailableoptionsResponses];

export type GetLibrarySelectablemediafoldersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/SelectableMediaFolders';
};

export type GetLibrarySelectablemediafoldersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLibrarySelectablemediafoldersResponses = {
    /**
     * Operation successful. Returning a MediaFolder[] object.
     */
    200: Array<LibraryMediaFolder>;
};

export type GetLibrarySelectablemediafoldersResponse = GetLibrarySelectablemediafoldersResponses[keyof GetLibrarySelectablemediafoldersResponses];

export type GetLibraryMediafoldersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by folders that are marked hidden, or not.
         */
        IsHidden?: boolean | null;
    };
    url: '/Library/MediaFolders';
};

export type GetLibraryMediafoldersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLibraryMediafoldersResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetLibraryMediafoldersResponse = GetLibraryMediafoldersResponses[keyof GetLibraryMediafoldersResponses];

export type GetLibraryPhysicalpathsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/PhysicalPaths';
};

export type GetLibraryPhysicalpathsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLibraryPhysicalpathsResponses = {
    /**
     * Operation successful. Returning a List<String> object.
     */
    200: Array<string>;
};

export type GetLibraryPhysicalpathsResponse = GetLibraryPhysicalpathsResponses[keyof GetLibraryPhysicalpathsResponses];

export type PostLibraryRefreshData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/Refresh';
};

export type PostLibraryRefreshErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryRefreshResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteLibraryVirtualfoldersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders';
};

export type DeleteLibraryVirtualfoldersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteLibraryVirtualfoldersResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLibraryVirtualfoldersData = {
    /**
     * AddVirtualFolder
     */
    body: LibraryAddVirtualFolder;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders';
};

export type PostLibraryVirtualfoldersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryVirtualfoldersResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLivestreamsOpenData = {
    /**
     * LiveStreamRequest:
     */
    body: LiveStreamRequest;
    path?: never;
    query?: never;
    url: '/LiveStreams/Open';
};

export type PostLivestreamsOpenErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivestreamsOpenResponses = {
    /**
     * Operation successful. Returning a LiveStreamResponse object.
     */
    200: LiveStreamResponse;
};

export type PostLivestreamsOpenResponse = PostLivestreamsOpenResponses[keyof PostLivestreamsOpenResponses];

export type PostLivestreamsCloseData = {
    body?: never;
    path?: never;
    query: {
        /**
         * LiveStreamId
         */
        LiveStreamId: string;
    };
    url: '/LiveStreams/Close';
};

export type PostLivestreamsCloseErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivestreamsCloseResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLivestreamsMediainfoData = {
    body?: never;
    path?: never;
    query: {
        /**
         * LiveStreamId
         */
        LiveStreamId: string;
    };
    url: '/LiveStreams/MediaInfo';
};

export type PostLivestreamsMediainfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivestreamsMediainfoResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvChanneltagsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/LiveTv/ChannelTags';
};

export type GetLivetvChanneltagsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvChanneltagsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetLivetvChanneltagsResponse = GetLivetvChanneltagsResponses[keyof GetLivetvChanneltagsResponses];

export type GetLivetvFolderData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/Folder';
};

export type GetLivetvFolderErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvFolderResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetLivetvFolderResponse = GetLivetvFolderResponses[keyof GetLivetvFolderResponses];

export type DeleteLivetvChannelmappingsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Provider id
         */
        ProviderId: string;
    };
    url: '/LiveTv/ChannelMappings';
};

export type DeleteLivetvChannelmappingsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteLivetvChannelmappingsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvChannelmappingsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Provider id
         */
        ProviderId: string;
    };
    url: '/LiveTv/ChannelMappings';
};

export type GetLivetvChannelmappingsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvChannelmappingsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadLivetvChannelmappingsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Provider id
         */
        ProviderId: string;
    };
    url: '/LiveTv/ChannelMappings';
};

export type HeadLivetvChannelmappingsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadLivetvChannelmappingsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostLivetvChannelmappingsData = {
    /**
     * SetChannelMapping
     */
    body: ApiSetChannelMapping;
    path?: never;
    query: {
        /**
         * Provider id
         */
        ProviderId: string;
    };
    url: '/LiveTv/ChannelMappings';
};

export type PostLivetvChannelmappingsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvChannelmappingsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PutLivetvChannelmappingsData = {
    /**
     * SetChannelMapping
     */
    body: ApiSetChannelMapping;
    path?: never;
    query: {
        /**
         * Provider id
         */
        ProviderId: string;
    };
    url: '/LiveTv/ChannelMappings';
};

export type PutLivetvChannelmappingsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PutLivetvChannelmappingsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type DeleteLivetvChannelmappingoptionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Provider id
         */
        ProviderId: string;
    };
    url: '/LiveTv/ChannelMappingOptions';
};

export type DeleteLivetvChannelmappingoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteLivetvChannelmappingoptionsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvChannelmappingoptionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Provider id
         */
        ProviderId: string;
    };
    url: '/LiveTv/ChannelMappingOptions';
};

export type GetLivetvChannelmappingoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvChannelmappingoptionsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadLivetvChannelmappingoptionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Provider id
         */
        ProviderId: string;
    };
    url: '/LiveTv/ChannelMappingOptions';
};

export type HeadLivetvChannelmappingoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadLivetvChannelmappingoptionsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostLivetvChannelmappingoptionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Provider id
         */
        ProviderId: string;
    };
    url: '/LiveTv/ChannelMappingOptions';
};

export type PostLivetvChannelmappingoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvChannelmappingoptionsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PutLivetvChannelmappingoptionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Provider id
         */
        ProviderId: string;
    };
    url: '/LiveTv/ChannelMappingOptions';
};

export type PutLivetvChannelmappingoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PutLivetvChannelmappingoptionsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type DeleteLivetvListingprovidersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Provider id
         */
        Id?: string;
    };
    url: '/LiveTv/ListingProviders';
};

export type DeleteLivetvListingprovidersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteLivetvListingprovidersResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvListingprovidersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Channel id
         */
        ChannelId: string;
    };
    url: '/LiveTv/ListingProviders';
};

export type GetLivetvListingprovidersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvListingprovidersResponses = {
    /**
     * Operation successful. Returning a ListingsProviderInfo[] object.
     */
    200: Array<LiveTvListingsProviderInfo>;
};

export type GetLivetvListingprovidersResponse = GetLivetvListingprovidersResponses[keyof GetLivetvListingprovidersResponses];

export type PostLivetvListingprovidersData = {
    /**
     * ListingsProviderInfo:
     */
    body: LiveTvListingsProviderInfo;
    path?: never;
    query?: never;
    url: '/LiveTv/ListingProviders';
};

export type PostLivetvListingprovidersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvListingprovidersResponses = {
    /**
     * Operation successful. Returning a ListingsProviderInfo object.
     */
    200: LiveTvListingsProviderInfo;
};

export type PostLivetvListingprovidersResponse = PostLivetvListingprovidersResponses[keyof PostLivetvListingprovidersResponses];

export type DeleteLivetvTunerhostsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Tuner host id
         */
        Id?: string;
    };
    url: '/LiveTv/TunerHosts';
};

export type DeleteLivetvTunerhostsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteLivetvTunerhostsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvTunerhostsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/TunerHosts';
};

export type GetLivetvTunerhostsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvTunerhostsResponses = {
    /**
     * Operation successful. Returning a TunerHostInfo[] object.
     */
    200: Array<LiveTvTunerHostInfo>;
};

export type GetLivetvTunerhostsResponse = GetLivetvTunerhostsResponses[keyof GetLivetvTunerhostsResponses];

export type PostLivetvTunerhostsData = {
    /**
     * TunerHostInfo:
     */
    body: LiveTvTunerHostInfo;
    path?: never;
    query?: never;
    url: '/LiveTv/TunerHosts';
};

export type PostLivetvTunerhostsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvTunerhostsResponses = {
    /**
     * Operation successful. Returning a TunerHostInfo object.
     */
    200: LiveTvTunerHostInfo;
};

export type PostLivetvTunerhostsResponse = PostLivetvTunerhostsResponses[keyof PostLivetvTunerhostsResponses];

export type GetLivetvInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/Info';
};

export type GetLivetvInfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvInfoResponses = {
    /**
     * Operation successful. Returning a LiveTvInfo object.
     */
    200: LiveTvLiveTvInfo;
};

export type GetLivetvInfoResponse = GetLivetvInfoResponses[keyof GetLivetvInfoResponses];

export type GetLivetvEpgData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter by channel type.
         */
        Type?: LiveTvChannelType;
        /**
         * Filter by channels that are liked, or not.
         */
        IsLiked?: boolean | null;
        /**
         * Filter by channels that are disliked, or not.
         */
        IsDisliked?: boolean | null;
        /**
         * Incorporate favorite and like status into channel sorting.
         */
        EnableFavoriteSorting?: boolean;
        /**
         * Optional. Adds current program info to each channel
         */
        AddCurrentProgram?: boolean;
        /**
         * The channels to return guide information for.
         */
        ChannelIds?: string;
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/LiveTv/EPG';
};

export type GetLivetvEpgErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvEpgResponses = {
    /**
     * Operation successful. Returning a QueryResult<EpgRow> object.
     */
    200: QueryResultApiEpgRow;
};

export type GetLivetvEpgResponse = GetLivetvEpgResponses[keyof GetLivetvEpgResponses];

export type GetLivetvChannelsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter by channel type.
         */
        Type?: LiveTvChannelType;
        /**
         * Filter by channels that are liked, or not.
         */
        IsLiked?: boolean | null;
        /**
         * Filter by channels that are disliked, or not.
         */
        IsDisliked?: boolean | null;
        /**
         * Incorporate favorite and like status into channel sorting.
         */
        EnableFavoriteSorting?: boolean;
        /**
         * Optional. Adds current program info to each channel
         */
        AddCurrentProgram?: boolean;
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/LiveTv/Channels';
};

export type GetLivetvChannelsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvChannelsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetLivetvChannelsResponse = GetLivetvChannelsResponses[keyof GetLivetvChannelsResponses];

export type GetLivetvProgramsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The channels to return guide information for.
         */
        ChannelIds?: string;
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/LiveTv/Programs';
};

export type GetLivetvProgramsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvProgramsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostLivetvProgramsData = {
    /**
     * BaseItemsRequest:
     */
    body: ApiBaseItemsRequest;
    path?: never;
    query?: {
        /**
         * The channels to return guide information for.
         */
        ChannelIds?: string;
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/LiveTv/Programs';
};

export type PostLivetvProgramsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvProgramsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvRecordingsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter by channel id.
         */
        ChannelId?: string;
        /**
         * Optional filter by recording status.
         */
        Status?: LiveTvRecordingStatus;
        /**
         * Optional filter by recordings that are in progress, or not.
         */
        IsInProgress?: boolean | null;
        /**
         * Optional filter by recordings belonging to a series timer
         */
        SeriesTimerId?: string;
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/LiveTv/Recordings';
};

export type GetLivetvRecordingsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvRecordingsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvTimersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter by channel id.
         */
        ChannelId?: string;
        /**
         * Optional filter by timers belonging to a series timer
         */
        SeriesTimerId?: string;
    };
    url: '/LiveTv/Timers';
};

export type GetLivetvTimersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvTimersResponses = {
    /**
     * Operation successful. Returning a QueryResult<TimerInfoDto> object.
     */
    200: QueryResultLiveTvTimerInfoDto;
};

export type GetLivetvTimersResponse = GetLivetvTimersResponses[keyof GetLivetvTimersResponses];

export type PostLivetvTimersData = {
    /**
     * TimerInfoDto:
     */
    body: LiveTvTimerInfoDto;
    path?: never;
    query?: never;
    url: '/LiveTv/Timers';
};

export type PostLivetvTimersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvTimersResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvSeriestimersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Sort by SortName or Priority
         */
        SortBy?: string;
        /**
         * Optional. Sort in Ascending or Descending order
         */
        SortOrder?: SortOrder;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
    };
    url: '/LiveTv/SeriesTimers';
};

export type GetLivetvSeriestimersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvSeriestimersResponses = {
    /**
     * Operation successful. Returning a QueryResult<SeriesTimerInfoDto> object.
     */
    200: QueryResultLiveTvSeriesTimerInfoDto;
};

export type GetLivetvSeriestimersResponse = GetLivetvSeriestimersResponses[keyof GetLivetvSeriestimersResponses];

export type PostLivetvSeriestimersData = {
    /**
     * SeriesTimerInfo:
     */
    body: LiveTvSeriesTimerInfo;
    path?: never;
    query?: never;
    url: '/LiveTv/SeriesTimers';
};

export type PostLivetvSeriestimersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvSeriestimersResponses = {
    /**
     * Operation successful. Returning a SeriesTimerInfoDto object.
     */
    200: LiveTvSeriesTimerInfoDto;
};

export type PostLivetvSeriestimersResponse = PostLivetvSeriestimersResponses[keyof PostLivetvSeriestimersResponses];

export type GetLivetvGuideinfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/GuideInfo';
};

export type GetLivetvGuideinfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvGuideinfoResponses = {
    /**
     * Operation successful. Returning a GuideInfo object.
     */
    200: LiveTvGuideInfo;
};

export type GetLivetvGuideinfoResponse = GetLivetvGuideinfoResponses[keyof GetLivetvGuideinfoResponses];

export type GetLivetvAvailablerecordingoptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/AvailableRecordingOptions';
};

export type GetLivetvAvailablerecordingoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvAvailablerecordingoptionsResponses = {
    /**
     * Operation successful. Returning a AvailableRecordingOptions object.
     */
    200: ApiAvailableRecordingOptions;
};

export type GetLivetvAvailablerecordingoptionsResponse = GetLivetvAvailablerecordingoptionsResponses[keyof GetLivetvAvailablerecordingoptionsResponses];

export type GetLocalizationParentalratingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Localization/ParentalRatings';
};

export type GetLocalizationParentalratingsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLocalizationParentalratingsResponses = {
    /**
     * Operation successful. Returning a ParentalRating[] object.
     */
    200: Array<ParentalRating>;
};

export type GetLocalizationParentalratingsResponse = GetLocalizationParentalratingsResponses[keyof GetLocalizationParentalratingsResponses];

export type GetLocalizationOptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Localization/Options';
};

export type GetLocalizationOptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLocalizationOptionsResponses = {
    /**
     * Operation successful. Returning a LocalizatonOption[] object.
     */
    200: Array<GlobalizationLocalizatonOption>;
};

export type GetLocalizationOptionsResponse = GetLocalizationOptionsResponses[keyof GetLocalizationOptionsResponses];

export type GetLocalizationCountriesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Localization/Countries';
};

export type GetLocalizationCountriesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLocalizationCountriesResponses = {
    /**
     * Operation successful. Returning a CountryInfo[] object.
     */
    200: Array<GlobalizationCountryInfo>;
};

export type GetLocalizationCountriesResponse = GetLocalizationCountriesResponses[keyof GetLocalizationCountriesResponses];

export type GetLocalizationCulturesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Localization/Cultures';
};

export type GetLocalizationCulturesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLocalizationCulturesResponses = {
    /**
     * Operation successful. Returning a CultureDto[] object.
     */
    200: Array<GlobalizationCultureDto>;
};

export type GetLocalizationCulturesResponse = GetLocalizationCulturesResponses[keyof GetLocalizationCulturesResponses];

export type GetMoviesRecommendationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The max number of categories to return
         */
        CategoryLimit?: number;
        /**
         * The max number of items to return per category
         */
        ItemLimit?: number;
        /**
         * Optional. Filter by user id, and attach user data
         */
        UserId?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
    };
    url: '/Movies/Recommendations';
};

export type GetMoviesRecommendationsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetMoviesRecommendationsResponses = {
    /**
     * Operation successful. Returning a RecommendationDto[] object.
     */
    200: Array<RecommendationDto>;
};

export type GetMoviesRecommendationsResponse = GetMoviesRecommendationsResponses[keyof GetMoviesRecommendationsResponses];

export type GetMusicgenresByNameData = {
    body?: never;
    path: {
        /**
         * The genre name
         */
        Name: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data
         */
        UserId?: string;
    };
    url: '/MusicGenres/{Name}';
};

export type GetMusicgenresByNameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetMusicgenresByNameResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetMusicgenresByNameResponse = GetMusicgenresByNameResponses[keyof GetMusicgenresByNameResponses];

export type GetMusicgenresInstantmixData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/MusicGenres/InstantMix';
};

export type GetMusicgenresInstantmixErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetMusicgenresInstantmixResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetMusicgenresInstantmixResponse = GetMusicgenresInstantmixResponses[keyof GetMusicgenresInstantmixResponses];

export type GetNotificationsTypesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Notifications/Types';
};

export type GetNotificationsTypesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetNotificationsTypesResponses = {
    /**
     * Operation successful. Returning a NotificationCategoryInfo[] object.
     */
    200: Array<NotificationCategoryInfo>;
};

export type GetNotificationsTypesResponse = GetNotificationsTypesResponses[keyof GetNotificationsTypesResponses];

export type PostNotificationsAdminData = {
    /**
     * AddAdminNotification
     */
    body: ApiAddAdminNotification;
    path?: never;
    query: {
        /**
         * The notification's name
         */
        Name: string;
        /**
         * The notification's description
         */
        Description: string;
        /**
         * The notification's image url
         */
        ImageUrl?: string;
        /**
         * The notification's info url
         */
        Url?: string;
        /**
         * The notification level
         */
        Level?: string;
    };
    url: '/Notifications/Admin';
};

export type PostNotificationsAdminErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostNotificationsAdminResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetPackagesUpdatesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Package type filter (System/UserInstalled)
         */
        PackageType: string;
    };
    url: '/Packages/Updates';
};

export type GetPackagesUpdatesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPackagesUpdatesResponses = {
    /**
     * Operation successful. Returning a PackageVersionInfo[] object.
     */
    200: Array<PackageVersionInfo>;
};

export type GetPackagesUpdatesResponse = GetPackagesUpdatesResponses[keyof GetPackagesUpdatesResponses];

export type GetPackagesByNameData = {
    body?: never;
    path: {
        /**
         * The name of the package
         */
        Name: string;
    };
    query?: {
        /**
         * The guid of the associated assembly
         */
        AssemblyGuid?: string;
    };
    url: '/Packages/{Name}';
};

export type GetPackagesByNameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPackagesByNameResponses = {
    /**
     * Operation successful. Returning a PackageInfo object.
     */
    200: PackageInfo;
};

export type GetPackagesByNameResponse = GetPackagesByNameResponses[keyof GetPackagesByNameResponses];

export type GetPersonsByNameData = {
    body?: never;
    path: {
        /**
         * The person name
         */
        Name: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data
         */
        UserId?: string;
    };
    url: '/Persons/{Name}';
};

export type GetPersonsByNameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPersonsByNameResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetPersonsByNameResponse = GetPersonsByNameResponses[keyof GetPersonsByNameResponses];

export type GetPlaybackBitratetestData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Size
         */
        Size: number;
    };
    url: '/Playback/BitrateTest';
};

export type GetPlaybackBitratetestErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPlaybackBitratetestResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type DeletePluginsByIdData = {
    body?: never;
    path: {
        /**
         * Plugin Id
         */
        Id: string;
    };
    query?: never;
    url: '/Plugins/{Id}';
};

export type DeletePluginsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeletePluginsByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetScheduledtasksByIdData = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/ScheduledTasks/{Id}';
};

export type GetScheduledtasksByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetScheduledtasksByIdResponses = {
    /**
     * Operation successful. Returning a TaskInfo object.
     */
    200: TaskInfo;
};

export type GetScheduledtasksByIdResponse = GetScheduledtasksByIdResponses[keyof GetScheduledtasksByIdResponses];

export type GetSessionsPlayqueueData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. Filter by session id.
         */
        Id?: string;
        /**
         * Optional. Filter by device id.
         */
        DeviceId?: string;
    };
    url: '/Sessions/PlayQueue';
};

export type GetSessionsPlayqueueErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSessionsPlayqueueResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetSessionsPlayqueueResponse = GetSessionsPlayqueueResponses[keyof GetSessionsPlayqueueResponses];

export type PostSessionsLogoutData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Sessions/Logout';
};

export type PostSessionsLogoutErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsLogoutResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsCapabilitiesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Session Id
         */
        Id: string;
        /**
         * A list of playable media types, comma delimited. Audio, Video, Book, Game, Photo.
         */
        PlayableMediaTypes?: string;
        /**
         * A list of supported remote control commands, comma delimited
         */
        SupportedCommands?: string;
        /**
         * Determines whether media can be played remotely.
         */
        SupportsMediaControl?: boolean;
        /**
         * Determines whether sync is supported.
         */
        SupportsSync?: boolean;
    };
    url: '/Sessions/Capabilities';
};

export type PostSessionsCapabilitiesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsCapabilitiesResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsPlayingData = {
    /**
     * PlaybackStartInfo:
     */
    body: PlaybackStartInfo;
    path?: never;
    query?: never;
    url: '/Sessions/Playing';
};

export type PostSessionsPlayingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsPlayingResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetShowsMissingData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Shows/Missing';
};

export type GetShowsMissingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetShowsMissingResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetShowsUpcomingData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Shows/Upcoming';
};

export type GetShowsUpcomingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetShowsUpcomingResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetShowsNextupData = {
    body?: never;
    path?: never;
    query: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         */
        Fields?: string;
        /**
         * Optional. Filter by series id
         */
        SeriesId?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
    };
    url: '/Shows/NextUp';
};

export type GetShowsNextupErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetShowsNextupResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetShowsNextupResponse = GetShowsNextupResponses[keyof GetShowsNextupResponses];

export type GetStudiosByNameData = {
    body?: never;
    path: {
        /**
         * The studio name
         */
        Name: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data
         */
        UserId?: string;
    };
    url: '/Studios/{Name}';
};

export type GetStudiosByNameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetStudiosByNameResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetStudiosByNameResponse = GetStudiosByNameResponses[keyof GetStudiosByNameResponses];

export type GetSyncTargetsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * UserId
         */
        UserId: string;
    };
    url: '/Sync/Targets';
};

export type GetSyncTargetsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSyncTargetsResponses = {
    /**
     * Operation successful. Returning a List<SyncTarget> object.
     */
    200: Array<SyncTarget>;
};

export type GetSyncTargetsResponse = GetSyncTargetsResponses[keyof GetSyncTargetsResponses];

export type GetSyncJobsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Sync/Jobs';
};

export type GetSyncJobsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSyncJobsResponses = {
    /**
     * Operation successful. Returning a QueryResult<SyncJob> object.
     */
    200: QueryResultSyncJob;
};

export type GetSyncJobsResponse = GetSyncJobsResponses[keyof GetSyncJobsResponses];

export type PostSyncJobsData = {
    /**
     * SyncJobRequest:
     */
    body: SyncJobRequest;
    path?: never;
    query?: never;
    url: '/Sync/Jobs';
};

export type PostSyncJobsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncJobsResponses = {
    /**
     * Operation successful. Returning a SyncJobCreationResult object.
     */
    200: SyncJobCreationResult;
};

export type PostSyncJobsResponse = PostSyncJobsResponses[keyof PostSyncJobsResponses];

export type GetSyncJobitemsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * TargetId
         */
        TargetId: string;
    };
    url: '/Sync/JobItems';
};

export type GetSyncJobitemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSyncJobitemsResponses = {
    /**
     * Operation successful. Returning a QueryResult<SyncJobItem> object.
     */
    200: QueryResultSyncJobItem;
};

export type GetSyncJobitemsResponse = GetSyncJobitemsResponses[keyof GetSyncJobitemsResponses];

export type GetSyncOptionsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * UserId
         */
        UserId: string;
        /**
         * ItemIds
         */
        ItemIds?: string;
        /**
         * ParentId
         */
        ParentId?: string;
        /**
         * TargetId
         */
        TargetId?: string;
        /**
         * Category
         */
        Category?: SyncCategory;
    };
    url: '/Sync/Options';
};

export type GetSyncOptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSyncOptionsResponses = {
    /**
     * Operation successful. Returning a SyncDialogOptions object.
     */
    200: SyncDialogOptions;
};

export type GetSyncOptionsResponse = GetSyncOptionsResponses[keyof GetSyncOptionsResponses];

export type PostSyncOfflineactionsData = {
    /**
     * List`1:
     */
    body: Array<UserAction>;
    path?: never;
    query?: never;
    url: '/Sync/OfflineActions';
};

export type PostSyncOfflineactionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncOfflineactionsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSyncDataData = {
    /**
     * SyncDataRequest:
     */
    body: SyncDataRequest;
    path?: never;
    query: {
        /**
         * TargetId
         */
        TargetId: string;
    };
    url: '/Sync/Data';
};

export type PostSyncDataErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncDataResponses = {
    /**
     * Operation successful. Returning a SyncDataResponse object.
     */
    200: SyncDataResponse;
};

export type PostSyncDataResponse = PostSyncDataResponses[keyof PostSyncDataResponses];

export type GetSystemConfigurationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Configuration';
};

export type GetSystemConfigurationErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemConfigurationResponses = {
    /**
     * Operation successful. Returning a ServerConfiguration object.
     */
    200: ServerConfiguration;
};

export type GetSystemConfigurationResponse = GetSystemConfigurationResponses[keyof GetSystemConfigurationResponses];

export type PostSystemConfigurationData = {
    /**
     * ServerConfiguration:
     */
    body: ServerConfiguration;
    path?: never;
    query?: never;
    url: '/System/Configuration';
};

export type PostSystemConfigurationErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSystemConfigurationResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetSystemReleasenotesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/ReleaseNotes';
};

export type GetSystemReleasenotesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemReleasenotesResponses = {
    /**
     * Operation successful. Returning a PackageVersionInfo object.
     */
    200: PackageVersionInfo;
};

export type GetSystemReleasenotesResponse = GetSystemReleasenotesResponses[keyof GetSystemReleasenotesResponses];

export type GetSystemPingData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Ping';
};

export type GetSystemPingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemPingResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type HeadSystemPingData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Ping';
};

export type HeadSystemPingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadSystemPingResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSystemPingData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Ping';
};

export type PostSystemPingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSystemPingResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetSystemWakeonlaninfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/WakeOnLanInfo';
};

export type GetSystemWakeonlaninfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemWakeonlaninfoResponses = {
    /**
     * Operation successful. Returning a WakeOnLanInfo[] object.
     */
    200: Array<WakeOnLanInfo>;
};

export type GetSystemWakeonlaninfoResponse = GetSystemWakeonlaninfoResponses[keyof GetSystemWakeonlaninfoResponses];

export type GetSystemInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Info';
};

export type GetSystemInfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemInfoResponses = {
    /**
     * Operation successful. Returning a SystemInfo object.
     */
    200: SystemInfo;
};

export type GetSystemInfoResponse = GetSystemInfoResponses[keyof GetSystemInfoResponses];

export type PostSystemRestartData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Restart';
};

export type PostSystemRestartErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSystemRestartResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostSystemShutdownData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Shutdown';
};

export type PostSystemShutdownErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSystemShutdownResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetSystemEndpointData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Endpoint';
};

export type GetSystemEndpointErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemEndpointResponses = {
    /**
     * Operation successful. Returning a EndPointInfo object.
     */
    200: NetEndPointInfo;
};

export type GetSystemEndpointResponse = GetSystemEndpointResponses[keyof GetSystemEndpointResponses];

export type GetUiViewData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Id of the page controller
         */
        PageId: string;
        /**
         * Locale identifier of the client
         */
        ClientLocale: string;
    };
    url: '/UI/View';
};

export type GetUiViewErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUiViewResponses = {
    /**
     * Operation successful. Returning a UIViewInfo object.
     */
    200: UiViewInfo;
};

export type GetUiViewResponse = GetUiViewResponses[keyof GetUiViewResponses];

export type PostUiCommandData = {
    /**
     * RunUICommand
     */
    body: RunUiCommand;
    path?: never;
    query?: never;
    url: '/UI/Command';
};

export type PostUiCommandErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUiCommandResponses = {
    /**
     * Operation successful. Returning a UIViewInfo object.
     */
    200: UiViewInfo;
};

export type PostUiCommandResponse = PostUiCommandResponses[keyof PostUiCommandResponses];

export type GetUsersPublicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Users/Public';
};

export type GetUsersPublicErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersPublicResponses = {
    /**
     * Operation successful. Returning a UserDto[] object.
     */
    200: Array<UserDto>;
};

export type GetUsersPublicResponse = GetUsersPublicResponses[keyof GetUsersPublicResponses];

export type GetUsersQueryData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter by IsHidden=true or false
         */
        IsHidden?: boolean | null;
        /**
         * Optional filter by IsDisabled=true or false
         */
        IsDisabled?: boolean | null;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
    };
    url: '/Users/Query';
};

export type GetUsersQueryErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersQueryResponses = {
    /**
     * Operation successful. Returning a QueryResult<UserDto> object.
     */
    200: QueryResultUserDto;
};

export type GetUsersQueryResponse = GetUsersQueryResponses[keyof GetUsersQueryResponses];

export type GetUsersPrefixesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter by IsHidden=true or false
         */
        IsHidden?: boolean | null;
        /**
         * Optional filter by IsDisabled=true or false
         */
        IsDisabled?: boolean | null;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
    };
    url: '/Users/Prefixes';
};

export type GetUsersPrefixesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersPrefixesResponses = {
    /**
     * Operation successful. Returning a NameIdPair[] object.
     */
    200: Array<NameIdPair>;
};

export type GetUsersPrefixesResponse = GetUsersPrefixesResponses[keyof GetUsersPrefixesResponses];

export type GetUsersItemaccessData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional filter by IsHidden=true or false
         */
        IsHidden?: boolean | null;
        /**
         * Optional filter by IsDisabled=true or false
         */
        IsDisabled?: boolean | null;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
    };
    url: '/Users/ItemAccess';
};

export type GetUsersItemaccessErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersItemaccessResponses = {
    /**
     * Operation successful. Returning a QueryResult<UserDto> object.
     */
    200: QueryResultUserDto;
};

export type GetUsersItemaccessResponse = GetUsersItemaccessResponses[keyof GetUsersItemaccessResponses];

export type DeleteUsersByIdData = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}';
};

export type DeleteUsersByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteUsersByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetUsersByIdData = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}';
};

export type GetUsersByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByIdResponses = {
    /**
     * Operation successful. Returning a UserDto object.
     */
    200: UserDto;
};

export type GetUsersByIdResponse = GetUsersByIdResponses[keyof GetUsersByIdResponses];

export type PostUsersByIdData = {
    /**
     * UserDto:
     */
    body: UserDto;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}';
};

export type PostUsersByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersAuthenticatebynameData = {
    /**
     * AuthenticateUserByName
     */
    body: AuthenticateUserByName;
    headers: {
        /**
         * The authorization header can be either named 'Authorization' or 'X-Emby-Authorization'.
         * It must be of the following schema:
         * Emby UserId="(guid)", Client="(string)", Device="(string)", DeviceId="(string)", Version="string", Token="(string)"
         * Please consult the documentation for further details.
         */
        'X-Emby-Authorization': string;
    };
    path?: never;
    query?: never;
    url: '/Users/AuthenticateByName';
};

export type PostUsersAuthenticatebynameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersAuthenticatebynameResponses = {
    /**
     * Operation successful. Returning a AuthenticationResult object.
     */
    200: AuthenticationAuthenticationResult;
};

export type PostUsersAuthenticatebynameResponse = PostUsersAuthenticatebynameResponses[keyof PostUsersAuthenticatebynameResponses];

export type PostUsersNewData = {
    /**
     * CreateUserByName
     */
    body: CreateUserByName;
    path?: never;
    query?: never;
    url: '/Users/New';
};

export type PostUsersNewErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersNewResponses = {
    /**
     * Operation successful. Returning a UserDto object.
     */
    200: UserDto;
};

export type PostUsersNewResponse = PostUsersNewResponses[keyof PostUsersNewResponses];

export type PostUsersForgotpasswordData = {
    /**
     * ForgotPassword
     */
    body: ForgotPassword;
    path?: never;
    query?: never;
    url: '/Users/ForgotPassword';
};

export type PostUsersForgotpasswordErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersForgotpasswordResponses = {
    /**
     * Operation successful. Returning a ForgotPasswordResult object.
     */
    200: ForgotPasswordResult;
};

export type PostUsersForgotpasswordResponse = PostUsersForgotpasswordResponses[keyof PostUsersForgotpasswordResponses];

export type GetUsersettingsByUseridData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
    };
    query?: never;
    url: '/UserSettings/{UserId}';
};

export type GetUsersettingsByUseridErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersettingsByUseridResponses = {
    /**
     * Operation successful. Returning a Dictionary<String,String> object.
     */
    200: {
        [key: string]: string;
    };
};

export type GetUsersettingsByUseridResponse = GetUsersettingsByUseridResponses[keyof GetUsersettingsByUseridResponses];

export type PostUsersettingsByUseridData = {
    /**
     * UserSettings:
     */
    body: Array<string>;
    path: {
        /**
         * User Id
         */
        UserId: string;
    };
    query?: never;
    url: '/UserSettings/{UserId}';
};

export type PostUsersettingsByUseridErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersettingsByUseridResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostVideosMergeversionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Item id list. This allows multiple, comma delimited.
         */
        Ids?: string;
    };
    url: '/Videos/MergeVersions';
};

export type PostVideosMergeversionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostVideosMergeversionsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteVideosActiveencodingsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId: string;
        /**
         * The play session id
         */
        PlaySessionId: string;
    };
    url: '/Videos/ActiveEncodings';
};

export type DeleteVideosActiveencodingsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteVideosActiveencodingsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetWebConfigurationpageData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/web/ConfigurationPage';
};

export type GetWebConfigurationpageErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetWebConfigurationpageResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetWebConfigurationpagesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/web/ConfigurationPages';
};

export type GetWebConfigurationpagesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetWebConfigurationpagesResponses = {
    /**
     * Operation successful. Returning a List<ConfigurationPageInfo> object.
     */
    200: Array<ApiConfigurationPageInfo>;
};

export type GetWebConfigurationpagesResponse = GetWebConfigurationpagesResponses[keyof GetWebConfigurationpagesResponses];

export type GetWebStringsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/web/strings';
};

export type GetWebStringsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetWebStringsResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetWebStringsetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/web/stringset';
};

export type GetWebStringsetErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetWebStringsetResponses = {
    /**
     * Operation successful. Returning a String[] object.
     */
    200: Array<string>;
};

export type GetWebStringsetResponse = GetWebStringsetResponses[keyof GetWebStringsetResponses];

export type GetAlbumsByIdInstantmixData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Albums/{Id}/InstantMix';
};

export type GetAlbumsByIdInstantmixErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAlbumsByIdInstantmixResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetAlbumsByIdInstantmixResponse = GetAlbumsByIdInstantmixResponses[keyof GetAlbumsByIdInstantmixResponses];

export type GetAlbumsByIdSimilarData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Albums/{Id}/Similar';
};

export type GetAlbumsByIdSimilarErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAlbumsByIdSimilarResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetAlbumsByIdSimilarResponse = GetAlbumsByIdSimilarResponses[keyof GetAlbumsByIdSimilarResponses];

export type GetArtistsByIdSimilarData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Artists/{Id}/Similar';
};

export type GetArtistsByIdSimilarErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetArtistsByIdSimilarResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetArtistsByIdSimilarResponse = GetArtistsByIdSimilarResponses[keyof GetArtistsByIdSimilarResponses];

export type GetAudioByIdUniversalByContainerData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        Container: string;
    };
    query?: {
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
    };
    url: '/Audio/{Id}/universal.{Container}';
};

export type GetAudioByIdUniversalByContainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudioByIdUniversalByContainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadAudioByIdUniversalByContainerData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        Container: string;
    };
    query?: {
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
    };
    url: '/Audio/{Id}/universal.{Container}';
};

export type HeadAudioByIdUniversalByContainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadAudioByIdUniversalByContainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetAudioByIdUniversalData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
    };
    url: '/Audio/{Id}/universal';
};

export type GetAudioByIdUniversalErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudioByIdUniversalResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadAudioByIdUniversalData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
    };
    url: '/Audio/{Id}/universal';
};

export type HeadAudioByIdUniversalErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadAudioByIdUniversalResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetAudioByIdStreamByContainerData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Container
         */
        Container: string;
    };
    query?: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Audio/{Id}/stream.{Container}';
};

export type GetAudioByIdStreamByContainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudioByIdStreamByContainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadAudioByIdStreamByContainerData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Container
         */
        Container: string;
    };
    query?: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Audio/{Id}/stream.{Container}';
};

export type HeadAudioByIdStreamByContainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadAudioByIdStreamByContainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetAudioByIdStreamData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Audio/{Id}/stream';
};

export type GetAudioByIdStreamErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudioByIdStreamResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadAudioByIdStreamData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Audio/{Id}/stream';
};

export type HeadAudioByIdStreamErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadAudioByIdStreamResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetAudioByIdByStreamfilenameData = {
    body?: never;
    path: {
        StreamFileName: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Audio/{Id}/{StreamFileName}';
};

export type GetAudioByIdByStreamfilenameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudioByIdByStreamfilenameResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadAudioByIdByStreamfilenameData = {
    body?: never;
    path: {
        StreamFileName: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Audio/{Id}/{StreamFileName}';
};

export type HeadAudioByIdByStreamfilenameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadAudioByIdByStreamfilenameResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetAudioByIdMasterM3U8Data = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Audio/{Id}/master.m3u8';
};

export type GetAudioByIdMasterM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudioByIdMasterM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadAudioByIdMasterM3U8Data = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Audio/{Id}/master.m3u8';
};

export type HeadAudioByIdMasterM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadAudioByIdMasterM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetAudioByIdLiveM3U8Data = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Audio/{Id}/live.m3u8';
};

export type GetAudioByIdLiveM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudioByIdLiveM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetAudioByIdMainM3U8Data = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Audio/{Id}/main.m3u8';
};

export type GetAudioByIdMainM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudioByIdMainM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type DeleteAuthKeysByKeyData = {
    body?: never;
    path: {
        /**
         * Auth Key
         */
        Key: string;
    };
    query?: never;
    url: '/Auth/Keys/{Key}';
};

export type DeleteAuthKeysByKeyErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteAuthKeysByKeyResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type DeleteCollectionsByIdItemsData = {
    body?: never;
    path: {
        Id: string;
    };
    query: {
        /**
         * Item id, comma delimited
         */
        Ids: string;
    };
    url: '/Collections/{Id}/Items';
};

export type DeleteCollectionsByIdItemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteCollectionsByIdItemsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostCollectionsByIdItemsData = {
    body?: never;
    path: {
        Id: string;
    };
    query: {
        /**
         * Item id, comma delimited
         */
        Ids: string;
    };
    url: '/Collections/{Id}/Items';
};

export type PostCollectionsByIdItemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostCollectionsByIdItemsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetDlnaByUuidDescriptionXmlData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/description.xml';
};

export type GetDlnaByUuidDescriptionXmlErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaByUuidDescriptionXmlResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadDlnaByUuidDescriptionXmlData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/description.xml';
};

export type HeadDlnaByUuidDescriptionXmlErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadDlnaByUuidDescriptionXmlResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetDlnaByUuidDescriptionData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/description';
};

export type GetDlnaByUuidDescriptionErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaByUuidDescriptionResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadDlnaByUuidDescriptionData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/description';
};

export type HeadDlnaByUuidDescriptionErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadDlnaByUuidDescriptionResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetDlnaIconsByFilenameData = {
    body?: never;
    path: {
        /**
         * The icon filename
         */
        Filename: string;
    };
    query?: {
        /**
         * Server UuId
         */
        UuId?: string;
    };
    url: '/Dlna/icons/{Filename}';
};

export type GetDlnaIconsByFilenameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaIconsByFilenameResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type DeleteDlnaProfilesByIdData = {
    body?: never;
    path: {
        /**
         * Profile Id
         */
        Id: string;
    };
    query?: never;
    url: '/Dlna/Profiles/{Id}';
};

export type DeleteDlnaProfilesByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteDlnaProfilesByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetDlnaProfilesByIdData = {
    body?: never;
    path: {
        /**
         * Profile Id
         */
        Id: string;
    };
    query?: never;
    url: '/Dlna/Profiles/{Id}';
};

export type GetDlnaProfilesByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaProfilesByIdResponses = {
    /**
     * Operation successful. Returning a DlnaProfile object.
     */
    200: DlnaProfilesDlnaProfile;
};

export type GetDlnaProfilesByIdResponse = GetDlnaProfilesByIdResponses[keyof GetDlnaProfilesByIdResponses];

export type PostDlnaProfilesByIdData = {
    /**
     * DlnaProfile:
     */
    body: DlnaProfilesDlnaProfile;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Dlna/Profiles/{Id}';
};

export type PostDlnaProfilesByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostDlnaProfilesByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetDlnaProfilesDefaultData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Dlna/Profiles/Default';
};

export type GetDlnaProfilesDefaultErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaProfilesDefaultResponses = {
    /**
     * Operation successful. Returning a DlnaProfile object.
     */
    200: DlnaProfilesDlnaProfile;
};

export type GetDlnaProfilesDefaultResponse = GetDlnaProfilesDefaultResponses[keyof GetDlnaProfilesDefaultResponses];

export type GetEncodingCodecinformationVideoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Encoding/CodecInformation/Video';
};

export type GetEncodingCodecinformationVideoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEncodingCodecinformationVideoResponses = {
    /**
     * Operation successful. Returning a VideoCodecBase[] object.
     */
    200: Array<VideoCodecBase>;
};

export type GetEncodingCodecinformationVideoResponse = GetEncodingCodecinformationVideoResponses[keyof GetEncodingCodecinformationVideoResponses];

export type GetEncodingCodecconfigurationDefaultsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Encoding/CodecConfiguration/Defaults';
};

export type GetEncodingCodecconfigurationDefaultsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetEncodingCodecconfigurationDefaultsResponses = {
    /**
     * Operation successful. Returning a CodecConfiguration[] object.
     */
    200: Array<CodecConfiguration>;
};

export type GetEncodingCodecconfigurationDefaultsResponse = GetEncodingCodecconfigurationDefaultsResponses[keyof GetEncodingCodecconfigurationDefaultsResponses];

export type GetGamesByIdSimilarData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Games/{Id}/Similar';
};

export type GetGamesByIdSimilarErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetGamesByIdSimilarResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetGamesByIdSimilarResponse = GetGamesByIdSimilarResponses[keyof GetGamesByIdSimilarResponses];

export type GetItemsByIdExternalidinfosData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/ExternalIdInfos';
};

export type GetItemsByIdExternalidinfosErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdExternalidinfosResponses = {
    /**
     * Operation successful. Returning a List<ExternalIdInfo> object.
     */
    200: Array<ExternalIdInfo>;
};

export type GetItemsByIdExternalidinfosResponse = GetItemsByIdExternalidinfosResponses[keyof GetItemsByIdExternalidinfosResponses];

export type PostItemsRemotesearchTrailerData = {
    /**
     * RemoteSearchQuery`1:
     */
    body: RemoteSearchQueryTrailerInfo;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Trailer';
};

export type PostItemsRemotesearchTrailerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchTrailerResponses = {
    /**
     * Operation successful. Returning a List<RemoteSearchResult> object.
     */
    200: Array<RemoteSearchResult>;
};

export type PostItemsRemotesearchTrailerResponse = PostItemsRemotesearchTrailerResponses[keyof PostItemsRemotesearchTrailerResponses];

export type PostItemsRemotesearchBookData = {
    /**
     * RemoteSearchQuery`1:
     */
    body: RemoteSearchQueryBookInfo;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Book';
};

export type PostItemsRemotesearchBookErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchBookResponses = {
    /**
     * Operation successful. Returning a List<RemoteSearchResult> object.
     */
    200: Array<RemoteSearchResult>;
};

export type PostItemsRemotesearchBookResponse = PostItemsRemotesearchBookResponses[keyof PostItemsRemotesearchBookResponses];

export type PostItemsRemotesearchMovieData = {
    /**
     * RemoteSearchQuery`1:
     */
    body: RemoteSearchQueryMovieInfo;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Movie';
};

export type PostItemsRemotesearchMovieErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchMovieResponses = {
    /**
     * Operation successful. Returning a List<RemoteSearchResult> object.
     */
    200: Array<RemoteSearchResult>;
};

export type PostItemsRemotesearchMovieResponse = PostItemsRemotesearchMovieResponses[keyof PostItemsRemotesearchMovieResponses];

export type PostItemsRemotesearchSeriesData = {
    /**
     * RemoteSearchQuery`1:
     */
    body: RemoteSearchQuerySeriesInfo;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Series';
};

export type PostItemsRemotesearchSeriesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchSeriesResponses = {
    /**
     * Operation successful. Returning a List<RemoteSearchResult> object.
     */
    200: Array<RemoteSearchResult>;
};

export type PostItemsRemotesearchSeriesResponse = PostItemsRemotesearchSeriesResponses[keyof PostItemsRemotesearchSeriesResponses];

export type PostItemsRemotesearchGameData = {
    /**
     * RemoteSearchQuery`1:
     */
    body: RemoteSearchQueryGameInfo;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Game';
};

export type PostItemsRemotesearchGameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchGameResponses = {
    /**
     * Operation successful. Returning a List<RemoteSearchResult> object.
     */
    200: Array<RemoteSearchResult>;
};

export type PostItemsRemotesearchGameResponse = PostItemsRemotesearchGameResponses[keyof PostItemsRemotesearchGameResponses];

export type PostItemsRemotesearchBoxsetData = {
    /**
     * RemoteSearchQuery`1:
     */
    body: RemoteSearchQueryItemLookupInfo;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/BoxSet';
};

export type PostItemsRemotesearchBoxsetErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchBoxsetResponses = {
    /**
     * Operation successful. Returning a List<RemoteSearchResult> object.
     */
    200: Array<RemoteSearchResult>;
};

export type PostItemsRemotesearchBoxsetResponse = PostItemsRemotesearchBoxsetResponses[keyof PostItemsRemotesearchBoxsetResponses];

export type PostItemsRemotesearchMusicvideoData = {
    /**
     * RemoteSearchQuery`1:
     */
    body: RemoteSearchQueryMusicVideoInfo;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/MusicVideo';
};

export type PostItemsRemotesearchMusicvideoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchMusicvideoResponses = {
    /**
     * Operation successful. Returning a List<RemoteSearchResult> object.
     */
    200: Array<RemoteSearchResult>;
};

export type PostItemsRemotesearchMusicvideoResponse = PostItemsRemotesearchMusicvideoResponses[keyof PostItemsRemotesearchMusicvideoResponses];

export type PostItemsRemotesearchPersonData = {
    /**
     * RemoteSearchQuery`1:
     */
    body: RemoteSearchQueryPersonLookupInfo;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/Person';
};

export type PostItemsRemotesearchPersonErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchPersonResponses = {
    /**
     * Operation successful. Returning a List<RemoteSearchResult> object.
     */
    200: Array<RemoteSearchResult>;
};

export type PostItemsRemotesearchPersonResponse = PostItemsRemotesearchPersonResponses[keyof PostItemsRemotesearchPersonResponses];

export type PostItemsRemotesearchMusicalbumData = {
    /**
     * RemoteSearchQuery`1:
     */
    body: RemoteSearchQueryAlbumInfo;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/MusicAlbum';
};

export type PostItemsRemotesearchMusicalbumErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchMusicalbumResponses = {
    /**
     * Operation successful. Returning a List<RemoteSearchResult> object.
     */
    200: Array<RemoteSearchResult>;
};

export type PostItemsRemotesearchMusicalbumResponse = PostItemsRemotesearchMusicalbumResponses[keyof PostItemsRemotesearchMusicalbumResponses];

export type PostItemsRemotesearchMusicartistData = {
    /**
     * RemoteSearchQuery`1:
     */
    body: RemoteSearchQueryArtistInfo;
    path?: never;
    query?: never;
    url: '/Items/RemoteSearch/MusicArtist';
};

export type PostItemsRemotesearchMusicartistErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchMusicartistResponses = {
    /**
     * Operation successful. Returning a List<RemoteSearchResult> object.
     */
    200: Array<RemoteSearchResult>;
};

export type PostItemsRemotesearchMusicartistResponse = PostItemsRemotesearchMusicartistResponses[keyof PostItemsRemotesearchMusicartistResponses];

export type GetItemsRemotesearchImageData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The image url
         */
        ImageUrl: string;
        ProviderName: string;
    };
    url: '/Items/RemoteSearch/Image';
};

export type GetItemsRemotesearchImageErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsRemotesearchImageResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostItemsMetadataResetData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The item ids
         */
        ItemIds: string;
    };
    url: '/Items/Metadata/Reset';
};

export type PostItemsMetadataResetErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsMetadataResetResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostItemsByIdRefreshData = {
    /**
     * BaseRefreshRequest:
     */
    body: BaseRefreshRequest;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Indicates if the refresh should occur recursively.
         */
        Recursive?: boolean;
        /**
         * Specifies the metadata refresh mode
         */
        MetadataRefreshMode?: MetadataRefreshMode;
        /**
         * Specifies the image refresh mode
         */
        ImageRefreshMode?: MetadataRefreshMode;
        /**
         * Determines if metadata should be replaced. Only applicable if mode is FullRefresh
         */
        ReplaceAllMetadata?: boolean;
        /**
         * Determines if images should be replaced. Only applicable if mode is FullRefresh
         */
        ReplaceAllImages?: boolean;
    };
    url: '/Items/{Id}/Refresh';
};

export type PostItemsByIdRefreshErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdRefreshResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetItemsByItemidMetadataeditorData = {
    body?: never;
    path: {
        /**
         * The id of the item
         */
        ItemId: string;
    };
    query?: never;
    url: '/Items/{ItemId}/MetadataEditor';
};

export type GetItemsByItemidMetadataeditorErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByItemidMetadataeditorResponses = {
    /**
     * Operation successful. Returning a MetadataEditorInfo object.
     */
    200: MetadataEditorInfo;
};

export type GetItemsByItemidMetadataeditorResponse = GetItemsByItemidMetadataeditorResponses[keyof GetItemsByItemidMetadataeditorResponses];

export type PostItemsByIdMakepublicData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/MakePublic';
};

export type PostItemsByIdMakepublicErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdMakepublicResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostItemsByIdMakeprivateData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/MakePrivate';
};

export type PostItemsByIdMakeprivateErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdMakeprivateResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostItemsSharedLeaveData = {
    /**
     * LeaveSharedItems
     */
    body: UserLibraryLeaveSharedItems;
    path?: never;
    query?: never;
    url: '/Items/Shared/Leave';
};

export type PostItemsSharedLeaveErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsSharedLeaveResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetItemsByIdInstantmixData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Items/{Id}/InstantMix';
};

export type GetItemsByIdInstantmixErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdInstantmixResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetItemsByIdInstantmixResponse = GetItemsByIdInstantmixResponses[keyof GetItemsByIdInstantmixResponses];

export type GetItemsByIdDeleteinfoData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/DeleteInfo';
};

export type GetItemsByIdDeleteinfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdDeleteinfoResponses = {
    /**
     * Operation successful. Returning a DeleteInfo object.
     */
    200: LibraryDeleteInfo;
};

export type GetItemsByIdDeleteinfoResponse = GetItemsByIdDeleteinfoResponses[keyof GetItemsByIdDeleteinfoResponses];

export type GetItemsByIdSimilarData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Items/{Id}/Similar';
};

export type GetItemsByIdSimilarErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdSimilarResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetItemsByIdSimilarResponse = GetItemsByIdSimilarResponses[keyof GetItemsByIdSimilarResponses];

export type GetItemsByIdDownloadData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/Download';
};

export type GetItemsByIdDownloadErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdDownloadResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetItemsByIdFileData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/File';
};

export type GetItemsByIdFileErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdFileResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetItemsByIdAncestorsData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data
         */
        UserId?: string;
    };
    url: '/Items/{Id}/Ancestors';
};

export type GetItemsByIdAncestorsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdAncestorsResponses = {
    /**
     * Operation successful. Returning a BaseItemDto[] object.
     */
    200: Array<BaseItemDto>;
};

export type GetItemsByIdAncestorsResponse = GetItemsByIdAncestorsResponses[keyof GetItemsByIdAncestorsResponses];

export type GetItemsByIdCriticreviewsData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
    };
    url: '/Items/{Id}/CriticReviews';
};

export type GetItemsByIdCriticreviewsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdCriticreviewsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetItemsByIdCriticreviewsResponse = GetItemsByIdCriticreviewsResponses[keyof GetItemsByIdCriticreviewsResponses];

export type PostItemsByIdDeleteData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/Delete';
};

export type PostItemsByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetItemsByIdThememediaData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Determines whether or not parent items should be searched for theme media.
         */
        InheritFromParent?: boolean;
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Items/{Id}/ThemeMedia';
};

export type GetItemsByIdThememediaErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdThememediaResponses = {
    /**
     * Operation successful. Returning a AllThemeMediaResult object.
     */
    200: AllThemeMediaResult;
};

export type GetItemsByIdThememediaResponse = GetItemsByIdThememediaResponses[keyof GetItemsByIdThememediaResponses];

export type GetItemsByIdThemesongsData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Determines whether or not parent items should be searched for theme media.
         */
        InheritFromParent?: boolean;
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Items/{Id}/ThemeSongs';
};

export type GetItemsByIdThemesongsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdThemesongsResponses = {
    /**
     * Operation successful. Returning a ThemeMediaResult object.
     */
    200: ThemeMediaResult;
};

export type GetItemsByIdThemesongsResponse = GetItemsByIdThemesongsResponses[keyof GetItemsByIdThemesongsResponses];

export type GetItemsByIdThemevideosData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Determines whether or not parent items should be searched for theme media.
         */
        InheritFromParent?: boolean;
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Items/{Id}/ThemeVideos';
};

export type GetItemsByIdThemevideosErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdThemevideosResponses = {
    /**
     * Operation successful. Returning a ThemeMediaResult object.
     */
    200: ThemeMediaResult;
};

export type GetItemsByIdThemevideosResponse = GetItemsByIdThemevideosResponses[keyof GetItemsByIdThemevideosResponses];

export type GetItemsByIdImagesData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/Images';
};

export type GetItemsByIdImagesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdImagesResponses = {
    /**
     * Operation successful. Returning a List<ImageInfo> object.
     */
    200: Array<ImageInfo>;
};

export type GetItemsByIdImagesResponse = GetItemsByIdImagesResponses[keyof GetItemsByIdImagesResponses];

export type GetItemsByIdRemoteimagesData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * The image type
         */
        Type?: ImageType;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * Optional. The image provider to use
         */
        ProviderName?: string;
        /**
         * Optional.
         */
        IncludeAllLanguages?: boolean;
    };
    url: '/Items/{Id}/RemoteImages';
};

export type GetItemsByIdRemoteimagesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdRemoteimagesResponses = {
    /**
     * Operation successful. Returning a RemoteImageResult object.
     */
    200: RemoteImageResult;
};

export type GetItemsByIdRemoteimagesResponse = GetItemsByIdRemoteimagesResponses[keyof GetItemsByIdRemoteimagesResponses];

export type GetItemsByIdThumbnailsetData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        Width: number;
    };
    url: '/Items/{Id}/ThumbnailSet';
};

export type GetItemsByIdThumbnailsetErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdThumbnailsetResponses = {
    /**
     * Operation successful. Returning a ThumbnailSetInfo object.
     */
    200: RokuMetadataApiThumbnailSetInfo;
};

export type GetItemsByIdThumbnailsetResponse = GetItemsByIdThumbnailsetResponses[keyof GetItemsByIdThumbnailsetResponses];

export type GetItemsByIdPlaybackinfoData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * User Id
         */
        UserId: string;
    };
    url: '/Items/{Id}/PlaybackInfo';
};

export type GetItemsByIdPlaybackinfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdPlaybackinfoResponses = {
    /**
     * Operation successful. Returning a PlaybackInfoResponse object.
     */
    200: PlaybackInfoResponse;
};

export type GetItemsByIdPlaybackinfoResponse = GetItemsByIdPlaybackinfoResponses[keyof GetItemsByIdPlaybackinfoResponses];

export type PostItemsByIdPlaybackinfoData = {
    /**
     * PlaybackInfoRequest:
     */
    body: PlaybackInfoRequest;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/PlaybackInfo';
};

export type PostItemsByIdPlaybackinfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdPlaybackinfoResponses = {
    /**
     * Operation successful. Returning a PlaybackInfoResponse object.
     */
    200: PlaybackInfoResponse;
};

export type PostItemsByIdPlaybackinfoResponse = PostItemsByIdPlaybackinfoResponses[keyof PostItemsByIdPlaybackinfoResponses];

export type PostLibrarySeriesAddedData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/Series/Added';
};

export type PostLibrarySeriesAddedErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibrarySeriesAddedResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLibrarySeriesUpdatedData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/Series/Updated';
};

export type PostLibrarySeriesUpdatedErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibrarySeriesUpdatedResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLibraryMediaUpdatedData = {
    /**
     * PostUpdatedMedia
     */
    body: LibraryPostUpdatedMedia;
    path?: never;
    query?: never;
    url: '/Library/Media/Updated';
};

export type PostLibraryMediaUpdatedErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryMediaUpdatedResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLibraryMoviesAddedData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/Movies/Added';
};

export type PostLibraryMoviesAddedErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryMoviesAddedResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLibraryMoviesUpdatedData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/Movies/Updated';
};

export type PostLibraryMoviesUpdatedErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryMoviesUpdatedResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLibraryVirtualfoldersQueryData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
    };
    url: '/Library/VirtualFolders/Query';
};

export type GetLibraryVirtualfoldersQueryErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLibraryVirtualfoldersQueryResponses = {
    /**
     * Operation successful. Returning a QueryResult<VirtualFolderInfo> object.
     */
    200: QueryResultVirtualFolderInfo;
};

export type GetLibraryVirtualfoldersQueryResponse = GetLibraryVirtualfoldersQueryResponses[keyof GetLibraryVirtualfoldersQueryResponses];

export type PostLibraryVirtualfoldersLibraryoptionsData = {
    /**
     * UpdateLibraryOptions
     */
    body: LibraryUpdateLibraryOptions;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders/LibraryOptions';
};

export type PostLibraryVirtualfoldersLibraryoptionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryVirtualfoldersLibraryoptionsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLibraryVirtualfoldersNameData = {
    /**
     * RenameVirtualFolder
     */
    body: LibraryRenameVirtualFolder;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders/Name';
};

export type PostLibraryVirtualfoldersNameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryVirtualfoldersNameResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLibraryVirtualfoldersDeleteData = {
    /**
     * RemoveVirtualFolder
     */
    body: LibraryRemoveVirtualFolder;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders/Delete';
};

export type PostLibraryVirtualfoldersDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryVirtualfoldersDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteLibraryVirtualfoldersPathsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders/Paths';
};

export type DeleteLibraryVirtualfoldersPathsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteLibraryVirtualfoldersPathsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLibraryVirtualfoldersPathsData = {
    /**
     * AddMediaPath
     */
    body: LibraryAddMediaPath;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders/Paths';
};

export type PostLibraryVirtualfoldersPathsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryVirtualfoldersPathsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvProgramsByIdData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/LiveTv/Programs/{Id}';
};

export type GetLivetvProgramsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvProgramsByIdResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetLivetvProgramsByIdResponse = GetLivetvProgramsByIdResponses[keyof GetLivetvProgramsByIdResponses];

export type GetLivetvTunerhostsTypesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/TunerHosts/Types';
};

export type GetLivetvTunerhostsTypesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvTunerhostsTypesResponses = {
    /**
     * Operation successful. Returning a List<NameIdPair> object.
     */
    200: Array<NameIdPair>;
};

export type GetLivetvTunerhostsTypesResponse = GetLivetvTunerhostsTypesResponses[keyof GetLivetvTunerhostsTypesResponses];

export type GetLivetvManageChannelsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Name, StartDate
         */
        SortBy?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
    };
    url: '/LiveTv/Manage/Channels';
};

export type GetLivetvManageChannelsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvManageChannelsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetLivetvManageChannelsResponse = GetLivetvManageChannelsResponses[keyof GetLivetvManageChannelsResponses];

export type GetLivetvChanneltagsPrefixesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/LiveTv/ChannelTags/Prefixes';
};

export type GetLivetvChanneltagsPrefixesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvChanneltagsPrefixesResponses = {
    /**
     * Operation successful. Returning a TagItem[] object.
     */
    200: Array<ApiTagItem>;
};

export type GetLivetvChanneltagsPrefixesResponse = GetLivetvChanneltagsPrefixesResponses[keyof GetLivetvChanneltagsPrefixesResponses];

export type GetLivetvRecordingsFoldersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/LiveTv/Recordings/Folders';
};

export type GetLivetvRecordingsFoldersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvRecordingsFoldersResponses = {
    /**
     * Operation successful. Returning a BaseItemDto[] object.
     */
    200: Array<BaseItemDto>;
};

export type GetLivetvRecordingsFoldersResponse = GetLivetvRecordingsFoldersResponses[keyof GetLivetvRecordingsFoldersResponses];

export type GetLivetvTunersDiscvoverData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/Tuners/Discvover';
};

export type GetLivetvTunersDiscvoverErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvTunersDiscvoverResponses = {
    /**
     * Operation successful. Returning a List<TunerHostInfo> object.
     */
    200: Array<LiveTvTunerHostInfo>;
};

export type GetLivetvTunersDiscvoverResponse = GetLivetvTunersDiscvoverResponses[keyof GetLivetvTunersDiscvoverResponses];

export type GetLivetvTunersDiscoverData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/Tuners/Discover';
};

export type GetLivetvTunersDiscoverErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvTunersDiscoverResponses = {
    /**
     * Operation successful. Returning a List<TunerHostInfo> object.
     */
    200: Array<LiveTvTunerHostInfo>;
};

export type GetLivetvTunersDiscoverResponse = GetLivetvTunersDiscoverResponses[keyof GetLivetvTunersDiscoverResponses];

export type GetLivetvListingprovidersDefaultData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/ListingProviders/Default';
};

export type GetLivetvListingprovidersDefaultErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvListingprovidersDefaultResponses = {
    /**
     * Operation successful. Returning a ListingsProviderInfo object.
     */
    200: LiveTvListingsProviderInfo;
};

export type GetLivetvListingprovidersDefaultResponse = GetLivetvListingprovidersDefaultResponses[keyof GetLivetvListingprovidersDefaultResponses];

export type PostLivetvListingprovidersDeleteData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Provider id
         */
        Id?: string;
    };
    url: '/LiveTv/ListingProviders/Delete';
};

export type PostLivetvListingprovidersDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvListingprovidersDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLivetvTunerhostsDeleteData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Tuner host id
         */
        Id?: string;
    };
    url: '/LiveTv/TunerHosts/Delete';
};

export type PostLivetvTunerhostsDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvTunerhostsDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvListingprovidersLineupsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Provider id
         */
        Id?: string;
        /**
         * Provider Type
         */
        Type?: string;
        /**
         * Location
         */
        Location?: string;
        /**
         * Country
         */
        Country?: string;
    };
    url: '/LiveTv/ListingProviders/Lineups';
};

export type GetLivetvListingprovidersLineupsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvListingprovidersLineupsResponses = {
    /**
     * Operation successful. Returning a List<NameIdPair> object.
     */
    200: Array<NameIdPair>;
};

export type GetLivetvListingprovidersLineupsResponse = GetLivetvListingprovidersLineupsResponses[keyof GetLivetvListingprovidersLineupsResponses];

export type GetLivetvChannelsByIdData = {
    body?: never;
    path: {
        /**
         * Channel Id
         */
        Id: string;
    };
    query?: {
        /**
         * Optional attach user data.
         */
        UserId?: string;
    };
    url: '/LiveTv/Channels/{Id}';
};

export type GetLivetvChannelsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvChannelsByIdResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetLivetvChannelsByIdResponse = GetLivetvChannelsByIdResponses[keyof GetLivetvChannelsByIdResponses];

export type GetLivetvProgramsRecommendedData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/LiveTv/Programs/Recommended';
};

export type GetLivetvProgramsRecommendedErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvProgramsRecommendedResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetLivetvProgramsRecommendedResponse = GetLivetvProgramsRecommendedResponses[keyof GetLivetvProgramsRecommendedResponses];

export type GetLivetvRecordingsSeriesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/Recordings/Series';
};

export type GetLivetvRecordingsSeriesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvRecordingsSeriesResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetLivetvRecordingsSeriesResponse = GetLivetvRecordingsSeriesResponses[keyof GetLivetvRecordingsSeriesResponses];

export type DeleteLivetvRecordingsByIdData = {
    body?: never;
    path: {
        /**
         * Recording Id
         */
        Id: string;
    };
    query?: never;
    url: '/LiveTv/Recordings/{Id}';
};

export type DeleteLivetvRecordingsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteLivetvRecordingsByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvRecordingsByIdData = {
    body?: never;
    path: {
        /**
         * Recording Id
         */
        Id: string;
    };
    query?: {
        /**
         * Optional attach user data.
         */
        UserId?: string;
    };
    url: '/LiveTv/Recordings/{Id}';
};

export type GetLivetvRecordingsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvRecordingsByIdResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetLivetvRecordingsByIdResponse = GetLivetvRecordingsByIdResponses[keyof GetLivetvRecordingsByIdResponses];

export type DeleteLivetvTimersByIdData = {
    body?: never;
    path: {
        /**
         * Timer Id
         */
        Id: string;
    };
    query?: never;
    url: '/LiveTv/Timers/{Id}';
};

export type DeleteLivetvTimersByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteLivetvTimersByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvTimersByIdData = {
    body?: never;
    path: {
        /**
         * Timer Id
         */
        Id: string;
    };
    query?: never;
    url: '/LiveTv/Timers/{Id}';
};

export type GetLivetvTimersByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvTimersByIdResponses = {
    /**
     * Operation successful. Returning a TimerInfoDto object.
     */
    200: LiveTvTimerInfoDto;
};

export type GetLivetvTimersByIdResponse = GetLivetvTimersByIdResponses[keyof GetLivetvTimersByIdResponses];

export type PostLivetvTimersByIdData = {
    /**
     * TimerInfoDto:
     */
    body: LiveTvTimerInfoDto;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/Timers/{Id}';
};

export type PostLivetvTimersByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvTimersByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteLivetvSeriestimersByIdData = {
    body?: never;
    path: {
        /**
         * Timer Id
         */
        Id: string;
    };
    query?: never;
    url: '/LiveTv/SeriesTimers/{Id}';
};

export type DeleteLivetvSeriestimersByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteLivetvSeriestimersByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvSeriestimersByIdData = {
    body?: never;
    path: {
        /**
         * Timer Id
         */
        Id: string;
    };
    query?: never;
    url: '/LiveTv/SeriesTimers/{Id}';
};

export type GetLivetvSeriestimersByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvSeriestimersByIdResponses = {
    /**
     * Operation successful. Returning a TimerInfoDto object.
     */
    200: LiveTvTimerInfoDto;
};

export type GetLivetvSeriestimersByIdResponse = GetLivetvSeriestimersByIdResponses[keyof GetLivetvSeriestimersByIdResponses];

export type PostLivetvSeriestimersByIdData = {
    /**
     * SeriesTimerInfo:
     */
    body: LiveTvSeriesTimerInfo;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/SeriesTimers/{Id}';
};

export type PostLivetvSeriestimersByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvSeriestimersByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvTimersDefaultsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional, to attach default values based on a program.
         */
        ProgramId?: string;
    };
    url: '/LiveTv/Timers/Defaults';
};

export type GetLivetvTimersDefaultsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvTimersDefaultsResponses = {
    /**
     * Operation successful. Returning a SeriesTimerInfoDto object.
     */
    200: LiveTvSeriesTimerInfoDto;
};

export type GetLivetvTimersDefaultsResponse = GetLivetvTimersDefaultsResponses[keyof GetLivetvTimersDefaultsResponses];

export type GetLivetvRecordingsGroupsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/Recordings/Groups';
};

export type GetLivetvRecordingsGroupsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvRecordingsGroupsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetLivetvRecordingsGroupsResponse = GetLivetvRecordingsGroupsResponses[keyof GetLivetvRecordingsGroupsResponses];

export type GetLivetvListingprovidersAvailableData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/ListingProviders/Available';
};

export type GetLivetvListingprovidersAvailableErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvListingprovidersAvailableResponses = {
    /**
     * Operation successful. Returning a ListingProviderTypeInfo[] object.
     */
    200: Array<ApiListingProviderTypeInfo>;
};

export type GetLivetvListingprovidersAvailableResponse = GetLivetvListingprovidersAvailableResponses[keyof GetLivetvListingprovidersAvailableResponses];

export type GetMoviesByIdSimilarData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Movies/{Id}/Similar';
};

export type GetMoviesByIdSimilarErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetMoviesByIdSimilarResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetMoviesByIdSimilarResponse = GetMoviesByIdSimilarResponses[keyof GetMoviesByIdSimilarResponses];

export type GetMusicgenresByNameInstantmixData = {
    body?: never;
    path: {
        Name: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/MusicGenres/{Name}/InstantMix';
};

export type GetMusicgenresByNameInstantmixErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetMusicgenresByNameInstantmixResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetMusicgenresByNameInstantmixResponse = GetMusicgenresByNameInstantmixResponses[keyof GetMusicgenresByNameInstantmixResponses];

export type PostNotificationsServicesTestData = {
    /**
     * UserNotificationInfo:
     */
    body: UserNotificationInfo;
    path?: never;
    query?: never;
    url: '/Notifications/Services/Test';
};

export type PostNotificationsServicesTestErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostNotificationsServicesTestResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetNotificationsServicesDefaultsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Notifications/Services/Defaults';
};

export type GetNotificationsServicesDefaultsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetNotificationsServicesDefaultsResponses = {
    /**
     * Operation successful. Returning a UserNotificationInfo object.
     */
    200: UserNotificationInfo;
};

export type GetNotificationsServicesDefaultsResponse = GetNotificationsServicesDefaultsResponses[keyof GetNotificationsServicesDefaultsResponses];

export type PostPackagesInstalledByNameData = {
    body?: never;
    path: {
        /**
         * Package name
         */
        Name: string;
    };
    query?: {
        /**
         * Guid of the associated assembly
         */
        AssemblyGuid?: string;
        /**
         * Optional version. Defaults to latest version.
         */
        Version?: string;
        /**
         * Optional update class (Dev, Beta, Release). Defaults to Release.
         */
        UpdateClass?: PackageVersionClass;
    };
    url: '/Packages/Installed/{Name}';
};

export type PostPackagesInstalledByNameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostPackagesInstalledByNameResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeletePackagesInstallingByIdData = {
    body?: never;
    path: {
        /**
         * Installation Id
         */
        Id: string;
    };
    query?: never;
    url: '/Packages/Installing/{Id}';
};

export type DeletePackagesInstallingByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeletePackagesInstallingByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetPlaylistsByIdAddtoplaylistinfoData = {
    body?: never;
    path: {
        Id: string;
    };
    query: {
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Item id, comma delimited
         */
        Ids: string;
    };
    url: '/Playlists/{Id}/AddToPlaylistInfo';
};

export type GetPlaylistsByIdAddtoplaylistinfoErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPlaylistsByIdAddtoplaylistinfoResponses = {
    /**
     * Operation successful. Returning a AddToPlaylistInfo object.
     */
    200: PlaylistsAddToPlaylistInfo;
};

export type GetPlaylistsByIdAddtoplaylistinfoResponse = GetPlaylistsByIdAddtoplaylistinfoResponses[keyof GetPlaylistsByIdAddtoplaylistinfoResponses];

export type DeletePlaylistsByIdItemsData = {
    body?: never;
    path: {
        Id: string;
    };
    query: {
        EntryIds: string;
    };
    url: '/Playlists/{Id}/Items';
};

export type DeletePlaylistsByIdItemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeletePlaylistsByIdItemsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetPlaylistsByIdItemsData = {
    body?: never;
    path: {
        Id: string;
    };
    query?: {
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
    };
    url: '/Playlists/{Id}/Items';
};

export type GetPlaylistsByIdItemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPlaylistsByIdItemsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetPlaylistsByIdItemsResponse = GetPlaylistsByIdItemsResponses[keyof GetPlaylistsByIdItemsResponses];

export type PostPlaylistsByIdItemsData = {
    body?: never;
    path: {
        Id: string;
    };
    query: {
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Item id, comma delimited
         */
        Ids: string;
    };
    url: '/Playlists/{Id}/Items';
};

export type PostPlaylistsByIdItemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostPlaylistsByIdItemsResponses = {
    /**
     * Operation successful. Returning a AddToPlaylistResult object.
     */
    200: PlaylistsAddToPlaylistResult;
};

export type PostPlaylistsByIdItemsResponse = PostPlaylistsByIdItemsResponses[keyof PostPlaylistsByIdItemsResponses];

export type GetPlaylistsByIdInstantmixData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Playlists/{Id}/InstantMix';
};

export type GetPlaylistsByIdInstantmixErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPlaylistsByIdInstantmixResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetPlaylistsByIdInstantmixResponse = GetPlaylistsByIdInstantmixResponses[keyof GetPlaylistsByIdInstantmixResponses];

export type GetPluginsByIdThumbData = {
    body?: never;
    path: {
        /**
         * Plugin Id
         */
        Id: string;
    };
    query?: never;
    url: '/Plugins/{Id}/Thumb';
};

export type GetPluginsByIdThumbErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPluginsByIdThumbResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetPluginsByIdConfigurationData = {
    body?: never;
    path: {
        /**
         * Plugin Id
         */
        Id: string;
    };
    query?: never;
    url: '/Plugins/{Id}/Configuration';
};

export type GetPluginsByIdConfigurationErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPluginsByIdConfigurationResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostPluginsByIdConfigurationData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        /**
         * Plugin Id
         */
        Id: string;
    };
    query?: never;
    url: '/Plugins/{Id}/Configuration';
};

export type PostPluginsByIdConfigurationErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostPluginsByIdConfigurationResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostPluginsByIdDeleteData = {
    body?: never;
    path: {
        /**
         * Plugin Id
         */
        Id: string;
    };
    query?: never;
    url: '/Plugins/{Id}/Delete';
};

export type PostPluginsByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostPluginsByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteScheduledtasksRunningByIdData = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/ScheduledTasks/Running/{Id}';
};

export type DeleteScheduledtasksRunningByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteScheduledtasksRunningByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostScheduledtasksRunningByIdData = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/ScheduledTasks/Running/{Id}';
};

export type PostScheduledtasksRunningByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostScheduledtasksRunningByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostScheduledtasksByIdTriggersData = {
    /**
     * List`1:
     */
    body: Array<TaskTriggerInfo>;
    path: {
        Id: string;
    };
    query?: never;
    url: '/ScheduledTasks/{Id}/Triggers';
};

export type PostScheduledtasksByIdTriggersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostScheduledtasksByIdTriggersResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsByIdViewingData = {
    body?: never;
    path: {
        /**
         * Session Id
         */
        Id: string;
    };
    query: {
        /**
         * The type of item to browse to.
         */
        ItemType: string;
        /**
         * The Id of the item.
         */
        ItemId: string;
        /**
         * The name of the item.
         */
        ItemName: string;
    };
    url: '/Sessions/{Id}/Viewing';
};

export type PostSessionsByIdViewingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsByIdViewingResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsByIdMessageData = {
    body?: never;
    path: {
        /**
         * Session Id
         */
        Id: string;
    };
    query: {
        /**
         * The message text.
         */
        Text: string;
        /**
         * The message header.
         */
        Header: string;
        /**
         * The message timeout. If omitted the user will have to confirm viewing the message.
         */
        TimeoutMs?: number | null;
    };
    url: '/Sessions/{Id}/Message';
};

export type PostSessionsByIdMessageErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsByIdMessageResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsByIdPlayingData = {
    /**
     * PlayRequest:
     */
    body: PlayRequest;
    path: {
        /**
         * Session Id
         */
        Id: string;
    };
    query: {
        /**
         * The ids of the items to play, comma delimited
         */
        ItemIds: Array<number>;
        /**
         * The starting position of the first item.
         */
        StartPositionTicks?: number | null;
        /**
         * The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
         */
        PlayCommand: PlayCommand;
    };
    url: '/Sessions/{Id}/Playing';
};

export type PostSessionsByIdPlayingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsByIdPlayingResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostSessionsByIdCommandData = {
    /**
     * GeneralCommand:
     */
    body: GeneralCommand;
    path: {
        /**
         * Session Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sessions/{Id}/Command';
};

export type PostSessionsByIdCommandErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsByIdCommandResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsCapabilitiesFullData = {
    /**
     * ClientCapabilities:
     */
    body: ClientCapabilities;
    path?: never;
    query: {
        /**
         * Session Id
         */
        Id: string;
    };
    url: '/Sessions/Capabilities/Full';
};

export type PostSessionsCapabilitiesFullErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsCapabilitiesFullResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsPlayingProgressData = {
    /**
     * PlaybackProgressInfo:
     */
    body: PlaybackProgressInfo;
    path?: never;
    query?: never;
    url: '/Sessions/Playing/Progress';
};

export type PostSessionsPlayingProgressErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsPlayingProgressResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsPlayingPingData = {
    body?: never;
    path?: never;
    query?: {
        PlaySessionId?: string;
    };
    url: '/Sessions/Playing/Ping';
};

export type PostSessionsPlayingPingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsPlayingPingResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsPlayingStoppedData = {
    /**
     * PlaybackStopInfo:
     */
    body: PlaybackStopInfo;
    path?: never;
    query?: never;
    url: '/Sessions/Playing/Stopped';
};

export type PostSessionsPlayingStoppedErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsPlayingStoppedResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetShowsByIdSeasonsData = {
    body?: never;
    path: {
        /**
         * The series id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Shows/{Id}/Seasons';
};

export type GetShowsByIdSeasonsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetShowsByIdSeasonsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetShowsByIdSeasonsResponse = GetShowsByIdSeasonsResponses[keyof GetShowsByIdSeasonsResponses];

export type GetShowsByIdEpisodesData = {
    body?: never;
    path: {
        /**
         * The series id
         */
        Id: string;
    };
    query?: {
        /**
         * Optional filter by season number.
         */
        Season?: number | null;
        /**
         * Optional. Filter by season id
         */
        SeasonId?: string;
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Shows/{Id}/Episodes';
};

export type GetShowsByIdEpisodesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetShowsByIdEpisodesResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetShowsByIdSimilarData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Shows/{Id}/Similar';
};

export type GetShowsByIdSimilarErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetShowsByIdSimilarResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetShowsByIdSimilarResponse = GetShowsByIdSimilarResponses[keyof GetShowsByIdSimilarResponses];

export type GetSongsByIdInstantmixData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Songs/{Id}/InstantMix';
};

export type GetSongsByIdInstantmixErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSongsByIdInstantmixResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetSongsByIdInstantmixResponse = GetSongsByIdInstantmixResponses[keyof GetSongsByIdInstantmixResponses];

export type PostSyncByItemidStatusData = {
    /**
     * SyncedItemProgress:
     */
    body: SyncedItemProgress;
    path: {
        ItemId: string;
    };
    query?: never;
    url: '/Sync/{ItemId}/Status';
};

export type PostSyncByItemidStatusErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncByItemidStatusResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteSyncJobsByIdData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/Jobs/{Id}';
};

export type DeleteSyncJobsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteSyncJobsByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetSyncJobsByIdData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/Jobs/{Id}';
};

export type GetSyncJobsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSyncJobsByIdResponses = {
    /**
     * Operation successful. Returning a SyncJob object.
     */
    200: SyncJob;
};

export type GetSyncJobsByIdResponse = GetSyncJobsByIdResponses[keyof GetSyncJobsByIdResponses];

export type PostSyncJobsByIdData = {
    /**
     * SyncJob:
     */
    body: SyncJob;
    path: {
        Id: number;
    };
    query?: never;
    url: '/Sync/Jobs/{Id}';
};

export type PostSyncJobsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncJobsByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSyncItemsCancelData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * ItemIds
         */
        ItemIds?: string;
    };
    url: '/Sync/Items/Cancel';
};

export type PostSyncItemsCancelErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncItemsCancelResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteSyncByTargetidItemsData = {
    body?: never;
    path: {
        /**
         * TargetId
         */
        TargetId: string;
    };
    query?: {
        /**
         * ItemIds
         */
        ItemIds?: string;
    };
    url: '/Sync/{TargetId}/Items';
};

export type DeleteSyncByTargetidItemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteSyncByTargetidItemsResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetSyncItemsReadyData = {
    body?: never;
    path?: never;
    query: {
        /**
         * TargetId
         */
        TargetId: string;
    };
    url: '/Sync/Items/Ready';
};

export type GetSyncItemsReadyErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSyncItemsReadyResponses = {
    /**
     * Operation successful. Returning a List<SyncedItem> object.
     */
    200: Array<SyncedItem>;
};

export type GetSyncItemsReadyResponse = GetSyncItemsReadyResponses[keyof GetSyncItemsReadyResponses];

export type DeleteSyncJobitemsByIdData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/JobItems/{Id}';
};

export type DeleteSyncJobitemsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteSyncJobitemsByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSystemConfigurationPartialData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path?: never;
    query?: never;
    url: '/System/Configuration/Partial';
};

export type PostSystemConfigurationPartialErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSystemConfigurationPartialResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetSystemConfigurationByKeyData = {
    body?: never;
    path: {
        /**
         * Key
         */
        Key: string;
    };
    query?: never;
    url: '/System/Configuration/{Key}';
};

export type GetSystemConfigurationByKeyErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemConfigurationByKeyResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostSystemConfigurationByKeyData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        /**
         * Key
         */
        Key: string;
    };
    query?: never;
    url: '/System/Configuration/{Key}';
};

export type PostSystemConfigurationByKeyErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSystemConfigurationByKeyResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetSystemReleasenotesVersionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/ReleaseNotes/Versions';
};

export type GetSystemReleasenotesVersionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemReleasenotesVersionsResponses = {
    /**
     * Operation successful. Returning a PackageVersionInfo[] object.
     */
    200: Array<PackageVersionInfo>;
};

export type GetSystemReleasenotesVersionsResponse = GetSystemReleasenotesVersionsResponses[keyof GetSystemReleasenotesVersionsResponses];

export type GetSystemLogsQueryData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
    };
    url: '/System/Logs/Query';
};

export type GetSystemLogsQueryErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemLogsQueryResponses = {
    /**
     * Operation successful. Returning a QueryResult<LogFile> object.
     */
    200: QueryResultLogFile;
};

export type GetSystemLogsQueryResponse = GetSystemLogsQueryResponses[keyof GetSystemLogsQueryResponses];

export type GetSystemLogsByNameData = {
    body?: never;
    path: {
        /**
         * The log file name.
         */
        Name: string;
    };
    query?: {
        /**
         * Return sanitized log
         */
        Sanitize?: boolean;
    };
    url: '/System/Logs/{Name}';
};

export type GetSystemLogsByNameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemLogsByNameResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetSystemInfoPublicData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/System/Info/Public';
};

export type GetSystemInfoPublicErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemInfoPublicResponses = {
    /**
     * Operation successful. Returning a PublicSystemInfo object.
     */
    200: PublicSystemInfo;
};

export type GetSystemInfoPublicResponse = GetSystemInfoPublicResponses[keyof GetSystemInfoPublicResponses];

export type GetSystemActivitylogEntriesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * Optional. The minimum date. Format = ISO
         */
        MinDate?: string | null;
    };
    url: '/System/ActivityLog/Entries';
};

export type GetSystemActivitylogEntriesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemActivitylogEntriesResponses = {
    /**
     * Operation successful. Returning a QueryResult<ActivityLogEntry> object.
     */
    200: QueryResultActivityLogEntry;
};

export type GetSystemActivitylogEntriesResponse = GetSystemActivitylogEntriesResponses[keyof GetSystemActivitylogEntriesResponses];

export type GetTrailersByIdSimilarData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * User Id
         */
        UserId?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Trailers/{Id}/Similar';
};

export type GetTrailersByIdSimilarErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetTrailersByIdSimilarResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetTrailersByIdSimilarResponse = GetTrailersByIdSimilarResponses[keyof GetTrailersByIdSimilarResponses];

export type GetUsersByUseridSuggestionsData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Users/{UserId}/Suggestions';
};

export type GetUsersByUseridSuggestionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridSuggestionsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetUsersByUseridSuggestionsResponse = GetUsersByUseridSuggestionsResponses[keyof GetUsersByUseridSuggestionsResponses];

export type PostUsersByIdDeleteData = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}/Delete';
};

export type PostUsersByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByIdAuthenticateData = {
    /**
     * AuthenticateUser
     */
    body: AuthenticateUser;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}/Authenticate';
};

export type PostUsersByIdAuthenticateErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdAuthenticateResponses = {
    /**
     * Operation successful. Returning a AuthenticationResult object.
     */
    200: AuthenticationAuthenticationResult;
};

export type PostUsersByIdAuthenticateResponse = PostUsersByIdAuthenticateResponses[keyof PostUsersByIdAuthenticateResponses];

export type PostUsersByIdPasswordData = {
    /**
     * UpdateUserPassword
     */
    body: UpdateUserPassword;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}/Password';
};

export type PostUsersByIdPasswordErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdPasswordResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersForgotpasswordPinData = {
    /**
     * ForgotPasswordPin
     */
    body: ForgotPasswordPin;
    path?: never;
    query?: never;
    url: '/Users/ForgotPassword/Pin';
};

export type PostUsersForgotpasswordPinErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersForgotpasswordPinResponses = {
    /**
     * Operation successful. Returning a PinRedeemResult object.
     */
    200: PinRedeemResult;
};

export type PostUsersForgotpasswordPinResponse = PostUsersForgotpasswordPinResponses[keyof PostUsersForgotpasswordPinResponses];

export type PostUsersByIdConfigurationData = {
    /**
     * UserConfiguration:
     */
    body: UserConfiguration;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}/Configuration';
};

export type PostUsersByIdConfigurationErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdConfigurationResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByIdPolicyData = {
    /**
     * UserPolicy:
     */
    body: UserPolicy;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}/Policy';
};

export type PostUsersByIdPolicyErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdPolicyResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetUsersByUseridHomesectionsData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
    };
    query?: never;
    url: '/Users/{UserId}/HomeSections';
};

export type GetUsersByUseridHomesectionsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridHomesectionsResponses = {
    /**
     * Operation successful. Returning a List<ContentSection> object.
     */
    200: Array<ContentSection>;
};

export type GetUsersByUseridHomesectionsResponse = GetUsersByUseridHomesectionsResponses[keyof GetUsersByUseridHomesectionsResponses];

export type GetUsersByUseridItemsData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Users/{UserId}/Items';
};

export type GetUsersByUseridItemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridItemsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetUsersByUseridItemsResponse = GetUsersByUseridItemsResponses[keyof GetUsersByUseridItemsResponses];

export type GetUsersByUseridViewsData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
    };
    query: {
        /**
         * Whether or not to include external views such as channels or live tv
         */
        IncludeExternalContent: boolean | null;
    };
    url: '/Users/{UserId}/Views';
};

export type GetUsersByUseridViewsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridViewsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetUsersByUseridViewsResponse = GetUsersByUseridViewsResponses[keyof GetUsersByUseridViewsResponses];

export type PostUsersettingsByUseridPartialData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        /**
         * User Id
         */
        UserId: string;
    };
    query?: never;
    url: '/UserSettings/{UserId}/Partial';
};

export type PostUsersettingsByUseridPartialErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersettingsByUseridPartialResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteVideosByIdAlternatesourcesData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Videos/{Id}/AlternateSources';
};

export type DeleteVideosByIdAlternatesourcesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteVideosByIdAlternatesourcesResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetVideosByIdAdditionalpartsData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Optional. Filter by user id, and attach user data
         */
        UserId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         */
        Fields?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
    };
    url: '/Videos/{Id}/AdditionalParts';
};

export type GetVideosByIdAdditionalpartsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdAdditionalpartsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetVideosByIdAdditionalpartsResponse = GetVideosByIdAdditionalpartsResponses[keyof GetVideosByIdAdditionalpartsResponses];

export type GetVideosByIdIndexBifData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        Width: number;
    };
    url: '/Videos/{Id}/index.bif';
};

export type GetVideosByIdIndexBifErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdIndexBifResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdStreamByContainerData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Container
         */
        Container: string;
    };
    query?: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Videos/{Id}/stream.{Container}';
};

export type GetVideosByIdStreamByContainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdStreamByContainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadVideosByIdStreamByContainerData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Container
         */
        Container: string;
    };
    query?: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Videos/{Id}/stream.{Container}';
};

export type HeadVideosByIdStreamByContainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadVideosByIdStreamByContainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdStreamData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Videos/{Id}/stream';
};

export type GetVideosByIdStreamErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdStreamResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadVideosByIdStreamData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Videos/{Id}/stream';
};

export type HeadVideosByIdStreamErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadVideosByIdStreamResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdByStreamfilenameData = {
    body?: never;
    path: {
        StreamFileName: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Videos/{Id}/{StreamFileName}';
};

export type GetVideosByIdByStreamfilenameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdByStreamfilenameResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadVideosByIdByStreamfilenameData = {
    body?: never;
    path: {
        StreamFileName: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Videos/{Id}/{StreamFileName}';
};

export type HeadVideosByIdByStreamfilenameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadVideosByIdByStreamfilenameResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdMasterM3U8Data = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Videos/{Id}/master.m3u8';
};

export type GetVideosByIdMasterM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdMasterM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadVideosByIdMasterM3U8Data = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Videos/{Id}/master.m3u8';
};

export type HeadVideosByIdMasterM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadVideosByIdMasterM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdLiveM3U8Data = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Videos/{Id}/live.m3u8';
};

export type GetVideosByIdLiveM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdLiveM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdMainM3U8Data = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Optional. The dlna device profile id to utilize.
         */
        DeviceProfileId?: string;
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId?: string;
        /**
         * Container
         */
        Container: string;
        /**
         * Optional. Specify a audio codec to encode to, e.g. mp3. If omitted the server will auto-select using the url's extension. Options: aac, mp3, vorbis, wma.
         */
        AudioCodec?: string;
        /**
         * Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
         */
        EnableAutoStreamCopy?: boolean;
        /**
         * Optional. Specify a specific audio sample rate, e.g. 44100
         */
        AudioSampleRate?: number | null;
        /**
         * Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
         */
        AudioBitRate?: number | null;
        /**
         * Optional. Specify a specific number of audio channels to encode to, e.g. 2
         */
        AudioChannels?: number | null;
        /**
         * Optional. Specify a maximum number of audio channels to encode to, e.g. 2
         */
        MaxAudioChannels?: number | null;
        /**
         * Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false
         */
        Static?: boolean;
        /**
         * Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
         */
        CopyTimestamps?: boolean;
        /**
         * Optional. Specify a starting offset, in ticks. 1ms = 10000 ticks.
         */
        StartTimeTicks?: number | null;
        /**
         * Optional. The fixed horizontal resolution of the encoded video.
         */
        Width?: number | null;
        /**
         * Optional. The fixed vertical resolution of the encoded video.
         */
        Height?: number | null;
        /**
         * Optional. The maximum horizontal resolution of the encoded video.
         */
        MaxWidth?: number | null;
        /**
         * Optional. The maximum vertical resolution of the encoded video.
         */
        MaxHeight?: number | null;
        /**
         * Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
         */
        VideoBitRate?: number | null;
        /**
         * Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
         */
        SubtitleStreamIndex?: number | null;
        /**
         * Optional. Specify the subtitle delivery method.
         */
        SubtitleMethod?: SubtitleDeliveryMethod;
        /**
         * Optional.
         */
        MaxVideoBitDepth?: number | null;
        /**
         * Optional. Specify a video codec to encode to, e.g. h264. If omitted the server will auto-select using the url's extension. Options: h264, mpeg4, theora, vpx, wmv.
         */
        VideoCodec?: string;
        /**
         * Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
         */
        AudioStreamIndex?: number | null;
        /**
         * Optional. The index of the video stream to use. If omitted the first video stream will be used.
         */
        VideoStreamIndex?: number | null;
    };
    url: '/Videos/{Id}/main.m3u8';
};

export type GetVideosByIdMainM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdMainM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdSubtitlesM3U8Data = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * The subtitle segment length
         */
        SubtitleSegmentLength: number;
        /**
         * The subtitle segment format
         */
        ManifestSubtitles: string;
    };
    url: '/Videos/{Id}/subtitles.m3u8';
};

export type GetVideosByIdSubtitlesM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdSubtitlesM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdLiveSubtitlesM3U8Data = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * The subtitle segment length
         */
        SubtitleSegmentLength: number;
        /**
         * The subtitle segment format
         */
        ManifestSubtitles: string;
    };
    url: '/Videos/{Id}/live_subtitles.m3u8';
};

export type GetVideosByIdLiveSubtitlesM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdLiveSubtitlesM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostVideosActiveencodingsDeleteData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The device id of the client requesting. Used to stop encoding processes when needed.
         */
        DeviceId: string;
        /**
         * The play session id
         */
        PlaySessionId: string;
    };
    url: '/Videos/ActiveEncodings/Delete';
};

export type PostVideosActiveencodingsDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostVideosActiveencodingsDeleteResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetArtistsByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Artists/{Name}/Images/{Type}';
};

export type GetArtistsByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetArtistsByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadArtistsByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Artists/{Name}/Images/{Type}';
};

export type HeadArtistsByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadArtistsByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostAuthKeysByKeyDeleteData = {
    body?: never;
    path: {
        /**
         * Auth Key
         */
        Key: string;
    };
    query?: never;
    url: '/Auth/Keys/{Key}/Delete';
};

export type PostAuthKeysByKeyDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostAuthKeysByKeyDeleteResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostCollectionsByIdItemsDeleteData = {
    body?: never;
    path: {
        Id: string;
    };
    query: {
        /**
         * Item id, comma delimited
         */
        Ids: string;
    };
    url: '/Collections/{Id}/Items/Delete';
};

export type PostCollectionsByIdItemsDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostCollectionsByIdItemsDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetDlnaByUuidContentdirectoryContentdirectoryXmlData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/contentdirectory/contentdirectory.xml';
};

export type GetDlnaByUuidContentdirectoryContentdirectoryXmlErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaByUuidContentdirectoryContentdirectoryXmlResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadDlnaByUuidContentdirectoryContentdirectoryXmlData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/contentdirectory/contentdirectory.xml';
};

export type HeadDlnaByUuidContentdirectoryContentdirectoryXmlErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadDlnaByUuidContentdirectoryContentdirectoryXmlResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetDlnaByUuidContentdirectoryContentdirectoryData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/contentdirectory/contentdirectory';
};

export type GetDlnaByUuidContentdirectoryContentdirectoryErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaByUuidContentdirectoryContentdirectoryResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadDlnaByUuidContentdirectoryContentdirectoryData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/contentdirectory/contentdirectory';
};

export type HeadDlnaByUuidContentdirectoryContentdirectoryErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadDlnaByUuidContentdirectoryContentdirectoryResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetDlnaByUuidConnectionmanagerConnectionmanagerXmlData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/connectionmanager/connectionmanager.xml';
};

export type GetDlnaByUuidConnectionmanagerConnectionmanagerXmlErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaByUuidConnectionmanagerConnectionmanagerXmlResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/connectionmanager/connectionmanager.xml';
};

export type HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetDlnaByUuidConnectionmanagerConnectionmanagerData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/connectionmanager/connectionmanager';
};

export type GetDlnaByUuidConnectionmanagerConnectionmanagerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaByUuidConnectionmanagerConnectionmanagerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadDlnaByUuidConnectionmanagerConnectionmanagerData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/connectionmanager/connectionmanager';
};

export type HeadDlnaByUuidConnectionmanagerConnectionmanagerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadDlnaByUuidConnectionmanagerConnectionmanagerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostDlnaByUuidContentdirectoryControlData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/contentdirectory/control';
};

export type PostDlnaByUuidContentdirectoryControlErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostDlnaByUuidContentdirectoryControlResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostDlnaByUuidConnectionmanagerControlData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/connectionmanager/control';
};

export type PostDlnaByUuidConnectionmanagerControlErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostDlnaByUuidConnectionmanagerControlResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetDlnaByUuidIconsByFilenameData = {
    body?: never;
    path: {
        /**
         * Server UuId
         */
        UuId: string;
        /**
         * The icon filename
         */
        Filename: string;
    };
    query?: never;
    url: '/Dlna/{UuId}/icons/{Filename}';
};

export type GetDlnaByUuidIconsByFilenameErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetDlnaByUuidIconsByFilenameResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetGamegenresByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/GameGenres/{Name}/Images/{Type}';
};

export type GetGamegenresByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetGamegenresByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadGamegenresByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/GameGenres/{Name}/Images/{Type}';
};

export type HeadGamegenresByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadGamegenresByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetGenresByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Genres/{Name}/Images/{Type}';
};

export type GetGenresByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetGenresByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadGenresByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Genres/{Name}/Images/{Type}';
};

export type HeadGenresByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadGenresByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostItemsRemotesearchApplyByIdData = {
    /**
     * RemoteSearchResult:
     */
    body: RemoteSearchResult;
    path: {
        /**
         * The item id
         */
        Id: string;
    };
    query?: {
        /**
         * Whether or not to replace all images
         */
        ReplaceAllImages?: boolean;
    };
    url: '/Items/RemoteSearch/Apply/{Id}';
};

export type PostItemsRemotesearchApplyByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsRemotesearchApplyByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostItemsByIdTagsAddData = {
    /**
     * AddTags
     */
    body: UserLibraryAddTags;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/Tags/Add';
};

export type PostItemsByIdTagsAddErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdTagsAddResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostItemsByIdTagsDeleteData = {
    /**
     * RemoveTags
     */
    body: UserLibraryRemoveTags;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/Tags/Delete';
};

export type PostItemsByIdTagsDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdTagsDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteItemsByIdSubtitlesByIndexData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * The subtitle stream index
         */
        Index: number;
    };
    query: {
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
    };
    url: '/Items/{Id}/Subtitles/{Index}';
};

export type DeleteItemsByIdSubtitlesByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteItemsByIdSubtitlesByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type DeleteItemsByIdImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Items/{Id}/Images/{Type}';
};

export type DeleteItemsByIdImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteItemsByIdImagesByTypeResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetItemsByIdImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Items/{Id}/Images/{Type}';
};

export type GetItemsByIdImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadItemsByIdImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Items/{Id}/Images/{Type}';
};

export type HeadItemsByIdImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadItemsByIdImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostItemsByIdImagesByTypeData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * Image Index
         */
        Index?: number | null;
    };
    url: '/Items/{Id}/Images/{Type}';
};

export type PostItemsByIdImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdImagesByTypeResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetItemsByIdRemoteimagesProvidersData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Items/{Id}/RemoteImages/Providers';
};

export type GetItemsByIdRemoteimagesProvidersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdRemoteimagesProvidersResponses = {
    /**
     * Operation successful. Returning a List<ImageProviderInfo> object.
     */
    200: Array<ImageProviderInfo>;
};

export type GetItemsByIdRemoteimagesProvidersResponse = GetItemsByIdRemoteimagesProvidersResponses[keyof GetItemsByIdRemoteimagesProvidersResponses];

export type PostItemsByIdRemoteimagesDownloadData = {
    /**
     * BaseDownloadRemoteImage:
     */
    body: ImagesBaseDownloadRemoteImage;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * The image type
         */
        Type: ImageType;
        /**
         * The image provider
         */
        ProviderName?: string;
        /**
         * The image url
         */
        ImageUrl?: string;
    };
    url: '/Items/{Id}/RemoteImages/Download';
};

export type PostItemsByIdRemoteimagesDownloadErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdRemoteimagesDownloadResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLibraryVirtualfoldersPathsUpdateData = {
    /**
     * UpdateMediaPath
     */
    body: LibraryUpdateMediaPath;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders/Paths/Update';
};

export type PostLibraryVirtualfoldersPathsUpdateErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryVirtualfoldersPathsUpdateResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLibraryVirtualfoldersPathsDeleteData = {
    /**
     * RemoveMediaPath
     */
    body: LibraryRemoveMediaPath;
    path?: never;
    query?: never;
    url: '/Library/VirtualFolders/Paths/Delete';
};

export type PostLibraryVirtualfoldersPathsDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLibraryVirtualfoldersPathsDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvLivestreamfilesByIdStreamByContainerData = {
    body?: never;
    path: {
        Id: string;
        Container: string;
    };
    query?: never;
    url: '/LiveTv/LiveStreamFiles/{Id}/stream.{Container}';
};

export type GetLivetvLivestreamfilesByIdStreamByContainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvLivestreamfilesByIdStreamByContainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvLiverecordingsByIdStreamData = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/LiveRecordings/{Id}/stream';
};

export type GetLivetvLiverecordingsByIdStreamErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvLiverecordingsByIdStreamResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvListingprovidersSchedulesdirectCountriesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/LiveTv/ListingProviders/SchedulesDirect/Countries';
};

export type GetLivetvListingprovidersSchedulesdirectCountriesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvListingprovidersSchedulesdirectCountriesResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvTunerhostsDefaultByTypeData = {
    body?: never;
    path: {
        /**
         * Type
         */
        Type: string;
    };
    query?: never;
    url: '/LiveTv/TunerHosts/Default/{Type}';
};

export type GetLivetvTunerhostsDefaultByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvTunerhostsDefaultByTypeResponses = {
    /**
     * Operation successful. Returning a TunerHostInfo object.
     */
    200: LiveTvTunerHostInfo;
};

export type GetLivetvTunerhostsDefaultByTypeResponse = GetLivetvTunerhostsDefaultByTypeResponses[keyof GetLivetvTunerhostsDefaultByTypeResponses];

export type PostLivetvRecordingsByIdDeleteData = {
    body?: never;
    path: {
        /**
         * Recording Id
         */
        Id: string;
    };
    query?: never;
    url: '/LiveTv/Recordings/{Id}/Delete';
};

export type PostLivetvRecordingsByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvRecordingsByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLivetvTimersByIdDeleteData = {
    body?: never;
    path: {
        /**
         * Timer Id
         */
        Id: string;
    };
    query?: never;
    url: '/LiveTv/Timers/{Id}/Delete';
};

export type PostLivetvTimersByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvTimersByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLivetvSeriestimersByIdDeleteData = {
    body?: never;
    path: {
        /**
         * Timer Id
         */
        Id: string;
    };
    query?: never;
    url: '/LiveTv/SeriesTimers/{Id}/Delete';
};

export type PostLivetvSeriestimersByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvSeriestimersByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostLivetvTunersByIdResetData = {
    body?: never;
    path: {
        /**
         * Tuner Id
         */
        Id: string;
    };
    query?: never;
    url: '/LiveTv/Tuners/{Id}/Reset';
};

export type PostLivetvTunersByIdResetErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvTunersByIdResetResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetMusicgenresByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/MusicGenres/{Name}/Images/{Type}';
};

export type GetMusicgenresByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetMusicgenresByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadMusicgenresByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/MusicGenres/{Name}/Images/{Type}';
};

export type HeadMusicgenresByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadMusicgenresByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostPackagesInstallingByIdDeleteData = {
    body?: never;
    path: {
        /**
         * Installation Id
         */
        Id: string;
    };
    query?: never;
    url: '/Packages/Installing/{Id}/Delete';
};

export type PostPackagesInstallingByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostPackagesInstallingByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetPersonsByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Persons/{Name}/Images/{Type}';
};

export type GetPersonsByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPersonsByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadPersonsByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Persons/{Name}/Images/{Type}';
};

export type HeadPersonsByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadPersonsByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostPlaylistsByIdItemsDeleteData = {
    body?: never;
    path: {
        Id: string;
    };
    query: {
        EntryIds: string;
    };
    url: '/Playlists/{Id}/Items/Delete';
};

export type PostPlaylistsByIdItemsDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostPlaylistsByIdItemsDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetProvidersSubtitlesSubtitlesByIdData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Providers/Subtitles/Subtitles/{Id}';
};

export type GetProvidersSubtitlesSubtitlesByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetProvidersSubtitlesSubtitlesByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostScheduledtasksRunningByIdDeleteData = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/ScheduledTasks/Running/{Id}/Delete';
};

export type PostScheduledtasksRunningByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostScheduledtasksRunningByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsByIdPlayingByCommandData = {
    /**
     * PlaystateRequest:
     */
    body: PlaystateRequest;
    path: {
        /**
         * Session Id
         */
        Id: string;
        Command: PlaystateCommand;
    };
    query?: never;
    url: '/Sessions/{Id}/Playing/{Command}';
};

export type PostSessionsByIdPlayingByCommandErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsByIdPlayingByCommandResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsByIdSystemByCommandData = {
    body?: never;
    path: {
        /**
         * Session Id
         */
        Id: string;
        /**
         * The command to send.
         */
        Command: string;
    };
    query?: never;
    url: '/Sessions/{Id}/System/{Command}';
};

export type PostSessionsByIdSystemByCommandErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsByIdSystemByCommandResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsByIdCommandByCommandData = {
    body?: never;
    path: {
        /**
         * Session Id
         */
        Id: string;
        /**
         * The command to send.
         */
        Command: string;
    };
    query?: never;
    url: '/Sessions/{Id}/Command/{Command}';
};

export type PostSessionsByIdCommandByCommandErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsByIdCommandByCommandResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteSessionsByIdUsersByUseridData = {
    body?: never;
    path: {
        /**
         * Session Id
         */
        Id: string;
        /**
         * UserId Id
         */
        UserId: string;
    };
    query?: never;
    url: '/Sessions/{Id}/Users/{UserId}';
};

export type DeleteSessionsByIdUsersByUseridErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteSessionsByIdUsersByUseridResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSessionsByIdUsersByUseridData = {
    body?: never;
    path: {
        /**
         * Session Id
         */
        Id: string;
        /**
         * UserId Id
         */
        UserId: string;
    };
    query?: never;
    url: '/Sessions/{Id}/Users/{UserId}';
};

export type PostSessionsByIdUsersByUseridErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsByIdUsersByUseridResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetStudiosByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Studios/{Name}/Images/{Type}';
};

export type GetStudiosByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetStudiosByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadStudiosByNameImagesByTypeData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Studios/{Name}/Images/{Type}';
};

export type HeadStudiosByNameImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadStudiosByNameImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostSyncJobsByIdDeleteData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/Jobs/{Id}/Delete';
};

export type PostSyncJobsByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncJobsByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSyncByTargetidItemsDeleteData = {
    body?: never;
    path: {
        /**
         * TargetId
         */
        TargetId: string;
    };
    query?: {
        /**
         * ItemIds
         */
        ItemIds?: string;
    };
    url: '/Sync/{TargetId}/Items/Delete';
};

export type PostSyncByTargetidItemsDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncByTargetidItemsDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSyncJobitemsByIdTransferredData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/JobItems/{Id}/Transferred';
};

export type PostSyncJobitemsByIdTransferredErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncJobitemsByIdTransferredResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetSyncJobitemsByIdFileData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/JobItems/{Id}/File';
};

export type GetSyncJobitemsByIdFileErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSyncJobitemsByIdFileResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadSyncJobitemsByIdFileData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/JobItems/{Id}/File';
};

export type HeadSyncJobitemsByIdFileErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadSyncJobitemsByIdFileResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetSyncJobitemsByIdAdditionalfilesData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query: {
        /**
         * Name
         */
        Name: string;
    };
    url: '/Sync/JobItems/{Id}/AdditionalFiles';
};

export type GetSyncJobitemsByIdAdditionalfilesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSyncJobitemsByIdAdditionalfilesResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostSyncJobitemsByIdEnableData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/JobItems/{Id}/Enable';
};

export type PostSyncJobitemsByIdEnableErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncJobitemsByIdEnableResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSyncJobitemsByIdDeleteData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/JobItems/{Id}/Delete';
};

export type PostSyncJobitemsByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncJobitemsByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSyncJobitemsByIdMarkforremovalData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/JobItems/{Id}/MarkForRemoval';
};

export type PostSyncJobitemsByIdMarkforremovalErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncJobitemsByIdMarkforremovalResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostSyncJobitemsByIdUnmarkforremovalData = {
    body?: never;
    path: {
        /**
         * Id
         */
        Id: string;
    };
    query?: never;
    url: '/Sync/JobItems/{Id}/UnmarkForRemoval';
};

export type PostSyncJobitemsByIdUnmarkforremovalErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSyncJobitemsByIdUnmarkforremovalResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetSystemLogsByNameLinesData = {
    body?: never;
    path: {
        /**
         * The log file name.
         */
        Name: string;
    };
    query?: never;
    url: '/System/Logs/{Name}/Lines';
};

export type GetSystemLogsByNameLinesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetSystemLogsByNameLinesResponses = {
    /**
     * Operation successful. Returning a QueryResult<String> object.
     */
    200: QueryResultString;
};

export type GetSystemLogsByNameLinesResponse = GetSystemLogsByNameLinesResponses[keyof GetSystemLogsByNameLinesResponses];

export type DeleteUsersByIdTrackselectionsByTracktypeData = {
    body?: never;
    path: {
        Id: string;
        TrackType: string;
    };
    query?: never;
    url: '/Users/{Id}/TrackSelections/{TrackType}';
};

export type DeleteUsersByIdTrackselectionsByTracktypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteUsersByIdTrackselectionsByTracktypeResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByIdConfigurationPartialData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}/Configuration/Partial';
};

export type PostUsersByIdConfigurationPartialErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdConfigurationPartialResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetUsersByUseridTypedsettingsByKeyData = {
    body?: never;
    path: {
        /**
         * Key
         */
        Key: string;
        UserId: string;
    };
    query?: never;
    url: '/Users/{UserId}/TypedSettings/{Key}';
};

export type GetUsersByUseridTypedsettingsByKeyErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridTypedsettingsByKeyResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostUsersByUseridTypedsettingsByKeyData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        UserId: string;
        /**
         * Key
         */
        Key: string;
    };
    query?: never;
    url: '/Users/{UserId}/TypedSettings/{Key}';
};

export type PostUsersByUseridTypedsettingsByKeyErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridTypedsettingsByKeyResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetUsersByUseridItemsResumeData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Users/{UserId}/Items/Resume';
};

export type GetUsersByUseridItemsResumeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridItemsResumeResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetUsersByUseridItemsResumeResponse = GetUsersByUseridItemsResumeResponses[keyof GetUsersByUseridItemsResumeResponses];

export type GetUsersByUseridItemsLatestData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
    };
    query?: {
        /**
         * Limit
         */
        Limit?: number;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Filter by items that are folders, or not.
         */
        IsFolder?: boolean | null;
        /**
         * Filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Whether or not to group items into a parent container.
         */
        GroupItems?: boolean;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
    };
    url: '/Users/{UserId}/Items/Latest';
};

export type GetUsersByUseridItemsLatestErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridItemsLatestResponses = {
    /**
     * Operation successful. Returning a BaseItemDto[] object.
     */
    200: Array<BaseItemDto>;
};

export type GetUsersByUseridItemsLatestResponse = GetUsersByUseridItemsLatestResponses[keyof GetUsersByUseridItemsLatestResponses];

export type GetUsersByUseridItemsByIdData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Users/{UserId}/Items/{Id}';
};

export type GetUsersByUseridItemsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridItemsByIdResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetUsersByUseridItemsByIdResponse = GetUsersByUseridItemsByIdResponses[keyof GetUsersByUseridItemsByIdResponses];

export type GetUsersByUseridItemsRootData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
    };
    query?: never;
    url: '/Users/{UserId}/Items/Root';
};

export type GetUsersByUseridItemsRootErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridItemsRootResponses = {
    /**
     * Operation successful. Returning a BaseItemDto object.
     */
    200: BaseItemDto;
};

export type GetUsersByUseridItemsRootResponse = GetUsersByUseridItemsRootResponses[keyof GetUsersByUseridItemsRootResponses];

export type DeleteUsersByUseridFavoriteitemsByIdData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Users/{UserId}/FavoriteItems/{Id}';
};

export type DeleteUsersByUseridFavoriteitemsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteUsersByUseridFavoriteitemsByIdResponses = {
    /**
     * Operation successful. Returning a UserItemDataDto object.
     */
    200: UserItemDataDto;
};

export type DeleteUsersByUseridFavoriteitemsByIdResponse = DeleteUsersByUseridFavoriteitemsByIdResponses[keyof DeleteUsersByUseridFavoriteitemsByIdResponses];

export type PostUsersByUseridFavoriteitemsByIdData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Users/{UserId}/FavoriteItems/{Id}';
};

export type PostUsersByUseridFavoriteitemsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridFavoriteitemsByIdResponses = {
    /**
     * Operation successful. Returning a UserItemDataDto object.
     */
    200: UserItemDataDto;
};

export type PostUsersByUseridFavoriteitemsByIdResponse = PostUsersByUseridFavoriteitemsByIdResponses[keyof PostUsersByUseridFavoriteitemsByIdResponses];

export type DeleteUsersByIdImagesByTypeData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Users/{Id}/Images/{Type}';
};

export type DeleteUsersByIdImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteUsersByIdImagesByTypeResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetUsersByIdImagesByTypeData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Users/{Id}/Images/{Type}';
};

export type GetUsersByIdImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByIdImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadUsersByIdImagesByTypeData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Users/{Id}/Images/{Type}';
};

export type HeadUsersByIdImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadUsersByIdImagesByTypeResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostUsersByIdImagesByTypeData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        /**
         * User Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: never;
    url: '/Users/{Id}/Images/{Type}';
};

export type PostUsersByIdImagesByTypeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdImagesByTypeResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteUsersByUseridPlayeditemsByIdData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Users/{UserId}/PlayedItems/{Id}';
};

export type DeleteUsersByUseridPlayeditemsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteUsersByUseridPlayeditemsByIdResponses = {
    /**
     * Operation successful. Returning a UserItemDataDto object.
     */
    200: UserItemDataDto;
};

export type DeleteUsersByUseridPlayeditemsByIdResponse = DeleteUsersByUseridPlayeditemsByIdResponses[keyof DeleteUsersByUseridPlayeditemsByIdResponses];

export type PostUsersByUseridPlayeditemsByIdData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * The date the item was played (if any). Format = yyyyMMddHHmmss
         */
        DatePlayed?: string;
    };
    url: '/Users/{UserId}/PlayedItems/{Id}';
};

export type PostUsersByUseridPlayeditemsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridPlayeditemsByIdResponses = {
    /**
     * Operation successful. Returning a UserItemDataDto object.
     */
    200: UserItemDataDto;
};

export type PostUsersByUseridPlayeditemsByIdResponse = PostUsersByUseridPlayeditemsByIdResponses[keyof PostUsersByUseridPlayeditemsByIdResponses];

export type DeleteUsersByUseridPlayingitemsByIdData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * The id of the MediaSource
         */
        MediaSourceId: string;
        /**
         * The next media type that will play
         */
        NextMediaType: string;
        /**
         * Optional. The position, in ticks, where playback stopped. 1ms = 10000 ticks.
         */
        PositionTicks?: number | null;
        LiveStreamId?: string;
        PlaySessionId?: string;
    };
    url: '/Users/{UserId}/PlayingItems/{Id}';
};

export type DeleteUsersByUseridPlayingitemsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteUsersByUseridPlayingitemsByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByUseridPlayingitemsByIdData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * The id of the MediaSource
         */
        MediaSourceId: string;
        /**
         * Indicates if the client can seek
         */
        CanSeek?: boolean;
        AudioStreamIndex?: number | null;
        SubtitleStreamIndex?: number | null;
        PlayMethod?: PlayMethod;
        LiveStreamId?: string;
        PlaySessionId?: string;
    };
    url: '/Users/{UserId}/PlayingItems/{Id}';
};

export type PostUsersByUseridPlayingitemsByIdErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridPlayingitemsByIdResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteUsersByIdConnectLinkData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}/Connect/Link';
};

export type DeleteUsersByIdConnectLinkErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteUsersByIdConnectLinkResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByIdConnectLinkData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
    };
    query: {
        /**
         * Connect username
         */
        ConnectUsername: string;
    };
    url: '/Users/{Id}/Connect/Link';
};

export type PostUsersByIdConnectLinkErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdConnectLinkResponses = {
    /**
     * Operation successful. Returning a UserLinkResult object.
     */
    200: ConnectUserLinkResult;
};

export type PostUsersByIdConnectLinkResponse = PostUsersByIdConnectLinkResponses[keyof PostUsersByIdConnectLinkResponses];

export type PostVideosByIdAlternatesourcesDeleteData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Videos/{Id}/AlternateSources/Delete';
};

export type PostVideosByIdAlternatesourcesDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostVideosByIdAlternatesourcesDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type DeleteVideosByIdSubtitlesByIndexData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * The subtitle stream index
         */
        Index: number;
    };
    query: {
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
    };
    url: '/Videos/{Id}/Subtitles/{Index}';
};

export type DeleteVideosByIdSubtitlesByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteVideosByIdSubtitlesByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetArtistsByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Artists/{Name}/Images/{Type}/{Index}';
};

export type GetArtistsByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetArtistsByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadArtistsByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Artists/{Name}/Images/{Type}/{Index}';
};

export type HeadArtistsByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadArtistsByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    body?: never;
    path: {
        SegmentContainer: string;
        SegmentId: string;
        Id: string;
        PlaylistId: string;
    };
    query?: never;
    url: '/Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}';
};

export type GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    body?: never;
    path: {
        SegmentContainer: string;
        SegmentId: string;
        Id: string;
        PlaylistId: string;
    };
    query?: never;
    url: '/Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}';
};

export type HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerData = {
    body?: never;
    path: {
        SegmentContainer: string;
        SegmentId: string;
        Id: string;
        PlaylistId: string;
    };
    query?: never;
    url: '/Audio/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}';
};

export type GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetGamegenresByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/GameGenres/{Name}/Images/{Type}/{Index}';
};

export type GetGamegenresByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetGamegenresByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadGamegenresByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/GameGenres/{Name}/Images/{Type}/{Index}';
};

export type HeadGamegenresByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadGamegenresByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetGenresByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Genres/{Name}/Images/{Type}/{Index}';
};

export type GetGenresByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetGenresByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadGenresByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Genres/{Name}/Images/{Type}/{Index}';
};

export type HeadGenresByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadGenresByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetItemsByIdRemotesearchSubtitlesByLanguageData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Language
         */
        Language: string;
    };
    query: {
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
        /**
         * IsPerfectMatch
         */
        IsPerfectMatch?: boolean | null;
        /**
         * IsForced
         */
        IsForced?: boolean | null;
        /**
         * IsHearingImpaired
         */
        IsHearingImpaired?: boolean | null;
    };
    url: '/Items/{Id}/RemoteSearch/Subtitles/{Language}';
};

export type GetItemsByIdRemotesearchSubtitlesByLanguageErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdRemotesearchSubtitlesByLanguageResponses = {
    /**
     * Operation successful. Returning a RemoteSubtitleInfo[] object.
     */
    200: Array<RemoteSubtitleInfo>;
};

export type GetItemsByIdRemotesearchSubtitlesByLanguageResponse = GetItemsByIdRemotesearchSubtitlesByLanguageResponses[keyof GetItemsByIdRemotesearchSubtitlesByLanguageResponses];

export type PostItemsByIdSubtitlesByIndexDeleteData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * The subtitle stream index
         */
        Index: number;
    };
    query: {
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
    };
    url: '/Items/{Id}/Subtitles/{Index}/Delete';
};

export type PostItemsByIdSubtitlesByIndexDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdSubtitlesByIndexDeleteResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostItemsByIdRemotesearchSubtitlesBySubtitleidData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * SubtitleId
         */
        SubtitleId: string;
    };
    query: {
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
    };
    url: '/Items/{Id}/RemoteSearch/Subtitles/{SubtitleId}';
};

export type PostItemsByIdRemotesearchSubtitlesBySubtitleidErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdRemotesearchSubtitlesBySubtitleidResponses = {
    /**
     * Operation successful. Returning a SubtitleDownloadResult object.
     */
    200: SubtitlesSubtitleDownloadResult;
};

export type PostItemsByIdRemotesearchSubtitlesBySubtitleidResponse = PostItemsByIdRemotesearchSubtitlesBySubtitleidResponses[keyof PostItemsByIdRemotesearchSubtitlesBySubtitleidResponses];

export type DeleteItemsByIdImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: never;
    url: '/Items/{Id}/Images/{Type}/{Index}';
};

export type DeleteItemsByIdImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteItemsByIdImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetItemsByIdImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Items/{Id}/Images/{Type}/{Index}';
};

export type GetItemsByIdImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadItemsByIdImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Items/{Id}/Images/{Type}/{Index}';
};

export type HeadItemsByIdImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadItemsByIdImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostItemsByIdImagesByTypeByIndexData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Index
         */
        Index: number | null;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: never;
    url: '/Items/{Id}/Images/{Type}/{Index}';
};

export type PostItemsByIdImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostItemsByIdImagesByTypeDeleteData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Items/{Id}/Images/{Type}/Delete';
};

export type PostItemsByIdImagesByTypeDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdImagesByTypeDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetLivetvLivestreamfilesByIdHlsMasterM3U8Data = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/LiveStreamFiles/{Id}/hls/master.m3u8';
};

export type GetLivetvLivestreamfilesByIdHlsMasterM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvLivestreamfilesByIdHlsMasterM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadLivetvLivestreamfilesByIdHlsMasterM3U8Data = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/LiveStreamFiles/{Id}/hls/master.m3u8';
};

export type HeadLivetvLivestreamfilesByIdHlsMasterM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadLivetvLivestreamfilesByIdHlsMasterM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvLiverecordingsByIdHlsMasterM3U8Data = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/LiveRecordings/{Id}/hls/master.m3u8';
};

export type GetLivetvLiverecordingsByIdHlsMasterM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvLiverecordingsByIdHlsMasterM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadLivetvLiverecordingsByIdHlsMasterM3U8Data = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/LiveRecordings/{Id}/hls/master.m3u8';
};

export type HeadLivetvLiverecordingsByIdHlsMasterM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadLivetvLiverecordingsByIdHlsMasterM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvLiverecordingsByIdHlsLiveM3U8Data = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/LiveRecordings/{Id}/hls/live.m3u8';
};

export type GetLivetvLiverecordingsByIdHlsLiveM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvLiverecordingsByIdHlsLiveM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadLivetvLiverecordingsByIdHlsLiveM3U8Data = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/LiveRecordings/{Id}/hls/live.m3u8';
};

export type HeadLivetvLiverecordingsByIdHlsLiveM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadLivetvLiverecordingsByIdHlsLiveM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvLivestreamfilesByIdHlsLiveM3U8Data = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/LiveStreamFiles/{Id}/hls/live.m3u8';
};

export type GetLivetvLivestreamfilesByIdHlsLiveM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvLivestreamfilesByIdHlsLiveM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadLivetvLivestreamfilesByIdHlsLiveM3U8Data = {
    body?: never;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/LiveStreamFiles/{Id}/hls/live.m3u8';
};

export type HeadLivetvLivestreamfilesByIdHlsLiveM3U8Errors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadLivetvLivestreamfilesByIdHlsLiveM3U8Responses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvLivestreamfilesByIdHlsBySegmentData = {
    body?: never;
    path: {
        Id: string;
        Segment: string;
    };
    query?: never;
    url: '/LiveTv/LiveStreamFiles/{Id}/hls/{Segment}';
};

export type GetLivetvLivestreamfilesByIdHlsBySegmentErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvLivestreamfilesByIdHlsBySegmentResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadLivetvLivestreamfilesByIdHlsBySegmentData = {
    body?: never;
    path: {
        Id: string;
        Segment: string;
    };
    query?: never;
    url: '/LiveTv/LiveStreamFiles/{Id}/hls/{Segment}';
};

export type HeadLivetvLivestreamfilesByIdHlsBySegmentErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadLivetvLivestreamfilesByIdHlsBySegmentResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetLivetvLiverecordingsByIdHlsBySegmentData = {
    body?: never;
    path: {
        Id: string;
        Segment: string;
    };
    query?: never;
    url: '/LiveTv/LiveRecordings/{Id}/hls/{Segment}';
};

export type GetLivetvLiverecordingsByIdHlsBySegmentErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetLivetvLiverecordingsByIdHlsBySegmentResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadLivetvLiverecordingsByIdHlsBySegmentData = {
    body?: never;
    path: {
        Id: string;
        Segment: string;
    };
    query?: never;
    url: '/LiveTv/LiveRecordings/{Id}/hls/{Segment}';
};

export type HeadLivetvLiverecordingsByIdHlsBySegmentErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadLivetvLiverecordingsByIdHlsBySegmentResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostLivetvManageChannelsByIdDisabledData = {
    /**
     * SetChannelDisabled
     */
    body: ApiSetChannelDisabled;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/Manage/Channels/{Id}/Disabled';
};

export type PostLivetvManageChannelsByIdDisabledErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvManageChannelsByIdDisabledResponses = {
    /**
     * Operation successful. Returning a QueryResult<ChannelManagementInfo> object.
     */
    200: QueryResultChannelManagementInfo;
};

export type PostLivetvManageChannelsByIdDisabledResponse = PostLivetvManageChannelsByIdDisabledResponses[keyof PostLivetvManageChannelsByIdDisabledResponses];

export type PostLivetvManageChannelsByIdSortindexData = {
    /**
     * SetChannelSortIndex
     */
    body: ApiSetChannelSortIndex;
    path: {
        Id: string;
    };
    query?: never;
    url: '/LiveTv/Manage/Channels/{Id}/SortIndex';
};

export type PostLivetvManageChannelsByIdSortindexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostLivetvManageChannelsByIdSortindexResponses = {
    /**
     * Operation successful. Returning a QueryResult<ChannelManagementInfo> object.
     */
    200: QueryResultChannelManagementInfo;
};

export type PostLivetvManageChannelsByIdSortindexResponse = PostLivetvManageChannelsByIdSortindexResponses[keyof PostLivetvManageChannelsByIdSortindexResponses];

export type GetMusicgenresByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/MusicGenres/{Name}/Images/{Type}/{Index}';
};

export type GetMusicgenresByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetMusicgenresByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadMusicgenresByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/MusicGenres/{Name}/Images/{Type}/{Index}';
};

export type HeadMusicgenresByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadMusicgenresByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetPersonsByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Persons/{Name}/Images/{Type}/{Index}';
};

export type GetPersonsByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetPersonsByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadPersonsByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Persons/{Name}/Images/{Type}/{Index}';
};

export type HeadPersonsByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadPersonsByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostSessionsByIdUsersByUseridDeleteData = {
    body?: never;
    path: {
        /**
         * Session Id
         */
        Id: string;
        /**
         * UserId Id
         */
        UserId: string;
    };
    query?: never;
    url: '/Sessions/{Id}/Users/{UserId}/Delete';
};

export type PostSessionsByIdUsersByUseridDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostSessionsByIdUsersByUseridDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetStudiosByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Studios/{Name}/Images/{Type}/{Index}';
};

export type GetStudiosByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetStudiosByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadStudiosByNameImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * Item name
         */
        Name: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Studios/{Name}/Images/{Type}/{Index}';
};

export type HeadStudiosByNameImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadStudiosByNameImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostUsersByIdTrackselectionsByTracktypeDeleteData = {
    body?: never;
    path: {
        Id: string;
        TrackType: string;
    };
    query?: never;
    url: '/Users/{Id}/TrackSelections/{TrackType}/Delete';
};

export type PostUsersByIdTrackselectionsByTracktypeDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdTrackselectionsByTracktypeDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetUsersByUseridSectionsBySectionidItemsData = {
    body?: never;
    path: {
        SectionId: string;
        /**
         * User Id
         */
        UserId: string;
    };
    query?: {
        /**
         * Artist or AlbumArtist
         */
        ArtistType?: string;
        /**
         * Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
         */
        MaxOfficialRating?: string;
        /**
         * Optional filter by items with theme songs.
         */
        HasThemeSong?: boolean | null;
        /**
         * Optional filter by items with theme videos.
         */
        HasThemeVideo?: boolean | null;
        /**
         * Optional filter by items with subtitles.
         */
        HasSubtitles?: boolean | null;
        /**
         * Optional filter by items with special features.
         */
        HasSpecialFeature?: boolean | null;
        /**
         * Optional filter by items with trailers.
         */
        HasTrailer?: boolean | null;
        /**
         * Optional. Filter by special season.
         */
        IsSpecialSeason?: boolean | null;
        /**
         * Optional. Return items that are siblings of a supplied item.
         */
        AdjacentTo?: string;
        /**
         * Optional. Skip through the list until a given item is found.
         */
        StartItemId?: string;
        /**
         * Optional filter by minimum index number.
         */
        MinIndexNumber?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinStartDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxStartDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinEndDate?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxEndDate?: string | null;
        /**
         * Optional filter by minimum number of game players.
         */
        MinPlayers?: number | null;
        /**
         * Optional filter by maximum number of game players.
         */
        MaxPlayers?: number | null;
        /**
         * Optional filter by parent index number.
         */
        ParentIndexNumber?: number | null;
        /**
         * Optional filter by items that have or do not have a parental rating
         */
        HasParentalRating?: boolean | null;
        /**
         * Optional filter by items that are HD or not.
         */
        IsHD?: boolean | null;
        /**
         * Optional filter by items that are unaired episodes or not.
         */
        IsUnaired?: boolean | null;
        /**
         * Optional filter by minimum community rating.
         */
        MinCommunityRating?: number | null;
        /**
         * Optional filter by minimum critic rating.
         */
        MinCriticRating?: number | null;
        /**
         * Gets all episodes that aired during a season, including specials.
         */
        AiredDuringSeason?: number | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinPremiereDate?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSaved?: string | null;
        /**
         * Optional. The minimum premiere date. Format = ISO
         */
        MinDateLastSavedForUser?: string | null;
        /**
         * Optional. The maximum premiere date. Format = ISO
         */
        MaxPremiereDate?: string | null;
        /**
         * Optional filter by items that have an overview or not.
         */
        HasOverview?: boolean | null;
        /**
         * Optional filter by items that have an imdb id or not.
         */
        HasImdbId?: boolean | null;
        /**
         * Optional filter by items that have a tmdb id or not.
         */
        HasTmdbId?: boolean | null;
        /**
         * Optional filter by items that have a tvdb id or not.
         */
        HasTvdbId?: boolean | null;
        /**
         * Optional. If specified, results will be filtered by exxcluding item ids. This allows multiple, comma delimeted.
         */
        ExcludeItemIds?: string;
        /**
         * Optional. The record index to start at. All items with a lower index will be dropped from the results.
         */
        StartIndex?: number | null;
        /**
         * Optional. The maximum number of records to return
         */
        Limit?: number | null;
        /**
         * When searching within folders, this determines whether or not the search will be recursive. true/false
         */
        Recursive?: boolean;
        /**
         * Enter a search term to perform a search request
         */
        SearchTerm?: string;
        /**
         * Sort Order - Ascending,Descending
         */
        SortOrder?: string;
        /**
         * Specify this to localize the search to a specific item or folder. Omit to use the root
         */
        ParentId?: string;
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines
         */
        Fields?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        ExcludeItemTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimeted.
         */
        IncludeItemTypes?: string;
        /**
         * Optional. If specified, result will be filtered to contain only items which match at least one of the specified IDs. Each provider ID must be in the form 'prov.id', e.g. 'imdb.tt123456'. This allows multiple, comma delimeted value pairs.
         */
        AnyProviderIdEquals?: string;
        /**
         * Optional. Specify additional filters to apply. This allows multiple, comma delimeted. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes
         */
        Filters?: string;
        /**
         * Optional filter by items that are marked as favorite, or not.
         */
        IsFavorite?: boolean | null;
        /**
         * Optional filter for movies.
         */
        IsMovie?: boolean | null;
        /**
         * Optional filter for series.
         */
        IsSeries?: boolean | null;
        /**
         * Optional filter for folders.
         */
        IsFolder?: boolean | null;
        /**
         * Optional filter for news.
         */
        IsNews?: boolean | null;
        /**
         * Optional filter for kids.
         */
        IsKids?: boolean | null;
        /**
         * Optional filter for sports.
         */
        IsSports?: boolean | null;
        /**
         * Optional filter for IsNew.
         */
        IsNew?: boolean | null;
        /**
         * Optional filter for IsPremiere.
         */
        IsPremiere?: boolean | null;
        /**
         * Optional filter for IsNewOrPremiere.
         */
        IsNewOrPremiere?: boolean | null;
        /**
         * Optional filter for IsRepeat.
         */
        IsRepeat?: boolean | null;
        /**
         * ProjectToMedia
         */
        ProjectToMedia?: boolean;
        /**
         * Optional filter by MediaType. Allows multiple, comma delimited.
         */
        MediaTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
         */
        ImageTypes?: string;
        /**
         * Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime
         */
        SortBy?: string;
        /**
         * Optional filter by items that are played, or not.
         */
        IsPlayed?: boolean | null;
        /**
         * Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimeted.
         */
        Genres?: string;
        /**
         * Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimeted.
         */
        OfficialRatings?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        Tags?: string;
        /**
         * Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimeted.
         */
        ExcludeTags?: string;
        /**
         * Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimeted.
         */
        Years?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        Person?: string;
        /**
         * Optional. If specified, results will be filtered to include only those containing the specified person.
         */
        PersonIds?: string;
        /**
         * Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited
         */
        PersonTypes?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        Studios?: string;
        /**
         * Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimeted.
         */
        StudioIds?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        Artists?: string;
        /**
         * Optional. If specified, results will be filtered based on artist. This allows multiple, pipe delimeted.
         */
        ArtistIds?: string;
        /**
         * Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimeted.
         */
        Albums?: string;
        /**
         * Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
         */
        Ids?: string;
        /**
         * Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimeted.
         */
        VideoTypes?: string;
        /**
         * Optional filter by Container. Allows multiple, comma delimeted.
         */
        Containers?: string;
        /**
         * Optional filter by AudioCodec. Allows multiple, comma delimeted.
         */
        AudioCodecs?: string;
        /**
         * Optional filter by AudioLayout. Allows multiple, comma delimeted.
         */
        AudioLayouts?: string;
        /**
         * Optional filter by VideoCodec. Allows multiple, comma delimeted.
         */
        VideoCodecs?: string;
        /**
         * Optional filter by ExtendedVideoType. Allows multiple, comma delimeted.
         */
        ExtendedVideoTypes?: string;
        /**
         * Optional filter by SubtitleCodec. Allows multiple, comma delimeted.
         */
        SubtitleCodecs?: string;
        /**
         * Optional filter by Path.
         */
        Path?: string;
        /**
         * Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
         */
        MinOfficialRating?: string;
        /**
         * Optional filter by items that are locked.
         */
        IsLocked?: boolean | null;
        /**
         * Optional filter by items that are placeholders
         */
        IsPlaceHolder?: boolean | null;
        /**
         * Optional filter by items that have official ratings
         */
        HasOfficialRating?: boolean | null;
        /**
         * Whether or not to hide items behind their boxsets.
         */
        GroupItemsIntoCollections?: boolean;
        /**
         * Optional filter by items that are 3D, or not.
         */
        Is3D?: boolean | null;
        /**
         * Optional filter by Series Status. Allows multiple, comma delimeted.
         */
        SeriesStatus?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        NameStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        ArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally or greater than a given input string.
         */
        AlbumArtistStartsWithOrGreater?: string;
        /**
         * Optional filter by items whose name is sorted equally than a given input string.
         */
        NameStartsWith?: string;
        /**
         * Optional filter by items whose name is equally or lesser than a given input string.
         */
        NameLessThan?: string;
    };
    url: '/Users/{UserId}/Sections/{SectionId}/Items';
};

export type GetUsersByUseridSectionsBySectionidItemsErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridSectionsBySectionidItemsResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetUsersByUseridSectionsBySectionidItemsResponse = GetUsersByUseridSectionsBySectionidItemsResponses[keyof GetUsersByUseridSectionsBySectionidItemsResponses];

export type GetUsersByUseridItemsByIdSpecialfeaturesData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Movie Id
         */
        Id: string;
    };
    query?: {
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         */
        Fields?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
    };
    url: '/Users/{UserId}/Items/{Id}/SpecialFeatures';
};

export type GetUsersByUseridItemsByIdSpecialfeaturesErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridItemsByIdSpecialfeaturesResponses = {
    /**
     * Operation successful. Returning a BaseItemDto[] object.
     */
    200: Array<BaseItemDto>;
};

export type GetUsersByUseridItemsByIdSpecialfeaturesResponse = GetUsersByUseridItemsByIdSpecialfeaturesResponses[keyof GetUsersByUseridItemsByIdSpecialfeaturesResponses];

export type GetUsersByUseridItemsByIdLocaltrailersData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         */
        Fields?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
    };
    url: '/Users/{UserId}/Items/{Id}/LocalTrailers';
};

export type GetUsersByUseridItemsByIdLocaltrailersErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridItemsByIdLocaltrailersResponses = {
    /**
     * Operation successful. Returning a BaseItemDto[] object.
     */
    200: Array<BaseItemDto>;
};

export type GetUsersByUseridItemsByIdLocaltrailersResponse = GetUsersByUseridItemsByIdLocaltrailersResponses[keyof GetUsersByUseridItemsByIdLocaltrailersResponses];

export type GetUsersByUseridItemsByIdIntrosData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: {
        /**
         * Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls
         */
        Fields?: string;
        /**
         * Optional, include image information in output
         */
        EnableImages?: boolean | null;
        /**
         * Optional, the max number of images to return, per image type
         */
        ImageTypeLimit?: number | null;
        /**
         * Optional. The image types to include in the output.
         */
        EnableImageTypes?: string;
        /**
         * Optional, include user data
         */
        EnableUserData?: boolean | null;
    };
    url: '/Users/{UserId}/Items/{Id}/Intros';
};

export type GetUsersByUseridItemsByIdIntrosErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByUseridItemsByIdIntrosResponses = {
    /**
     * Operation successful. Returning a QueryResult<BaseItemDto> object.
     */
    200: QueryResultBaseItemDto;
};

export type GetUsersByUseridItemsByIdIntrosResponse = GetUsersByUseridItemsByIdIntrosResponses[keyof GetUsersByUseridItemsByIdIntrosResponses];

export type PostUsersByUseridFavoriteitemsByIdDeleteData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Users/{UserId}/FavoriteItems/{Id}/Delete';
};

export type PostUsersByUseridFavoriteitemsByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridFavoriteitemsByIdDeleteResponses = {
    /**
     * Operation successful. Returning a UserItemDataDto object.
     */
    200: UserItemDataDto;
};

export type PostUsersByUseridFavoriteitemsByIdDeleteResponse = PostUsersByUseridFavoriteitemsByIdDeleteResponses[keyof PostUsersByUseridFavoriteitemsByIdDeleteResponses];

export type DeleteUsersByUseridItemsByIdRatingData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Users/{UserId}/Items/{Id}/Rating';
};

export type DeleteUsersByUseridItemsByIdRatingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteUsersByUseridItemsByIdRatingResponses = {
    /**
     * Operation successful. Returning a UserItemDataDto object.
     */
    200: UserItemDataDto;
};

export type DeleteUsersByUseridItemsByIdRatingResponse = DeleteUsersByUseridItemsByIdRatingResponses[keyof DeleteUsersByUseridItemsByIdRatingResponses];

export type PostUsersByUseridItemsByIdRatingData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Whether the user likes the item or not. true/false
         */
        Likes: boolean;
    };
    url: '/Users/{UserId}/Items/{Id}/Rating';
};

export type PostUsersByUseridItemsByIdRatingErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridItemsByIdRatingResponses = {
    /**
     * Operation successful. Returning a UserItemDataDto object.
     */
    200: UserItemDataDto;
};

export type PostUsersByUseridItemsByIdRatingResponse = PostUsersByUseridItemsByIdRatingResponses[keyof PostUsersByUseridItemsByIdRatingResponses];

export type PostUsersByUseridItemsByIdHidefromresumeData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * Whether the item should be hidden from reusme or not. true/false
         */
        Hide: boolean;
    };
    url: '/Users/{UserId}/Items/{Id}/HideFromResume';
};

export type PostUsersByUseridItemsByIdHidefromresumeErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridItemsByIdHidefromresumeResponses = {
    /**
     * Operation successful. Returning a UserItemDataDto object.
     */
    200: UserItemDataDto;
};

export type PostUsersByUseridItemsByIdHidefromresumeResponse = PostUsersByUseridItemsByIdHidefromresumeResponses[keyof PostUsersByUseridItemsByIdHidefromresumeResponses];

export type DeleteUsersByIdImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: never;
    url: '/Users/{Id}/Images/{Type}/{Index}';
};

export type DeleteUsersByIdImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type DeleteUsersByIdImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetUsersByIdImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Users/{Id}/Images/{Type}/{Index}';
};

export type GetUsersByIdImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetUsersByIdImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadUsersByIdImagesByTypeByIndexData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * The maximum image width to return.
         */
        MaxWidth?: number;
        /**
         * The maximum image height to return.
         */
        MaxHeight?: number;
        /**
         * The fixed image width to return.
         */
        Width?: number;
        /**
         * The fixed image height to return.
         */
        Height?: number;
        /**
         * Optional quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
         */
        Quality?: number;
        /**
         * Optional. Supply the cache tag from the item object to receive strong caching headers.
         */
        Tag?: string;
        /**
         * Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
         */
        CropWhitespace?: boolean | null;
        /**
         * Enable or disable image enhancers such as cover art.
         */
        EnableImageEnhancers?: boolean;
        /**
         * Determines the output foramt of the image - original,gif,jpg,png
         */
        Format?: string;
        /**
         * Optional. Apply a background color for transparent images.
         */
        BackgroundColor?: string;
        /**
         * Optional. Apply a foreground layer on top of the image.
         */
        ForegroundLayer?: string;
        /**
         * Set to true to force normalization of orientation in the event the renderer does not support it.
         */
        AutoOrient?: boolean;
        /**
         * Set to true to retain image animation (when supported).
         */
        KeepAnimation?: boolean;
    };
    url: '/Users/{Id}/Images/{Type}/{Index}';
};

export type HeadUsersByIdImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadUsersByIdImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostUsersByIdImagesByTypeByIndexData = {
    /**
     * Binary stream
     */
    body: Blob | File;
    path: {
        /**
         * User Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: never;
    url: '/Users/{Id}/Images/{Type}/{Index}';
};

export type PostUsersByIdImagesByTypeByIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdImagesByTypeByIndexResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByIdImagesByTypeDeleteData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: {
        /**
         * Image Index
         */
        Index?: number;
    };
    url: '/Users/{Id}/Images/{Type}/Delete';
};

export type PostUsersByIdImagesByTypeDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdImagesByTypeDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByUseridItemsByItemidUserdataData = {
    /**
     * UserItemDataDto:
     */
    body: UserItemDataDto;
    path: {
        /**
         * User Id
         */
        UserId: string;
        ItemId: string;
    };
    query?: never;
    url: '/Users/{UserId}/Items/{ItemId}/UserData';
};

export type PostUsersByUseridItemsByItemidUserdataErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridItemsByItemidUserdataResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByUseridPlayingitemsByIdProgressData = {
    /**
     * OnPlaybackProgress
     */
    body: ApiOnPlaybackProgress;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * The id of the MediaSource
         */
        MediaSourceId: string;
        /**
         * Optional. The current position, in ticks. 1ms = 10000 ticks.
         */
        PositionTicks?: number | null;
        /**
         * Indicates if the player is paused.
         */
        IsPaused?: boolean;
        /**
         * Indicates if the player is muted.
         */
        IsMuted?: boolean;
        AudioStreamIndex?: number | null;
        SubtitleStreamIndex?: number | null;
        /**
         * Scale of 0-100
         */
        VolumeLevel?: number | null;
        PlayMethod?: PlayMethod;
        LiveStreamId?: string;
        PlaySessionId?: string;
        RepeatMode?: RepeatMode;
        SubtitleOffset?: number;
        PlaybackRate?: number;
    };
    url: '/Users/{UserId}/PlayingItems/{Id}/Progress';
};

export type PostUsersByUseridPlayingitemsByIdProgressErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridPlayingitemsByIdProgressResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByUseridPlayingitemsByIdDeleteData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query: {
        /**
         * The id of the MediaSource
         */
        MediaSourceId: string;
        /**
         * The next media type that will play
         */
        NextMediaType: string;
        /**
         * Optional. The position, in ticks, where playback stopped. 1ms = 10000 ticks.
         */
        PositionTicks?: number | null;
        LiveStreamId?: string;
        PlaySessionId?: string;
    };
    url: '/Users/{UserId}/PlayingItems/{Id}/Delete';
};

export type PostUsersByUseridPlayingitemsByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridPlayingitemsByIdDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByUseridPlayeditemsByIdDeleteData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Users/{UserId}/PlayedItems/{Id}/Delete';
};

export type PostUsersByUseridPlayeditemsByIdDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridPlayeditemsByIdDeleteResponses = {
    /**
     * Operation successful. Returning a UserItemDataDto object.
     */
    200: UserItemDataDto;
};

export type PostUsersByUseridPlayeditemsByIdDeleteResponse = PostUsersByUseridPlayeditemsByIdDeleteResponses[keyof PostUsersByUseridPlayeditemsByIdDeleteResponses];

export type PostUsersByIdConnectLinkDeleteData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
    };
    query?: never;
    url: '/Users/{Id}/Connect/Link/Delete';
};

export type PostUsersByIdConnectLinkDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdConnectLinkDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostVideosByIdSubtitlesByIndexDeleteData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * The subtitle stream index
         */
        Index: number;
    };
    query: {
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
    };
    url: '/Videos/{Id}/Subtitles/{Index}/Delete';
};

export type PostVideosByIdSubtitlesByIndexDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostVideosByIdSubtitlesByIndexDeleteResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    body?: never;
    path: {
        SegmentContainer: string;
        SegmentId: string;
        Id: string;
        PlaylistId: string;
    };
    query?: never;
    url: '/Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}';
};

export type GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData = {
    body?: never;
    path: {
        SegmentContainer: string;
        SegmentId: string;
        Id: string;
        PlaylistId: string;
    };
    query?: never;
    url: '/Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}';
};

export type HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerData = {
    body?: never;
    path: {
        SegmentContainer: string;
        SegmentId: string;
        Id: string;
        PlaylistId: string;
    };
    query?: never;
    url: '/Videos/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}';
};

export type GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
        /**
         * The subtitle stream index
         */
        Index: number;
        /**
         * Format
         */
        Format: string;
    };
    query?: {
        /**
         * StartPositionTicks
         */
        StartPositionTicks?: number;
        /**
         * EndPositionTicks
         */
        EndPositionTicks?: number | null;
        /**
         * CopyTimestamps
         */
        CopyTimestamps?: boolean;
    };
    url: '/Items/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}';
};

export type GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
        /**
         * The subtitle stream index
         */
        Index: number;
        /**
         * Format
         */
        Format: string;
    };
    query?: {
        /**
         * StartPositionTicks
         */
        StartPositionTicks?: number;
        /**
         * EndPositionTicks
         */
        EndPositionTicks?: number | null;
        /**
         * CopyTimestamps
         */
        CopyTimestamps?: boolean;
    };
    url: '/Items/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}';
};

export type HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type PostItemsByIdImagesByTypeByIndexDeleteData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: never;
    url: '/Items/{Id}/Images/{Type}/{Index}/Delete';
};

export type PostItemsByIdImagesByTypeByIndexDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdImagesByTypeByIndexDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostItemsByIdImagesByTypeByIndexIndexData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
        /**
         * Image Index
         */
        Index: number;
    };
    query: {
        /**
         * The new image index
         */
        NewIndex: number;
    };
    url: '/Items/{Id}/Images/{Type}/{Index}/Index';
};

export type PostItemsByIdImagesByTypeByIndexIndexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdImagesByTypeByIndexIndexResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostItemsByIdImagesByTypeByIndexUrlData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * Image Type
         */
        Type: ImageType;
        /**
         * Image Index
         */
        Index: number;
    };
    query: {
        /**
         * The url for the new image
         */
        Url: string;
    };
    url: '/Items/{Id}/Images/{Type}/{Index}/Url';
};

export type PostItemsByIdImagesByTypeByIndexUrlErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostItemsByIdImagesByTypeByIndexUrlResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostPlaylistsByIdItemsByItemidMoveByNewindexData = {
    body?: never;
    path: {
        /**
         * ItemId
         */
        ItemId: number;
        Id: string;
        /**
         * NewIndex
         */
        NewIndex: number;
    };
    query?: never;
    url: '/Playlists/{Id}/Items/{ItemId}/Move/{NewIndex}';
};

export type PostPlaylistsByIdItemsByItemidMoveByNewindexErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostPlaylistsByIdItemsByItemidMoveByNewindexResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type PostUsersByUseridItemsByIdRatingDeleteData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        UserId: string;
        /**
         * Item Id
         */
        Id: string;
    };
    query?: never;
    url: '/Users/{UserId}/Items/{Id}/Rating/Delete';
};

export type PostUsersByUseridItemsByIdRatingDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByUseridItemsByIdRatingDeleteResponses = {
    /**
     * Operation successful. Returning a UserItemDataDto object.
     */
    200: UserItemDataDto;
};

export type PostUsersByUseridItemsByIdRatingDeleteResponse = PostUsersByUseridItemsByIdRatingDeleteResponses[keyof PostUsersByUseridItemsByIdRatingDeleteResponses];

export type PostUsersByIdImagesByTypeByIndexDeleteData = {
    body?: never;
    path: {
        /**
         * User Id
         */
        Id: string;
        /**
         * Image Index
         */
        Index: number;
        /**
         * Image Type
         */
        Type: ImageType;
    };
    query?: never;
    url: '/Users/{Id}/Images/{Type}/{Index}/Delete';
};

export type PostUsersByIdImagesByTypeByIndexDeleteErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type PostUsersByIdImagesByTypeByIndexDeleteResponses = {
    /**
     * Operation successful. Empty response.
     */
    200: unknown;
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
        /**
         * The subtitle stream index
         */
        Index: number;
        /**
         * Format
         */
        Format: string;
    };
    query?: {
        /**
         * StartPositionTicks
         */
        StartPositionTicks?: number;
        /**
         * EndPositionTicks
         */
        EndPositionTicks?: number | null;
        /**
         * CopyTimestamps
         */
        CopyTimestamps?: boolean;
    };
    url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}';
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
        /**
         * The subtitle stream index
         */
        Index: number;
        /**
         * Format
         */
        Format: string;
    };
    query?: {
        /**
         * StartPositionTicks
         */
        StartPositionTicks?: number;
        /**
         * EndPositionTicks
         */
        EndPositionTicks?: number | null;
        /**
         * CopyTimestamps
         */
        CopyTimestamps?: boolean;
    };
    url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}';
};

export type HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdByMediasourceidAttachmentsByIndexStreamData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
        /**
         * The subtitle stream index
         */
        Index: number;
    };
    query?: never;
    url: '/Videos/{Id}/{MediaSourceId}/Attachments/{Index}/Stream';
};

export type GetVideosByIdByMediasourceidAttachmentsByIndexStreamErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdByMediasourceidAttachmentsByIndexStreamResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
        /**
         * The subtitle stream index
         */
        Index: number;
        /**
         * Format
         */
        Format: string;
        /**
         * StartPositionTicks
         */
        StartPositionTicks: number;
    };
    query?: {
        /**
         * EndPositionTicks
         */
        EndPositionTicks?: number | null;
        /**
         * CopyTimestamps
         */
        CopyTimestamps?: boolean;
    };
    url: '/Items/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}';
};

export type GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
        /**
         * The subtitle stream index
         */
        Index: number;
        /**
         * Format
         */
        Format: string;
        /**
         * StartPositionTicks
         */
        StartPositionTicks: number;
    };
    query?: {
        /**
         * EndPositionTicks
         */
        EndPositionTicks?: number | null;
        /**
         * CopyTimestamps
         */
        CopyTimestamps?: boolean;
    };
    url: '/Items/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}';
};

export type HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
        /**
         * The subtitle stream index
         */
        Index: number;
        /**
         * Format
         */
        Format: string;
        /**
         * StartPositionTicks
         */
        StartPositionTicks: number;
    };
    query?: {
        /**
         * EndPositionTicks
         */
        EndPositionTicks?: number | null;
        /**
         * CopyTimestamps
         */
        CopyTimestamps?: boolean;
    };
    url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}';
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};

export type HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData = {
    body?: never;
    path: {
        /**
         * Item Id
         */
        Id: string;
        /**
         * MediaSourceId
         */
        MediaSourceId: string;
        /**
         * The subtitle stream index
         */
        Index: number;
        /**
         * Format
         */
        Format: string;
        /**
         * StartPositionTicks
         */
        StartPositionTicks: number;
    };
    query?: {
        /**
         * EndPositionTicks
         */
        EndPositionTicks?: number | null;
        /**
         * CopyTimestamps
         */
        CopyTimestamps?: boolean;
    };
    url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}';
};

export type HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors = {
    /**
     * Bad Request. Server cannot process request.
     */
    400: unknown;
    /**
     * Unauthorized. Client needs to authenticate.
     */
    401: unknown;
    /**
     * Forbidden. No permission for the reqested operation.
     */
    403: unknown;
    /**
     * Resource not found or unavailable.
     */
    404: unknown;
    /**
     * Server error.
     */
    500: unknown;
};

export type HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses = {
    /**
     * Operation successful. Response content unknown.
     */
    200: unknown;
};
