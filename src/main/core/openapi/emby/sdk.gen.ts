// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { DeleteAuthKeysByKeyData, DeleteAuthKeysByKeyErrors, DeleteAuthKeysByKeyResponses, DeleteCollectionsByIdItemsData, DeleteCollectionsByIdItemsErrors, DeleteCollectionsByIdItemsResponses, DeleteDevicesData, DeleteDevicesErrors, DeleteDevicesResponses, DeleteDlnaProfilesByIdData, DeleteDlnaProfilesByIdErrors, DeleteDlnaProfilesByIdResponses, DeleteItemsByIdData, DeleteItemsByIdErrors, DeleteItemsByIdImagesByTypeByIndexData, DeleteItemsByIdImagesByTypeByIndexErrors, DeleteItemsByIdImagesByTypeByIndexResponses, DeleteItemsByIdImagesByTypeData, DeleteItemsByIdImagesByTypeErrors, DeleteItemsByIdImagesByTypeResponses, DeleteItemsByIdResponses, DeleteItemsByIdSubtitlesByIndexData, DeleteItemsByIdSubtitlesByIndexErrors, DeleteItemsByIdSubtitlesByIndexResponses, DeleteItemsData, DeleteItemsErrors, DeleteItemsResponses, DeleteLibraryVirtualfoldersData, DeleteLibraryVirtualfoldersErrors, DeleteLibraryVirtualfoldersPathsData, DeleteLibraryVirtualfoldersPathsErrors, DeleteLibraryVirtualfoldersPathsResponses, DeleteLibraryVirtualfoldersResponses, DeleteLivetvChannelmappingoptionsData, DeleteLivetvChannelmappingoptionsErrors, DeleteLivetvChannelmappingoptionsResponses, DeleteLivetvChannelmappingsData, DeleteLivetvChannelmappingsErrors, DeleteLivetvChannelmappingsResponses, DeleteLivetvListingprovidersData, DeleteLivetvListingprovidersErrors, DeleteLivetvListingprovidersResponses, DeleteLivetvRecordingsByIdData, DeleteLivetvRecordingsByIdErrors, DeleteLivetvRecordingsByIdResponses, DeleteLivetvSeriestimersByIdData, DeleteLivetvSeriestimersByIdErrors, DeleteLivetvSeriestimersByIdResponses, DeleteLivetvTimersByIdData, DeleteLivetvTimersByIdErrors, DeleteLivetvTimersByIdResponses, DeleteLivetvTunerhostsData, DeleteLivetvTunerhostsErrors, DeleteLivetvTunerhostsResponses, DeletePackagesInstallingByIdData, DeletePackagesInstallingByIdErrors, DeletePackagesInstallingByIdResponses, DeletePlaylistsByIdItemsData, DeletePlaylistsByIdItemsErrors, DeletePlaylistsByIdItemsResponses, DeletePluginsByIdData, DeletePluginsByIdErrors, DeletePluginsByIdResponses, DeleteScheduledtasksRunningByIdData, DeleteScheduledtasksRunningByIdErrors, DeleteScheduledtasksRunningByIdResponses, DeleteSessionsByIdUsersByUseridData, DeleteSessionsByIdUsersByUseridErrors, DeleteSessionsByIdUsersByUseridResponses, DeleteSyncByTargetidItemsData, DeleteSyncByTargetidItemsErrors, DeleteSyncByTargetidItemsResponses, DeleteSyncJobitemsByIdData, DeleteSyncJobitemsByIdErrors, DeleteSyncJobitemsByIdResponses, DeleteSyncJobsByIdData, DeleteSyncJobsByIdErrors, DeleteSyncJobsByIdResponses, DeleteUsersByIdConnectLinkData, DeleteUsersByIdConnectLinkErrors, DeleteUsersByIdConnectLinkResponses, DeleteUsersByIdData, DeleteUsersByIdErrors, DeleteUsersByIdImagesByTypeByIndexData, DeleteUsersByIdImagesByTypeByIndexErrors, DeleteUsersByIdImagesByTypeByIndexResponses, DeleteUsersByIdImagesByTypeData, DeleteUsersByIdImagesByTypeErrors, DeleteUsersByIdImagesByTypeResponses, DeleteUsersByIdResponses, DeleteUsersByIdTrackselectionsByTracktypeData, DeleteUsersByIdTrackselectionsByTracktypeErrors, DeleteUsersByIdTrackselectionsByTracktypeResponses, DeleteUsersByUseridFavoriteitemsByIdData, DeleteUsersByUseridFavoriteitemsByIdErrors, DeleteUsersByUseridFavoriteitemsByIdResponses, DeleteUsersByUseridItemsByIdRatingData, DeleteUsersByUseridItemsByIdRatingErrors, DeleteUsersByUseridItemsByIdRatingResponses, DeleteUsersByUseridPlayeditemsByIdData, DeleteUsersByUseridPlayeditemsByIdErrors, DeleteUsersByUseridPlayeditemsByIdResponses, DeleteUsersByUseridPlayingitemsByIdData, DeleteUsersByUseridPlayingitemsByIdErrors, DeleteUsersByUseridPlayingitemsByIdResponses, DeleteVideosActiveencodingsData, DeleteVideosActiveencodingsErrors, DeleteVideosActiveencodingsResponses, DeleteVideosByIdAlternatesourcesData, DeleteVideosByIdAlternatesourcesErrors, DeleteVideosByIdAlternatesourcesResponses, DeleteVideosByIdSubtitlesByIndexData, DeleteVideosByIdSubtitlesByIndexErrors, DeleteVideosByIdSubtitlesByIndexResponses, GetAlbumsByIdInstantmixData, GetAlbumsByIdInstantmixErrors, GetAlbumsByIdInstantmixResponses, GetAlbumsByIdSimilarData, GetAlbumsByIdSimilarErrors, GetAlbumsByIdSimilarResponses, GetArtistsAlbumartistsData, GetArtistsAlbumartistsErrors, GetArtistsAlbumartistsResponses, GetArtistsByIdSimilarData, GetArtistsByIdSimilarErrors, GetArtistsByIdSimilarResponses, GetArtistsByNameData, GetArtistsByNameErrors, GetArtistsByNameImagesByTypeByIndexData, GetArtistsByNameImagesByTypeByIndexErrors, GetArtistsByNameImagesByTypeByIndexResponses, GetArtistsByNameImagesByTypeData, GetArtistsByNameImagesByTypeErrors, GetArtistsByNameImagesByTypeResponses, GetArtistsByNameResponses, GetArtistsData, GetArtistsErrors, GetArtistsInstantmixData, GetArtistsInstantmixErrors, GetArtistsInstantmixResponses, GetArtistsPrefixesData, GetArtistsPrefixesErrors, GetArtistsPrefixesResponses, GetArtistsResponses, GetAudiobooksNextupData, GetAudiobooksNextupErrors, GetAudiobooksNextupResponses, GetAudioByIdByStreamfilenameData, GetAudioByIdByStreamfilenameErrors, GetAudioByIdByStreamfilenameResponses, GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors, GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses, GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerData, GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerErrors, GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponses, GetAudioByIdLiveM3U8Data, GetAudioByIdLiveM3U8Errors, GetAudioByIdLiveM3U8Responses, GetAudioByIdMainM3U8Data, GetAudioByIdMainM3U8Errors, GetAudioByIdMainM3U8Responses, GetAudioByIdMasterM3U8Data, GetAudioByIdMasterM3U8Errors, GetAudioByIdMasterM3U8Responses, GetAudioByIdStreamByContainerData, GetAudioByIdStreamByContainerErrors, GetAudioByIdStreamByContainerResponses, GetAudioByIdStreamData, GetAudioByIdStreamErrors, GetAudioByIdStreamResponses, GetAudioByIdUniversalByContainerData, GetAudioByIdUniversalByContainerErrors, GetAudioByIdUniversalByContainerResponses, GetAudioByIdUniversalData, GetAudioByIdUniversalErrors, GetAudioByIdUniversalResponses, GetAudiocodecsData, GetAudiocodecsErrors, GetAudiocodecsResponses, GetAudiolayoutsData, GetAudiolayoutsErrors, GetAudiolayoutsResponses, GetAuthKeysData, GetAuthKeysErrors, GetAuthKeysResponses, GetAuthProvidersData, GetAuthProvidersErrors, GetAuthProvidersResponses, GetBackuprestoreBackupinfoData, GetBackuprestoreBackupinfoErrors, GetBackuprestoreBackupinfoResponses, GetBrandingConfigurationData, GetBrandingConfigurationErrors, GetBrandingConfigurationResponses, GetBrandingCssCssData, GetBrandingCssCssErrors, GetBrandingCssCssResponses, GetBrandingCssData, GetBrandingCssErrors, GetBrandingCssResponses, GetChannelsData, GetChannelsErrors, GetChannelsResponses, GetConnectExchangeData, GetConnectExchangeErrors, GetConnectExchangeResponses, GetConnectPendingData, GetConnectPendingErrors, GetConnectPendingResponses, GetContainersData, GetContainersErrors, GetContainersResponses, GetDevicesCamerauploadsData, GetDevicesCamerauploadsErrors, GetDevicesCamerauploadsResponses, GetDevicesData, GetDevicesErrors, GetDevicesInfoData, GetDevicesInfoErrors, GetDevicesInfoResponses, GetDevicesOptionsData, GetDevicesOptionsErrors, GetDevicesOptionsResponses, GetDevicesResponses, GetDisplaypreferencesByIdData, GetDisplaypreferencesByIdErrors, GetDisplaypreferencesByIdResponses, GetDlnaByUuidConnectionmanagerConnectionmanagerData, GetDlnaByUuidConnectionmanagerConnectionmanagerErrors, GetDlnaByUuidConnectionmanagerConnectionmanagerResponses, GetDlnaByUuidConnectionmanagerConnectionmanagerXmlData, GetDlnaByUuidConnectionmanagerConnectionmanagerXmlErrors, GetDlnaByUuidConnectionmanagerConnectionmanagerXmlResponses, GetDlnaByUuidContentdirectoryContentdirectoryData, GetDlnaByUuidContentdirectoryContentdirectoryErrors, GetDlnaByUuidContentdirectoryContentdirectoryResponses, GetDlnaByUuidContentdirectoryContentdirectoryXmlData, GetDlnaByUuidContentdirectoryContentdirectoryXmlErrors, GetDlnaByUuidContentdirectoryContentdirectoryXmlResponses, GetDlnaByUuidDescriptionData, GetDlnaByUuidDescriptionErrors, GetDlnaByUuidDescriptionResponses, GetDlnaByUuidDescriptionXmlData, GetDlnaByUuidDescriptionXmlErrors, GetDlnaByUuidDescriptionXmlResponses, GetDlnaByUuidIconsByFilenameData, GetDlnaByUuidIconsByFilenameErrors, GetDlnaByUuidIconsByFilenameResponses, GetDlnaIconsByFilenameData, GetDlnaIconsByFilenameErrors, GetDlnaIconsByFilenameResponses, GetDlnaProfileinfosData, GetDlnaProfileinfosErrors, GetDlnaProfileinfosResponses, GetDlnaProfilesByIdData, GetDlnaProfilesByIdErrors, GetDlnaProfilesByIdResponses, GetDlnaProfilesDefaultData, GetDlnaProfilesDefaultErrors, GetDlnaProfilesDefaultResponses, GetEncodingCodecconfigurationDefaultsData, GetEncodingCodecconfigurationDefaultsErrors, GetEncodingCodecconfigurationDefaultsResponses, GetEncodingCodecinformationVideoData, GetEncodingCodecinformationVideoErrors, GetEncodingCodecinformationVideoResponses, GetEncodingCodecparametersData, GetEncodingCodecparametersErrors, GetEncodingCodecparametersResponses, GetEncodingFfmpegoptionsData, GetEncodingFfmpegoptionsErrors, GetEncodingFfmpegoptionsResponses, GetEncodingFulltonemapoptionsData, GetEncodingFulltonemapoptionsErrors, GetEncodingFulltonemapoptionsResponses, GetEncodingPublictonemapoptionsData, GetEncodingPublictonemapoptionsErrors, GetEncodingPublictonemapoptionsResponses, GetEncodingSubtitleoptionsData, GetEncodingSubtitleoptionsErrors, GetEncodingSubtitleoptionsResponses, GetEncodingTonemapoptionsData, GetEncodingTonemapoptionsErrors, GetEncodingTonemapoptionsResponses, GetEnvironmentDefaultdirectorybrowserData, GetEnvironmentDefaultdirectorybrowserErrors, GetEnvironmentDefaultdirectorybrowserResponses, GetEnvironmentDirectorycontentsData, GetEnvironmentDirectorycontentsErrors, GetEnvironmentDirectorycontentsResponses, GetEnvironmentDrivesData, GetEnvironmentDrivesErrors, GetEnvironmentDrivesResponses, GetEnvironmentNetworkdevicesData, GetEnvironmentNetworkdevicesErrors, GetEnvironmentNetworkdevicesResponses, GetEnvironmentNetworksharesData, GetEnvironmentNetworksharesErrors, GetEnvironmentNetworksharesResponses, GetEnvironmentParentpathData, GetEnvironmentParentpathErrors, GetEnvironmentParentpathResponses, GetExtendedvideotypesData, GetExtendedvideotypesErrors, GetExtendedvideotypesResponses, GetFeaturesData, GetFeaturesErrors, GetFeaturesResponses, GetGamegenresByNameData, GetGamegenresByNameErrors, GetGamegenresByNameImagesByTypeByIndexData, GetGamegenresByNameImagesByTypeByIndexErrors, GetGamegenresByNameImagesByTypeByIndexResponses, GetGamegenresByNameImagesByTypeData, GetGamegenresByNameImagesByTypeErrors, GetGamegenresByNameImagesByTypeResponses, GetGamegenresByNameResponses, GetGamegenresData, GetGamegenresErrors, GetGamegenresResponses, GetGamesByIdSimilarData, GetGamesByIdSimilarErrors, GetGamesByIdSimilarResponses, GetGenresByNameData, GetGenresByNameErrors, GetGenresByNameImagesByTypeByIndexData, GetGenresByNameImagesByTypeByIndexErrors, GetGenresByNameImagesByTypeByIndexResponses, GetGenresByNameImagesByTypeData, GetGenresByNameImagesByTypeErrors, GetGenresByNameImagesByTypeResponses, GetGenresByNameResponses, GetGenresData, GetGenresErrors, GetGenresResponses, GetImagesRemoteData, GetImagesRemoteErrors, GetImagesRemoteResponses, GetItemsByIdAncestorsData, GetItemsByIdAncestorsErrors, GetItemsByIdAncestorsResponses, GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData, GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors, GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses, GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData, GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors, GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses, GetItemsByIdCriticreviewsData, GetItemsByIdCriticreviewsErrors, GetItemsByIdCriticreviewsResponses, GetItemsByIdDeleteinfoData, GetItemsByIdDeleteinfoErrors, GetItemsByIdDeleteinfoResponses, GetItemsByIdDownloadData, GetItemsByIdDownloadErrors, GetItemsByIdDownloadResponses, GetItemsByIdExternalidinfosData, GetItemsByIdExternalidinfosErrors, GetItemsByIdExternalidinfosResponses, GetItemsByIdFileData, GetItemsByIdFileErrors, GetItemsByIdFileResponses, GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData, GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountErrors, GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponses, GetItemsByIdImagesByTypeByIndexData, GetItemsByIdImagesByTypeByIndexErrors, GetItemsByIdImagesByTypeByIndexResponses, GetItemsByIdImagesByTypeData, GetItemsByIdImagesByTypeErrors, GetItemsByIdImagesByTypeResponses, GetItemsByIdImagesData, GetItemsByIdImagesErrors, GetItemsByIdImagesResponses, GetItemsByIdInstantmixData, GetItemsByIdInstantmixErrors, GetItemsByIdInstantmixResponses, GetItemsByIdPlaybackinfoData, GetItemsByIdPlaybackinfoErrors, GetItemsByIdPlaybackinfoResponses, GetItemsByIdRemoteimagesData, GetItemsByIdRemoteimagesErrors, GetItemsByIdRemoteimagesProvidersData, GetItemsByIdRemoteimagesProvidersErrors, GetItemsByIdRemoteimagesProvidersResponses, GetItemsByIdRemoteimagesResponses, GetItemsByIdRemotesearchSubtitlesByLanguageData, GetItemsByIdRemotesearchSubtitlesByLanguageErrors, GetItemsByIdRemotesearchSubtitlesByLanguageResponses, GetItemsByIdSimilarData, GetItemsByIdSimilarErrors, GetItemsByIdSimilarResponses, GetItemsByIdThememediaData, GetItemsByIdThememediaErrors, GetItemsByIdThememediaResponses, GetItemsByIdThemesongsData, GetItemsByIdThemesongsErrors, GetItemsByIdThemesongsResponses, GetItemsByIdThemevideosData, GetItemsByIdThemevideosErrors, GetItemsByIdThemevideosResponses, GetItemsByIdThumbnailsetData, GetItemsByIdThumbnailsetErrors, GetItemsByIdThumbnailsetResponses, GetItemsByItemidMetadataeditorData, GetItemsByItemidMetadataeditorErrors, GetItemsByItemidMetadataeditorResponses, GetItemsCountsData, GetItemsCountsErrors, GetItemsCountsResponses, GetItemsData, GetItemsErrors, GetItemsIntrosData, GetItemsIntrosErrors, GetItemsIntrosResponses, GetItemsPrefixesData, GetItemsPrefixesErrors, GetItemsPrefixesResponses, GetItemsRemotesearchImageData, GetItemsRemotesearchImageErrors, GetItemsRemotesearchImageResponses, GetItemsResponses, GetItemtypesData, GetItemtypesErrors, GetItemtypesResponses, GetLibrariesAvailableoptionsData, GetLibrariesAvailableoptionsErrors, GetLibrariesAvailableoptionsResponses, GetLibraryMediafoldersData, GetLibraryMediafoldersErrors, GetLibraryMediafoldersResponses, GetLibraryPhysicalpathsData, GetLibraryPhysicalpathsErrors, GetLibraryPhysicalpathsResponses, GetLibrarySelectablemediafoldersData, GetLibrarySelectablemediafoldersErrors, GetLibrarySelectablemediafoldersResponses, GetLibraryVirtualfoldersQueryData, GetLibraryVirtualfoldersQueryErrors, GetLibraryVirtualfoldersQueryResponses, GetLivetvAvailablerecordingoptionsData, GetLivetvAvailablerecordingoptionsErrors, GetLivetvAvailablerecordingoptionsResponses, GetLivetvChannelmappingoptionsData, GetLivetvChannelmappingoptionsErrors, GetLivetvChannelmappingoptionsResponses, GetLivetvChannelmappingsData, GetLivetvChannelmappingsErrors, GetLivetvChannelmappingsResponses, GetLivetvChannelsByIdData, GetLivetvChannelsByIdErrors, GetLivetvChannelsByIdResponses, GetLivetvChannelsData, GetLivetvChannelsErrors, GetLivetvChannelsResponses, GetLivetvChanneltagsData, GetLivetvChanneltagsErrors, GetLivetvChanneltagsPrefixesData, GetLivetvChanneltagsPrefixesErrors, GetLivetvChanneltagsPrefixesResponses, GetLivetvChanneltagsResponses, GetLivetvEpgData, GetLivetvEpgErrors, GetLivetvEpgResponses, GetLivetvFolderData, GetLivetvFolderErrors, GetLivetvFolderResponses, GetLivetvGuideinfoData, GetLivetvGuideinfoErrors, GetLivetvGuideinfoResponses, GetLivetvInfoData, GetLivetvInfoErrors, GetLivetvInfoResponses, GetLivetvListingprovidersAvailableData, GetLivetvListingprovidersAvailableErrors, GetLivetvListingprovidersAvailableResponses, GetLivetvListingprovidersData, GetLivetvListingprovidersDefaultData, GetLivetvListingprovidersDefaultErrors, GetLivetvListingprovidersDefaultResponses, GetLivetvListingprovidersErrors, GetLivetvListingprovidersLineupsData, GetLivetvListingprovidersLineupsErrors, GetLivetvListingprovidersLineupsResponses, GetLivetvListingprovidersResponses, GetLivetvListingprovidersSchedulesdirectCountriesData, GetLivetvListingprovidersSchedulesdirectCountriesErrors, GetLivetvListingprovidersSchedulesdirectCountriesResponses, GetLivetvLiverecordingsByIdHlsBySegmentData, GetLivetvLiverecordingsByIdHlsBySegmentErrors, GetLivetvLiverecordingsByIdHlsBySegmentResponses, GetLivetvLiverecordingsByIdHlsLiveM3U8Data, GetLivetvLiverecordingsByIdHlsLiveM3U8Errors, GetLivetvLiverecordingsByIdHlsLiveM3U8Responses, GetLivetvLiverecordingsByIdHlsMasterM3U8Data, GetLivetvLiverecordingsByIdHlsMasterM3U8Errors, GetLivetvLiverecordingsByIdHlsMasterM3U8Responses, GetLivetvLiverecordingsByIdStreamData, GetLivetvLiverecordingsByIdStreamErrors, GetLivetvLiverecordingsByIdStreamResponses, GetLivetvLivestreamfilesByIdHlsBySegmentData, GetLivetvLivestreamfilesByIdHlsBySegmentErrors, GetLivetvLivestreamfilesByIdHlsBySegmentResponses, GetLivetvLivestreamfilesByIdHlsLiveM3U8Data, GetLivetvLivestreamfilesByIdHlsLiveM3U8Errors, GetLivetvLivestreamfilesByIdHlsLiveM3U8Responses, GetLivetvLivestreamfilesByIdHlsMasterM3U8Data, GetLivetvLivestreamfilesByIdHlsMasterM3U8Errors, GetLivetvLivestreamfilesByIdHlsMasterM3U8Responses, GetLivetvLivestreamfilesByIdStreamByContainerData, GetLivetvLivestreamfilesByIdStreamByContainerErrors, GetLivetvLivestreamfilesByIdStreamByContainerResponses, GetLivetvManageChannelsData, GetLivetvManageChannelsErrors, GetLivetvManageChannelsResponses, GetLivetvProgramsByIdData, GetLivetvProgramsByIdErrors, GetLivetvProgramsByIdResponses, GetLivetvProgramsData, GetLivetvProgramsErrors, GetLivetvProgramsRecommendedData, GetLivetvProgramsRecommendedErrors, GetLivetvProgramsRecommendedResponses, GetLivetvProgramsResponses, GetLivetvRecordingsByIdData, GetLivetvRecordingsByIdErrors, GetLivetvRecordingsByIdResponses, GetLivetvRecordingsData, GetLivetvRecordingsErrors, GetLivetvRecordingsFoldersData, GetLivetvRecordingsFoldersErrors, GetLivetvRecordingsFoldersResponses, GetLivetvRecordingsGroupsData, GetLivetvRecordingsGroupsErrors, GetLivetvRecordingsGroupsResponses, GetLivetvRecordingsResponses, GetLivetvRecordingsSeriesData, GetLivetvRecordingsSeriesErrors, GetLivetvRecordingsSeriesResponses, GetLivetvSeriestimersByIdData, GetLivetvSeriestimersByIdErrors, GetLivetvSeriestimersByIdResponses, GetLivetvSeriestimersData, GetLivetvSeriestimersErrors, GetLivetvSeriestimersResponses, GetLivetvTimersByIdData, GetLivetvTimersByIdErrors, GetLivetvTimersByIdResponses, GetLivetvTimersData, GetLivetvTimersDefaultsData, GetLivetvTimersDefaultsErrors, GetLivetvTimersDefaultsResponses, GetLivetvTimersErrors, GetLivetvTimersResponses, GetLivetvTunerhostsData, GetLivetvTunerhostsDefaultByTypeData, GetLivetvTunerhostsDefaultByTypeErrors, GetLivetvTunerhostsDefaultByTypeResponses, GetLivetvTunerhostsErrors, GetLivetvTunerhostsResponses, GetLivetvTunerhostsTypesData, GetLivetvTunerhostsTypesErrors, GetLivetvTunerhostsTypesResponses, GetLivetvTunersDiscoverData, GetLivetvTunersDiscoverErrors, GetLivetvTunersDiscoverResponses, GetLivetvTunersDiscvoverData, GetLivetvTunersDiscvoverErrors, GetLivetvTunersDiscvoverResponses, GetLocalizationCountriesData, GetLocalizationCountriesErrors, GetLocalizationCountriesResponses, GetLocalizationCulturesData, GetLocalizationCulturesErrors, GetLocalizationCulturesResponses, GetLocalizationOptionsData, GetLocalizationOptionsErrors, GetLocalizationOptionsResponses, GetLocalizationParentalratingsData, GetLocalizationParentalratingsErrors, GetLocalizationParentalratingsResponses, GetMoviesByIdSimilarData, GetMoviesByIdSimilarErrors, GetMoviesByIdSimilarResponses, GetMoviesRecommendationsData, GetMoviesRecommendationsErrors, GetMoviesRecommendationsResponses, GetMusicgenresByNameData, GetMusicgenresByNameErrors, GetMusicgenresByNameImagesByTypeByIndexData, GetMusicgenresByNameImagesByTypeByIndexErrors, GetMusicgenresByNameImagesByTypeByIndexResponses, GetMusicgenresByNameImagesByTypeData, GetMusicgenresByNameImagesByTypeErrors, GetMusicgenresByNameImagesByTypeResponses, GetMusicgenresByNameInstantmixData, GetMusicgenresByNameInstantmixErrors, GetMusicgenresByNameInstantmixResponses, GetMusicgenresByNameResponses, GetMusicgenresData, GetMusicgenresErrors, GetMusicgenresInstantmixData, GetMusicgenresInstantmixErrors, GetMusicgenresInstantmixResponses, GetMusicgenresResponses, GetNotificationsServicesDefaultsData, GetNotificationsServicesDefaultsErrors, GetNotificationsServicesDefaultsResponses, GetNotificationsTypesData, GetNotificationsTypesErrors, GetNotificationsTypesResponses, GetOfficialratingsData, GetOfficialratingsErrors, GetOfficialratingsResponses, GetOpenapiData, GetOpenapiErrors, GetOpenapiJsonData, GetOpenapiJsonErrors, GetOpenapiJsonResponses, GetOpenapiResponses, GetPackagesByNameData, GetPackagesByNameErrors, GetPackagesByNameResponses, GetPackagesData, GetPackagesErrors, GetPackagesResponses, GetPackagesUpdatesData, GetPackagesUpdatesErrors, GetPackagesUpdatesResponses, GetPersonsByNameData, GetPersonsByNameErrors, GetPersonsByNameImagesByTypeByIndexData, GetPersonsByNameImagesByTypeByIndexErrors, GetPersonsByNameImagesByTypeByIndexResponses, GetPersonsByNameImagesByTypeData, GetPersonsByNameImagesByTypeErrors, GetPersonsByNameImagesByTypeResponses, GetPersonsByNameResponses, GetPersonsData, GetPersonsErrors, GetPersonsResponses, GetPlaybackBitratetestData, GetPlaybackBitratetestErrors, GetPlaybackBitratetestResponses, GetPlaylistsByIdAddtoplaylistinfoData, GetPlaylistsByIdAddtoplaylistinfoErrors, GetPlaylistsByIdAddtoplaylistinfoResponses, GetPlaylistsByIdInstantmixData, GetPlaylistsByIdInstantmixErrors, GetPlaylistsByIdInstantmixResponses, GetPlaylistsByIdItemsData, GetPlaylistsByIdItemsErrors, GetPlaylistsByIdItemsResponses, GetPluginsByIdConfigurationData, GetPluginsByIdConfigurationErrors, GetPluginsByIdConfigurationResponses, GetPluginsByIdThumbData, GetPluginsByIdThumbErrors, GetPluginsByIdThumbResponses, GetPluginsData, GetPluginsErrors, GetPluginsResponses, GetProvidersSubtitlesSubtitlesByIdData, GetProvidersSubtitlesSubtitlesByIdErrors, GetProvidersSubtitlesSubtitlesByIdResponses, GetScheduledtasksByIdData, GetScheduledtasksByIdErrors, GetScheduledtasksByIdResponses, GetScheduledtasksData, GetScheduledtasksErrors, GetScheduledtasksResponses, GetSessionsData, GetSessionsErrors, GetSessionsPlayqueueData, GetSessionsPlayqueueErrors, GetSessionsPlayqueueResponses, GetSessionsResponses, GetShowsByIdEpisodesData, GetShowsByIdEpisodesErrors, GetShowsByIdEpisodesResponses, GetShowsByIdSeasonsData, GetShowsByIdSeasonsErrors, GetShowsByIdSeasonsResponses, GetShowsByIdSimilarData, GetShowsByIdSimilarErrors, GetShowsByIdSimilarResponses, GetShowsMissingData, GetShowsMissingErrors, GetShowsMissingResponses, GetShowsNextupData, GetShowsNextupErrors, GetShowsNextupResponses, GetShowsUpcomingData, GetShowsUpcomingErrors, GetShowsUpcomingResponses, GetSongsByIdInstantmixData, GetSongsByIdInstantmixErrors, GetSongsByIdInstantmixResponses, GetStreamlanguagesData, GetStreamlanguagesErrors, GetStreamlanguagesResponses, GetStudiosByNameData, GetStudiosByNameErrors, GetStudiosByNameImagesByTypeByIndexData, GetStudiosByNameImagesByTypeByIndexErrors, GetStudiosByNameImagesByTypeByIndexResponses, GetStudiosByNameImagesByTypeData, GetStudiosByNameImagesByTypeErrors, GetStudiosByNameImagesByTypeResponses, GetStudiosByNameResponses, GetStudiosData, GetStudiosErrors, GetStudiosResponses, GetSubtitlecodecsData, GetSubtitlecodecsErrors, GetSubtitlecodecsResponses, GetSwaggerData, GetSwaggerErrors, GetSwaggerJsonData, GetSwaggerJsonErrors, GetSwaggerJsonResponses, GetSwaggerResponses, GetSyncItemsReadyData, GetSyncItemsReadyErrors, GetSyncItemsReadyResponses, GetSyncJobitemsByIdAdditionalfilesData, GetSyncJobitemsByIdAdditionalfilesErrors, GetSyncJobitemsByIdAdditionalfilesResponses, GetSyncJobitemsByIdFileData, GetSyncJobitemsByIdFileErrors, GetSyncJobitemsByIdFileResponses, GetSyncJobitemsData, GetSyncJobitemsErrors, GetSyncJobitemsResponses, GetSyncJobsByIdData, GetSyncJobsByIdErrors, GetSyncJobsByIdResponses, GetSyncJobsData, GetSyncJobsErrors, GetSyncJobsResponses, GetSyncOptionsData, GetSyncOptionsErrors, GetSyncOptionsResponses, GetSyncTargetsData, GetSyncTargetsErrors, GetSyncTargetsResponses, GetSystemActivitylogEntriesData, GetSystemActivitylogEntriesErrors, GetSystemActivitylogEntriesResponses, GetSystemConfigurationByKeyData, GetSystemConfigurationByKeyErrors, GetSystemConfigurationByKeyResponses, GetSystemConfigurationData, GetSystemConfigurationErrors, GetSystemConfigurationResponses, GetSystemEndpointData, GetSystemEndpointErrors, GetSystemEndpointResponses, GetSystemInfoData, GetSystemInfoErrors, GetSystemInfoPublicData, GetSystemInfoPublicErrors, GetSystemInfoPublicResponses, GetSystemInfoResponses, GetSystemLogsByNameData, GetSystemLogsByNameErrors, GetSystemLogsByNameLinesData, GetSystemLogsByNameLinesErrors, GetSystemLogsByNameLinesResponses, GetSystemLogsByNameResponses, GetSystemLogsQueryData, GetSystemLogsQueryErrors, GetSystemLogsQueryResponses, GetSystemPingData, GetSystemPingErrors, GetSystemPingResponses, GetSystemReleasenotesData, GetSystemReleasenotesErrors, GetSystemReleasenotesResponses, GetSystemReleasenotesVersionsData, GetSystemReleasenotesVersionsErrors, GetSystemReleasenotesVersionsResponses, GetSystemWakeonlaninfoData, GetSystemWakeonlaninfoErrors, GetSystemWakeonlaninfoResponses, GetTagsData, GetTagsErrors, GetTagsResponses, GetTrailersByIdSimilarData, GetTrailersByIdSimilarErrors, GetTrailersByIdSimilarResponses, GetTrailersData, GetTrailersErrors, GetTrailersResponses, GetUiViewData, GetUiViewErrors, GetUiViewResponses, GetUsersByIdData, GetUsersByIdErrors, GetUsersByIdImagesByTypeByIndexData, GetUsersByIdImagesByTypeByIndexErrors, GetUsersByIdImagesByTypeByIndexResponses, GetUsersByIdImagesByTypeData, GetUsersByIdImagesByTypeErrors, GetUsersByIdImagesByTypeResponses, GetUsersByIdResponses, GetUsersByUseridHomesectionsData, GetUsersByUseridHomesectionsErrors, GetUsersByUseridHomesectionsResponses, GetUsersByUseridItemsByIdData, GetUsersByUseridItemsByIdErrors, GetUsersByUseridItemsByIdIntrosData, GetUsersByUseridItemsByIdIntrosErrors, GetUsersByUseridItemsByIdIntrosResponses, GetUsersByUseridItemsByIdLocaltrailersData, GetUsersByUseridItemsByIdLocaltrailersErrors, GetUsersByUseridItemsByIdLocaltrailersResponses, GetUsersByUseridItemsByIdResponses, GetUsersByUseridItemsByIdSpecialfeaturesData, GetUsersByUseridItemsByIdSpecialfeaturesErrors, GetUsersByUseridItemsByIdSpecialfeaturesResponses, GetUsersByUseridItemsData, GetUsersByUseridItemsErrors, GetUsersByUseridItemsLatestData, GetUsersByUseridItemsLatestErrors, GetUsersByUseridItemsLatestResponses, GetUsersByUseridItemsResponses, GetUsersByUseridItemsResumeData, GetUsersByUseridItemsResumeErrors, GetUsersByUseridItemsResumeResponses, GetUsersByUseridItemsRootData, GetUsersByUseridItemsRootErrors, GetUsersByUseridItemsRootResponses, GetUsersByUseridSectionsBySectionidItemsData, GetUsersByUseridSectionsBySectionidItemsErrors, GetUsersByUseridSectionsBySectionidItemsResponses, GetUsersByUseridSuggestionsData, GetUsersByUseridSuggestionsErrors, GetUsersByUseridSuggestionsResponses, GetUsersByUseridTypedsettingsByKeyData, GetUsersByUseridTypedsettingsByKeyErrors, GetUsersByUseridTypedsettingsByKeyResponses, GetUsersByUseridViewsData, GetUsersByUseridViewsErrors, GetUsersByUseridViewsResponses, GetUsersettingsByUseridData, GetUsersettingsByUseridErrors, GetUsersettingsByUseridResponses, GetUsersItemaccessData, GetUsersItemaccessErrors, GetUsersItemaccessResponses, GetUsersPrefixesData, GetUsersPrefixesErrors, GetUsersPrefixesResponses, GetUsersPublicData, GetUsersPublicErrors, GetUsersPublicResponses, GetUsersQueryData, GetUsersQueryErrors, GetUsersQueryResponses, GetVideocodecsData, GetVideocodecsErrors, GetVideocodecsResponses, GetVideosByIdAdditionalpartsData, GetVideosByIdAdditionalpartsErrors, GetVideosByIdAdditionalpartsResponses, GetVideosByIdByMediasourceidAttachmentsByIndexStreamData, GetVideosByIdByMediasourceidAttachmentsByIndexStreamErrors, GetVideosByIdByMediasourceidAttachmentsByIndexStreamResponses, GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData, GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors, GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses, GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData, GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors, GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses, GetVideosByIdByStreamfilenameData, GetVideosByIdByStreamfilenameErrors, GetVideosByIdByStreamfilenameResponses, GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors, GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses, GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerData, GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerErrors, GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponses, GetVideosByIdIndexBifData, GetVideosByIdIndexBifErrors, GetVideosByIdIndexBifResponses, GetVideosByIdLiveM3U8Data, GetVideosByIdLiveM3U8Errors, GetVideosByIdLiveM3U8Responses, GetVideosByIdLiveSubtitlesM3U8Data, GetVideosByIdLiveSubtitlesM3U8Errors, GetVideosByIdLiveSubtitlesM3U8Responses, GetVideosByIdMainM3U8Data, GetVideosByIdMainM3U8Errors, GetVideosByIdMainM3U8Responses, GetVideosByIdMasterM3U8Data, GetVideosByIdMasterM3U8Errors, GetVideosByIdMasterM3U8Responses, GetVideosByIdStreamByContainerData, GetVideosByIdStreamByContainerErrors, GetVideosByIdStreamByContainerResponses, GetVideosByIdStreamData, GetVideosByIdStreamErrors, GetVideosByIdStreamResponses, GetVideosByIdSubtitlesM3U8Data, GetVideosByIdSubtitlesM3U8Errors, GetVideosByIdSubtitlesM3U8Responses, GetWebConfigurationpageData, GetWebConfigurationpageErrors, GetWebConfigurationpageResponses, GetWebConfigurationpagesData, GetWebConfigurationpagesErrors, GetWebConfigurationpagesResponses, GetWebStringsData, GetWebStringsErrors, GetWebStringsetData, GetWebStringsetErrors, GetWebStringsetResponses, GetWebStringsResponses, GetYearsData, GetYearsErrors, GetYearsResponses, HeadArtistsByNameImagesByTypeByIndexData, HeadArtistsByNameImagesByTypeByIndexErrors, HeadArtistsByNameImagesByTypeByIndexResponses, HeadArtistsByNameImagesByTypeData, HeadArtistsByNameImagesByTypeErrors, HeadArtistsByNameImagesByTypeResponses, HeadAudioByIdByStreamfilenameData, HeadAudioByIdByStreamfilenameErrors, HeadAudioByIdByStreamfilenameResponses, HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors, HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses, HeadAudioByIdMasterM3U8Data, HeadAudioByIdMasterM3U8Errors, HeadAudioByIdMasterM3U8Responses, HeadAudioByIdStreamByContainerData, HeadAudioByIdStreamByContainerErrors, HeadAudioByIdStreamByContainerResponses, HeadAudioByIdStreamData, HeadAudioByIdStreamErrors, HeadAudioByIdStreamResponses, HeadAudioByIdUniversalByContainerData, HeadAudioByIdUniversalByContainerErrors, HeadAudioByIdUniversalByContainerResponses, HeadAudioByIdUniversalData, HeadAudioByIdUniversalErrors, HeadAudioByIdUniversalResponses, HeadDlnaByUuidConnectionmanagerConnectionmanagerData, HeadDlnaByUuidConnectionmanagerConnectionmanagerErrors, HeadDlnaByUuidConnectionmanagerConnectionmanagerResponses, HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlData, HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlErrors, HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlResponses, HeadDlnaByUuidContentdirectoryContentdirectoryData, HeadDlnaByUuidContentdirectoryContentdirectoryErrors, HeadDlnaByUuidContentdirectoryContentdirectoryResponses, HeadDlnaByUuidContentdirectoryContentdirectoryXmlData, HeadDlnaByUuidContentdirectoryContentdirectoryXmlErrors, HeadDlnaByUuidContentdirectoryContentdirectoryXmlResponses, HeadDlnaByUuidDescriptionData, HeadDlnaByUuidDescriptionErrors, HeadDlnaByUuidDescriptionResponses, HeadDlnaByUuidDescriptionXmlData, HeadDlnaByUuidDescriptionXmlErrors, HeadDlnaByUuidDescriptionXmlResponses, HeadGamegenresByNameImagesByTypeByIndexData, HeadGamegenresByNameImagesByTypeByIndexErrors, HeadGamegenresByNameImagesByTypeByIndexResponses, HeadGamegenresByNameImagesByTypeData, HeadGamegenresByNameImagesByTypeErrors, HeadGamegenresByNameImagesByTypeResponses, HeadGenresByNameImagesByTypeByIndexData, HeadGenresByNameImagesByTypeByIndexErrors, HeadGenresByNameImagesByTypeByIndexResponses, HeadGenresByNameImagesByTypeData, HeadGenresByNameImagesByTypeErrors, HeadGenresByNameImagesByTypeResponses, HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData, HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors, HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses, HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData, HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors, HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses, HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData, HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountErrors, HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponses, HeadItemsByIdImagesByTypeByIndexData, HeadItemsByIdImagesByTypeByIndexErrors, HeadItemsByIdImagesByTypeByIndexResponses, HeadItemsByIdImagesByTypeData, HeadItemsByIdImagesByTypeErrors, HeadItemsByIdImagesByTypeResponses, HeadLivetvChannelmappingoptionsData, HeadLivetvChannelmappingoptionsErrors, HeadLivetvChannelmappingoptionsResponses, HeadLivetvChannelmappingsData, HeadLivetvChannelmappingsErrors, HeadLivetvChannelmappingsResponses, HeadLivetvLiverecordingsByIdHlsBySegmentData, HeadLivetvLiverecordingsByIdHlsBySegmentErrors, HeadLivetvLiverecordingsByIdHlsBySegmentResponses, HeadLivetvLiverecordingsByIdHlsLiveM3U8Data, HeadLivetvLiverecordingsByIdHlsLiveM3U8Errors, HeadLivetvLiverecordingsByIdHlsLiveM3U8Responses, HeadLivetvLiverecordingsByIdHlsMasterM3U8Data, HeadLivetvLiverecordingsByIdHlsMasterM3U8Errors, HeadLivetvLiverecordingsByIdHlsMasterM3U8Responses, HeadLivetvLivestreamfilesByIdHlsBySegmentData, HeadLivetvLivestreamfilesByIdHlsBySegmentErrors, HeadLivetvLivestreamfilesByIdHlsBySegmentResponses, HeadLivetvLivestreamfilesByIdHlsLiveM3U8Data, HeadLivetvLivestreamfilesByIdHlsLiveM3U8Errors, HeadLivetvLivestreamfilesByIdHlsLiveM3U8Responses, HeadLivetvLivestreamfilesByIdHlsMasterM3U8Data, HeadLivetvLivestreamfilesByIdHlsMasterM3U8Errors, HeadLivetvLivestreamfilesByIdHlsMasterM3U8Responses, HeadMusicgenresByNameImagesByTypeByIndexData, HeadMusicgenresByNameImagesByTypeByIndexErrors, HeadMusicgenresByNameImagesByTypeByIndexResponses, HeadMusicgenresByNameImagesByTypeData, HeadMusicgenresByNameImagesByTypeErrors, HeadMusicgenresByNameImagesByTypeResponses, HeadPersonsByNameImagesByTypeByIndexData, HeadPersonsByNameImagesByTypeByIndexErrors, HeadPersonsByNameImagesByTypeByIndexResponses, HeadPersonsByNameImagesByTypeData, HeadPersonsByNameImagesByTypeErrors, HeadPersonsByNameImagesByTypeResponses, HeadStudiosByNameImagesByTypeByIndexData, HeadStudiosByNameImagesByTypeByIndexErrors, HeadStudiosByNameImagesByTypeByIndexResponses, HeadStudiosByNameImagesByTypeData, HeadStudiosByNameImagesByTypeErrors, HeadStudiosByNameImagesByTypeResponses, HeadSyncJobitemsByIdFileData, HeadSyncJobitemsByIdFileErrors, HeadSyncJobitemsByIdFileResponses, HeadSystemPingData, HeadSystemPingErrors, HeadSystemPingResponses, HeadUsersByIdImagesByTypeByIndexData, HeadUsersByIdImagesByTypeByIndexErrors, HeadUsersByIdImagesByTypeByIndexResponses, HeadUsersByIdImagesByTypeData, HeadUsersByIdImagesByTypeErrors, HeadUsersByIdImagesByTypeResponses, HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData, HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors, HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses, HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData, HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors, HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses, HeadVideosByIdByStreamfilenameData, HeadVideosByIdByStreamfilenameErrors, HeadVideosByIdByStreamfilenameResponses, HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors, HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses, HeadVideosByIdMasterM3U8Data, HeadVideosByIdMasterM3U8Errors, HeadVideosByIdMasterM3U8Responses, HeadVideosByIdStreamByContainerData, HeadVideosByIdStreamByContainerErrors, HeadVideosByIdStreamByContainerResponses, HeadVideosByIdStreamData, HeadVideosByIdStreamErrors, HeadVideosByIdStreamResponses, PostAuthKeysByKeyDeleteData, PostAuthKeysByKeyDeleteErrors, PostAuthKeysByKeyDeleteResponses, PostAuthKeysData, PostAuthKeysErrors, PostAuthKeysResponses, PostBackuprestoreRestoreData, PostBackuprestoreRestoredataData, PostBackuprestoreRestoredataErrors, PostBackuprestoreRestoredataResponses, PostBackuprestoreRestoreErrors, PostBackuprestoreRestoreResponses, PostCollectionsByIdItemsData, PostCollectionsByIdItemsDeleteData, PostCollectionsByIdItemsDeleteErrors, PostCollectionsByIdItemsDeleteResponses, PostCollectionsByIdItemsErrors, PostCollectionsByIdItemsResponses, PostCollectionsData, PostCollectionsErrors, PostCollectionsResponses, PostDevicesCamerauploadsData, PostDevicesCamerauploadsErrors, PostDevicesCamerauploadsResponses, PostDevicesDeleteData, PostDevicesDeleteErrors, PostDevicesDeleteResponses, PostDevicesOptionsData, PostDevicesOptionsErrors, PostDevicesOptionsResponses, PostDisplaypreferencesByDisplaypreferencesidData, PostDisplaypreferencesByDisplaypreferencesidErrors, PostDisplaypreferencesByDisplaypreferencesidResponses, PostDlnaByUuidConnectionmanagerControlData, PostDlnaByUuidConnectionmanagerControlErrors, PostDlnaByUuidConnectionmanagerControlResponses, PostDlnaByUuidContentdirectoryControlData, PostDlnaByUuidContentdirectoryControlErrors, PostDlnaByUuidContentdirectoryControlResponses, PostDlnaProfilesByIdData, PostDlnaProfilesByIdErrors, PostDlnaProfilesByIdResponses, PostDlnaProfilesData, PostDlnaProfilesErrors, PostDlnaProfilesResponses, PostEncodingCodecparametersData, PostEncodingCodecparametersErrors, PostEncodingCodecparametersResponses, PostEncodingFfmpegoptionsData, PostEncodingFfmpegoptionsErrors, PostEncodingFfmpegoptionsResponses, PostEncodingFulltonemapoptionsData, PostEncodingFulltonemapoptionsErrors, PostEncodingFulltonemapoptionsResponses, PostEncodingPublictonemapoptionsData, PostEncodingPublictonemapoptionsErrors, PostEncodingPublictonemapoptionsResponses, PostEncodingSubtitleoptionsData, PostEncodingSubtitleoptionsErrors, PostEncodingSubtitleoptionsResponses, PostEnvironmentDirectorycontentsData, PostEnvironmentDirectorycontentsErrors, PostEnvironmentDirectorycontentsResponses, PostEnvironmentValidatepathData, PostEnvironmentValidatepathErrors, PostEnvironmentValidatepathResponses, PostItemsAccessData, PostItemsAccessErrors, PostItemsAccessResponses, PostItemsByIdDeleteData, PostItemsByIdDeleteErrors, PostItemsByIdDeleteResponses, PostItemsByIdImagesByTypeByIndexData, PostItemsByIdImagesByTypeByIndexDeleteData, PostItemsByIdImagesByTypeByIndexDeleteErrors, PostItemsByIdImagesByTypeByIndexDeleteResponses, PostItemsByIdImagesByTypeByIndexErrors, PostItemsByIdImagesByTypeByIndexIndexData, PostItemsByIdImagesByTypeByIndexIndexErrors, PostItemsByIdImagesByTypeByIndexIndexResponses, PostItemsByIdImagesByTypeByIndexResponses, PostItemsByIdImagesByTypeByIndexUrlData, PostItemsByIdImagesByTypeByIndexUrlErrors, PostItemsByIdImagesByTypeByIndexUrlResponses, PostItemsByIdImagesByTypeData, PostItemsByIdImagesByTypeDeleteData, PostItemsByIdImagesByTypeDeleteErrors, PostItemsByIdImagesByTypeDeleteResponses, PostItemsByIdImagesByTypeErrors, PostItemsByIdImagesByTypeResponses, PostItemsByIdMakeprivateData, PostItemsByIdMakeprivateErrors, PostItemsByIdMakeprivateResponses, PostItemsByIdMakepublicData, PostItemsByIdMakepublicErrors, PostItemsByIdMakepublicResponses, PostItemsByIdPlaybackinfoData, PostItemsByIdPlaybackinfoErrors, PostItemsByIdPlaybackinfoResponses, PostItemsByIdRefreshData, PostItemsByIdRefreshErrors, PostItemsByIdRefreshResponses, PostItemsByIdRemoteimagesDownloadData, PostItemsByIdRemoteimagesDownloadErrors, PostItemsByIdRemoteimagesDownloadResponses, PostItemsByIdRemotesearchSubtitlesBySubtitleidData, PostItemsByIdRemotesearchSubtitlesBySubtitleidErrors, PostItemsByIdRemotesearchSubtitlesBySubtitleidResponses, PostItemsByIdSubtitlesByIndexDeleteData, PostItemsByIdSubtitlesByIndexDeleteErrors, PostItemsByIdSubtitlesByIndexDeleteResponses, PostItemsByIdTagsAddData, PostItemsByIdTagsAddErrors, PostItemsByIdTagsAddResponses, PostItemsByIdTagsDeleteData, PostItemsByIdTagsDeleteErrors, PostItemsByIdTagsDeleteResponses, PostItemsByItemidData, PostItemsByItemidErrors, PostItemsByItemidResponses, PostItemsDeleteData, PostItemsDeleteErrors, PostItemsDeleteResponses, PostItemsMetadataResetData, PostItemsMetadataResetErrors, PostItemsMetadataResetResponses, PostItemsRemotesearchApplyByIdData, PostItemsRemotesearchApplyByIdErrors, PostItemsRemotesearchApplyByIdResponses, PostItemsRemotesearchBookData, PostItemsRemotesearchBookErrors, PostItemsRemotesearchBookResponses, PostItemsRemotesearchBoxsetData, PostItemsRemotesearchBoxsetErrors, PostItemsRemotesearchBoxsetResponses, PostItemsRemotesearchGameData, PostItemsRemotesearchGameErrors, PostItemsRemotesearchGameResponses, PostItemsRemotesearchMovieData, PostItemsRemotesearchMovieErrors, PostItemsRemotesearchMovieResponses, PostItemsRemotesearchMusicalbumData, PostItemsRemotesearchMusicalbumErrors, PostItemsRemotesearchMusicalbumResponses, PostItemsRemotesearchMusicartistData, PostItemsRemotesearchMusicartistErrors, PostItemsRemotesearchMusicartistResponses, PostItemsRemotesearchMusicvideoData, PostItemsRemotesearchMusicvideoErrors, PostItemsRemotesearchMusicvideoResponses, PostItemsRemotesearchPersonData, PostItemsRemotesearchPersonErrors, PostItemsRemotesearchPersonResponses, PostItemsRemotesearchSeriesData, PostItemsRemotesearchSeriesErrors, PostItemsRemotesearchSeriesResponses, PostItemsRemotesearchTrailerData, PostItemsRemotesearchTrailerErrors, PostItemsRemotesearchTrailerResponses, PostItemsSharedLeaveData, PostItemsSharedLeaveErrors, PostItemsSharedLeaveResponses, PostLibraryMediaUpdatedData, PostLibraryMediaUpdatedErrors, PostLibraryMediaUpdatedResponses, PostLibraryMoviesAddedData, PostLibraryMoviesAddedErrors, PostLibraryMoviesAddedResponses, PostLibraryMoviesUpdatedData, PostLibraryMoviesUpdatedErrors, PostLibraryMoviesUpdatedResponses, PostLibraryRefreshData, PostLibraryRefreshErrors, PostLibraryRefreshResponses, PostLibrarySeriesAddedData, PostLibrarySeriesAddedErrors, PostLibrarySeriesAddedResponses, PostLibrarySeriesUpdatedData, PostLibrarySeriesUpdatedErrors, PostLibrarySeriesUpdatedResponses, PostLibraryVirtualfoldersData, PostLibraryVirtualfoldersDeleteData, PostLibraryVirtualfoldersDeleteErrors, PostLibraryVirtualfoldersDeleteResponses, PostLibraryVirtualfoldersErrors, PostLibraryVirtualfoldersLibraryoptionsData, PostLibraryVirtualfoldersLibraryoptionsErrors, PostLibraryVirtualfoldersLibraryoptionsResponses, PostLibraryVirtualfoldersNameData, PostLibraryVirtualfoldersNameErrors, PostLibraryVirtualfoldersNameResponses, PostLibraryVirtualfoldersPathsData, PostLibraryVirtualfoldersPathsDeleteData, PostLibraryVirtualfoldersPathsDeleteErrors, PostLibraryVirtualfoldersPathsDeleteResponses, PostLibraryVirtualfoldersPathsErrors, PostLibraryVirtualfoldersPathsResponses, PostLibraryVirtualfoldersPathsUpdateData, PostLibraryVirtualfoldersPathsUpdateErrors, PostLibraryVirtualfoldersPathsUpdateResponses, PostLibraryVirtualfoldersResponses, PostLivestreamsCloseData, PostLivestreamsCloseErrors, PostLivestreamsCloseResponses, PostLivestreamsMediainfoData, PostLivestreamsMediainfoErrors, PostLivestreamsMediainfoResponses, PostLivestreamsOpenData, PostLivestreamsOpenErrors, PostLivestreamsOpenResponses, PostLivetvChannelmappingoptionsData, PostLivetvChannelmappingoptionsErrors, PostLivetvChannelmappingoptionsResponses, PostLivetvChannelmappingsData, PostLivetvChannelmappingsErrors, PostLivetvChannelmappingsResponses, PostLivetvListingprovidersData, PostLivetvListingprovidersDeleteData, PostLivetvListingprovidersDeleteErrors, PostLivetvListingprovidersDeleteResponses, PostLivetvListingprovidersErrors, PostLivetvListingprovidersResponses, PostLivetvManageChannelsByIdDisabledData, PostLivetvManageChannelsByIdDisabledErrors, PostLivetvManageChannelsByIdDisabledResponses, PostLivetvManageChannelsByIdSortindexData, PostLivetvManageChannelsByIdSortindexErrors, PostLivetvManageChannelsByIdSortindexResponses, PostLivetvProgramsData, PostLivetvProgramsErrors, PostLivetvProgramsResponses, PostLivetvRecordingsByIdDeleteData, PostLivetvRecordingsByIdDeleteErrors, PostLivetvRecordingsByIdDeleteResponses, PostLivetvSeriestimersByIdData, PostLivetvSeriestimersByIdDeleteData, PostLivetvSeriestimersByIdDeleteErrors, PostLivetvSeriestimersByIdDeleteResponses, PostLivetvSeriestimersByIdErrors, PostLivetvSeriestimersByIdResponses, PostLivetvSeriestimersData, PostLivetvSeriestimersErrors, PostLivetvSeriestimersResponses, PostLivetvTimersByIdData, PostLivetvTimersByIdDeleteData, PostLivetvTimersByIdDeleteErrors, PostLivetvTimersByIdDeleteResponses, PostLivetvTimersByIdErrors, PostLivetvTimersByIdResponses, PostLivetvTimersData, PostLivetvTimersErrors, PostLivetvTimersResponses, PostLivetvTunerhostsData, PostLivetvTunerhostsDeleteData, PostLivetvTunerhostsDeleteErrors, PostLivetvTunerhostsDeleteResponses, PostLivetvTunerhostsErrors, PostLivetvTunerhostsResponses, PostLivetvTunersByIdResetData, PostLivetvTunersByIdResetErrors, PostLivetvTunersByIdResetResponses, PostNotificationsAdminData, PostNotificationsAdminErrors, PostNotificationsAdminResponses, PostNotificationsServicesTestData, PostNotificationsServicesTestErrors, PostNotificationsServicesTestResponses, PostPackagesInstalledByNameData, PostPackagesInstalledByNameErrors, PostPackagesInstalledByNameResponses, PostPackagesInstallingByIdDeleteData, PostPackagesInstallingByIdDeleteErrors, PostPackagesInstallingByIdDeleteResponses, PostPlaylistsByIdItemsByItemidMoveByNewindexData, PostPlaylistsByIdItemsByItemidMoveByNewindexErrors, PostPlaylistsByIdItemsByItemidMoveByNewindexResponses, PostPlaylistsByIdItemsData, PostPlaylistsByIdItemsDeleteData, PostPlaylistsByIdItemsDeleteErrors, PostPlaylistsByIdItemsDeleteResponses, PostPlaylistsByIdItemsErrors, PostPlaylistsByIdItemsResponses, PostPlaylistsData, PostPlaylistsErrors, PostPlaylistsResponses, PostPluginsByIdConfigurationData, PostPluginsByIdConfigurationErrors, PostPluginsByIdConfigurationResponses, PostPluginsByIdDeleteData, PostPluginsByIdDeleteErrors, PostPluginsByIdDeleteResponses, PostScheduledtasksByIdTriggersData, PostScheduledtasksByIdTriggersErrors, PostScheduledtasksByIdTriggersResponses, PostScheduledtasksRunningByIdData, PostScheduledtasksRunningByIdDeleteData, PostScheduledtasksRunningByIdDeleteErrors, PostScheduledtasksRunningByIdDeleteResponses, PostScheduledtasksRunningByIdErrors, PostScheduledtasksRunningByIdResponses, PostSessionsByIdCommandByCommandData, PostSessionsByIdCommandByCommandErrors, PostSessionsByIdCommandByCommandResponses, PostSessionsByIdCommandData, PostSessionsByIdCommandErrors, PostSessionsByIdCommandResponses, PostSessionsByIdMessageData, PostSessionsByIdMessageErrors, PostSessionsByIdMessageResponses, PostSessionsByIdPlayingByCommandData, PostSessionsByIdPlayingByCommandErrors, PostSessionsByIdPlayingByCommandResponses, PostSessionsByIdPlayingData, PostSessionsByIdPlayingErrors, PostSessionsByIdPlayingResponses, PostSessionsByIdSystemByCommandData, PostSessionsByIdSystemByCommandErrors, PostSessionsByIdSystemByCommandResponses, PostSessionsByIdUsersByUseridData, PostSessionsByIdUsersByUseridDeleteData, PostSessionsByIdUsersByUseridDeleteErrors, PostSessionsByIdUsersByUseridDeleteResponses, PostSessionsByIdUsersByUseridErrors, PostSessionsByIdUsersByUseridResponses, PostSessionsByIdViewingData, PostSessionsByIdViewingErrors, PostSessionsByIdViewingResponses, PostSessionsCapabilitiesData, PostSessionsCapabilitiesErrors, PostSessionsCapabilitiesFullData, PostSessionsCapabilitiesFullErrors, PostSessionsCapabilitiesFullResponses, PostSessionsCapabilitiesResponses, PostSessionsLogoutData, PostSessionsLogoutErrors, PostSessionsLogoutResponses, PostSessionsPlayingData, PostSessionsPlayingErrors, PostSessionsPlayingPingData, PostSessionsPlayingPingErrors, PostSessionsPlayingPingResponses, PostSessionsPlayingProgressData, PostSessionsPlayingProgressErrors, PostSessionsPlayingProgressResponses, PostSessionsPlayingResponses, PostSessionsPlayingStoppedData, PostSessionsPlayingStoppedErrors, PostSessionsPlayingStoppedResponses, PostSyncByItemidStatusData, PostSyncByItemidStatusErrors, PostSyncByItemidStatusResponses, PostSyncByTargetidItemsDeleteData, PostSyncByTargetidItemsDeleteErrors, PostSyncByTargetidItemsDeleteResponses, PostSyncDataData, PostSyncDataErrors, PostSyncDataResponses, PostSyncItemsCancelData, PostSyncItemsCancelErrors, PostSyncItemsCancelResponses, PostSyncJobitemsByIdDeleteData, PostSyncJobitemsByIdDeleteErrors, PostSyncJobitemsByIdDeleteResponses, PostSyncJobitemsByIdEnableData, PostSyncJobitemsByIdEnableErrors, PostSyncJobitemsByIdEnableResponses, PostSyncJobitemsByIdMarkforremovalData, PostSyncJobitemsByIdMarkforremovalErrors, PostSyncJobitemsByIdMarkforremovalResponses, PostSyncJobitemsByIdTransferredData, PostSyncJobitemsByIdTransferredErrors, PostSyncJobitemsByIdTransferredResponses, PostSyncJobitemsByIdUnmarkforremovalData, PostSyncJobitemsByIdUnmarkforremovalErrors, PostSyncJobitemsByIdUnmarkforremovalResponses, PostSyncJobsByIdData, PostSyncJobsByIdDeleteData, PostSyncJobsByIdDeleteErrors, PostSyncJobsByIdDeleteResponses, PostSyncJobsByIdErrors, PostSyncJobsByIdResponses, PostSyncJobsData, PostSyncJobsErrors, PostSyncJobsResponses, PostSyncOfflineactionsData, PostSyncOfflineactionsErrors, PostSyncOfflineactionsResponses, PostSystemConfigurationByKeyData, PostSystemConfigurationByKeyErrors, PostSystemConfigurationByKeyResponses, PostSystemConfigurationData, PostSystemConfigurationErrors, PostSystemConfigurationPartialData, PostSystemConfigurationPartialErrors, PostSystemConfigurationPartialResponses, PostSystemConfigurationResponses, PostSystemPingData, PostSystemPingErrors, PostSystemPingResponses, PostSystemRestartData, PostSystemRestartErrors, PostSystemRestartResponses, PostSystemShutdownData, PostSystemShutdownErrors, PostSystemShutdownResponses, PostUiCommandData, PostUiCommandErrors, PostUiCommandResponses, PostUsersAuthenticatebynameData, PostUsersAuthenticatebynameErrors, PostUsersAuthenticatebynameResponses, PostUsersByIdAuthenticateData, PostUsersByIdAuthenticateErrors, PostUsersByIdAuthenticateResponses, PostUsersByIdConfigurationData, PostUsersByIdConfigurationErrors, PostUsersByIdConfigurationPartialData, PostUsersByIdConfigurationPartialErrors, PostUsersByIdConfigurationPartialResponses, PostUsersByIdConfigurationResponses, PostUsersByIdConnectLinkData, PostUsersByIdConnectLinkDeleteData, PostUsersByIdConnectLinkDeleteErrors, PostUsersByIdConnectLinkDeleteResponses, PostUsersByIdConnectLinkErrors, PostUsersByIdConnectLinkResponses, PostUsersByIdData, PostUsersByIdDeleteData, PostUsersByIdDeleteErrors, PostUsersByIdDeleteResponses, PostUsersByIdErrors, PostUsersByIdImagesByTypeByIndexData, PostUsersByIdImagesByTypeByIndexDeleteData, PostUsersByIdImagesByTypeByIndexDeleteErrors, PostUsersByIdImagesByTypeByIndexDeleteResponses, PostUsersByIdImagesByTypeByIndexErrors, PostUsersByIdImagesByTypeByIndexResponses, PostUsersByIdImagesByTypeData, PostUsersByIdImagesByTypeDeleteData, PostUsersByIdImagesByTypeDeleteErrors, PostUsersByIdImagesByTypeDeleteResponses, PostUsersByIdImagesByTypeErrors, PostUsersByIdImagesByTypeResponses, PostUsersByIdPasswordData, PostUsersByIdPasswordErrors, PostUsersByIdPasswordResponses, PostUsersByIdPolicyData, PostUsersByIdPolicyErrors, PostUsersByIdPolicyResponses, PostUsersByIdResponses, PostUsersByIdTrackselectionsByTracktypeDeleteData, PostUsersByIdTrackselectionsByTracktypeDeleteErrors, PostUsersByIdTrackselectionsByTracktypeDeleteResponses, PostUsersByUseridFavoriteitemsByIdData, PostUsersByUseridFavoriteitemsByIdDeleteData, PostUsersByUseridFavoriteitemsByIdDeleteErrors, PostUsersByUseridFavoriteitemsByIdDeleteResponses, PostUsersByUseridFavoriteitemsByIdErrors, PostUsersByUseridFavoriteitemsByIdResponses, PostUsersByUseridItemsByIdHidefromresumeData, PostUsersByUseridItemsByIdHidefromresumeErrors, PostUsersByUseridItemsByIdHidefromresumeResponses, PostUsersByUseridItemsByIdRatingData, PostUsersByUseridItemsByIdRatingDeleteData, PostUsersByUseridItemsByIdRatingDeleteErrors, PostUsersByUseridItemsByIdRatingDeleteResponses, PostUsersByUseridItemsByIdRatingErrors, PostUsersByUseridItemsByIdRatingResponses, PostUsersByUseridItemsByItemidUserdataData, PostUsersByUseridItemsByItemidUserdataErrors, PostUsersByUseridItemsByItemidUserdataResponses, PostUsersByUseridPlayeditemsByIdData, PostUsersByUseridPlayeditemsByIdDeleteData, PostUsersByUseridPlayeditemsByIdDeleteErrors, PostUsersByUseridPlayeditemsByIdDeleteResponses, PostUsersByUseridPlayeditemsByIdErrors, PostUsersByUseridPlayeditemsByIdResponses, PostUsersByUseridPlayingitemsByIdData, PostUsersByUseridPlayingitemsByIdDeleteData, PostUsersByUseridPlayingitemsByIdDeleteErrors, PostUsersByUseridPlayingitemsByIdDeleteResponses, PostUsersByUseridPlayingitemsByIdErrors, PostUsersByUseridPlayingitemsByIdProgressData, PostUsersByUseridPlayingitemsByIdProgressErrors, PostUsersByUseridPlayingitemsByIdProgressResponses, PostUsersByUseridPlayingitemsByIdResponses, PostUsersByUseridTypedsettingsByKeyData, PostUsersByUseridTypedsettingsByKeyErrors, PostUsersByUseridTypedsettingsByKeyResponses, PostUsersettingsByUseridData, PostUsersettingsByUseridErrors, PostUsersettingsByUseridPartialData, PostUsersettingsByUseridPartialErrors, PostUsersettingsByUseridPartialResponses, PostUsersettingsByUseridResponses, PostUsersForgotpasswordData, PostUsersForgotpasswordErrors, PostUsersForgotpasswordPinData, PostUsersForgotpasswordPinErrors, PostUsersForgotpasswordPinResponses, PostUsersForgotpasswordResponses, PostUsersNewData, PostUsersNewErrors, PostUsersNewResponses, PostVideosActiveencodingsDeleteData, PostVideosActiveencodingsDeleteErrors, PostVideosActiveencodingsDeleteResponses, PostVideosByIdAlternatesourcesDeleteData, PostVideosByIdAlternatesourcesDeleteErrors, PostVideosByIdAlternatesourcesDeleteResponses, PostVideosByIdSubtitlesByIndexDeleteData, PostVideosByIdSubtitlesByIndexDeleteErrors, PostVideosByIdSubtitlesByIndexDeleteResponses, PostVideosMergeversionsData, PostVideosMergeversionsErrors, PostVideosMergeversionsResponses, PutLivetvChannelmappingoptionsData, PutLivetvChannelmappingoptionsErrors, PutLivetvChannelmappingoptionsResponses, PutLivetvChannelmappingsData, PutLivetvChannelmappingsErrors, PutLivetvChannelmappingsResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

/**
 * Gets all artists from a given item, folder, or the entire library
 *
 * Requires authentication as user
 */
export const getArtists = <ThrowOnError extends boolean = false>(options?: Options<GetArtistsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetArtistsResponses, GetArtistsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Artists',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getAudiocodecs = <ThrowOnError extends boolean = false>(options?: Options<GetAudiocodecsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAudiocodecsResponses, GetAudiocodecsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/AudioCodecs',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getAudiolayouts = <ThrowOnError extends boolean = false>(options?: Options<GetAudiolayoutsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAudiolayoutsResponses, GetAudiolayoutsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/AudioLayouts',
        ...options
    });
};

/**
 * Gets available channels
 *
 * Requires authentication as user
 */
export const getChannels = <ThrowOnError extends boolean = false>(options?: Options<GetChannelsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetChannelsResponses, GetChannelsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Channels',
        ...options
    });
};

/**
 * Creates a new collection
 *
 * Requires authentication as user
 */
export const postCollections = <ThrowOnError extends boolean = false>(options?: Options<PostCollectionsData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostCollectionsResponses, PostCollectionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Collections',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getContainers = <ThrowOnError extends boolean = false>(options?: Options<GetContainersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetContainersResponses, GetContainersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Containers',
        ...options
    });
};

/**
 * Deletes a device
 *
 * Requires authentication as administrator
 */
export const deleteDevices = <ThrowOnError extends boolean = false>(options: Options<DeleteDevicesData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteDevicesResponses, DeleteDevicesErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Devices',
        ...options
    });
};

/**
 * Gets all devices
 *
 * Requires authentication as administrator
 */
export const getDevices = <ThrowOnError extends boolean = false>(options?: Options<GetDevicesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetDevicesResponses, GetDevicesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Devices',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getExtendedvideotypes = <ThrowOnError extends boolean = false>(options?: Options<GetExtendedvideotypesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetExtendedvideotypesResponses, GetExtendedvideotypesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/ExtendedVideoTypes',
        ...options
    });
};

/**
 * Gets a list of installed features
 *
 * Requires authentication as administrator
 */
export const getFeatures = <ThrowOnError extends boolean = false>(options?: Options<GetFeaturesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetFeaturesResponses, GetFeaturesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Features',
        ...options
    });
};

/**
 * Gets all Game genres from a given item, folder, or the entire library
 *
 * Requires authentication as user
 */
export const getGamegenres = <ThrowOnError extends boolean = false>(options?: Options<GetGamegenresData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGamegenresResponses, GetGamegenresErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/GameGenres',
        ...options
    });
};

/**
 * Gets all genres from a given item, folder, or the entire library
 *
 * Requires authentication as user
 */
export const getGenres = <ThrowOnError extends boolean = false>(options?: Options<GetGenresData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGenresResponses, GetGenresErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Genres',
        ...options
    });
};

/**
 * Deletes an item from the library and file system
 *
 * Requires authentication as user
 */
export const deleteItems = <ThrowOnError extends boolean = false>(options: Options<DeleteItemsData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteItemsResponses, DeleteItemsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getItems = <ThrowOnError extends boolean = false>(options?: Options<GetItemsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetItemsResponses, GetItemsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getItemtypes = <ThrowOnError extends boolean = false>(options?: Options<GetItemtypesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetItemtypesResponses, GetItemtypesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/ItemTypes',
        ...options
    });
};

/**
 * Gets all music genres from a given item, folder, or the entire library
 *
 * Requires authentication as user
 */
export const getMusicgenres = <ThrowOnError extends boolean = false>(options?: Options<GetMusicgenresData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetMusicgenresResponses, GetMusicgenresErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/MusicGenres',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getOfficialratings = <ThrowOnError extends boolean = false>(options?: Options<GetOfficialratingsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetOfficialratingsResponses, GetOfficialratingsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/OfficialRatings',
        ...options
    });
};

/**
 * Gets the OpenAPI 3 specifications
 *
 * No authentication required
 */
export const getOpenapi = <ThrowOnError extends boolean = false>(options?: Options<GetOpenapiData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetOpenapiResponses, GetOpenapiErrors, ThrowOnError>({
        responseType: 'json',
        url: '/openapi',
        ...options
    });
};

/**
 * Gets OpenAPI 3 specifications
 *
 * No authentication required
 */
export const getOpenapiJson = <ThrowOnError extends boolean = false>(options?: Options<GetOpenapiJsonData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetOpenapiJsonResponses, GetOpenapiJsonErrors, ThrowOnError>({
        responseType: 'json',
        url: '/openapi.json',
        ...options
    });
};

/**
 * Gets available packages
 *
 * Requires authentication as user
 */
export const getPackages = <ThrowOnError extends boolean = false>(options?: Options<GetPackagesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPackagesResponses, GetPackagesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Packages',
        ...options
    });
};

/**
 * Gets all persons from a given item, folder, or the entire library
 *
 * Requires authentication as user
 */
export const getPersons = <ThrowOnError extends boolean = false>(options?: Options<GetPersonsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPersonsResponses, GetPersonsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Persons',
        ...options
    });
};

/**
 * Creates a new playlist
 *
 * Requires authentication as user
 */
export const postPlaylists = <ThrowOnError extends boolean = false>(options?: Options<PostPlaylistsData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostPlaylistsResponses, PostPlaylistsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Playlists',
        ...options
    });
};

/**
 * Gets a list of currently installed plugins
 *
 * Requires authentication as administrator
 */
export const getPlugins = <ThrowOnError extends boolean = false>(options?: Options<GetPluginsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPluginsResponses, GetPluginsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Plugins',
        ...options
    });
};

/**
 * Gets scheduled tasks
 *
 * Requires authentication as administrator
 */
export const getScheduledtasks = <ThrowOnError extends boolean = false>(options?: Options<GetScheduledtasksData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetScheduledtasksResponses, GetScheduledtasksErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/ScheduledTasks',
        ...options
    });
};

/**
 * Gets a list of sessions
 *
 * Requires authentication as user
 */
export const getSessions = <ThrowOnError extends boolean = false>(options?: Options<GetSessionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSessionsResponses, GetSessionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getStreamlanguages = <ThrowOnError extends boolean = false>(options?: Options<GetStreamlanguagesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetStreamlanguagesResponses, GetStreamlanguagesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/StreamLanguages',
        ...options
    });
};

/**
 * Gets all studios from a given item, folder, or the entire library
 *
 * Requires authentication as user
 */
export const getStudios = <ThrowOnError extends boolean = false>(options?: Options<GetStudiosData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetStudiosResponses, GetStudiosErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Studios',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getSubtitlecodecs = <ThrowOnError extends boolean = false>(options?: Options<GetSubtitlecodecsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSubtitlecodecsResponses, GetSubtitlecodecsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/SubtitleCodecs',
        ...options
    });
};

/**
 * Gets the swagger specifications
 *
 * No authentication required
 */
export const getSwagger = <ThrowOnError extends boolean = false>(options?: Options<GetSwaggerData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSwaggerResponses, GetSwaggerErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swagger',
        ...options
    });
};

/**
 * Gets the swagger specifications
 *
 * No authentication required
 */
export const getSwaggerJson = <ThrowOnError extends boolean = false>(options?: Options<GetSwaggerJsonData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSwaggerJsonResponses, GetSwaggerJsonErrors, ThrowOnError>({
        responseType: 'json',
        url: '/swagger.json',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getTags = <ThrowOnError extends boolean = false>(options?: Options<GetTagsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetTagsResponses, GetTagsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Tags',
        ...options
    });
};

/**
 * Finds movies and trailers similar to a given trailer.
 *
 * Requires authentication as user
 */
export const getTrailers = <ThrowOnError extends boolean = false>(options?: Options<GetTrailersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetTrailersResponses, GetTrailersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Trailers',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getVideocodecs = <ThrowOnError extends boolean = false>(options?: Options<GetVideocodecsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetVideocodecsResponses, GetVideocodecsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/VideoCodecs',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getYears = <ThrowOnError extends boolean = false>(options?: Options<GetYearsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetYearsResponses, GetYearsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Years',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponses, GetItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnPlayedCount}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcount = <ThrowOnError extends boolean = false>(options: Options<HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountResponses, HeadItemsByIdImagesByTypeByIndexByTagByFormatByMaxwidthByMaxheightByPercentplayedByUnplayedcountErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}/{Index}/{Tag}/{Format}/{MaxWidth}/{MaxHeight}/{PercentPlayed}/{UnPlayedCount}',
        ...options
    });
};

/**
 * Gets an artist, by name
 *
 * Requires authentication as user
 */
export const getArtistsByName = <ThrowOnError extends boolean = false>(options: Options<GetArtistsByNameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetArtistsByNameResponses, GetArtistsByNameErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Artists/{Name}',
        ...options
    });
};

/**
 * Gets all album artists from a given item, folder, or the entire library
 *
 * Requires authentication as user
 */
export const getArtistsAlbumartists = <ThrowOnError extends boolean = false>(options?: Options<GetArtistsAlbumartistsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetArtistsAlbumartistsResponses, GetArtistsAlbumartistsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Artists/AlbumArtists',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getArtistsPrefixes = <ThrowOnError extends boolean = false>(options?: Options<GetArtistsPrefixesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetArtistsPrefixesResponses, GetArtistsPrefixesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Artists/Prefixes',
        ...options
    });
};

/**
 * Creates an instant playlist based on a given artist
 *
 * Requires authentication as user
 */
export const getArtistsInstantmix = <ThrowOnError extends boolean = false>(options?: Options<GetArtistsInstantmixData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetArtistsInstantmixResponses, GetArtistsInstantmixErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Artists/InstantMix',
        ...options
    });
};

/**
 * Gets a list of next up episodes
 *
 * Requires authentication as user
 */
export const getAudiobooksNextup = <ThrowOnError extends boolean = false>(options: Options<GetAudiobooksNextupData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudiobooksNextupResponses, GetAudiobooksNextupErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/AudioBooks/NextUp',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const getAuthProviders = <ThrowOnError extends boolean = false>(options?: Options<GetAuthProvidersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAuthProvidersResponses, GetAuthProvidersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Auth/Providers',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const getAuthKeys = <ThrowOnError extends boolean = false>(options?: Options<GetAuthKeysData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAuthKeysResponses, GetAuthKeysErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Auth/Keys',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const postAuthKeys = <ThrowOnError extends boolean = false>(options: Options<PostAuthKeysData, ThrowOnError>) => {
    return (options.client ?? client).post<PostAuthKeysResponses, PostAuthKeysErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Auth/Keys',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const postBackuprestoreRestore = <ThrowOnError extends boolean = false>(options: Options<PostBackuprestoreRestoreData, ThrowOnError>) => {
    return (options.client ?? client).post<PostBackuprestoreRestoreResponses, PostBackuprestoreRestoreErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/BackupRestore/Restore',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const postBackuprestoreRestoredata = <ThrowOnError extends boolean = false>(options: Options<PostBackuprestoreRestoredataData, ThrowOnError>) => {
    return (options.client ?? client).post<PostBackuprestoreRestoredataResponses, PostBackuprestoreRestoredataErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/BackupRestore/RestoreData',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const getBackuprestoreBackupinfo = <ThrowOnError extends boolean = false>(options?: Options<GetBackuprestoreBackupinfoData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetBackuprestoreBackupinfoResponses, GetBackuprestoreBackupinfoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/BackupRestore/BackupInfo',
        ...options
    });
};

/**
 * Gets branding configuration
 *
 * Requires authentication as user
 */
export const getBrandingConfiguration = <ThrowOnError extends boolean = false>(options?: Options<GetBrandingConfigurationData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetBrandingConfigurationResponses, GetBrandingConfigurationErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Branding/Configuration',
        ...options
    });
};

/**
 * Gets custom css
 *
 * Requires authentication as user
 */
export const getBrandingCss = <ThrowOnError extends boolean = false>(options?: Options<GetBrandingCssData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetBrandingCssResponses, GetBrandingCssErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Branding/Css',
        ...options
    });
};

/**
 * Gets custom css
 *
 * Requires authentication as user
 */
export const getBrandingCssCss = <ThrowOnError extends boolean = false>(options?: Options<GetBrandingCssCssData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetBrandingCssCssResponses, GetBrandingCssCssErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Branding/Css.css',
        ...options
    });
};

/**
 * Creates a Connect link for a user
 *
 * Requires authentication as administrator
 */
export const getConnectPending = <ThrowOnError extends boolean = false>(options?: Options<GetConnectPendingData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetConnectPendingResponses, GetConnectPendingErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Connect/Pending',
        ...options
    });
};

/**
 * Gets the corresponding local user from a connect user id
 *
 * Requires authentication as user
 */
export const getConnectExchange = <ThrowOnError extends boolean = false>(options: Options<GetConnectExchangeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetConnectExchangeResponses, GetConnectExchangeErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Connect/Exchange',
        ...options
    });
};

/**
 * Gets options for a device
 *
 * Requires authentication as administrator
 */
export const getDevicesOptions = <ThrowOnError extends boolean = false>(options: Options<GetDevicesOptionsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDevicesOptionsResponses, GetDevicesOptionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Devices/Options',
        ...options
    });
};

/**
 * Updates device options
 *
 * Requires authentication as administrator
 */
export const postDevicesOptions = <ThrowOnError extends boolean = false>(options: Options<PostDevicesOptionsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostDevicesOptionsResponses, PostDevicesOptionsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Devices/Options',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets info for a device
 *
 * Requires authentication as administrator
 */
export const getDevicesInfo = <ThrowOnError extends boolean = false>(options: Options<GetDevicesInfoData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDevicesInfoResponses, GetDevicesInfoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Devices/Info',
        ...options
    });
};

/**
 * Gets camera upload history for a device
 *
 * Requires authentication as user
 */
export const getDevicesCamerauploads = <ThrowOnError extends boolean = false>(options?: Options<GetDevicesCamerauploadsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetDevicesCamerauploadsResponses, GetDevicesCamerauploadsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Devices/CameraUploads',
        ...options
    });
};

/**
 * Uploads content
 *
 * Requires authentication as user
 */
export const postDevicesCamerauploads = <ThrowOnError extends boolean = false>(options: Options<PostDevicesCamerauploadsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostDevicesCamerauploadsResponses, PostDevicesCamerauploadsErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Devices/CameraUploads',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Deletes a device
 *
 * Requires authentication as administrator
 */
export const postDevicesDelete = <ThrowOnError extends boolean = false>(options: Options<PostDevicesDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostDevicesDeleteResponses, PostDevicesDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Devices/Delete',
        ...options
    });
};

/**
 * Gets a user's display preferences for an item
 *
 * Requires authentication as user
 */
export const getDisplaypreferencesById = <ThrowOnError extends boolean = false>(options: Options<GetDisplaypreferencesByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDisplaypreferencesByIdResponses, GetDisplaypreferencesByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/DisplayPreferences/{Id}',
        ...options
    });
};

/**
 * Updates a user's display preferences for an item
 *
 * Requires authentication as user
 */
export const postDisplaypreferencesByDisplaypreferencesid = <ThrowOnError extends boolean = false>(options: Options<PostDisplaypreferencesByDisplaypreferencesidData, ThrowOnError>) => {
    return (options.client ?? client).post<PostDisplaypreferencesByDisplaypreferencesidResponses, PostDisplaypreferencesByDisplaypreferencesidErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/DisplayPreferences/{DisplayPreferencesId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets a list of profiles
 *
 * Requires authentication as administrator
 */
export const getDlnaProfileinfos = <ThrowOnError extends boolean = false>(options?: Options<GetDlnaProfileinfosData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetDlnaProfileinfosResponses, GetDlnaProfileinfosErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Dlna/ProfileInfos',
        ...options
    });
};

/**
 * Creates a profile
 *
 * Requires authentication as administrator
 */
export const postDlnaProfiles = <ThrowOnError extends boolean = false>(options: Options<PostDlnaProfilesData, ThrowOnError>) => {
    return (options.client ?? client).post<PostDlnaProfilesResponses, PostDlnaProfilesErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Dlna/Profiles',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets available tone mapping options
 *
 * Requires authentication as administrator
 */
export const getEncodingTonemapoptions = <ThrowOnError extends boolean = false>(options?: Options<GetEncodingTonemapoptionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetEncodingTonemapoptionsResponses, GetEncodingTonemapoptionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/ToneMapOptions',
        ...options
    });
};

/**
 * Gets the tone mapping options
 *
 * Requires authentication as user
 */
export const getEncodingFulltonemapoptions = <ThrowOnError extends boolean = false>(options?: Options<GetEncodingFulltonemapoptionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetEncodingFulltonemapoptionsResponses, GetEncodingFulltonemapoptionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/FullToneMapOptions',
        ...options
    });
};

/**
 * Updates the tone mapping options
 *
 * Requires authentication as administrator
 */
export const postEncodingFulltonemapoptions = <ThrowOnError extends boolean = false>(options: Options<PostEncodingFulltonemapoptionsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostEncodingFulltonemapoptionsResponses, PostEncodingFulltonemapoptionsErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/FullToneMapOptions',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets the tone mapping options
 *
 * Requires authentication as user
 */
export const getEncodingPublictonemapoptions = <ThrowOnError extends boolean = false>(options?: Options<GetEncodingPublictonemapoptionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetEncodingPublictonemapoptionsResponses, GetEncodingPublictonemapoptionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/PublicToneMapOptions',
        ...options
    });
};

/**
 * Updates the tone mapping options
 *
 * Requires authentication as administrator
 */
export const postEncodingPublictonemapoptions = <ThrowOnError extends boolean = false>(options: Options<PostEncodingPublictonemapoptionsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostEncodingPublictonemapoptionsResponses, PostEncodingPublictonemapoptionsErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/PublicToneMapOptions',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets the subtitle options
 *
 * Requires authentication as user
 */
export const getEncodingSubtitleoptions = <ThrowOnError extends boolean = false>(options?: Options<GetEncodingSubtitleoptionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetEncodingSubtitleoptionsResponses, GetEncodingSubtitleoptionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/SubtitleOptions',
        ...options
    });
};

/**
 * Updates the subtitle options
 *
 * Requires authentication as administrator
 */
export const postEncodingSubtitleoptions = <ThrowOnError extends boolean = false>(options: Options<PostEncodingSubtitleoptionsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostEncodingSubtitleoptionsResponses, PostEncodingSubtitleoptionsErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/SubtitleOptions',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets the ffmpeg options
 *
 * Requires authentication as user
 */
export const getEncodingFfmpegoptions = <ThrowOnError extends boolean = false>(options?: Options<GetEncodingFfmpegoptionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetEncodingFfmpegoptionsResponses, GetEncodingFfmpegoptionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/FfmpegOptions',
        ...options
    });
};

/**
 * Updates the ffmpeg options
 *
 * Requires authentication as administrator
 */
export const postEncodingFfmpegoptions = <ThrowOnError extends boolean = false>(options: Options<PostEncodingFfmpegoptionsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostEncodingFfmpegoptionsResponses, PostEncodingFfmpegoptionsErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/FfmpegOptions',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets the parameters for a specified codec.
 *
 * Requires authentication as user
 */
export const getEncodingCodecparameters = <ThrowOnError extends boolean = false>(options: Options<GetEncodingCodecparametersData, ThrowOnError>) => {
    return (options.client ?? client).get<GetEncodingCodecparametersResponses, GetEncodingCodecparametersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/CodecParameters',
        ...options
    });
};

/**
 * Updates the parameters for a specified codec.
 *
 * Requires authentication as administrator
 */
export const postEncodingCodecparameters = <ThrowOnError extends boolean = false>(options: Options<PostEncodingCodecparametersData, ThrowOnError>) => {
    return (options.client ?? client).post<PostEncodingCodecparametersResponses, PostEncodingCodecparametersErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/CodecParameters',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets the contents of a given directory in the file system
 *
 * Requires authentication as administrator
 */
export const postEnvironmentValidatepath = <ThrowOnError extends boolean = false>(options: Options<PostEnvironmentValidatepathData, ThrowOnError>) => {
    return (options.client ?? client).post<PostEnvironmentValidatepathResponses, PostEnvironmentValidatepathErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Environment/ValidatePath',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets the parent path of a given path
 *
 * Requires authentication as administrator
 */
export const getEnvironmentDefaultdirectorybrowser = <ThrowOnError extends boolean = false>(options?: Options<GetEnvironmentDefaultdirectorybrowserData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetEnvironmentDefaultdirectorybrowserResponses, GetEnvironmentDefaultdirectorybrowserErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Environment/DefaultDirectoryBrowser',
        ...options
    });
};

/**
 * Gets the contents of a given directory in the file system
 *
 * Requires authentication as administrator
 */
export const getEnvironmentDirectorycontents = <ThrowOnError extends boolean = false>(options: Options<GetEnvironmentDirectorycontentsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetEnvironmentDirectorycontentsResponses, GetEnvironmentDirectorycontentsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Environment/DirectoryContents',
        ...options
    });
};

/**
 * Gets the contents of a given directory in the file system
 *
 * Requires authentication as administrator
 */
export const postEnvironmentDirectorycontents = <ThrowOnError extends boolean = false>(options: Options<PostEnvironmentDirectorycontentsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostEnvironmentDirectorycontentsResponses, PostEnvironmentDirectorycontentsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Environment/DirectoryContents',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets shares from a network device
 *
 * Requires authentication as administrator
 */
export const getEnvironmentNetworkshares = <ThrowOnError extends boolean = false>(options: Options<GetEnvironmentNetworksharesData, ThrowOnError>) => {
    return (options.client ?? client).get<GetEnvironmentNetworksharesResponses, GetEnvironmentNetworksharesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Environment/NetworkShares',
        ...options
    });
};

/**
 * Gets available drives from the server's file system
 *
 * Requires authentication as administrator
 */
export const getEnvironmentDrives = <ThrowOnError extends boolean = false>(options?: Options<GetEnvironmentDrivesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetEnvironmentDrivesResponses, GetEnvironmentDrivesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Environment/Drives',
        ...options
    });
};

/**
 * Gets a list of devices on the network
 *
 * Requires authentication as administrator
 */
export const getEnvironmentNetworkdevices = <ThrowOnError extends boolean = false>(options?: Options<GetEnvironmentNetworkdevicesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetEnvironmentNetworkdevicesResponses, GetEnvironmentNetworkdevicesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Environment/NetworkDevices',
        ...options
    });
};

/**
 * Gets the parent path of a given path
 *
 * Requires authentication as administrator
 */
export const getEnvironmentParentpath = <ThrowOnError extends boolean = false>(options: Options<GetEnvironmentParentpathData, ThrowOnError>) => {
    return (options.client ?? client).get<GetEnvironmentParentpathResponses, GetEnvironmentParentpathErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Environment/ParentPath',
        ...options
    });
};

/**
 * Gets a Game genre, by name
 *
 * Requires authentication as user
 */
export const getGamegenresByName = <ThrowOnError extends boolean = false>(options: Options<GetGamegenresByNameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGamegenresByNameResponses, GetGamegenresByNameErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/GameGenres/{Name}',
        ...options
    });
};

/**
 * Gets a genre, by name
 *
 * Requires authentication as user
 */
export const getGenresByName = <ThrowOnError extends boolean = false>(options: Options<GetGenresByNameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGenresByNameResponses, GetGenresByNameErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Genres/{Name}',
        ...options
    });
};

/**
 * Gets a remote image
 *
 * Requires authentication as administrator
 */
export const getImagesRemote = <ThrowOnError extends boolean = false>(options: Options<GetImagesRemoteData, ThrowOnError>) => {
    return (options.client ?? client).get<GetImagesRemoteResponses, GetImagesRemoteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Images/Remote',
        ...options
    });
};

/**
 * Updates an item
 *
 * Requires authentication as user
 */
export const postItemsByItemid = <ThrowOnError extends boolean = false>(options: Options<PostItemsByItemidData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByItemidResponses, PostItemsByItemidErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{ItemId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getItemsPrefixes = <ThrowOnError extends boolean = false>(options?: Options<GetItemsPrefixesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetItemsPrefixesResponses, GetItemsPrefixesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/Prefixes',
        ...options
    });
};

/**
 * Updates user item access
 *
 * Requires authentication as user
 */
export const postItemsAccess = <ThrowOnError extends boolean = false>(options: Options<PostItemsAccessData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsAccessResponses, PostItemsAccessErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/Access',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const getItemsCounts = <ThrowOnError extends boolean = false>(options?: Options<GetItemsCountsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetItemsCountsResponses, GetItemsCountsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/Counts',
        ...options
    });
};

/**
 * Gets info to debug intros
 *
 * Requires authentication as administrator
 */
export const getItemsIntros = <ThrowOnError extends boolean = false>(options?: Options<GetItemsIntrosData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetItemsIntrosResponses, GetItemsIntrosErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/Intros',
        ...options
    });
};

/**
 * Deletes an item from the library and file system
 *
 * Requires authentication as user
 */
export const postItemsDelete = <ThrowOnError extends boolean = false>(options: Options<PostItemsDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsDeleteResponses, PostItemsDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/Delete',
        ...options
    });
};

/**
 * Deletes an item from the library and file system
 *
 * Requires authentication as user
 */
export const deleteItemsById = <ThrowOnError extends boolean = false>(options: Options<DeleteItemsByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteItemsByIdResponses, DeleteItemsByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getLibrariesAvailableoptions = <ThrowOnError extends boolean = false>(options?: Options<GetLibrariesAvailableoptionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLibrariesAvailableoptionsResponses, GetLibrariesAvailableoptionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Libraries/AvailableOptions',
        ...options
    });
};

/**
 * Gets all user media folders.
 *
 * Requires authentication as user
 */
export const getLibrarySelectablemediafolders = <ThrowOnError extends boolean = false>(options?: Options<GetLibrarySelectablemediafoldersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLibrarySelectablemediafoldersResponses, GetLibrarySelectablemediafoldersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/SelectableMediaFolders',
        ...options
    });
};

/**
 * Gets all user media folders.
 *
 * Requires authentication as user
 */
export const getLibraryMediafolders = <ThrowOnError extends boolean = false>(options?: Options<GetLibraryMediafoldersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLibraryMediafoldersResponses, GetLibraryMediafoldersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/MediaFolders',
        ...options
    });
};

/**
 * Gets a list of physical paths from virtual folders
 *
 * Requires authentication as administrator
 */
export const getLibraryPhysicalpaths = <ThrowOnError extends boolean = false>(options?: Options<GetLibraryPhysicalpathsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLibraryPhysicalpathsResponses, GetLibraryPhysicalpathsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/PhysicalPaths',
        ...options
    });
};

/**
 * Starts a library scan
 *
 * Requires authentication as administrator
 */
export const postLibraryRefresh = <ThrowOnError extends boolean = false>(options?: Options<PostLibraryRefreshData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostLibraryRefreshResponses, PostLibraryRefreshErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/Refresh',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const deleteLibraryVirtualfolders = <ThrowOnError extends boolean = false>(options?: Options<DeleteLibraryVirtualfoldersData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteLibraryVirtualfoldersResponses, DeleteLibraryVirtualfoldersErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/VirtualFolders',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const postLibraryVirtualfolders = <ThrowOnError extends boolean = false>(options: Options<PostLibraryVirtualfoldersData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLibraryVirtualfoldersResponses, PostLibraryVirtualfoldersErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/VirtualFolders',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Opens a media source
 *
 * Requires authentication as user
 */
export const postLivestreamsOpen = <ThrowOnError extends boolean = false>(options: Options<PostLivestreamsOpenData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivestreamsOpenResponses, PostLivestreamsOpenErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveStreams/Open',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Closes a media source
 *
 * Requires authentication as user
 */
export const postLivestreamsClose = <ThrowOnError extends boolean = false>(options: Options<PostLivestreamsCloseData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivestreamsCloseResponses, PostLivestreamsCloseErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveStreams/Close',
        ...options
    });
};

/**
 * Gets media info for a live stream
 *
 * Requires authentication as user
 */
export const postLivestreamsMediainfo = <ThrowOnError extends boolean = false>(options: Options<PostLivestreamsMediainfoData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivestreamsMediainfoResponses, PostLivestreamsMediainfoErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveStreams/MediaInfo',
        ...options
    });
};

/**
 * Gets live tv channel tags
 *
 * Requires authentication as user
 */
export const getLivetvChanneltags = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvChanneltagsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvChanneltagsResponses, GetLivetvChanneltagsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelTags',
        ...options
    });
};

/**
 * Gets the top level live tv folder
 *
 * Requires authentication as user
 */
export const getLivetvFolder = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvFolderData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvFolderResponses, GetLivetvFolderErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Folder',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const deleteLivetvChannelmappings = <ThrowOnError extends boolean = false>(options: Options<DeleteLivetvChannelmappingsData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteLivetvChannelmappingsResponses, DeleteLivetvChannelmappingsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelMappings',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const getLivetvChannelmappings = <ThrowOnError extends boolean = false>(options: Options<GetLivetvChannelmappingsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvChannelmappingsResponses, GetLivetvChannelmappingsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelMappings',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const headLivetvChannelmappings = <ThrowOnError extends boolean = false>(options: Options<HeadLivetvChannelmappingsData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadLivetvChannelmappingsResponses, HeadLivetvChannelmappingsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelMappings',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const postLivetvChannelmappings = <ThrowOnError extends boolean = false>(options: Options<PostLivetvChannelmappingsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvChannelmappingsResponses, PostLivetvChannelmappingsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelMappings',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const putLivetvChannelmappings = <ThrowOnError extends boolean = false>(options: Options<PutLivetvChannelmappingsData, ThrowOnError>) => {
    return (options.client ?? client).put<PutLivetvChannelmappingsResponses, PutLivetvChannelmappingsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelMappings',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const deleteLivetvChannelmappingoptions = <ThrowOnError extends boolean = false>(options: Options<DeleteLivetvChannelmappingoptionsData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteLivetvChannelmappingoptionsResponses, DeleteLivetvChannelmappingoptionsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelMappingOptions',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const getLivetvChannelmappingoptions = <ThrowOnError extends boolean = false>(options: Options<GetLivetvChannelmappingoptionsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvChannelmappingoptionsResponses, GetLivetvChannelmappingoptionsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelMappingOptions',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const headLivetvChannelmappingoptions = <ThrowOnError extends boolean = false>(options: Options<HeadLivetvChannelmappingoptionsData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadLivetvChannelmappingoptionsResponses, HeadLivetvChannelmappingoptionsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelMappingOptions',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const postLivetvChannelmappingoptions = <ThrowOnError extends boolean = false>(options: Options<PostLivetvChannelmappingoptionsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvChannelmappingoptionsResponses, PostLivetvChannelmappingoptionsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelMappingOptions',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const putLivetvChannelmappingoptions = <ThrowOnError extends boolean = false>(options: Options<PutLivetvChannelmappingoptionsData, ThrowOnError>) => {
    return (options.client ?? client).put<PutLivetvChannelmappingoptionsResponses, PutLivetvChannelmappingoptionsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelMappingOptions',
        ...options
    });
};

/**
 * Deletes a listing provider
 *
 * Requires authentication as administrator
 */
export const deleteLivetvListingproviders = <ThrowOnError extends boolean = false>(options?: Options<DeleteLivetvListingprovidersData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteLivetvListingprovidersResponses, DeleteLivetvListingprovidersErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ListingProviders',
        ...options
    });
};

/**
 * Gets current listing providers
 *
 * Requires authentication as administrator
 */
export const getLivetvListingproviders = <ThrowOnError extends boolean = false>(options: Options<GetLivetvListingprovidersData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvListingprovidersResponses, GetLivetvListingprovidersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ListingProviders',
        ...options
    });
};

/**
 * Adds a listing provider
 *
 * Requires authentication as administrator
 */
export const postLivetvListingproviders = <ThrowOnError extends boolean = false>(options: Options<PostLivetvListingprovidersData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvListingprovidersResponses, PostLivetvListingprovidersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ListingProviders',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Deletes a tuner host
 *
 * Requires authentication as administrator
 */
export const deleteLivetvTunerhosts = <ThrowOnError extends boolean = false>(options?: Options<DeleteLivetvTunerhostsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteLivetvTunerhostsResponses, DeleteLivetvTunerhostsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/TunerHosts',
        ...options
    });
};

/**
 * Gets tuner hosts
 *
 * Requires authentication as administrator
 */
export const getLivetvTunerhosts = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvTunerhostsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvTunerhostsResponses, GetLivetvTunerhostsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/TunerHosts',
        ...options
    });
};

/**
 * Adds a tuner host
 *
 * Requires authentication as administrator
 */
export const postLivetvTunerhosts = <ThrowOnError extends boolean = false>(options: Options<PostLivetvTunerhostsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvTunerhostsResponses, PostLivetvTunerhostsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/TunerHosts',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets available live tv services.
 *
 * Requires authentication as user
 */
export const getLivetvInfo = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvInfoData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvInfoResponses, GetLivetvInfoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Info',
        ...options
    });
};

/**
 * Gets the epg.
 *
 * Requires authentication as user
 */
export const getLivetvEpg = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvEpgData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvEpgResponses, GetLivetvEpgErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/EPG',
        ...options
    });
};

/**
 * Gets available live tv channels.
 *
 * Requires authentication as user
 */
export const getLivetvChannels = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvChannelsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvChannelsResponses, GetLivetvChannelsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Channels',
        ...options
    });
};

/**
 * Gets available live tv epgs..
 *
 * Requires authentication as user
 */
export const getLivetvPrograms = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvProgramsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvProgramsResponses, GetLivetvProgramsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Programs',
        ...options
    });
};

/**
 * Gets available live tv epgs..
 *
 * Requires authentication as user
 */
export const postLivetvPrograms = <ThrowOnError extends boolean = false>(options: Options<PostLivetvProgramsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvProgramsResponses, PostLivetvProgramsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Programs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets live tv recordings
 *
 * Requires authentication as user
 */
export const getLivetvRecordings = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvRecordingsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvRecordingsResponses, GetLivetvRecordingsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Recordings',
        ...options
    });
};

/**
 * Gets live tv timers
 *
 * Requires authentication as user
 */
export const getLivetvTimers = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvTimersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvTimersResponses, GetLivetvTimersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Timers',
        ...options
    });
};

/**
 * Creates a live tv timer
 *
 * Requires authentication as user
 */
export const postLivetvTimers = <ThrowOnError extends boolean = false>(options: Options<PostLivetvTimersData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvTimersResponses, PostLivetvTimersErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Timers',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets live tv series timers
 *
 * Requires authentication as user
 */
export const getLivetvSeriestimers = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvSeriestimersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvSeriestimersResponses, GetLivetvSeriestimersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/SeriesTimers',
        ...options
    });
};

/**
 * Creates a live tv series timer
 *
 * Requires authentication as user
 */
export const postLivetvSeriestimers = <ThrowOnError extends boolean = false>(options: Options<PostLivetvSeriestimersData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvSeriestimersResponses, PostLivetvSeriestimersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/SeriesTimers',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets guide info
 *
 * Requires authentication as user
 */
export const getLivetvGuideinfo = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvGuideinfoData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvGuideinfoResponses, GetLivetvGuideinfoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/GuideInfo',
        ...options
    });
};

/**
 * Gets available recording options
 *
 * Requires authentication as user
 */
export const getLivetvAvailablerecordingoptions = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvAvailablerecordingoptionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvAvailablerecordingoptionsResponses, GetLivetvAvailablerecordingoptionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/AvailableRecordingOptions',
        ...options
    });
};

/**
 * Gets known parental ratings
 *
 * Requires authentication as user
 */
export const getLocalizationParentalratings = <ThrowOnError extends boolean = false>(options?: Options<GetLocalizationParentalratingsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLocalizationParentalratingsResponses, GetLocalizationParentalratingsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Localization/ParentalRatings',
        ...options
    });
};

/**
 * Gets localization options
 *
 * Requires authentication as user
 */
export const getLocalizationOptions = <ThrowOnError extends boolean = false>(options?: Options<GetLocalizationOptionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLocalizationOptionsResponses, GetLocalizationOptionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Localization/Options',
        ...options
    });
};

/**
 * Gets known countries
 *
 * Requires authentication as user
 */
export const getLocalizationCountries = <ThrowOnError extends boolean = false>(options?: Options<GetLocalizationCountriesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLocalizationCountriesResponses, GetLocalizationCountriesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Localization/Countries',
        ...options
    });
};

/**
 * Gets known cultures
 *
 * Requires authentication as user
 */
export const getLocalizationCultures = <ThrowOnError extends boolean = false>(options?: Options<GetLocalizationCulturesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLocalizationCulturesResponses, GetLocalizationCulturesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Localization/Cultures',
        ...options
    });
};

/**
 * Gets movie recommendations
 *
 * Requires authentication as user
 */
export const getMoviesRecommendations = <ThrowOnError extends boolean = false>(options?: Options<GetMoviesRecommendationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetMoviesRecommendationsResponses, GetMoviesRecommendationsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Movies/Recommendations',
        ...options
    });
};

/**
 * Gets a music genre, by name
 *
 * Requires authentication as user
 */
export const getMusicgenresByName = <ThrowOnError extends boolean = false>(options: Options<GetMusicgenresByNameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetMusicgenresByNameResponses, GetMusicgenresByNameErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/MusicGenres/{Name}',
        ...options
    });
};

/**
 * Creates an instant playlist based on a music genre
 *
 * Requires authentication as user
 */
export const getMusicgenresInstantmix = <ThrowOnError extends boolean = false>(options?: Options<GetMusicgenresInstantmixData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetMusicgenresInstantmixResponses, GetMusicgenresInstantmixErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/MusicGenres/InstantMix',
        ...options
    });
};

/**
 * Gets notification types
 *
 * Requires authentication as user
 */
export const getNotificationsTypes = <ThrowOnError extends boolean = false>(options?: Options<GetNotificationsTypesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetNotificationsTypesResponses, GetNotificationsTypesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Notifications/Types',
        ...options
    });
};

/**
 * Sends a notification to all admin users
 *
 * Requires authentication as user
 */
export const postNotificationsAdmin = <ThrowOnError extends boolean = false>(options: Options<PostNotificationsAdminData, ThrowOnError>) => {
    return (options.client ?? client).post<PostNotificationsAdminResponses, PostNotificationsAdminErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Notifications/Admin',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets available package updates for currently installed packages
 *
 * Requires authentication as administrator
 */
export const getPackagesUpdates = <ThrowOnError extends boolean = false>(options: Options<GetPackagesUpdatesData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPackagesUpdatesResponses, GetPackagesUpdatesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Packages/Updates',
        ...options
    });
};

/**
 * Gets a package, by name or assembly guid
 *
 * Requires authentication as user
 */
export const getPackagesByName = <ThrowOnError extends boolean = false>(options: Options<GetPackagesByNameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPackagesByNameResponses, GetPackagesByNameErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Packages/{Name}',
        ...options
    });
};

/**
 * Gets a person, by name
 *
 * Requires authentication as user
 */
export const getPersonsByName = <ThrowOnError extends boolean = false>(options: Options<GetPersonsByNameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPersonsByNameResponses, GetPersonsByNameErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Persons/{Name}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getPlaybackBitratetest = <ThrowOnError extends boolean = false>(options: Options<GetPlaybackBitratetestData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPlaybackBitratetestResponses, GetPlaybackBitratetestErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Playback/BitrateTest',
        ...options
    });
};

/**
 * Uninstalls a plugin
 *
 * Requires authentication as administrator
 */
export const deletePluginsById = <ThrowOnError extends boolean = false>(options: Options<DeletePluginsByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeletePluginsByIdResponses, DeletePluginsByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Plugins/{Id}',
        ...options
    });
};

/**
 * Gets a scheduled task, by Id
 *
 * Requires authentication as administrator
 */
export const getScheduledtasksById = <ThrowOnError extends boolean = false>(options: Options<GetScheduledtasksByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetScheduledtasksByIdResponses, GetScheduledtasksByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/ScheduledTasks/{Id}',
        ...options
    });
};

/**
 * Gets a the current play queue from a session
 *
 * Requires authentication as user
 */
export const getSessionsPlayqueue = <ThrowOnError extends boolean = false>(options?: Options<GetSessionsPlayqueueData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSessionsPlayqueueResponses, GetSessionsPlayqueueErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/PlayQueue',
        ...options
    });
};

/**
 * Reports that a session has ended
 *
 * Requires authentication as user
 */
export const postSessionsLogout = <ThrowOnError extends boolean = false>(options?: Options<PostSessionsLogoutData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostSessionsLogoutResponses, PostSessionsLogoutErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/Logout',
        ...options
    });
};

/**
 * Updates capabilities for a device
 *
 * Requires authentication as user
 */
export const postSessionsCapabilities = <ThrowOnError extends boolean = false>(options: Options<PostSessionsCapabilitiesData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsCapabilitiesResponses, PostSessionsCapabilitiesErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/Capabilities',
        ...options
    });
};

/**
 * Reports playback has started within a session
 *
 * Requires authentication as user
 */
export const postSessionsPlaying = <ThrowOnError extends boolean = false>(options: Options<PostSessionsPlayingData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsPlayingResponses, PostSessionsPlayingErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/Playing',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets a list of missing episodes
 *
 * Requires authentication as user
 */
export const getShowsMissing = <ThrowOnError extends boolean = false>(options?: Options<GetShowsMissingData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetShowsMissingResponses, GetShowsMissingErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Shows/Missing',
        ...options
    });
};

/**
 * Gets a list of upcoming episodes
 *
 * Requires authentication as user
 */
export const getShowsUpcoming = <ThrowOnError extends boolean = false>(options?: Options<GetShowsUpcomingData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetShowsUpcomingResponses, GetShowsUpcomingErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Shows/Upcoming',
        ...options
    });
};

/**
 * Gets a list of next up episodes
 *
 * Requires authentication as user
 */
export const getShowsNextup = <ThrowOnError extends boolean = false>(options: Options<GetShowsNextupData, ThrowOnError>) => {
    return (options.client ?? client).get<GetShowsNextupResponses, GetShowsNextupErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Shows/NextUp',
        ...options
    });
};

/**
 * Gets a studio, by name
 *
 * Requires authentication as user
 */
export const getStudiosByName = <ThrowOnError extends boolean = false>(options: Options<GetStudiosByNameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetStudiosByNameResponses, GetStudiosByNameErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Studios/{Name}',
        ...options
    });
};

/**
 * Gets a list of available sync targets.
 *
 * Requires authentication as user
 */
export const getSyncTargets = <ThrowOnError extends boolean = false>(options: Options<GetSyncTargetsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSyncTargetsResponses, GetSyncTargetsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Targets',
        ...options
    });
};

/**
 * Gets sync jobs.
 *
 * Requires authentication as user
 */
export const getSyncJobs = <ThrowOnError extends boolean = false>(options?: Options<GetSyncJobsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSyncJobsResponses, GetSyncJobsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Jobs',
        ...options
    });
};

/**
 * Gets sync jobs.
 *
 * Requires authentication as user
 */
export const postSyncJobs = <ThrowOnError extends boolean = false>(options: Options<PostSyncJobsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncJobsResponses, PostSyncJobsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Jobs',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets sync job items.
 *
 * Requires authentication as user
 */
export const getSyncJobitems = <ThrowOnError extends boolean = false>(options: Options<GetSyncJobitemsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSyncJobitemsResponses, GetSyncJobitemsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/JobItems',
        ...options
    });
};

/**
 * Gets a list of available sync targets.
 *
 * Requires authentication as user
 */
export const getSyncOptions = <ThrowOnError extends boolean = false>(options: Options<GetSyncOptionsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSyncOptionsResponses, GetSyncOptionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Options',
        ...options
    });
};

/**
 * Reports an action that occurred while offline.
 *
 * Requires authentication as user
 */
export const postSyncOfflineactions = <ThrowOnError extends boolean = false>(options: Options<PostSyncOfflineactionsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncOfflineactionsResponses, PostSyncOfflineactionsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/OfflineActions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Syncs data between device and server
 *
 * Requires authentication as user
 */
export const postSyncData = <ThrowOnError extends boolean = false>(options: Options<PostSyncDataData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncDataResponses, PostSyncDataErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Data',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets application configuration
 *
 * Requires authentication as user
 */
export const getSystemConfiguration = <ThrowOnError extends boolean = false>(options?: Options<GetSystemConfigurationData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSystemConfigurationResponses, GetSystemConfigurationErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Configuration',
        ...options
    });
};

/**
 * Updates application configuration
 *
 * Requires authentication as administrator
 */
export const postSystemConfiguration = <ThrowOnError extends boolean = false>(options: Options<PostSystemConfigurationData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSystemConfigurationResponses, PostSystemConfigurationErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Configuration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets release notes
 *
 * Requires authentication as user
 */
export const getSystemReleasenotes = <ThrowOnError extends boolean = false>(options?: Options<GetSystemReleasenotesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSystemReleasenotesResponses, GetSystemReleasenotesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/ReleaseNotes',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getSystemPing = <ThrowOnError extends boolean = false>(options?: Options<GetSystemPingData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSystemPingResponses, GetSystemPingErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Ping',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headSystemPing = <ThrowOnError extends boolean = false>(options?: Options<HeadSystemPingData, ThrowOnError>) => {
    return (options?.client ?? client).head<HeadSystemPingResponses, HeadSystemPingErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Ping',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const postSystemPing = <ThrowOnError extends boolean = false>(options?: Options<PostSystemPingData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostSystemPingResponses, PostSystemPingErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Ping',
        ...options
    });
};

/**
 * Gets wake on lan information
 *
 * Requires authentication as user
 */
export const getSystemWakeonlaninfo = <ThrowOnError extends boolean = false>(options?: Options<GetSystemWakeonlaninfoData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSystemWakeonlaninfoResponses, GetSystemWakeonlaninfoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/WakeOnLanInfo',
        ...options
    });
};

/**
 * Gets information about the server
 *
 * Requires authentication as user
 */
export const getSystemInfo = <ThrowOnError extends boolean = false>(options?: Options<GetSystemInfoData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSystemInfoResponses, GetSystemInfoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Info',
        ...options
    });
};

/**
 * Restarts the application, if needed
 *
 * Requires authentication as administrator
 */
export const postSystemRestart = <ThrowOnError extends boolean = false>(options?: Options<PostSystemRestartData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostSystemRestartResponses, PostSystemRestartErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Restart',
        ...options
    });
};

/**
 * Shuts down the application
 *
 * Requires authentication as administrator
 */
export const postSystemShutdown = <ThrowOnError extends boolean = false>(options?: Options<PostSystemShutdownData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostSystemShutdownResponses, PostSystemShutdownErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Shutdown',
        ...options
    });
};

/**
 * Gets information about the request endpoint
 *
 * Requires authentication as user
 */
export const getSystemEndpoint = <ThrowOnError extends boolean = false>(options?: Options<GetSystemEndpointData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSystemEndpointResponses, GetSystemEndpointErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Endpoint',
        ...options
    });
};

/**
 * Gets UI view data
 *
 * Requires authentication as user
 */
export const getUiView = <ThrowOnError extends boolean = false>(options: Options<GetUiViewData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUiViewResponses, GetUiViewErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/UI/View',
        ...options
    });
};

/**
 * Execute a command in the context of tv setup
 *
 * Requires authentication as user
 */
export const postUiCommand = <ThrowOnError extends boolean = false>(options: Options<PostUiCommandData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUiCommandResponses, PostUiCommandErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/UI/Command',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets a list of publicly visible users for display on a login screen.
 *
 * Requires authentication as user
 */
export const getUsersPublic = <ThrowOnError extends boolean = false>(options?: Options<GetUsersPublicData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUsersPublicResponses, GetUsersPublicErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/Public',
        ...options
    });
};

/**
 * Gets a list of users
 *
 * Requires authentication as administrator
 */
export const getUsersQuery = <ThrowOnError extends boolean = false>(options?: Options<GetUsersQueryData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUsersQueryResponses, GetUsersQueryErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/Query',
        ...options
    });
};

/**
 * Gets a list of users
 *
 * Requires authentication as administrator
 */
export const getUsersPrefixes = <ThrowOnError extends boolean = false>(options?: Options<GetUsersPrefixesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUsersPrefixesResponses, GetUsersPrefixesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/Prefixes',
        ...options
    });
};

/**
 * Gets a list of users
 *
 * Requires authentication as user
 */
export const getUsersItemaccess = <ThrowOnError extends boolean = false>(options?: Options<GetUsersItemaccessData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUsersItemaccessResponses, GetUsersItemaccessErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/ItemAccess',
        ...options
    });
};

/**
 * Deletes a user
 *
 * Requires authentication as administrator
 */
export const deleteUsersById = <ThrowOnError extends boolean = false>(options: Options<DeleteUsersByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUsersByIdResponses, DeleteUsersByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}',
        ...options
    });
};

/**
 * Gets a user by Id
 *
 * Requires authentication as user
 */
export const getUsersById = <ThrowOnError extends boolean = false>(options: Options<GetUsersByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByIdResponses, GetUsersByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}',
        ...options
    });
};

/**
 * Updates a user
 *
 * Requires authentication as user
 */
export const postUsersById = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdResponses, PostUsersByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Authenticates a user
 *
 * Authenticate a user by nane and password. A 200 status code indicates success, while anything in the 400 or 500 range indicates failure
 * ---
 * Requires authentication as user
 */
export const postUsersAuthenticatebyname = <ThrowOnError extends boolean = false>(options: Options<PostUsersAuthenticatebynameData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersAuthenticatebynameResponses, PostUsersAuthenticatebynameErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/AuthenticateByName',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Creates a user
 *
 * Requires authentication as administrator
 */
export const postUsersNew = <ThrowOnError extends boolean = false>(options: Options<PostUsersNewData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersNewResponses, PostUsersNewErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/New',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Initiates the forgot password process for a local user
 *
 * Requires authentication as user
 */
export const postUsersForgotpassword = <ThrowOnError extends boolean = false>(options: Options<PostUsersForgotpasswordData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersForgotpasswordResponses, PostUsersForgotpasswordErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/ForgotPassword',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets user settings
 *
 * Requires authentication as user
 */
export const getUsersettingsByUserid = <ThrowOnError extends boolean = false>(options: Options<GetUsersettingsByUseridData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersettingsByUseridResponses, GetUsersettingsByUseridErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/UserSettings/{UserId}',
        ...options
    });
};

/**
 * Updates a user's display preferences for an item
 *
 * Requires authentication as user
 */
export const postUsersettingsByUserid = <ThrowOnError extends boolean = false>(options: Options<PostUsersettingsByUseridData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersettingsByUseridResponses, PostUsersettingsByUseridErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/UserSettings/{UserId}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Merges videos into a single record
 *
 * Requires authentication as administrator
 */
export const postVideosMergeversions = <ThrowOnError extends boolean = false>(options?: Options<PostVideosMergeversionsData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostVideosMergeversionsResponses, PostVideosMergeversionsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/MergeVersions',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const deleteVideosActiveencodings = <ThrowOnError extends boolean = false>(options: Options<DeleteVideosActiveencodingsData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteVideosActiveencodingsResponses, DeleteVideosActiveencodingsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/ActiveEncodings',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getWebConfigurationpage = <ThrowOnError extends boolean = false>(options?: Options<GetWebConfigurationpageData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetWebConfigurationpageResponses, GetWebConfigurationpageErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/web/ConfigurationPage',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getWebConfigurationpages = <ThrowOnError extends boolean = false>(options?: Options<GetWebConfigurationpagesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetWebConfigurationpagesResponses, GetWebConfigurationpagesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/web/ConfigurationPages',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getWebStrings = <ThrowOnError extends boolean = false>(options?: Options<GetWebStringsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetWebStringsResponses, GetWebStringsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/web/strings',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getWebStringset = <ThrowOnError extends boolean = false>(options?: Options<GetWebStringsetData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetWebStringsetResponses, GetWebStringsetErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/web/stringset',
        ...options
    });
};

/**
 * Creates an instant playlist based on a given album
 *
 * Requires authentication as user
 */
export const getAlbumsByIdInstantmix = <ThrowOnError extends boolean = false>(options: Options<GetAlbumsByIdInstantmixData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAlbumsByIdInstantmixResponses, GetAlbumsByIdInstantmixErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Albums/{Id}/InstantMix',
        ...options
    });
};

/**
 * Finds albums similar to a given album.
 *
 * Requires authentication as user
 */
export const getAlbumsByIdSimilar = <ThrowOnError extends boolean = false>(options: Options<GetAlbumsByIdSimilarData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAlbumsByIdSimilarResponses, GetAlbumsByIdSimilarErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Albums/{Id}/Similar',
        ...options
    });
};

/**
 * Finds albums similar to a given album.
 *
 * Requires authentication as user
 */
export const getArtistsByIdSimilar = <ThrowOnError extends boolean = false>(options: Options<GetArtistsByIdSimilarData, ThrowOnError>) => {
    return (options.client ?? client).get<GetArtistsByIdSimilarResponses, GetArtistsByIdSimilarErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Artists/{Id}/Similar',
        ...options
    });
};

/**
 * Gets an audio stream
 *
 * Requires authentication as user
 */
export const getAudioByIdUniversalByContainer = <ThrowOnError extends boolean = false>(options: Options<GetAudioByIdUniversalByContainerData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudioByIdUniversalByContainerResponses, GetAudioByIdUniversalByContainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/universal.{Container}',
        ...options
    });
};

/**
 * Gets an audio stream
 *
 * Requires authentication as user
 */
export const headAudioByIdUniversalByContainer = <ThrowOnError extends boolean = false>(options: Options<HeadAudioByIdUniversalByContainerData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadAudioByIdUniversalByContainerResponses, HeadAudioByIdUniversalByContainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/universal.{Container}',
        ...options
    });
};

/**
 * Gets an audio stream
 *
 * Requires authentication as user
 */
export const getAudioByIdUniversal = <ThrowOnError extends boolean = false>(options: Options<GetAudioByIdUniversalData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudioByIdUniversalResponses, GetAudioByIdUniversalErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/universal',
        ...options
    });
};

/**
 * Gets an audio stream
 *
 * Requires authentication as user
 */
export const headAudioByIdUniversal = <ThrowOnError extends boolean = false>(options: Options<HeadAudioByIdUniversalData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadAudioByIdUniversalResponses, HeadAudioByIdUniversalErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/universal',
        ...options
    });
};

/**
 * Gets an audio stream
 *
 * Requires authentication as user
 */
export const getAudioByIdStreamByContainer = <ThrowOnError extends boolean = false>(options: Options<GetAudioByIdStreamByContainerData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudioByIdStreamByContainerResponses, GetAudioByIdStreamByContainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/stream.{Container}',
        ...options
    });
};

/**
 * Gets an audio stream
 *
 * Requires authentication as user
 */
export const headAudioByIdStreamByContainer = <ThrowOnError extends boolean = false>(options: Options<HeadAudioByIdStreamByContainerData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadAudioByIdStreamByContainerResponses, HeadAudioByIdStreamByContainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/stream.{Container}',
        ...options
    });
};

/**
 * Gets an audio stream
 *
 * Requires authentication as user
 */
export const getAudioByIdStream = <ThrowOnError extends boolean = false>(options: Options<GetAudioByIdStreamData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudioByIdStreamResponses, GetAudioByIdStreamErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/stream',
        ...options
    });
};

/**
 * Gets an audio stream
 *
 * Requires authentication as user
 */
export const headAudioByIdStream = <ThrowOnError extends boolean = false>(options: Options<HeadAudioByIdStreamData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadAudioByIdStreamResponses, HeadAudioByIdStreamErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/stream',
        ...options
    });
};

/**
 * Gets an audio stream
 *
 * Requires authentication as user
 */
export const getAudioByIdByStreamfilename = <ThrowOnError extends boolean = false>(options: Options<GetAudioByIdByStreamfilenameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudioByIdByStreamfilenameResponses, GetAudioByIdByStreamfilenameErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/{StreamFileName}',
        ...options
    });
};

/**
 * Gets an audio stream
 *
 * Requires authentication as user
 */
export const headAudioByIdByStreamfilename = <ThrowOnError extends boolean = false>(options: Options<HeadAudioByIdByStreamfilenameData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadAudioByIdByStreamfilenameResponses, HeadAudioByIdByStreamfilenameErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/{StreamFileName}',
        ...options
    });
};

/**
 * Gets an audio stream using HTTP live streaming.
 *
 * Requires authentication as user
 */
export const getAudioByIdMasterM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetAudioByIdMasterM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudioByIdMasterM3U8Responses, GetAudioByIdMasterM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/master.m3u8',
        ...options
    });
};

/**
 * Gets an audio stream using HTTP live streaming.
 *
 * Requires authentication as user
 */
export const headAudioByIdMasterM3U8 = <ThrowOnError extends boolean = false>(options: Options<HeadAudioByIdMasterM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).head<HeadAudioByIdMasterM3U8Responses, HeadAudioByIdMasterM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/master.m3u8',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getAudioByIdLiveM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetAudioByIdLiveM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudioByIdLiveM3U8Responses, GetAudioByIdLiveM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/live.m3u8',
        ...options
    });
};

/**
 * Gets an audio stream using HTTP live streaming.
 *
 * Requires authentication as user
 */
export const getAudioByIdMainM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetAudioByIdMainM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudioByIdMainM3U8Responses, GetAudioByIdMainM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/main.m3u8',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const deleteAuthKeysByKey = <ThrowOnError extends boolean = false>(options: Options<DeleteAuthKeysByKeyData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteAuthKeysByKeyResponses, DeleteAuthKeysByKeyErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Auth/Keys/{Key}',
        ...options
    });
};

/**
 * Removes items from a collection
 *
 * Requires authentication as user
 */
export const deleteCollectionsByIdItems = <ThrowOnError extends boolean = false>(options: Options<DeleteCollectionsByIdItemsData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteCollectionsByIdItemsResponses, DeleteCollectionsByIdItemsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Collections/{Id}/Items',
        ...options
    });
};

/**
 * Adds items to a collection
 *
 * Requires authentication as user
 */
export const postCollectionsByIdItems = <ThrowOnError extends boolean = false>(options: Options<PostCollectionsByIdItemsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostCollectionsByIdItemsResponses, PostCollectionsByIdItemsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Collections/{Id}/Items',
        ...options
    });
};

/**
 * Gets dlna server info
 *
 * No authentication required
 */
export const getDlnaByUuidDescriptionXml = <ThrowOnError extends boolean = false>(options: Options<GetDlnaByUuidDescriptionXmlData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDlnaByUuidDescriptionXmlResponses, GetDlnaByUuidDescriptionXmlErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/description.xml',
        ...options
    });
};

/**
 * Gets dlna server info
 *
 * No authentication required
 */
export const headDlnaByUuidDescriptionXml = <ThrowOnError extends boolean = false>(options: Options<HeadDlnaByUuidDescriptionXmlData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadDlnaByUuidDescriptionXmlResponses, HeadDlnaByUuidDescriptionXmlErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/description.xml',
        ...options
    });
};

/**
 * Gets dlna server info
 *
 * No authentication required
 */
export const getDlnaByUuidDescription = <ThrowOnError extends boolean = false>(options: Options<GetDlnaByUuidDescriptionData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDlnaByUuidDescriptionResponses, GetDlnaByUuidDescriptionErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/description',
        ...options
    });
};

/**
 * Gets dlna server info
 *
 * No authentication required
 */
export const headDlnaByUuidDescription = <ThrowOnError extends boolean = false>(options: Options<HeadDlnaByUuidDescriptionData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadDlnaByUuidDescriptionResponses, HeadDlnaByUuidDescriptionErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/description',
        ...options
    });
};

/**
 * Gets a server icon
 *
 * No authentication required
 */
export const getDlnaIconsByFilename = <ThrowOnError extends boolean = false>(options: Options<GetDlnaIconsByFilenameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDlnaIconsByFilenameResponses, GetDlnaIconsByFilenameErrors, ThrowOnError>({
        url: '/Dlna/icons/{Filename}',
        ...options
    });
};

/**
 * Deletes a profile
 *
 * Requires authentication as administrator
 */
export const deleteDlnaProfilesById = <ThrowOnError extends boolean = false>(options: Options<DeleteDlnaProfilesByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteDlnaProfilesByIdResponses, DeleteDlnaProfilesByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Dlna/Profiles/{Id}',
        ...options
    });
};

/**
 * Gets a single profile
 *
 * Requires authentication as administrator
 */
export const getDlnaProfilesById = <ThrowOnError extends boolean = false>(options: Options<GetDlnaProfilesByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDlnaProfilesByIdResponses, GetDlnaProfilesByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Dlna/Profiles/{Id}',
        ...options
    });
};

/**
 * Updates a profile
 *
 * Requires authentication as administrator
 */
export const postDlnaProfilesById = <ThrowOnError extends boolean = false>(options: Options<PostDlnaProfilesByIdData, ThrowOnError>) => {
    return (options.client ?? client).post<PostDlnaProfilesByIdResponses, PostDlnaProfilesByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Dlna/Profiles/{Id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets the default profile
 *
 * Requires authentication as administrator
 */
export const getDlnaProfilesDefault = <ThrowOnError extends boolean = false>(options?: Options<GetDlnaProfilesDefaultData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetDlnaProfilesDefaultResponses, GetDlnaProfilesDefaultErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Dlna/Profiles/Default',
        ...options
    });
};

/**
 * Gets details about available video encoders and decoders
 *
 * Requires authentication as administrator
 */
export const getEncodingCodecinformationVideo = <ThrowOnError extends boolean = false>(options?: Options<GetEncodingCodecinformationVideoData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetEncodingCodecinformationVideoResponses, GetEncodingCodecinformationVideoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/CodecInformation/Video',
        ...options
    });
};

/**
 * Gets default codec configurations
 *
 * Requires authentication as administrator
 */
export const getEncodingCodecconfigurationDefaults = <ThrowOnError extends boolean = false>(options?: Options<GetEncodingCodecconfigurationDefaultsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetEncodingCodecconfigurationDefaultsResponses, GetEncodingCodecconfigurationDefaultsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Encoding/CodecConfiguration/Defaults',
        ...options
    });
};

/**
 * Finds games similar to a given game.
 *
 * Requires authentication as user
 */
export const getGamesByIdSimilar = <ThrowOnError extends boolean = false>(options: Options<GetGamesByIdSimilarData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGamesByIdSimilarResponses, GetGamesByIdSimilarErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Games/{Id}/Similar',
        ...options
    });
};

/**
 * Gets external id infos for an item
 *
 * Requires authentication as administrator
 */
export const getItemsByIdExternalidinfos = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdExternalidinfosData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdExternalidinfosResponses, GetItemsByIdExternalidinfosErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/ExternalIdInfos',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const postItemsRemotesearchTrailer = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchTrailerData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchTrailerResponses, PostItemsRemotesearchTrailerErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/Trailer',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const postItemsRemotesearchBook = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchBookData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchBookResponses, PostItemsRemotesearchBookErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/Book',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const postItemsRemotesearchMovie = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchMovieData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchMovieResponses, PostItemsRemotesearchMovieErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/Movie',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const postItemsRemotesearchSeries = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchSeriesData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchSeriesResponses, PostItemsRemotesearchSeriesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/Series',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const postItemsRemotesearchGame = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchGameData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchGameResponses, PostItemsRemotesearchGameErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/Game',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const postItemsRemotesearchBoxset = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchBoxsetData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchBoxsetResponses, PostItemsRemotesearchBoxsetErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/BoxSet',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const postItemsRemotesearchMusicvideo = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchMusicvideoData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchMusicvideoResponses, PostItemsRemotesearchMusicvideoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/MusicVideo',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const postItemsRemotesearchPerson = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchPersonData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchPersonResponses, PostItemsRemotesearchPersonErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/Person',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const postItemsRemotesearchMusicalbum = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchMusicalbumData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchMusicalbumResponses, PostItemsRemotesearchMusicalbumErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/MusicAlbum',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const postItemsRemotesearchMusicartist = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchMusicartistData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchMusicartistResponses, PostItemsRemotesearchMusicartistErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/MusicArtist',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets a remote image
 *
 * Requires authentication as administrator
 */
export const getItemsRemotesearchImage = <ThrowOnError extends boolean = false>(options: Options<GetItemsRemotesearchImageData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsRemotesearchImageResponses, GetItemsRemotesearchImageErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/Image',
        ...options
    });
};

/**
 * Resets metadata for one or more items
 *
 * Requires authentication as administrator
 */
export const postItemsMetadataReset = <ThrowOnError extends boolean = false>(options: Options<PostItemsMetadataResetData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsMetadataResetResponses, PostItemsMetadataResetErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/Metadata/Reset',
        ...options
    });
};

/**
 * Refreshes metadata for an item
 *
 * Requires authentication as user
 */
export const postItemsByIdRefresh = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdRefreshData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdRefreshResponses, PostItemsByIdRefreshErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Refresh',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets metadata editor info for an item
 *
 * Requires authentication as user
 */
export const getItemsByItemidMetadataeditor = <ThrowOnError extends boolean = false>(options: Options<GetItemsByItemidMetadataeditorData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByItemidMetadataeditorResponses, GetItemsByItemidMetadataeditorErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{ItemId}/MetadataEditor',
        ...options
    });
};

/**
 * Makes an item public to all users
 *
 * Requires authentication as user
 */
export const postItemsByIdMakepublic = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdMakepublicData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdMakepublicResponses, PostItemsByIdMakepublicErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/MakePublic',
        ...options
    });
};

/**
 * Makes an item private
 *
 * Requires authentication as user
 */
export const postItemsByIdMakeprivate = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdMakeprivateData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdMakeprivateResponses, PostItemsByIdMakeprivateErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/MakePrivate',
        ...options
    });
};

/**
 * Leaves a shared item
 *
 * Requires authentication as user
 */
export const postItemsSharedLeave = <ThrowOnError extends boolean = false>(options: Options<PostItemsSharedLeaveData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsSharedLeaveResponses, PostItemsSharedLeaveErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/Shared/Leave',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Creates an instant playlist based on a given item
 *
 * Requires authentication as user
 */
export const getItemsByIdInstantmix = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdInstantmixData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdInstantmixResponses, GetItemsByIdInstantmixErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/InstantMix',
        ...options
    });
};

/**
 * Gets delete info for an item
 *
 * Requires authentication as user
 */
export const getItemsByIdDeleteinfo = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdDeleteinfoData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdDeleteinfoResponses, GetItemsByIdDeleteinfoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/DeleteInfo',
        ...options
    });
};

/**
 * Gets similar items
 *
 * Requires authentication as user
 */
export const getItemsByIdSimilar = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdSimilarData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdSimilarResponses, GetItemsByIdSimilarErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Similar',
        ...options
    });
};

/**
 * Downloads item media
 *
 * Requires authentication as user
 */
export const getItemsByIdDownload = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdDownloadData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdDownloadResponses, GetItemsByIdDownloadErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Download',
        ...options
    });
};

/**
 * Gets the original file of an item
 *
 * Requires authentication as user
 */
export const getItemsByIdFile = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdFileData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdFileResponses, GetItemsByIdFileErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/File',
        ...options
    });
};

/**
 * Gets all parents of an item
 *
 * Requires authentication as user
 */
export const getItemsByIdAncestors = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdAncestorsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdAncestorsResponses, GetItemsByIdAncestorsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Ancestors',
        ...options
    });
};

/**
 * Gets critic reviews for an item
 *
 * Requires authentication as user
 */
export const getItemsByIdCriticreviews = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdCriticreviewsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdCriticreviewsResponses, GetItemsByIdCriticreviewsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/CriticReviews',
        ...options
    });
};

/**
 * Deletes an item from the library and file system
 *
 * Requires authentication as user
 */
export const postItemsByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdDeleteResponses, PostItemsByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Delete',
        ...options
    });
};

/**
 * Gets theme videos and songs for an item
 *
 * Requires authentication as user
 */
export const getItemsByIdThememedia = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdThememediaData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdThememediaResponses, GetItemsByIdThememediaErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/ThemeMedia',
        ...options
    });
};

/**
 * Gets theme songs for an item
 *
 * Requires authentication as user
 */
export const getItemsByIdThemesongs = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdThemesongsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdThemesongsResponses, GetItemsByIdThemesongsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/ThemeSongs',
        ...options
    });
};

/**
 * Gets theme videos for an item
 *
 * Requires authentication as user
 */
export const getItemsByIdThemevideos = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdThemevideosData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdThemevideosResponses, GetItemsByIdThemevideosErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/ThemeVideos',
        ...options
    });
};

/**
 * Gets information about an item's images
 *
 * Requires authentication as user
 */
export const getItemsByIdImages = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdImagesData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdImagesResponses, GetItemsByIdImagesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images',
        ...options
    });
};

/**
 * Gets available remote images for an item
 *
 * Requires authentication as user
 */
export const getItemsByIdRemoteimages = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdRemoteimagesData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdRemoteimagesResponses, GetItemsByIdRemoteimagesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/RemoteImages',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getItemsByIdThumbnailset = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdThumbnailsetData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdThumbnailsetResponses, GetItemsByIdThumbnailsetErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/ThumbnailSet',
        ...options
    });
};

/**
 * Gets live playback media info for an item
 *
 * Requires authentication as user
 */
export const getItemsByIdPlaybackinfo = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdPlaybackinfoData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdPlaybackinfoResponses, GetItemsByIdPlaybackinfoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/PlaybackInfo',
        ...options
    });
};

/**
 * Gets live playback media info for an item
 *
 * Requires authentication as user
 */
export const postItemsByIdPlaybackinfo = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdPlaybackinfoData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdPlaybackinfoResponses, PostItemsByIdPlaybackinfoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/PlaybackInfo',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Deprecated. Use /Library/Media/Updated
 *
 * Requires authentication as user
 */
export const postLibrarySeriesAdded = <ThrowOnError extends boolean = false>(options?: Options<PostLibrarySeriesAddedData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostLibrarySeriesAddedResponses, PostLibrarySeriesAddedErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/Series/Added',
        ...options
    });
};

/**
 * Deprecated. Use /Library/Media/Updated
 *
 * Requires authentication as user
 */
export const postLibrarySeriesUpdated = <ThrowOnError extends boolean = false>(options?: Options<PostLibrarySeriesUpdatedData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostLibrarySeriesUpdatedResponses, PostLibrarySeriesUpdatedErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/Series/Updated',
        ...options
    });
};

/**
 * Reports that new movies have been added by an external source
 *
 * Requires authentication as user
 */
export const postLibraryMediaUpdated = <ThrowOnError extends boolean = false>(options: Options<PostLibraryMediaUpdatedData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLibraryMediaUpdatedResponses, PostLibraryMediaUpdatedErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/Media/Updated',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Deprecated. Use /Library/Media/Updated
 *
 * Requires authentication as user
 */
export const postLibraryMoviesAdded = <ThrowOnError extends boolean = false>(options?: Options<PostLibraryMoviesAddedData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostLibraryMoviesAddedResponses, PostLibraryMoviesAddedErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/Movies/Added',
        ...options
    });
};

/**
 * Deprecated. Use /Library/Media/Updated
 *
 * Requires authentication as user
 */
export const postLibraryMoviesUpdated = <ThrowOnError extends boolean = false>(options?: Options<PostLibraryMoviesUpdatedData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostLibraryMoviesUpdatedResponses, PostLibraryMoviesUpdatedErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/Movies/Updated',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getLibraryVirtualfoldersQuery = <ThrowOnError extends boolean = false>(options?: Options<GetLibraryVirtualfoldersQueryData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLibraryVirtualfoldersQueryResponses, GetLibraryVirtualfoldersQueryErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/VirtualFolders/Query',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const postLibraryVirtualfoldersLibraryoptions = <ThrowOnError extends boolean = false>(options: Options<PostLibraryVirtualfoldersLibraryoptionsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLibraryVirtualfoldersLibraryoptionsResponses, PostLibraryVirtualfoldersLibraryoptionsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/VirtualFolders/LibraryOptions',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const postLibraryVirtualfoldersName = <ThrowOnError extends boolean = false>(options: Options<PostLibraryVirtualfoldersNameData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLibraryVirtualfoldersNameResponses, PostLibraryVirtualfoldersNameErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/VirtualFolders/Name',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const postLibraryVirtualfoldersDelete = <ThrowOnError extends boolean = false>(options: Options<PostLibraryVirtualfoldersDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLibraryVirtualfoldersDeleteResponses, PostLibraryVirtualfoldersDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/VirtualFolders/Delete',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const deleteLibraryVirtualfoldersPaths = <ThrowOnError extends boolean = false>(options?: Options<DeleteLibraryVirtualfoldersPathsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteLibraryVirtualfoldersPathsResponses, DeleteLibraryVirtualfoldersPathsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/VirtualFolders/Paths',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const postLibraryVirtualfoldersPaths = <ThrowOnError extends boolean = false>(options: Options<PostLibraryVirtualfoldersPathsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLibraryVirtualfoldersPathsResponses, PostLibraryVirtualfoldersPathsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/VirtualFolders/Paths',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets a live tv program
 *
 * Requires authentication as user
 */
export const getLivetvProgramsById = <ThrowOnError extends boolean = false>(options: Options<GetLivetvProgramsByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvProgramsByIdResponses, GetLivetvProgramsByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Programs/{Id}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getLivetvTunerhostsTypes = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvTunerhostsTypesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvTunerhostsTypesResponses, GetLivetvTunerhostsTypesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/TunerHosts/Types',
        ...options
    });
};

/**
 * Gets the channel management list
 *
 * Requires authentication as administrator
 */
export const getLivetvManageChannels = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvManageChannelsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvManageChannelsResponses, GetLivetvManageChannelsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Manage/Channels',
        ...options
    });
};

/**
 * Gets live tv channel tag prefixes
 *
 * Requires authentication as user
 */
export const getLivetvChanneltagsPrefixes = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvChanneltagsPrefixesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvChanneltagsPrefixesResponses, GetLivetvChanneltagsPrefixesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ChannelTags/Prefixes',
        ...options
    });
};

/**
 * Gets recording folders
 *
 * Requires authentication as user
 */
export const getLivetvRecordingsFolders = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvRecordingsFoldersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvRecordingsFoldersResponses, GetLivetvRecordingsFoldersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Recordings/Folders',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getLivetvTunersDiscvover = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvTunersDiscvoverData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvTunersDiscvoverResponses, GetLivetvTunersDiscvoverErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Tuners/Discvover',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getLivetvTunersDiscover = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvTunersDiscoverData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvTunersDiscoverResponses, GetLivetvTunersDiscoverErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Tuners/Discover',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getLivetvListingprovidersDefault = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvListingprovidersDefaultData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvListingprovidersDefaultResponses, GetLivetvListingprovidersDefaultErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ListingProviders/Default',
        ...options
    });
};

/**
 * Deletes a listing provider
 *
 * Requires authentication as administrator
 */
export const postLivetvListingprovidersDelete = <ThrowOnError extends boolean = false>(options?: Options<PostLivetvListingprovidersDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostLivetvListingprovidersDeleteResponses, PostLivetvListingprovidersDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ListingProviders/Delete',
        ...options
    });
};

/**
 * Deletes a tuner host
 *
 * Requires authentication as administrator
 */
export const postLivetvTunerhostsDelete = <ThrowOnError extends boolean = false>(options?: Options<PostLivetvTunerhostsDeleteData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostLivetvTunerhostsDeleteResponses, PostLivetvTunerhostsDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/TunerHosts/Delete',
        ...options
    });
};

/**
 * Gets available lineups
 *
 * Requires authentication as administrator
 */
export const getLivetvListingprovidersLineups = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvListingprovidersLineupsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvListingprovidersLineupsResponses, GetLivetvListingprovidersLineupsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ListingProviders/Lineups',
        ...options
    });
};

/**
 * Gets a live tv channel
 *
 * Requires authentication as user
 */
export const getLivetvChannelsById = <ThrowOnError extends boolean = false>(options: Options<GetLivetvChannelsByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvChannelsByIdResponses, GetLivetvChannelsByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Channels/{Id}',
        ...options
    });
};

/**
 * Gets available live tv epgs..
 *
 * Requires authentication as user
 */
export const getLivetvProgramsRecommended = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvProgramsRecommendedData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvProgramsRecommendedResponses, GetLivetvProgramsRecommendedErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Programs/Recommended',
        ...options
    });
};

/**
 * Gets live tv recordings
 *
 * Requires authentication as user
 */
export const getLivetvRecordingsSeries = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvRecordingsSeriesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvRecordingsSeriesResponses, GetLivetvRecordingsSeriesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Recordings/Series',
        ...options
    });
};

/**
 * Deletes a live tv recording
 *
 * Requires authentication as user
 */
export const deleteLivetvRecordingsById = <ThrowOnError extends boolean = false>(options: Options<DeleteLivetvRecordingsByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteLivetvRecordingsByIdResponses, DeleteLivetvRecordingsByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Recordings/{Id}',
        ...options
    });
};

/**
 * Gets a live tv recording
 *
 * Requires authentication as user
 */
export const getLivetvRecordingsById = <ThrowOnError extends boolean = false>(options: Options<GetLivetvRecordingsByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvRecordingsByIdResponses, GetLivetvRecordingsByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Recordings/{Id}',
        ...options
    });
};

/**
 * Cancels a live tv timer
 *
 * Requires authentication as user
 */
export const deleteLivetvTimersById = <ThrowOnError extends boolean = false>(options: Options<DeleteLivetvTimersByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteLivetvTimersByIdResponses, DeleteLivetvTimersByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Timers/{Id}',
        ...options
    });
};

/**
 * Gets a live tv timer
 *
 * Requires authentication as user
 */
export const getLivetvTimersById = <ThrowOnError extends boolean = false>(options: Options<GetLivetvTimersByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvTimersByIdResponses, GetLivetvTimersByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Timers/{Id}',
        ...options
    });
};

/**
 * Updates a live tv timer
 *
 * Requires authentication as user
 */
export const postLivetvTimersById = <ThrowOnError extends boolean = false>(options: Options<PostLivetvTimersByIdData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvTimersByIdResponses, PostLivetvTimersByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Timers/{Id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Cancels a live tv series timer
 *
 * Requires authentication as user
 */
export const deleteLivetvSeriestimersById = <ThrowOnError extends boolean = false>(options: Options<DeleteLivetvSeriestimersByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteLivetvSeriestimersByIdResponses, DeleteLivetvSeriestimersByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/SeriesTimers/{Id}',
        ...options
    });
};

/**
 * Gets a live tv series timer
 *
 * Requires authentication as user
 */
export const getLivetvSeriestimersById = <ThrowOnError extends boolean = false>(options: Options<GetLivetvSeriestimersByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvSeriestimersByIdResponses, GetLivetvSeriestimersByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/SeriesTimers/{Id}',
        ...options
    });
};

/**
 * Updates a live tv series timer
 *
 * Requires authentication as user
 */
export const postLivetvSeriestimersById = <ThrowOnError extends boolean = false>(options: Options<PostLivetvSeriestimersByIdData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvSeriestimersByIdResponses, PostLivetvSeriestimersByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/SeriesTimers/{Id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets default values for a new timer
 *
 * Requires authentication as user
 */
export const getLivetvTimersDefaults = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvTimersDefaultsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvTimersDefaultsResponses, GetLivetvTimersDefaultsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Timers/Defaults',
        ...options
    });
};

/**
 * Gets live tv recording groups
 *
 * Requires authentication as user
 */
export const getLivetvRecordingsGroups = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvRecordingsGroupsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvRecordingsGroupsResponses, GetLivetvRecordingsGroupsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Recordings/Groups',
        ...options
    });
};

/**
 * Gets listing provider
 *
 * Requires authentication as administrator
 */
export const getLivetvListingprovidersAvailable = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvListingprovidersAvailableData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvListingprovidersAvailableResponses, GetLivetvListingprovidersAvailableErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ListingProviders/Available',
        ...options
    });
};

/**
 * Finds movies and trailers similar to a given movie.
 *
 * Requires authentication as user
 */
export const getMoviesByIdSimilar = <ThrowOnError extends boolean = false>(options: Options<GetMoviesByIdSimilarData, ThrowOnError>) => {
    return (options.client ?? client).get<GetMoviesByIdSimilarResponses, GetMoviesByIdSimilarErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Movies/{Id}/Similar',
        ...options
    });
};

/**
 * Creates an instant playlist based on a music genre
 *
 * Requires authentication as user
 */
export const getMusicgenresByNameInstantmix = <ThrowOnError extends boolean = false>(options: Options<GetMusicgenresByNameInstantmixData, ThrowOnError>) => {
    return (options.client ?? client).get<GetMusicgenresByNameInstantmixResponses, GetMusicgenresByNameInstantmixErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/MusicGenres/{Name}/InstantMix',
        ...options
    });
};

/**
 * Sends a test notification
 *
 * Requires authentication as user
 */
export const postNotificationsServicesTest = <ThrowOnError extends boolean = false>(options: Options<PostNotificationsServicesTestData, ThrowOnError>) => {
    return (options.client ?? client).post<PostNotificationsServicesTestResponses, PostNotificationsServicesTestErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Notifications/Services/Test',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets default notification info
 *
 * Requires authentication as user
 */
export const getNotificationsServicesDefaults = <ThrowOnError extends boolean = false>(options?: Options<GetNotificationsServicesDefaultsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetNotificationsServicesDefaultsResponses, GetNotificationsServicesDefaultsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Notifications/Services/Defaults',
        ...options
    });
};

/**
 * Installs a package
 *
 * Requires authentication as administrator
 */
export const postPackagesInstalledByName = <ThrowOnError extends boolean = false>(options: Options<PostPackagesInstalledByNameData, ThrowOnError>) => {
    return (options.client ?? client).post<PostPackagesInstalledByNameResponses, PostPackagesInstalledByNameErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Packages/Installed/{Name}',
        ...options
    });
};

/**
 * Cancels a package installation
 *
 * Requires authentication as administrator
 */
export const deletePackagesInstallingById = <ThrowOnError extends boolean = false>(options: Options<DeletePackagesInstallingByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeletePackagesInstallingByIdResponses, DeletePackagesInstallingByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Packages/Installing/{Id}',
        ...options
    });
};

/**
 * Gets add to playlist info
 *
 * Requires authentication as user
 */
export const getPlaylistsByIdAddtoplaylistinfo = <ThrowOnError extends boolean = false>(options: Options<GetPlaylistsByIdAddtoplaylistinfoData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPlaylistsByIdAddtoplaylistinfoResponses, GetPlaylistsByIdAddtoplaylistinfoErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Playlists/{Id}/AddToPlaylistInfo',
        ...options
    });
};

/**
 * Removes items from a playlist
 *
 * Requires authentication as user
 */
export const deletePlaylistsByIdItems = <ThrowOnError extends boolean = false>(options: Options<DeletePlaylistsByIdItemsData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeletePlaylistsByIdItemsResponses, DeletePlaylistsByIdItemsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Playlists/{Id}/Items',
        ...options
    });
};

/**
 * Gets the original items of a playlist
 *
 * Requires authentication as user
 */
export const getPlaylistsByIdItems = <ThrowOnError extends boolean = false>(options: Options<GetPlaylistsByIdItemsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPlaylistsByIdItemsResponses, GetPlaylistsByIdItemsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Playlists/{Id}/Items',
        ...options
    });
};

/**
 * Adds items to a playlist
 *
 * Requires authentication as user
 */
export const postPlaylistsByIdItems = <ThrowOnError extends boolean = false>(options: Options<PostPlaylistsByIdItemsData, ThrowOnError>) => {
    return (options.client ?? client).post<PostPlaylistsByIdItemsResponses, PostPlaylistsByIdItemsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Playlists/{Id}/Items',
        ...options
    });
};

/**
 * Creates an instant playlist based on a given playlist
 *
 * Requires authentication as user
 */
export const getPlaylistsByIdInstantmix = <ThrowOnError extends boolean = false>(options: Options<GetPlaylistsByIdInstantmixData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPlaylistsByIdInstantmixResponses, GetPlaylistsByIdInstantmixErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Playlists/{Id}/InstantMix',
        ...options
    });
};

/**
 * Gets a plugin thumb image
 *
 * Requires authentication as user
 */
export const getPluginsByIdThumb = <ThrowOnError extends boolean = false>(options: Options<GetPluginsByIdThumbData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPluginsByIdThumbResponses, GetPluginsByIdThumbErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Plugins/{Id}/Thumb',
        ...options
    });
};

/**
 * Gets a plugin's configuration
 *
 * Requires authentication as administrator
 */
export const getPluginsByIdConfiguration = <ThrowOnError extends boolean = false>(options: Options<GetPluginsByIdConfigurationData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPluginsByIdConfigurationResponses, GetPluginsByIdConfigurationErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Plugins/{Id}/Configuration',
        ...options
    });
};

/**
 * Updates a plugin's configuration
 *
 * Requires authentication as administrator
 */
export const postPluginsByIdConfiguration = <ThrowOnError extends boolean = false>(options: Options<PostPluginsByIdConfigurationData, ThrowOnError>) => {
    return (options.client ?? client).post<PostPluginsByIdConfigurationResponses, PostPluginsByIdConfigurationErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Plugins/{Id}/Configuration',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Uninstalls a plugin
 *
 * Requires authentication as administrator
 */
export const postPluginsByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostPluginsByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostPluginsByIdDeleteResponses, PostPluginsByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Plugins/{Id}/Delete',
        ...options
    });
};

/**
 * Stops a scheduled task
 *
 * Requires authentication as administrator
 */
export const deleteScheduledtasksRunningById = <ThrowOnError extends boolean = false>(options: Options<DeleteScheduledtasksRunningByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteScheduledtasksRunningByIdResponses, DeleteScheduledtasksRunningByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/ScheduledTasks/Running/{Id}',
        ...options
    });
};

/**
 * Starts a scheduled task
 *
 * Requires authentication as administrator
 */
export const postScheduledtasksRunningById = <ThrowOnError extends boolean = false>(options: Options<PostScheduledtasksRunningByIdData, ThrowOnError>) => {
    return (options.client ?? client).post<PostScheduledtasksRunningByIdResponses, PostScheduledtasksRunningByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/ScheduledTasks/Running/{Id}',
        ...options
    });
};

/**
 * Updates the triggers for a scheduled task
 *
 * Requires authentication as administrator
 */
export const postScheduledtasksByIdTriggers = <ThrowOnError extends boolean = false>(options: Options<PostScheduledtasksByIdTriggersData, ThrowOnError>) => {
    return (options.client ?? client).post<PostScheduledtasksByIdTriggersResponses, PostScheduledtasksByIdTriggersErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/ScheduledTasks/{Id}/Triggers',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Instructs a session to browse to an item or view
 *
 * Requires authentication as user
 */
export const postSessionsByIdViewing = <ThrowOnError extends boolean = false>(options: Options<PostSessionsByIdViewingData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsByIdViewingResponses, PostSessionsByIdViewingErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/{Id}/Viewing',
        ...options
    });
};

/**
 * Issues a command to a client to display a message to the user
 *
 * Requires authentication as user
 */
export const postSessionsByIdMessage = <ThrowOnError extends boolean = false>(options: Options<PostSessionsByIdMessageData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsByIdMessageResponses, PostSessionsByIdMessageErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/{Id}/Message',
        ...options
    });
};

/**
 * Instructs a session to play an item
 *
 * Requires authentication as user
 */
export const postSessionsByIdPlaying = <ThrowOnError extends boolean = false>(options: Options<PostSessionsByIdPlayingData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsByIdPlayingResponses, PostSessionsByIdPlayingErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/{Id}/Playing',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Issues a system command to a client
 *
 * Requires authentication as user
 */
export const postSessionsByIdCommand = <ThrowOnError extends boolean = false>(options: Options<PostSessionsByIdCommandData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsByIdCommandResponses, PostSessionsByIdCommandErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/{Id}/Command',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Updates capabilities for a device
 *
 * Requires authentication as user
 */
export const postSessionsCapabilitiesFull = <ThrowOnError extends boolean = false>(options: Options<PostSessionsCapabilitiesFullData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsCapabilitiesFullResponses, PostSessionsCapabilitiesFullErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/Capabilities/Full',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Reports playback progress within a session
 *
 * Requires authentication as user
 */
export const postSessionsPlayingProgress = <ThrowOnError extends boolean = false>(options: Options<PostSessionsPlayingProgressData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsPlayingProgressResponses, PostSessionsPlayingProgressErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/Playing/Progress',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Pings a playback session
 *
 * Requires authentication as user
 */
export const postSessionsPlayingPing = <ThrowOnError extends boolean = false>(options?: Options<PostSessionsPlayingPingData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostSessionsPlayingPingResponses, PostSessionsPlayingPingErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/Playing/Ping',
        ...options
    });
};

/**
 * Reports playback has stopped within a session
 *
 * Requires authentication as user
 */
export const postSessionsPlayingStopped = <ThrowOnError extends boolean = false>(options: Options<PostSessionsPlayingStoppedData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsPlayingStoppedResponses, PostSessionsPlayingStoppedErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/Playing/Stopped',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets seasons for a tv series
 *
 * Requires authentication as user
 */
export const getShowsByIdSeasons = <ThrowOnError extends boolean = false>(options: Options<GetShowsByIdSeasonsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetShowsByIdSeasonsResponses, GetShowsByIdSeasonsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Shows/{Id}/Seasons',
        ...options
    });
};

/**
 * Gets episodes for a tv season
 *
 * Requires authentication as user
 */
export const getShowsByIdEpisodes = <ThrowOnError extends boolean = false>(options: Options<GetShowsByIdEpisodesData, ThrowOnError>) => {
    return (options.client ?? client).get<GetShowsByIdEpisodesResponses, GetShowsByIdEpisodesErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Shows/{Id}/Episodes',
        ...options
    });
};

/**
 * Finds tv shows similar to a given one.
 *
 * Requires authentication as user
 */
export const getShowsByIdSimilar = <ThrowOnError extends boolean = false>(options: Options<GetShowsByIdSimilarData, ThrowOnError>) => {
    return (options.client ?? client).get<GetShowsByIdSimilarResponses, GetShowsByIdSimilarErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Shows/{Id}/Similar',
        ...options
    });
};

/**
 * Creates an instant playlist based on a given song
 *
 * Requires authentication as user
 */
export const getSongsByIdInstantmix = <ThrowOnError extends boolean = false>(options: Options<GetSongsByIdInstantmixData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSongsByIdInstantmixResponses, GetSongsByIdInstantmixErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Songs/{Id}/InstantMix',
        ...options
    });
};

/**
 * Gets sync status for an item.
 *
 * Requires authentication as user
 */
export const postSyncByItemidStatus = <ThrowOnError extends boolean = false>(options: Options<PostSyncByItemidStatusData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncByItemidStatusResponses, PostSyncByItemidStatusErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/{ItemId}/Status',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Cancels a sync job.
 *
 * Requires authentication as user
 */
export const deleteSyncJobsById = <ThrowOnError extends boolean = false>(options: Options<DeleteSyncJobsByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteSyncJobsByIdResponses, DeleteSyncJobsByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Jobs/{Id}',
        ...options
    });
};

/**
 * Gets a sync job.
 *
 * Requires authentication as user
 */
export const getSyncJobsById = <ThrowOnError extends boolean = false>(options: Options<GetSyncJobsByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSyncJobsByIdResponses, GetSyncJobsByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Jobs/{Id}',
        ...options
    });
};

/**
 * Updates a sync job.
 *
 * Requires authentication as user
 */
export const postSyncJobsById = <ThrowOnError extends boolean = false>(options: Options<PostSyncJobsByIdData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncJobsByIdResponses, PostSyncJobsByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Jobs/{Id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Cancels items from a sync target
 *
 * Requires authentication as user
 */
export const postSyncItemsCancel = <ThrowOnError extends boolean = false>(options?: Options<PostSyncItemsCancelData, ThrowOnError>) => {
    return (options?.client ?? client).post<PostSyncItemsCancelResponses, PostSyncItemsCancelErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Items/Cancel',
        ...options
    });
};

/**
 * Cancels items from a sync target
 *
 * Requires authentication as user
 */
export const deleteSyncByTargetidItems = <ThrowOnError extends boolean = false>(options: Options<DeleteSyncByTargetidItemsData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteSyncByTargetidItemsResponses, DeleteSyncByTargetidItemsErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/{TargetId}/Items',
        ...options
    });
};

/**
 * Gets ready to download sync items.
 *
 * Requires authentication as user
 */
export const getSyncItemsReady = <ThrowOnError extends boolean = false>(options: Options<GetSyncItemsReadyData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSyncItemsReadyResponses, GetSyncItemsReadyErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Items/Ready',
        ...options
    });
};

/**
 * Cancels a sync job item
 *
 * Requires authentication as user
 */
export const deleteSyncJobitemsById = <ThrowOnError extends boolean = false>(options: Options<DeleteSyncJobitemsByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteSyncJobitemsByIdResponses, DeleteSyncJobitemsByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/JobItems/{Id}',
        ...options
    });
};

/**
 * Updates application configuration
 *
 * Requires authentication as administrator
 */
export const postSystemConfigurationPartial = <ThrowOnError extends boolean = false>(options: Options<PostSystemConfigurationPartialData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSystemConfigurationPartialResponses, PostSystemConfigurationPartialErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Configuration/Partial',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets a named configuration
 *
 * Requires authentication as user
 */
export const getSystemConfigurationByKey = <ThrowOnError extends boolean = false>(options: Options<GetSystemConfigurationByKeyData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSystemConfigurationByKeyResponses, GetSystemConfigurationByKeyErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Configuration/{Key}',
        ...options
    });
};

/**
 * Updates named configuration
 *
 * Requires authentication as administrator
 */
export const postSystemConfigurationByKey = <ThrowOnError extends boolean = false>(options: Options<PostSystemConfigurationByKeyData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSystemConfigurationByKeyResponses, PostSystemConfigurationByKeyErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Configuration/{Key}',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets release notes
 *
 * Requires authentication as user
 */
export const getSystemReleasenotesVersions = <ThrowOnError extends boolean = false>(options?: Options<GetSystemReleasenotesVersionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSystemReleasenotesVersionsResponses, GetSystemReleasenotesVersionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/ReleaseNotes/Versions',
        ...options
    });
};

/**
 * Gets a list of available server log files
 *
 * Requires authentication as administrator
 */
export const getSystemLogsQuery = <ThrowOnError extends boolean = false>(options?: Options<GetSystemLogsQueryData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSystemLogsQueryResponses, GetSystemLogsQueryErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Logs/Query',
        ...options
    });
};

/**
 * Gets a log file
 *
 * Requires authentication as administrator
 */
export const getSystemLogsByName = <ThrowOnError extends boolean = false>(options: Options<GetSystemLogsByNameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSystemLogsByNameResponses, GetSystemLogsByNameErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Logs/{Name}',
        ...options
    });
};

/**
 * Gets public information about the server
 *
 * Requires authentication as user
 */
export const getSystemInfoPublic = <ThrowOnError extends boolean = false>(options?: Options<GetSystemInfoPublicData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSystemInfoPublicResponses, GetSystemInfoPublicErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Info/Public',
        ...options
    });
};

/**
 * Gets activity log entries
 *
 * Requires authentication as administrator
 */
export const getSystemActivitylogEntries = <ThrowOnError extends boolean = false>(options?: Options<GetSystemActivitylogEntriesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetSystemActivitylogEntriesResponses, GetSystemActivitylogEntriesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/ActivityLog/Entries',
        ...options
    });
};

/**
 * Finds movies and trailers similar to a given trailer.
 *
 * Requires authentication as user
 */
export const getTrailersByIdSimilar = <ThrowOnError extends boolean = false>(options: Options<GetTrailersByIdSimilarData, ThrowOnError>) => {
    return (options.client ?? client).get<GetTrailersByIdSimilarResponses, GetTrailersByIdSimilarErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Trailers/{Id}/Similar',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getUsersByUseridSuggestions = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridSuggestionsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridSuggestionsResponses, GetUsersByUseridSuggestionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Suggestions',
        ...options
    });
};

/**
 * Deletes a user
 *
 * Requires authentication as administrator
 */
export const postUsersByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdDeleteResponses, PostUsersByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Delete',
        ...options
    });
};

/**
 * Authenticates a user
 *
 * Requires authentication as user
 */
export const postUsersByIdAuthenticate = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdAuthenticateData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdAuthenticateResponses, PostUsersByIdAuthenticateErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Authenticate',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Updates a user's password
 *
 * Requires authentication as user
 */
export const postUsersByIdPassword = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdPasswordData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdPasswordResponses, PostUsersByIdPasswordErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Password',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Redeems a forgot password pin
 *
 * Requires authentication as user
 */
export const postUsersForgotpasswordPin = <ThrowOnError extends boolean = false>(options: Options<PostUsersForgotpasswordPinData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersForgotpasswordPinResponses, PostUsersForgotpasswordPinErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/ForgotPassword/Pin',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Updates a user configuration
 *
 * Requires authentication as user
 */
export const postUsersByIdConfiguration = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdConfigurationData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdConfigurationResponses, PostUsersByIdConfigurationErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Configuration',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Updates a user policy
 *
 * Requires authentication as administrator
 */
export const postUsersByIdPolicy = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdPolicyData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdPolicyResponses, PostUsersByIdPolicyErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Policy',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const getUsersByUseridHomesections = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridHomesectionsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridHomesectionsResponses, GetUsersByUseridHomesectionsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/HomeSections',
        ...options
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getUsersByUseridItems = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridItemsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridItemsResponses, GetUsersByUseridItemsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getUsersByUseridViews = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridViewsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridViewsResponses, GetUsersByUseridViewsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Views',
        ...options
    });
};

/**
 * Updates a user's display preferences for an item
 *
 * Requires authentication as user
 */
export const postUsersettingsByUseridPartial = <ThrowOnError extends boolean = false>(options: Options<PostUsersettingsByUseridPartialData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersettingsByUseridPartialResponses, PostUsersettingsByUseridPartialErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/UserSettings/{UserId}/Partial',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Removes alternate video sources.
 *
 * Requires authentication as administrator
 */
export const deleteVideosByIdAlternatesources = <ThrowOnError extends boolean = false>(options: Options<DeleteVideosByIdAlternatesourcesData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteVideosByIdAlternatesourcesResponses, DeleteVideosByIdAlternatesourcesErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/AlternateSources',
        ...options
    });
};

/**
 * Gets additional parts for a video.
 *
 * Requires authentication as user
 */
export const getVideosByIdAdditionalparts = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdAdditionalpartsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdAdditionalpartsResponses, GetVideosByIdAdditionalpartsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/AdditionalParts',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getVideosByIdIndexBif = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdIndexBifData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdIndexBifResponses, GetVideosByIdIndexBifErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/index.bif',
        ...options
    });
};

/**
 * Gets a video stream
 *
 * Requires authentication as user
 */
export const getVideosByIdStreamByContainer = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdStreamByContainerData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdStreamByContainerResponses, GetVideosByIdStreamByContainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/stream.{Container}',
        ...options
    });
};

/**
 * Gets a video stream
 *
 * Requires authentication as user
 */
export const headVideosByIdStreamByContainer = <ThrowOnError extends boolean = false>(options: Options<HeadVideosByIdStreamByContainerData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadVideosByIdStreamByContainerResponses, HeadVideosByIdStreamByContainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/stream.{Container}',
        ...options
    });
};

/**
 * Gets a video stream
 *
 * Requires authentication as user
 */
export const getVideosByIdStream = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdStreamData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdStreamResponses, GetVideosByIdStreamErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/stream',
        ...options
    });
};

/**
 * Gets a video stream
 *
 * Requires authentication as user
 */
export const headVideosByIdStream = <ThrowOnError extends boolean = false>(options: Options<HeadVideosByIdStreamData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadVideosByIdStreamResponses, HeadVideosByIdStreamErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/stream',
        ...options
    });
};

/**
 * Gets a video stream
 *
 * Requires authentication as user
 */
export const getVideosByIdByStreamfilename = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdByStreamfilenameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdByStreamfilenameResponses, GetVideosByIdByStreamfilenameErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/{StreamFileName}',
        ...options
    });
};

/**
 * Gets a video stream
 *
 * Requires authentication as user
 */
export const headVideosByIdByStreamfilename = <ThrowOnError extends boolean = false>(options: Options<HeadVideosByIdByStreamfilenameData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadVideosByIdByStreamfilenameResponses, HeadVideosByIdByStreamfilenameErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/{StreamFileName}',
        ...options
    });
};

/**
 * Gets a video stream using HTTP live streaming.
 *
 * Requires authentication as user
 */
export const getVideosByIdMasterM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdMasterM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdMasterM3U8Responses, GetVideosByIdMasterM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/master.m3u8',
        ...options
    });
};

/**
 * Gets a video stream using HTTP live streaming.
 *
 * Requires authentication as user
 */
export const headVideosByIdMasterM3U8 = <ThrowOnError extends boolean = false>(options: Options<HeadVideosByIdMasterM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).head<HeadVideosByIdMasterM3U8Responses, HeadVideosByIdMasterM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/master.m3u8',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getVideosByIdLiveM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdLiveM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdLiveM3U8Responses, GetVideosByIdLiveM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/live.m3u8',
        ...options
    });
};

/**
 * Gets a video stream using HTTP live streaming.
 *
 * Requires authentication as user
 */
export const getVideosByIdMainM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdMainM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdMainM3U8Responses, GetVideosByIdMainM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/main.m3u8',
        ...options
    });
};

/**
 * Gets an HLS subtitle playlist.
 *
 * Requires authentication as user
 */
export const getVideosByIdSubtitlesM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdSubtitlesM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdSubtitlesM3U8Responses, GetVideosByIdSubtitlesM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/subtitles.m3u8',
        ...options
    });
};

/**
 * Gets an HLS subtitle playlist.
 *
 * Requires authentication as user
 */
export const getVideosByIdLiveSubtitlesM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdLiveSubtitlesM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdLiveSubtitlesM3U8Responses, GetVideosByIdLiveSubtitlesM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/live_subtitles.m3u8',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const postVideosActiveencodingsDelete = <ThrowOnError extends boolean = false>(options: Options<PostVideosActiveencodingsDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostVideosActiveencodingsDeleteResponses, PostVideosActiveencodingsDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/ActiveEncodings/Delete',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getArtistsByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<GetArtistsByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetArtistsByNameImagesByTypeResponses, GetArtistsByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Artists/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headArtistsByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<HeadArtistsByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadArtistsByNameImagesByTypeResponses, HeadArtistsByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Artists/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const postAuthKeysByKeyDelete = <ThrowOnError extends boolean = false>(options: Options<PostAuthKeysByKeyDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostAuthKeysByKeyDeleteResponses, PostAuthKeysByKeyDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Auth/Keys/{Key}/Delete',
        ...options
    });
};

/**
 * Removes items from a collection
 *
 * Requires authentication as user
 */
export const postCollectionsByIdItemsDelete = <ThrowOnError extends boolean = false>(options: Options<PostCollectionsByIdItemsDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostCollectionsByIdItemsDeleteResponses, PostCollectionsByIdItemsDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Collections/{Id}/Items/Delete',
        ...options
    });
};

/**
 * Gets dlna content directory xml
 *
 * No authentication required
 */
export const getDlnaByUuidContentdirectoryContentdirectoryXml = <ThrowOnError extends boolean = false>(options: Options<GetDlnaByUuidContentdirectoryContentdirectoryXmlData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDlnaByUuidContentdirectoryContentdirectoryXmlResponses, GetDlnaByUuidContentdirectoryContentdirectoryXmlErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/contentdirectory/contentdirectory.xml',
        ...options
    });
};

/**
 * Gets dlna content directory xml
 *
 * No authentication required
 */
export const headDlnaByUuidContentdirectoryContentdirectoryXml = <ThrowOnError extends boolean = false>(options: Options<HeadDlnaByUuidContentdirectoryContentdirectoryXmlData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadDlnaByUuidContentdirectoryContentdirectoryXmlResponses, HeadDlnaByUuidContentdirectoryContentdirectoryXmlErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/contentdirectory/contentdirectory.xml',
        ...options
    });
};

/**
 * Gets dlna content directory xml
 *
 * No authentication required
 */
export const getDlnaByUuidContentdirectoryContentdirectory = <ThrowOnError extends boolean = false>(options: Options<GetDlnaByUuidContentdirectoryContentdirectoryData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDlnaByUuidContentdirectoryContentdirectoryResponses, GetDlnaByUuidContentdirectoryContentdirectoryErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/contentdirectory/contentdirectory',
        ...options
    });
};

/**
 * Gets dlna content directory xml
 *
 * No authentication required
 */
export const headDlnaByUuidContentdirectoryContentdirectory = <ThrowOnError extends boolean = false>(options: Options<HeadDlnaByUuidContentdirectoryContentdirectoryData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadDlnaByUuidContentdirectoryContentdirectoryResponses, HeadDlnaByUuidContentdirectoryContentdirectoryErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/contentdirectory/contentdirectory',
        ...options
    });
};

/**
 * Gets dlna connection manager xml
 *
 * No authentication required
 */
export const getDlnaByUuidConnectionmanagerConnectionmanagerXml = <ThrowOnError extends boolean = false>(options: Options<GetDlnaByUuidConnectionmanagerConnectionmanagerXmlData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDlnaByUuidConnectionmanagerConnectionmanagerXmlResponses, GetDlnaByUuidConnectionmanagerConnectionmanagerXmlErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/connectionmanager/connectionmanager.xml',
        ...options
    });
};

/**
 * Gets dlna connection manager xml
 *
 * No authentication required
 */
export const headDlnaByUuidConnectionmanagerConnectionmanagerXml = <ThrowOnError extends boolean = false>(options: Options<HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlResponses, HeadDlnaByUuidConnectionmanagerConnectionmanagerXmlErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/connectionmanager/connectionmanager.xml',
        ...options
    });
};

/**
 * Gets dlna connection manager xml
 *
 * No authentication required
 */
export const getDlnaByUuidConnectionmanagerConnectionmanager = <ThrowOnError extends boolean = false>(options: Options<GetDlnaByUuidConnectionmanagerConnectionmanagerData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDlnaByUuidConnectionmanagerConnectionmanagerResponses, GetDlnaByUuidConnectionmanagerConnectionmanagerErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/connectionmanager/connectionmanager',
        ...options
    });
};

/**
 * Gets dlna connection manager xml
 *
 * No authentication required
 */
export const headDlnaByUuidConnectionmanagerConnectionmanager = <ThrowOnError extends boolean = false>(options: Options<HeadDlnaByUuidConnectionmanagerConnectionmanagerData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadDlnaByUuidConnectionmanagerConnectionmanagerResponses, HeadDlnaByUuidConnectionmanagerConnectionmanagerErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/connectionmanager/connectionmanager',
        ...options
    });
};

/**
 * Processes a control request
 *
 * No authentication required
 */
export const postDlnaByUuidContentdirectoryControl = <ThrowOnError extends boolean = false>(options: Options<PostDlnaByUuidContentdirectoryControlData, ThrowOnError>) => {
    return (options.client ?? client).post<PostDlnaByUuidContentdirectoryControlResponses, PostDlnaByUuidContentdirectoryControlErrors, ThrowOnError>({
        bodySerializer: null,
        url: '/Dlna/{UuId}/contentdirectory/control',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Processes a control request
 *
 * No authentication required
 */
export const postDlnaByUuidConnectionmanagerControl = <ThrowOnError extends boolean = false>(options: Options<PostDlnaByUuidConnectionmanagerControlData, ThrowOnError>) => {
    return (options.client ?? client).post<PostDlnaByUuidConnectionmanagerControlResponses, PostDlnaByUuidConnectionmanagerControlErrors, ThrowOnError>({
        bodySerializer: null,
        url: '/Dlna/{UuId}/connectionmanager/control',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets a server icon
 *
 * No authentication required
 */
export const getDlnaByUuidIconsByFilename = <ThrowOnError extends boolean = false>(options: Options<GetDlnaByUuidIconsByFilenameData, ThrowOnError>) => {
    return (options.client ?? client).get<GetDlnaByUuidIconsByFilenameResponses, GetDlnaByUuidIconsByFilenameErrors, ThrowOnError>({
        url: '/Dlna/{UuId}/icons/{Filename}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getGamegenresByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<GetGamegenresByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGamegenresByNameImagesByTypeResponses, GetGamegenresByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/GameGenres/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headGamegenresByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<HeadGamegenresByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadGamegenresByNameImagesByTypeResponses, HeadGamegenresByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/GameGenres/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getGenresByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<GetGenresByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGenresByNameImagesByTypeResponses, GetGenresByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Genres/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headGenresByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<HeadGenresByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadGenresByNameImagesByTypeResponses, HeadGenresByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Genres/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Applies search criteria to an item and refreshes metadata
 *
 * Requires authentication as administrator
 */
export const postItemsRemotesearchApplyById = <ThrowOnError extends boolean = false>(options: Options<PostItemsRemotesearchApplyByIdData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsRemotesearchApplyByIdResponses, PostItemsRemotesearchApplyByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/RemoteSearch/Apply/{Id}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Adds new tags to an item
 *
 * Requires authentication as user
 */
export const postItemsByIdTagsAdd = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdTagsAddData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdTagsAddResponses, PostItemsByIdTagsAddErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Tags/Add',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Removes tags from an item
 *
 * Requires authentication as user
 */
export const postItemsByIdTagsDelete = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdTagsDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdTagsDeleteResponses, PostItemsByIdTagsDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Tags/Delete',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Deletes an external subtitle file
 *
 * Requires authentication as user
 */
export const deleteItemsByIdSubtitlesByIndex = <ThrowOnError extends boolean = false>(options: Options<DeleteItemsByIdSubtitlesByIndexData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteItemsByIdSubtitlesByIndexResponses, DeleteItemsByIdSubtitlesByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Subtitles/{Index}',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const deleteItemsByIdImagesByType = <ThrowOnError extends boolean = false>(options: Options<DeleteItemsByIdImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteItemsByIdImagesByTypeResponses, DeleteItemsByIdImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getItemsByIdImagesByType = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdImagesByTypeResponses, GetItemsByIdImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headItemsByIdImagesByType = <ThrowOnError extends boolean = false>(options: Options<HeadItemsByIdImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadItemsByIdImagesByTypeResponses, HeadItemsByIdImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}',
        ...options
    });
};

/**
 * Uploads an image for an item, must be base64 encoded.
 *
 * Requires authentication as administrator
 */
export const postItemsByIdImagesByType = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdImagesByTypeResponses, PostItemsByIdImagesByTypeErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets available remote image providers for an item
 *
 * Requires authentication as user
 */
export const getItemsByIdRemoteimagesProviders = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdRemoteimagesProvidersData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdRemoteimagesProvidersResponses, GetItemsByIdRemoteimagesProvidersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/RemoteImages/Providers',
        ...options
    });
};

/**
 * Downloads a remote image for an item
 *
 * Requires authentication as administrator
 */
export const postItemsByIdRemoteimagesDownload = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdRemoteimagesDownloadData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdRemoteimagesDownloadResponses, PostItemsByIdRemoteimagesDownloadErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/RemoteImages/Download',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const postLibraryVirtualfoldersPathsUpdate = <ThrowOnError extends boolean = false>(options: Options<PostLibraryVirtualfoldersPathsUpdateData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLibraryVirtualfoldersPathsUpdateResponses, PostLibraryVirtualfoldersPathsUpdateErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/VirtualFolders/Paths/Update',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const postLibraryVirtualfoldersPathsDelete = <ThrowOnError extends boolean = false>(options: Options<PostLibraryVirtualfoldersPathsDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLibraryVirtualfoldersPathsDeleteResponses, PostLibraryVirtualfoldersPathsDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Library/VirtualFolders/Paths/Delete',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Gets a live tv channel
 *
 * Requires authentication as user
 */
export const getLivetvLivestreamfilesByIdStreamByContainer = <ThrowOnError extends boolean = false>(options: Options<GetLivetvLivestreamfilesByIdStreamByContainerData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvLivestreamfilesByIdStreamByContainerResponses, GetLivetvLivestreamfilesByIdStreamByContainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveStreamFiles/{Id}/stream.{Container}',
        ...options
    });
};

/**
 * Gets a live tv channel
 *
 * Requires authentication as user
 */
export const getLivetvLiverecordingsByIdStream = <ThrowOnError extends boolean = false>(options: Options<GetLivetvLiverecordingsByIdStreamData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvLiverecordingsByIdStreamResponses, GetLivetvLiverecordingsByIdStreamErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveRecordings/{Id}/stream',
        ...options
    });
};

/**
 * Gets available lineups
 *
 * Requires authentication as administrator
 */
export const getLivetvListingprovidersSchedulesdirectCountries = <ThrowOnError extends boolean = false>(options?: Options<GetLivetvListingprovidersSchedulesdirectCountriesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLivetvListingprovidersSchedulesdirectCountriesResponses, GetLivetvListingprovidersSchedulesdirectCountriesErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/ListingProviders/SchedulesDirect/Countries',
        ...options
    });
};

/**
 * Gets tuner hosts
 *
 * Requires authentication as administrator
 */
export const getLivetvTunerhostsDefaultByType = <ThrowOnError extends boolean = false>(options: Options<GetLivetvTunerhostsDefaultByTypeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvTunerhostsDefaultByTypeResponses, GetLivetvTunerhostsDefaultByTypeErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/TunerHosts/Default/{Type}',
        ...options
    });
};

/**
 * Deletes a live tv recording
 *
 * Requires authentication as user
 */
export const postLivetvRecordingsByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostLivetvRecordingsByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvRecordingsByIdDeleteResponses, PostLivetvRecordingsByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Recordings/{Id}/Delete',
        ...options
    });
};

/**
 * Cancels a live tv timer
 *
 * Requires authentication as user
 */
export const postLivetvTimersByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostLivetvTimersByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvTimersByIdDeleteResponses, PostLivetvTimersByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Timers/{Id}/Delete',
        ...options
    });
};

/**
 * Cancels a live tv series timer
 *
 * Requires authentication as user
 */
export const postLivetvSeriestimersByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostLivetvSeriestimersByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvSeriestimersByIdDeleteResponses, PostLivetvSeriestimersByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/SeriesTimers/{Id}/Delete',
        ...options
    });
};

/**
 * Resets a tv tuner
 *
 * Requires authentication as administrator
 */
export const postLivetvTunersByIdReset = <ThrowOnError extends boolean = false>(options: Options<PostLivetvTunersByIdResetData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvTunersByIdResetResponses, PostLivetvTunersByIdResetErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Tuners/{Id}/Reset',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getMusicgenresByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<GetMusicgenresByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetMusicgenresByNameImagesByTypeResponses, GetMusicgenresByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/MusicGenres/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headMusicgenresByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<HeadMusicgenresByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadMusicgenresByNameImagesByTypeResponses, HeadMusicgenresByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/MusicGenres/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Cancels a package installation
 *
 * Requires authentication as administrator
 */
export const postPackagesInstallingByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostPackagesInstallingByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostPackagesInstallingByIdDeleteResponses, PostPackagesInstallingByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Packages/Installing/{Id}/Delete',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getPersonsByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<GetPersonsByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPersonsByNameImagesByTypeResponses, GetPersonsByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Persons/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headPersonsByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<HeadPersonsByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadPersonsByNameImagesByTypeResponses, HeadPersonsByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Persons/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Removes items from a playlist
 *
 * Requires authentication as user
 */
export const postPlaylistsByIdItemsDelete = <ThrowOnError extends boolean = false>(options: Options<PostPlaylistsByIdItemsDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostPlaylistsByIdItemsDeleteResponses, PostPlaylistsByIdItemsDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Playlists/{Id}/Items/Delete',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getProvidersSubtitlesSubtitlesById = <ThrowOnError extends boolean = false>(options: Options<GetProvidersSubtitlesSubtitlesByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetProvidersSubtitlesSubtitlesByIdResponses, GetProvidersSubtitlesSubtitlesByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Providers/Subtitles/Subtitles/{Id}',
        ...options
    });
};

/**
 * Stops a scheduled task
 *
 * Requires authentication as administrator
 */
export const postScheduledtasksRunningByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostScheduledtasksRunningByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostScheduledtasksRunningByIdDeleteResponses, PostScheduledtasksRunningByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/ScheduledTasks/Running/{Id}/Delete',
        ...options
    });
};

/**
 * Issues a playstate command to a client
 *
 * Requires authentication as user
 */
export const postSessionsByIdPlayingByCommand = <ThrowOnError extends boolean = false>(options: Options<PostSessionsByIdPlayingByCommandData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsByIdPlayingByCommandResponses, PostSessionsByIdPlayingByCommandErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/{Id}/Playing/{Command}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Issues a system command to a client
 *
 * Requires authentication as user
 */
export const postSessionsByIdSystemByCommand = <ThrowOnError extends boolean = false>(options: Options<PostSessionsByIdSystemByCommandData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsByIdSystemByCommandResponses, PostSessionsByIdSystemByCommandErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/{Id}/System/{Command}',
        ...options
    });
};

/**
 * Issues a system command to a client
 *
 * Requires authentication as user
 */
export const postSessionsByIdCommandByCommand = <ThrowOnError extends boolean = false>(options: Options<PostSessionsByIdCommandByCommandData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsByIdCommandByCommandResponses, PostSessionsByIdCommandByCommandErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/{Id}/Command/{Command}',
        ...options
    });
};

/**
 * Removes an additional user from a session
 *
 * Requires authentication as user
 */
export const deleteSessionsByIdUsersByUserid = <ThrowOnError extends boolean = false>(options: Options<DeleteSessionsByIdUsersByUseridData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteSessionsByIdUsersByUseridResponses, DeleteSessionsByIdUsersByUseridErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/{Id}/Users/{UserId}',
        ...options
    });
};

/**
 * Adds an additional user to a session
 *
 * Requires authentication as user
 */
export const postSessionsByIdUsersByUserid = <ThrowOnError extends boolean = false>(options: Options<PostSessionsByIdUsersByUseridData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsByIdUsersByUseridResponses, PostSessionsByIdUsersByUseridErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/{Id}/Users/{UserId}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getStudiosByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<GetStudiosByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetStudiosByNameImagesByTypeResponses, GetStudiosByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Studios/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headStudiosByNameImagesByType = <ThrowOnError extends boolean = false>(options: Options<HeadStudiosByNameImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadStudiosByNameImagesByTypeResponses, HeadStudiosByNameImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Studios/{Name}/Images/{Type}',
        ...options
    });
};

/**
 * Cancels a sync job.
 *
 * Requires authentication as user
 */
export const postSyncJobsByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostSyncJobsByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncJobsByIdDeleteResponses, PostSyncJobsByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/Jobs/{Id}/Delete',
        ...options
    });
};

/**
 * Cancels items from a sync target
 *
 * Requires authentication as user
 */
export const postSyncByTargetidItemsDelete = <ThrowOnError extends boolean = false>(options: Options<PostSyncByTargetidItemsDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncByTargetidItemsDeleteResponses, PostSyncByTargetidItemsDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/{TargetId}/Items/Delete',
        ...options
    });
};

/**
 * Reports that a sync job item has successfully been transferred.
 *
 * Requires authentication as user
 */
export const postSyncJobitemsByIdTransferred = <ThrowOnError extends boolean = false>(options: Options<PostSyncJobitemsByIdTransferredData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncJobitemsByIdTransferredResponses, PostSyncJobitemsByIdTransferredErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/JobItems/{Id}/Transferred',
        ...options
    });
};

/**
 * Gets a sync job item file
 *
 * Requires authentication as user
 */
export const getSyncJobitemsByIdFile = <ThrowOnError extends boolean = false>(options: Options<GetSyncJobitemsByIdFileData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSyncJobitemsByIdFileResponses, GetSyncJobitemsByIdFileErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/JobItems/{Id}/File',
        ...options
    });
};

/**
 * Gets a sync job item file
 *
 * Requires authentication as user
 */
export const headSyncJobitemsByIdFile = <ThrowOnError extends boolean = false>(options: Options<HeadSyncJobitemsByIdFileData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadSyncJobitemsByIdFileResponses, HeadSyncJobitemsByIdFileErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/JobItems/{Id}/File',
        ...options
    });
};

/**
 * Gets a sync job item file
 *
 * Requires authentication as user
 */
export const getSyncJobitemsByIdAdditionalfiles = <ThrowOnError extends boolean = false>(options: Options<GetSyncJobitemsByIdAdditionalfilesData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSyncJobitemsByIdAdditionalfilesResponses, GetSyncJobitemsByIdAdditionalfilesErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/JobItems/{Id}/AdditionalFiles',
        ...options
    });
};

/**
 * Enables a cancelled or queued sync job item
 *
 * Requires authentication as user
 */
export const postSyncJobitemsByIdEnable = <ThrowOnError extends boolean = false>(options: Options<PostSyncJobitemsByIdEnableData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncJobitemsByIdEnableResponses, PostSyncJobitemsByIdEnableErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/JobItems/{Id}/Enable',
        ...options
    });
};

/**
 * Cancels a sync job item
 *
 * Requires authentication as user
 */
export const postSyncJobitemsByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostSyncJobitemsByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncJobitemsByIdDeleteResponses, PostSyncJobitemsByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/JobItems/{Id}/Delete',
        ...options
    });
};

/**
 * Marks a job item for removal
 *
 * Requires authentication as user
 */
export const postSyncJobitemsByIdMarkforremoval = <ThrowOnError extends boolean = false>(options: Options<PostSyncJobitemsByIdMarkforremovalData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncJobitemsByIdMarkforremovalResponses, PostSyncJobitemsByIdMarkforremovalErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/JobItems/{Id}/MarkForRemoval',
        ...options
    });
};

/**
 * Unmarks a job item for removal
 *
 * Requires authentication as user
 */
export const postSyncJobitemsByIdUnmarkforremoval = <ThrowOnError extends boolean = false>(options: Options<PostSyncJobitemsByIdUnmarkforremovalData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSyncJobitemsByIdUnmarkforremovalResponses, PostSyncJobitemsByIdUnmarkforremovalErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sync/JobItems/{Id}/UnmarkForRemoval',
        ...options
    });
};

/**
 * Gets a log file
 *
 * Requires authentication as administrator
 */
export const getSystemLogsByNameLines = <ThrowOnError extends boolean = false>(options: Options<GetSystemLogsByNameLinesData, ThrowOnError>) => {
    return (options.client ?? client).get<GetSystemLogsByNameLinesResponses, GetSystemLogsByNameLinesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/System/Logs/{Name}/Lines',
        ...options
    });
};

/**
 * Clears audio or subtitle track selections for a user
 *
 * Requires authentication as user
 */
export const deleteUsersByIdTrackselectionsByTracktype = <ThrowOnError extends boolean = false>(options: Options<DeleteUsersByIdTrackselectionsByTracktypeData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUsersByIdTrackselectionsByTracktypeResponses, DeleteUsersByIdTrackselectionsByTracktypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/TrackSelections/{TrackType}',
        ...options
    });
};

/**
 * Updates a user configuration
 *
 * Requires authentication as user
 */
export const postUsersByIdConfigurationPartial = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdConfigurationPartialData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdConfigurationPartialResponses, PostUsersByIdConfigurationPartialErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Configuration/Partial',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets a typed user setting
 *
 * Requires authentication as user
 */
export const getUsersByUseridTypedsettingsByKey = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridTypedsettingsByKeyData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridTypedsettingsByKeyResponses, GetUsersByUseridTypedsettingsByKeyErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/TypedSettings/{Key}',
        ...options
    });
};

/**
 * Updates a typed user setting
 *
 * Requires authentication as user
 */
export const postUsersByUseridTypedsettingsByKey = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridTypedsettingsByKeyData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridTypedsettingsByKeyResponses, PostUsersByUseridTypedsettingsByKeyErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/TypedSettings/{Key}',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Gets items based on a query.
 *
 * Requires authentication as user
 */
export const getUsersByUseridItemsResume = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridItemsResumeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridItemsResumeResponses, GetUsersByUseridItemsResumeErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/Resume',
        ...options
    });
};

/**
 * Gets latest media
 *
 * Requires authentication as user
 */
export const getUsersByUseridItemsLatest = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridItemsLatestData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridItemsLatestResponses, GetUsersByUseridItemsLatestErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/Latest',
        ...options
    });
};

/**
 * Gets an item from a user's library
 *
 * Requires authentication as user
 */
export const getUsersByUseridItemsById = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridItemsByIdData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridItemsByIdResponses, GetUsersByUseridItemsByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/{Id}',
        ...options
    });
};

/**
 * Gets the root folder from a user's library
 *
 * Requires authentication as user
 */
export const getUsersByUseridItemsRoot = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridItemsRootData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridItemsRootResponses, GetUsersByUseridItemsRootErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/Root',
        ...options
    });
};

/**
 * Unmarks an item as a favorite
 *
 * Requires authentication as user
 */
export const deleteUsersByUseridFavoriteitemsById = <ThrowOnError extends boolean = false>(options: Options<DeleteUsersByUseridFavoriteitemsByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUsersByUseridFavoriteitemsByIdResponses, DeleteUsersByUseridFavoriteitemsByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/FavoriteItems/{Id}',
        ...options
    });
};

/**
 * Marks an item as a favorite
 *
 * Requires authentication as user
 */
export const postUsersByUseridFavoriteitemsById = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridFavoriteitemsByIdData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridFavoriteitemsByIdResponses, PostUsersByUseridFavoriteitemsByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/FavoriteItems/{Id}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const deleteUsersByIdImagesByType = <ThrowOnError extends boolean = false>(options: Options<DeleteUsersByIdImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUsersByIdImagesByTypeResponses, DeleteUsersByIdImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getUsersByIdImagesByType = <ThrowOnError extends boolean = false>(options: Options<GetUsersByIdImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByIdImagesByTypeResponses, GetUsersByIdImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Images/{Type}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headUsersByIdImagesByType = <ThrowOnError extends boolean = false>(options: Options<HeadUsersByIdImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadUsersByIdImagesByTypeResponses, HeadUsersByIdImagesByTypeErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Images/{Type}',
        ...options
    });
};

/**
 * Uploads an image for an item, must be base64 encoded.
 *
 * Requires authentication as user
 */
export const postUsersByIdImagesByType = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdImagesByTypeData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdImagesByTypeResponses, PostUsersByIdImagesByTypeErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Images/{Type}',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Marks an item as unplayed
 *
 * Requires authentication as user
 */
export const deleteUsersByUseridPlayeditemsById = <ThrowOnError extends boolean = false>(options: Options<DeleteUsersByUseridPlayeditemsByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUsersByUseridPlayeditemsByIdResponses, DeleteUsersByUseridPlayeditemsByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/PlayedItems/{Id}',
        ...options
    });
};

/**
 * Marks an item as played
 *
 * Requires authentication as user
 */
export const postUsersByUseridPlayeditemsById = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridPlayeditemsByIdData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridPlayeditemsByIdResponses, PostUsersByUseridPlayeditemsByIdErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/PlayedItems/{Id}',
        ...options
    });
};

/**
 * Reports that a user has stopped playing an item
 *
 * Requires authentication as user
 */
export const deleteUsersByUseridPlayingitemsById = <ThrowOnError extends boolean = false>(options: Options<DeleteUsersByUseridPlayingitemsByIdData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUsersByUseridPlayingitemsByIdResponses, DeleteUsersByUseridPlayingitemsByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/PlayingItems/{Id}',
        ...options
    });
};

/**
 * Reports that a user has begun playing an item
 *
 * Requires authentication as user
 */
export const postUsersByUseridPlayingitemsById = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridPlayingitemsByIdData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridPlayingitemsByIdResponses, PostUsersByUseridPlayingitemsByIdErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/PlayingItems/{Id}',
        ...options
    });
};

/**
 * Removes a Connect link for a user
 *
 * Requires authentication as administrator
 */
export const deleteUsersByIdConnectLink = <ThrowOnError extends boolean = false>(options: Options<DeleteUsersByIdConnectLinkData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUsersByIdConnectLinkResponses, DeleteUsersByIdConnectLinkErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Connect/Link',
        ...options
    });
};

/**
 * Creates a Connect link for a user
 *
 * Requires authentication as administrator
 */
export const postUsersByIdConnectLink = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdConnectLinkData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdConnectLinkResponses, PostUsersByIdConnectLinkErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Connect/Link',
        ...options
    });
};

/**
 * Removes alternate video sources.
 *
 * Requires authentication as administrator
 */
export const postVideosByIdAlternatesourcesDelete = <ThrowOnError extends boolean = false>(options: Options<PostVideosByIdAlternatesourcesDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostVideosByIdAlternatesourcesDeleteResponses, PostVideosByIdAlternatesourcesDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/AlternateSources/Delete',
        ...options
    });
};

/**
 * Deletes an external subtitle file
 *
 * Requires authentication as user
 */
export const deleteVideosByIdSubtitlesByIndex = <ThrowOnError extends boolean = false>(options: Options<DeleteVideosByIdSubtitlesByIndexData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteVideosByIdSubtitlesByIndexResponses, DeleteVideosByIdSubtitlesByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/Subtitles/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getArtistsByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<GetArtistsByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).get<GetArtistsByNameImagesByTypeByIndexResponses, GetArtistsByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Artists/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headArtistsByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<HeadArtistsByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadArtistsByNameImagesByTypeByIndexResponses, HeadArtistsByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Artists/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer = <ThrowOnError extends boolean = false>(options: Options<GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses, GetAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainer = <ThrowOnError extends boolean = false>(options: Options<HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses, HeadAudioByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainer = <ThrowOnError extends boolean = false>(options: Options<GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerData, ThrowOnError>) => {
    return (options.client ?? client).get<GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponses, GetAudioByIdHlsByPlaylistidBySegmentidBySegmentcontainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Audio/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getGamegenresByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<GetGamegenresByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGamegenresByNameImagesByTypeByIndexResponses, GetGamegenresByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/GameGenres/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headGamegenresByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<HeadGamegenresByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadGamegenresByNameImagesByTypeByIndexResponses, HeadGamegenresByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/GameGenres/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getGenresByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<GetGenresByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).get<GetGenresByNameImagesByTypeByIndexResponses, GetGenresByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Genres/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headGenresByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<HeadGenresByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadGenresByNameImagesByTypeByIndexResponses, HeadGenresByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Genres/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getItemsByIdRemotesearchSubtitlesByLanguage = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdRemotesearchSubtitlesByLanguageData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdRemotesearchSubtitlesByLanguageResponses, GetItemsByIdRemotesearchSubtitlesByLanguageErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/RemoteSearch/Subtitles/{Language}',
        ...options
    });
};

/**
 * Deletes an external subtitle file
 *
 * Requires authentication as user
 */
export const postItemsByIdSubtitlesByIndexDelete = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdSubtitlesByIndexDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdSubtitlesByIndexDeleteResponses, PostItemsByIdSubtitlesByIndexDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Subtitles/{Index}/Delete',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const postItemsByIdRemotesearchSubtitlesBySubtitleid = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdRemotesearchSubtitlesBySubtitleidData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdRemotesearchSubtitlesBySubtitleidResponses, PostItemsByIdRemotesearchSubtitlesBySubtitleidErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/RemoteSearch/Subtitles/{SubtitleId}',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const deleteItemsByIdImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<DeleteItemsByIdImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteItemsByIdImagesByTypeByIndexResponses, DeleteItemsByIdImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getItemsByIdImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdImagesByTypeByIndexResponses, GetItemsByIdImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headItemsByIdImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<HeadItemsByIdImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadItemsByIdImagesByTypeByIndexResponses, HeadItemsByIdImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Uploads an image for an item, must be base64 encoded.
 *
 * Requires authentication as administrator
 */
export const postItemsByIdImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdImagesByTypeByIndexResponses, PostItemsByIdImagesByTypeByIndexErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}/{Index}',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as administrator
 */
export const postItemsByIdImagesByTypeDelete = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdImagesByTypeDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdImagesByTypeDeleteResponses, PostItemsByIdImagesByTypeDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}/Delete',
        ...options
    });
};

/**
 * Gets a live tv channel
 *
 * Requires authentication as user
 */
export const getLivetvLivestreamfilesByIdHlsMasterM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetLivetvLivestreamfilesByIdHlsMasterM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvLivestreamfilesByIdHlsMasterM3U8Responses, GetLivetvLivestreamfilesByIdHlsMasterM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveStreamFiles/{Id}/hls/master.m3u8',
        ...options
    });
};

/**
 * Gets a live tv channel
 *
 * Requires authentication as user
 */
export const headLivetvLivestreamfilesByIdHlsMasterM3U8 = <ThrowOnError extends boolean = false>(options: Options<HeadLivetvLivestreamfilesByIdHlsMasterM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).head<HeadLivetvLivestreamfilesByIdHlsMasterM3U8Responses, HeadLivetvLivestreamfilesByIdHlsMasterM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveStreamFiles/{Id}/hls/master.m3u8',
        ...options
    });
};

/**
 * Gets a live recording
 *
 * Requires authentication as user
 */
export const getLivetvLiverecordingsByIdHlsMasterM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetLivetvLiverecordingsByIdHlsMasterM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvLiverecordingsByIdHlsMasterM3U8Responses, GetLivetvLiverecordingsByIdHlsMasterM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveRecordings/{Id}/hls/master.m3u8',
        ...options
    });
};

/**
 * Gets a live recording
 *
 * Requires authentication as user
 */
export const headLivetvLiverecordingsByIdHlsMasterM3U8 = <ThrowOnError extends boolean = false>(options: Options<HeadLivetvLiverecordingsByIdHlsMasterM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).head<HeadLivetvLiverecordingsByIdHlsMasterM3U8Responses, HeadLivetvLiverecordingsByIdHlsMasterM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveRecordings/{Id}/hls/master.m3u8',
        ...options
    });
};

/**
 * Gets a live recording
 *
 * Requires authentication as user
 */
export const getLivetvLiverecordingsByIdHlsLiveM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetLivetvLiverecordingsByIdHlsLiveM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvLiverecordingsByIdHlsLiveM3U8Responses, GetLivetvLiverecordingsByIdHlsLiveM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveRecordings/{Id}/hls/live.m3u8',
        ...options
    });
};

/**
 * Gets a live recording
 *
 * Requires authentication as user
 */
export const headLivetvLiverecordingsByIdHlsLiveM3U8 = <ThrowOnError extends boolean = false>(options: Options<HeadLivetvLiverecordingsByIdHlsLiveM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).head<HeadLivetvLiverecordingsByIdHlsLiveM3U8Responses, HeadLivetvLiverecordingsByIdHlsLiveM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveRecordings/{Id}/hls/live.m3u8',
        ...options
    });
};

/**
 * Gets a live tv channel
 *
 * Requires authentication as user
 */
export const getLivetvLivestreamfilesByIdHlsLiveM3U8 = <ThrowOnError extends boolean = false>(options: Options<GetLivetvLivestreamfilesByIdHlsLiveM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvLivestreamfilesByIdHlsLiveM3U8Responses, GetLivetvLivestreamfilesByIdHlsLiveM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveStreamFiles/{Id}/hls/live.m3u8',
        ...options
    });
};

/**
 * Gets a live tv channel
 *
 * Requires authentication as user
 */
export const headLivetvLivestreamfilesByIdHlsLiveM3U8 = <ThrowOnError extends boolean = false>(options: Options<HeadLivetvLivestreamfilesByIdHlsLiveM3U8Data, ThrowOnError>) => {
    return (options.client ?? client).head<HeadLivetvLivestreamfilesByIdHlsLiveM3U8Responses, HeadLivetvLivestreamfilesByIdHlsLiveM3U8Errors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveStreamFiles/{Id}/hls/live.m3u8',
        ...options
    });
};

/**
 * Gets a live tv channel
 *
 * Requires authentication as user
 */
export const getLivetvLivestreamfilesByIdHlsBySegment = <ThrowOnError extends boolean = false>(options: Options<GetLivetvLivestreamfilesByIdHlsBySegmentData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvLivestreamfilesByIdHlsBySegmentResponses, GetLivetvLivestreamfilesByIdHlsBySegmentErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveStreamFiles/{Id}/hls/{Segment}',
        ...options
    });
};

/**
 * Gets a live tv channel
 *
 * Requires authentication as user
 */
export const headLivetvLivestreamfilesByIdHlsBySegment = <ThrowOnError extends boolean = false>(options: Options<HeadLivetvLivestreamfilesByIdHlsBySegmentData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadLivetvLivestreamfilesByIdHlsBySegmentResponses, HeadLivetvLivestreamfilesByIdHlsBySegmentErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveStreamFiles/{Id}/hls/{Segment}',
        ...options
    });
};

/**
 * Gets a live recording
 *
 * Requires authentication as user
 */
export const getLivetvLiverecordingsByIdHlsBySegment = <ThrowOnError extends boolean = false>(options: Options<GetLivetvLiverecordingsByIdHlsBySegmentData, ThrowOnError>) => {
    return (options.client ?? client).get<GetLivetvLiverecordingsByIdHlsBySegmentResponses, GetLivetvLiverecordingsByIdHlsBySegmentErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveRecordings/{Id}/hls/{Segment}',
        ...options
    });
};

/**
 * Gets a live recording
 *
 * Requires authentication as user
 */
export const headLivetvLiverecordingsByIdHlsBySegment = <ThrowOnError extends boolean = false>(options: Options<HeadLivetvLiverecordingsByIdHlsBySegmentData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadLivetvLiverecordingsByIdHlsBySegmentResponses, HeadLivetvLiverecordingsByIdHlsBySegmentErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/LiveRecordings/{Id}/hls/{Segment}',
        ...options
    });
};

/**
 * Sets a channel disabled or not
 *
 * Requires authentication as administrator
 */
export const postLivetvManageChannelsByIdDisabled = <ThrowOnError extends boolean = false>(options: Options<PostLivetvManageChannelsByIdDisabledData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvManageChannelsByIdDisabledResponses, PostLivetvManageChannelsByIdDisabledErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Manage/Channels/{Id}/Disabled',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Sets a channel sort index
 *
 * Requires authentication as administrator
 */
export const postLivetvManageChannelsByIdSortindex = <ThrowOnError extends boolean = false>(options: Options<PostLivetvManageChannelsByIdSortindexData, ThrowOnError>) => {
    return (options.client ?? client).post<PostLivetvManageChannelsByIdSortindexResponses, PostLivetvManageChannelsByIdSortindexErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/LiveTv/Manage/Channels/{Id}/SortIndex',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const getMusicgenresByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<GetMusicgenresByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).get<GetMusicgenresByNameImagesByTypeByIndexResponses, GetMusicgenresByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/MusicGenres/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headMusicgenresByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<HeadMusicgenresByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadMusicgenresByNameImagesByTypeByIndexResponses, HeadMusicgenresByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/MusicGenres/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getPersonsByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<GetPersonsByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).get<GetPersonsByNameImagesByTypeByIndexResponses, GetPersonsByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Persons/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headPersonsByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<HeadPersonsByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadPersonsByNameImagesByTypeByIndexResponses, HeadPersonsByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Persons/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Removes an additional user from a session
 *
 * Requires authentication as user
 */
export const postSessionsByIdUsersByUseridDelete = <ThrowOnError extends boolean = false>(options: Options<PostSessionsByIdUsersByUseridDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostSessionsByIdUsersByUseridDeleteResponses, PostSessionsByIdUsersByUseridDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Sessions/{Id}/Users/{UserId}/Delete',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getStudiosByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<GetStudiosByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).get<GetStudiosByNameImagesByTypeByIndexResponses, GetStudiosByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Studios/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headStudiosByNameImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<HeadStudiosByNameImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadStudiosByNameImagesByTypeByIndexResponses, HeadStudiosByNameImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Studios/{Name}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Clears audio or subtitle track selections for a user
 *
 * Requires authentication as user
 */
export const postUsersByIdTrackselectionsByTracktypeDelete = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdTrackselectionsByTracktypeDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdTrackselectionsByTracktypeDeleteResponses, PostUsersByIdTrackselectionsByTracktypeDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/TrackSelections/{TrackType}/Delete',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getUsersByUseridSectionsBySectionidItems = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridSectionsBySectionidItemsData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridSectionsBySectionidItemsResponses, GetUsersByUseridSectionsBySectionidItemsErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Sections/{SectionId}/Items',
        ...options
    });
};

/**
 * Gets special features for an item
 *
 * Requires authentication as user
 */
export const getUsersByUseridItemsByIdSpecialfeatures = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridItemsByIdSpecialfeaturesData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridItemsByIdSpecialfeaturesResponses, GetUsersByUseridItemsByIdSpecialfeaturesErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/{Id}/SpecialFeatures',
        ...options
    });
};

/**
 * Gets local trailers for an item
 *
 * Requires authentication as user
 */
export const getUsersByUseridItemsByIdLocaltrailers = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridItemsByIdLocaltrailersData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridItemsByIdLocaltrailersResponses, GetUsersByUseridItemsByIdLocaltrailersErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/{Id}/LocalTrailers',
        ...options
    });
};

/**
 * Gets intros to play before the main media item plays
 *
 * Requires authentication as user
 */
export const getUsersByUseridItemsByIdIntros = <ThrowOnError extends boolean = false>(options: Options<GetUsersByUseridItemsByIdIntrosData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByUseridItemsByIdIntrosResponses, GetUsersByUseridItemsByIdIntrosErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/{Id}/Intros',
        ...options
    });
};

/**
 * Unmarks an item as a favorite
 *
 * Requires authentication as user
 */
export const postUsersByUseridFavoriteitemsByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridFavoriteitemsByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridFavoriteitemsByIdDeleteResponses, PostUsersByUseridFavoriteitemsByIdDeleteErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/FavoriteItems/{Id}/Delete',
        ...options
    });
};

/**
 * Deletes a user's saved personal rating for an item
 *
 * Requires authentication as user
 */
export const deleteUsersByUseridItemsByIdRating = <ThrowOnError extends boolean = false>(options: Options<DeleteUsersByUseridItemsByIdRatingData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUsersByUseridItemsByIdRatingResponses, DeleteUsersByUseridItemsByIdRatingErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/{Id}/Rating',
        ...options
    });
};

/**
 * Updates a user's rating for an item
 *
 * Requires authentication as user
 */
export const postUsersByUseridItemsByIdRating = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridItemsByIdRatingData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridItemsByIdRatingResponses, PostUsersByUseridItemsByIdRatingErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/{Id}/Rating',
        ...options
    });
};

/**
 * Updates a user's hide from resume for an item
 *
 * Requires authentication as user
 */
export const postUsersByUseridItemsByIdHidefromresume = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridItemsByIdHidefromresumeData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridItemsByIdHidefromresumeResponses, PostUsersByUseridItemsByIdHidefromresumeErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/{Id}/HideFromResume',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const deleteUsersByIdImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<DeleteUsersByIdImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).delete<DeleteUsersByIdImagesByTypeByIndexResponses, DeleteUsersByIdImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getUsersByIdImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<GetUsersByIdImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).get<GetUsersByIdImagesByTypeByIndexResponses, GetUsersByIdImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headUsersByIdImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<HeadUsersByIdImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadUsersByIdImagesByTypeByIndexResponses, HeadUsersByIdImagesByTypeByIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Images/{Type}/{Index}',
        ...options
    });
};

/**
 * Uploads an image for an item, must be base64 encoded.
 *
 * Requires authentication as user
 */
export const postUsersByIdImagesByTypeByIndex = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdImagesByTypeByIndexData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdImagesByTypeByIndexResponses, PostUsersByIdImagesByTypeByIndexErrors, ThrowOnError>({
        bodySerializer: null,
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Images/{Type}/{Index}',
        ...options,
        headers: {
            'Content-Type': 'application/octet-stream',
            ...options.headers
        }
    });
};

/**
 * Requires authentication as user
 */
export const postUsersByIdImagesByTypeDelete = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdImagesByTypeDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdImagesByTypeDeleteResponses, PostUsersByIdImagesByTypeDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Images/{Type}/Delete',
        ...options
    });
};

/**
 * Updates userdata for an item
 *
 * Requires authentication as user
 */
export const postUsersByUseridItemsByItemidUserdata = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridItemsByItemidUserdataData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridItemsByItemidUserdataResponses, PostUsersByUseridItemsByItemidUserdataErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/{ItemId}/UserData',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Reports a user's playback progress
 *
 * Requires authentication as user
 */
export const postUsersByUseridPlayingitemsByIdProgress = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridPlayingitemsByIdProgressData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridPlayingitemsByIdProgressResponses, PostUsersByUseridPlayingitemsByIdProgressErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/PlayingItems/{Id}/Progress',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options.headers
        }
    });
};

/**
 * Reports that a user has stopped playing an item
 *
 * Requires authentication as user
 */
export const postUsersByUseridPlayingitemsByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridPlayingitemsByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridPlayingitemsByIdDeleteResponses, PostUsersByUseridPlayingitemsByIdDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/PlayingItems/{Id}/Delete',
        ...options
    });
};

/**
 * Marks an item as unplayed
 *
 * Requires authentication as user
 */
export const postUsersByUseridPlayeditemsByIdDelete = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridPlayeditemsByIdDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridPlayeditemsByIdDeleteResponses, PostUsersByUseridPlayeditemsByIdDeleteErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/PlayedItems/{Id}/Delete',
        ...options
    });
};

/**
 * Removes a Connect link for a user
 *
 * Requires authentication as administrator
 */
export const postUsersByIdConnectLinkDelete = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdConnectLinkDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdConnectLinkDeleteResponses, PostUsersByIdConnectLinkDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Connect/Link/Delete',
        ...options
    });
};

/**
 * Deletes an external subtitle file
 *
 * Requires authentication as user
 */
export const postVideosByIdSubtitlesByIndexDelete = <ThrowOnError extends boolean = false>(options: Options<PostVideosByIdSubtitlesByIndexDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostVideosByIdSubtitlesByIndexDeleteResponses, PostVideosByIdSubtitlesByIndexDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/Subtitles/{Index}/Delete',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses, GetVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const headVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainer = <ThrowOnError extends boolean = false>(options: Options<HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerResponses, HeadVideosByIdHls1ByPlaylistidBySegmentidBySegmentcontainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/hls1/{PlaylistId}/{SegmentId}.{SegmentContainer}',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const getVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainer = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerResponses, GetVideosByIdHlsByPlaylistidBySegmentidBySegmentcontainerErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}',
        ...options
    });
};

/**
 * Gets subtitles in a specified format.
 *
 * Requires authentication as user
 */
export const getItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses, GetItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}',
        ...options
    });
};

/**
 * Gets subtitles in a specified format.
 *
 * Requires authentication as user
 */
export const headItemsByIdByMediasourceidSubtitlesByIndexStreamByFormat = <ThrowOnError extends boolean = false>(options: Options<HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses, HeadItemsByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}',
        ...options
    });
};

/**
 * Requires authentication as administrator
 */
export const postItemsByIdImagesByTypeByIndexDelete = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdImagesByTypeByIndexDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdImagesByTypeByIndexDeleteResponses, PostItemsByIdImagesByTypeByIndexDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}/{Index}/Delete',
        ...options
    });
};

/**
 * Updates the index for an item image
 *
 * Requires authentication as administrator
 */
export const postItemsByIdImagesByTypeByIndexIndex = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdImagesByTypeByIndexIndexData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdImagesByTypeByIndexIndexResponses, PostItemsByIdImagesByTypeByIndexIndexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}/{Index}/Index',
        ...options
    });
};

/**
 * Updates the index for an item image
 *
 * Requires authentication as administrator
 */
export const postItemsByIdImagesByTypeByIndexUrl = <ThrowOnError extends boolean = false>(options: Options<PostItemsByIdImagesByTypeByIndexUrlData, ThrowOnError>) => {
    return (options.client ?? client).post<PostItemsByIdImagesByTypeByIndexUrlResponses, PostItemsByIdImagesByTypeByIndexUrlErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/Images/{Type}/{Index}/Url',
        ...options
    });
};

/**
 * Moves a playlist item
 *
 * Requires authentication as user
 */
export const postPlaylistsByIdItemsByItemidMoveByNewindex = <ThrowOnError extends boolean = false>(options: Options<PostPlaylistsByIdItemsByItemidMoveByNewindexData, ThrowOnError>) => {
    return (options.client ?? client).post<PostPlaylistsByIdItemsByItemidMoveByNewindexResponses, PostPlaylistsByIdItemsByItemidMoveByNewindexErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Playlists/{Id}/Items/{ItemId}/Move/{NewIndex}',
        ...options
    });
};

/**
 * Deletes a user's saved personal rating for an item
 *
 * Requires authentication as user
 */
export const postUsersByUseridItemsByIdRatingDelete = <ThrowOnError extends boolean = false>(options: Options<PostUsersByUseridItemsByIdRatingDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByUseridItemsByIdRatingDeleteResponses, PostUsersByUseridItemsByIdRatingDeleteErrors, ThrowOnError>({
        responseType: 'json',
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{UserId}/Items/{Id}/Rating/Delete',
        ...options
    });
};

/**
 * Requires authentication as user
 */
export const postUsersByIdImagesByTypeByIndexDelete = <ThrowOnError extends boolean = false>(options: Options<PostUsersByIdImagesByTypeByIndexDeleteData, ThrowOnError>) => {
    return (options.client ?? client).post<PostUsersByIdImagesByTypeByIndexDeleteResponses, PostUsersByIdImagesByTypeByIndexDeleteErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Users/{Id}/Images/{Type}/{Index}/Delete',
        ...options
    });
};

/**
 * Gets subtitles in a specified format.
 *
 * Requires authentication as user
 */
export const getVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses, GetVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}',
        ...options
    });
};

/**
 * Gets subtitles in a specified format.
 *
 * Requires authentication as user
 */
export const headVideosByIdByMediasourceidSubtitlesByIndexStreamByFormat = <ThrowOnError extends boolean = false>(options: Options<HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatResponses, HeadVideosByIdByMediasourceidSubtitlesByIndexStreamByFormatErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/Stream.{Format}',
        ...options
    });
};

/**
 * Gets subtitles in a specified format.
 *
 * Requires authentication as user
 */
export const getVideosByIdByMediasourceidAttachmentsByIndexStream = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdByMediasourceidAttachmentsByIndexStreamData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdByMediasourceidAttachmentsByIndexStreamResponses, GetVideosByIdByMediasourceidAttachmentsByIndexStreamErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/{MediaSourceId}/Attachments/{Index}/Stream',
        ...options
    });
};

/**
 * Gets subtitles in a specified format.
 *
 * Requires authentication as user
 */
export const getItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat = <ThrowOnError extends boolean = false>(options: Options<GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData, ThrowOnError>) => {
    return (options.client ?? client).get<GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses, GetItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}',
        ...options
    });
};

/**
 * Gets subtitles in a specified format.
 *
 * Requires authentication as user
 */
export const headItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat = <ThrowOnError extends boolean = false>(options: Options<HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses, HeadItemsByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Items/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}',
        ...options
    });
};

/**
 * Gets subtitles in a specified format.
 *
 * Requires authentication as user
 */
export const getVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat = <ThrowOnError extends boolean = false>(options: Options<GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData, ThrowOnError>) => {
    return (options.client ?? client).get<GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses, GetVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}',
        ...options
    });
};

/**
 * Gets subtitles in a specified format.
 *
 * Requires authentication as user
 */
export const headVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormat = <ThrowOnError extends boolean = false>(options: Options<HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatData, ThrowOnError>) => {
    return (options.client ?? client).head<HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatResponses, HeadVideosByIdByMediasourceidSubtitlesByIndexByStartpositionticksStreamByFormatErrors, ThrowOnError>({
        security: [
            {
                in: 'query',
                name: 'api_key',
                type: 'apiKey'
            },
            {
                scheme: 'bearer',
                type: 'http'
            }
        ],
        url: '/Videos/{Id}/{MediaSourceId}/Subtitles/{Index}/{StartPositionTicks}/Stream.{Format}',
        ...options
    });
};
